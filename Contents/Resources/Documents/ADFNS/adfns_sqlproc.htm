<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-85"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/SQL%20Processing%20for%20Application%20Developers"></a><title>SQL Processing for Application Developers</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1080"/>
<meta name="dcterms.created" content="2016-05-05T16:23:33Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Development Guide"/>
<meta name="dcterms.identifier" content="E41452-07"/>
<meta name="dcterms.isVersionOf" content="ADFNS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="adfns_part_sql.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adfns_sqltypes.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41452-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/38</span> <!-- End Header -->
<div id="ADFNS007" class="chapter"><a id="g1034534"></a> <a id="i1019774"></a>
<h1 class="chapter"><span class="secnum">6</span> SQL Processing for Application Developers</h1>
<p>This chapter explains what application developers must know about how Oracle Database processes SQL statements. Before reading this chapter, read the basic information about SQL statements and SQL processing in <a class="olink CNCPT015" href="../CNCPT/sqllangu.htm#CNCPT015"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p class="subhead2"><a id="ADFNS959"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJHJIAG">Description of SQL Statement Processing</a></p>
</li>
<li>
<p><a href="#i1024556">Grouping Operations into Transactions</a></p>
</li>
<li>
<p><a href="#i1024718">Ensuring Repeatable Reads with Read-Only Transactions</a></p>
</li>
<li>
<p><a href="#i1024830">Locking Tables Explicitly</a></p>
</li>
<li>
<p><a href="#i1025030">Using Oracle Lock Management Services (User Locks)</a></p>
</li>
<li>
<p><a href="#i1025370">Using Serializable Transactions for Concurrency Control</a></p>
</li>
<li>
<p><a href="#BEJECCJJ">Nonblocking and Blocking DDL Statements</a></p>
</li>
<li>
<p><a href="#i1007356">Autonomous Transactions</a></p>
</li>
<li>
<p><a href="#i1007522">Resuming Execution After Storage Allocation Errors</a></p>
</li>
</ul>
<a id="BEJHJIAG"></a>
<div id="ADFNS99995" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">6.1</span> Description of SQL Statement Processing</h2>
<p><a id="sthref133"></a>This topic explains what happens during each stage of processing the execution of a SQL statement, using a data manipulation language (DML) statement as an example.</p>
<p>Assume that you are using a Pro*C program to increase the salary for all employees in a department. The program has connected to Oracle Database and you are connected to the HR schema, which owns the <code dir="ltr">employees</code> table. You can embed this SQL statement in your program:</p>
<pre dir="ltr">EXEC SQL UPDATE employees SET salary = 1.10 * salary
  WHERE department_id = :department_id;
</pre>
<p>The program provides a value for the bind variable placeholder <code dir="ltr">:department_id</code>, which the SQL statement uses when it runs.</p>
<p class="subhead2"><a id="ADFNS1343"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJFABII">Stages of SQL Statement Processing</a></p>
</li>
<li>
<p><a href="#BEJBBHCJ">Shared SQL Areas</a></p>
</li>
</ul>
<a id="BEJFABII"></a>
<div id="ADFNS134" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.1.1</span> Stages of SQL Statement Processing</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
DML statements use all stages. Transaction management, session management, and <a id="sthref134"></a><a id="sthref135"></a>system management SQL statements use only stages&nbsp;<a href="#BEJFIGBJ">2</a> and <a href="#BEJCJIBH">8</a>.</div>
<ol>
<li>
<p><span class="bold">Open or create a cursor.</span></p>
<p>A program interface call opens or creates a cursor, in expectation of a SQL statement. Most applications create the cursor implicitly (automatically). Precompiler programs can create the cursor either implicitly or explicitly.</p>
</li>
<li id="BEJFIGBJ">
<p><span class="bold">Parse the statement.</span></p>
<p>The user process passes the SQL statement to Oracle Database, which loads a parsed representation of the statement into the shared SQL area. Oracle Database can catch many errors during parsing.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref136"></a><a id="sthref137"></a>For a data definition language (DDL) statement, parsing includes data dictionary lookup and execution.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT1740" href="../CNCPT/sqllangu.htm#CNCPT1740"><span class="italic">Oracle Database Concepts</span></a> for information about parsing</p>
</li>
<li>
<p><a href="#BEJBBHCJ">Section 6.1.2, &#34;Shared SQL Areas&#34;</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="bold">Determine if the statement is a query.</span></p>
</li>
<li>
<p><span class="bold">If the statement is a query, describe its results.</span></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This stage is necessary only if the characteristics of the result are unknown; for example, when a user enters the query interactively.</div>
<p>Oracle Database determines the characteristics (data types, lengths, and names) of the result.</p>
</li>
<li>
<p><span class="bold">If the statement is a query, define its output.</span></p>
<p>You specify the location, size, and data type of variables defined to receive each fetched value. These variables are called <span class="glossaryterm">define variables</span>. Oracle Database performs data type conversion if necessary.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT1741" href="../CNCPT/sqllangu.htm#CNCPT1741"><span class="italic">Oracle Database Concepts</span></a> for information about the <code dir="ltr">DEFINE</code> stage</div>
</li>
<li>
<p><span class="bold">Bind any variables.</span></p>
<p>Oracle Database has determined the meaning of the SQL statement but does not have enough information to run it. Oracle Database needs values for any bind variable placeholders in the statement. In the example, Oracle Database needs a value for <code dir="ltr">:department_id</code>. The process of obtaining these values is called <span class="bold">binding variables</span>.</p>
<p>A program must specify the location (memory address) of the value. End users of applications may be unaware that they are specifying values for bind variable placeholders, because the Oracle Database utility can prompt them for the values.</p>
<p>Because the program specifies the location of the value (that is, binds by reference), it need not rebind the variable before rerunning the statement, even if the value changes. Each time Oracle Database runs the statement, it gets the value of the variable from its address.</p>
<p>You must also specify a data type and length for each value (unless they are implied or defaulted) if Oracle Database must perform data type conversion.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about specifying a data type and length for a value:
<ul>
<li>
<p><a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a></p>
</li>
<li>
<p><a class="olink LNPCC015" href="../LNPCC/pc_15ody.htm#LNPCC015"><span class="italic">Pro*C/C++ Programmer&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="bold">(Optional) Parallelize the statement.</span></p>
<p>Oracle Database can parallelize queries and some data definition language (DDL) operations (for example, index creation, creating a table with a subquery, and operations on partitions). Parallelization causes multiple server processes to perform the work of the SQL statement so that it can complete faster.</p>
</li>
<li id="BEJCJIBH">
<p><span class="bold">Run the statement.</span></p>
<p>Oracle Database runs the statement. If the statement is a query or an <code dir="ltr">INSERT</code> statement, the database locks no rows, because no data is changing. If the statement is an <code dir="ltr">UPDATE</code> or <code dir="ltr">DELETE</code> statement, the database locks all rows that the statement affects, until the next <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, or <code dir="ltr">SAVEPOINT</code> for the transaction, thereby ensuring data integrity.</p>
<p>For some statements, you can specify multiple executions to be performed. This is called <span class="bold">array processing</span>. Given <span class="italic">n</span> number of executions, the bind and define locations are assumed to be the beginning of an array of size <span class="italic">n</span>.</p>
</li>
<li>
<p><span class="bold">If the statement is a query, fetch its rows.</span></p>
<p>Oracle Database selects rows and, if the query has an <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause, orders the rows. Each successive fetch retrieves another row of the result set, until the last row has been fetched.</p>
</li>
<li>
<p><span class="bold">Close the cursor.</span></p>
<p>Oracle Database closes the cursor.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
To rerun a transaction management, session management, or system management SQL statement, use another <code dir="ltr">EXECUTE</code> statement.</div>
</div>
<!-- class="sect2" -->
<a id="BEJBBHCJ"></a>
<div id="ADFNS99965" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.1.2</span> Shared SQL Areas</h3>
<p><a id="sthref138"></a><a id="sthref139"></a>Oracle Database automatically detects when applications send similar SQL statements to the database. The SQL area used to process the first occurrence of the statement is <span class="italic">shared</span>&mdash;that is, used for processing subsequent occurrences of that same statement. Therefore, only one shared SQL area exists for a unique statement. Because shared SQL areas are shared memory areas, any Oracle Database process can use a shared SQL area. The sharing of SQL areas reduces memory use on the database server, thereby increasing system throughput.</p>
<p>In determining whether statements are similar or identical, Oracle Database compares both SQL statements issued directly by users and applications and recursive SQL statements issued internally by DDL statements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT1226" href="../CNCPT/memory.htm#CNCPT1226"><span class="italic">Oracle Database Concepts</span></a> for more information about shared SQL areas</p>
</li>
<li>
<p><a class="olink TGSQL" href="../TGSQL/toc.htm"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for more information about shared SQL</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1024556"></a>
<div id="ADFNS00201" class="sect1">
<h2 class="sect1"><span class="secnum">6.2</span> Grouping Operations into Transactions</h2>
<p class="subhead2"><a id="ADFNS960"></a>Topics:</p>
<ul>
<li>
<p><a href="#CIHBEDID">Deciding How to Group Operations in Transactions</a></p>
</li>
<li>
<p><a href="#CIHIJGDD">Improving Transaction Performance</a></p>
</li>
<li>
<p><a href="#g1691118">Managing Commit Redo Action</a></p>
</li>
<li>
<p><a href="#BEJDJDGF">Determining Transaction Outcome After a Recoverable Outage</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT016" href="../CNCPT/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a> for basic information about transactions</div>
<a id="CIHBEDID"></a>
<div id="ADFNS99953" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.2.1</span> Deciding How to Group Operations in Transactions</h3>
<p><a id="sthref140"></a>Typically, deciding how to group operations in transactions is the concern of application developers who use programming interfaces to Oracle Database. When deciding how to group transactions:</p>
<ul>
<li>
<p>Define transactions such that work is accomplished in logical units and data remains consistent.</p>
</li>
<li>
<p>Ensure that data in all referenced tables is in a consistent state before the transaction begins and after it ends.</p>
</li>
<li>
<p>Ensure that each transaction consists only of the SQL statements or PL/SQL blocks that comprise one consistent change to the data.</p>
</li>
</ul>
<p>For example, suppose that you write a web application that lets users transfer funds between accounts. The transaction must include the debit to one account, executed by one SQL statement, and the credit to another account, executed by another SQL statement. Both statements must fail or succeed as a unit of work; one statement must not be committed without the other. Do not include unrelated actions, such as a deposit to one account, in the transaction.</p>
</div>
<!-- class="sect2" -->
<a id="CIHIJGDD"></a>
<div id="ADFNS99952" class="sect2">
<h3 class="sect2"><span class="secnum">6.2.2</span> Improving Transaction Performance</h3>
<p><a id="sthref141"></a>As an application developer, you must try to improve performance. Consider using these performance enhancement techniques when designing and writing your application:</p>
<ul>
<li>
<p>For each transaction:</p>
<ol>
<li>
<p>If you can use a single SQL statement, then do so.</p>
</li>
<li>
<p>If you cannot use a single SQL statement but you can use PL/SQL, then use as little PL/SQL as possible.</p>
<p>For information about PL/SQL, see <a href="adfns_part_plsql.htm#CHDGEBHI">Part II, &#34;PL/SQL for Application Developers&#34;</a>.</p>
</li>
<li>
<p>If you cannot use PL/SQL (because it cannot do what you must do; for example, read a directory), then use Java.</p>
</li>
<li>
<p>If you cannot use Java (for example, if it is too slow) or you have existing third-generation language (3GL) code, then use an external C subprogram.</p>
</li>
</ol>
<p>For information about using Java and C in your application, see <a href="adfns_externproc.htm#g1040439">Chapter 18, &#34;Developing Applications with Multiple Programming Languages.&#34;</a></p>
</li>
<li>
<p>Establish standards for writing SQL statements so that you can take advantage of shared SQL areas.</p>
<p>Oracle Database recognizes identical SQL statements and lets them share memory areas, reducing memory usage on the database server and increasing system throughput.</p>
</li>
<li>
<p>Collect statistics that Oracle Database can use to implement a cost-based approach to SQL statement optimization, and use additional hints to the optimizer as needed.</p>
<p>To collect most statistics, use the <code dir="ltr">DBMS_STATS</code> package, which lets you collect statistics in parallel, collect global statistics for partitioned objects, and tune your statistics collection in other ways. For more information about this package, see <a class="olink ARPLS059" href="../ARPLS/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
<p>To collect statistics unrelated to the cost-based optimizer (such as information about free list blocks), use the SQL statement <code dir="ltr">ANALYZE</code>. For more information about this statement, see <a class="olink SQLRF01105" href="../SQLRF/statements_4005.htm#SQLRF01105"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>For more information about hints, see <a class="olink SQLRF00219" href="../SQLRF/sql_elements006.htm#SQLRF00219"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Before beginning a transaction, invoke <code dir="ltr">DBMS_APPLICATION_INFO</code> procedures to record the name of the transaction in the database for later use when tracking its performance with Oracle Trace and the SQL trace facility. For information about the <code dir="ltr">DBMS_APPLICATION_INFO</code> package, see <a class="olink ARPLS003" href="../ARPLS/d_appinf.htm#ARPLS003"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li>
<p>Increase user productivity and query efficiency by including user-written PL/SQL functions in SQL expressions. For details, see <a href="adfns_packages.htm#i1007943">Section 11.9, &#34;Invoking Stored PL/SQL Functions from SQL Statements.&#34;</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT016" href="../CNCPT/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a> for more information about transaction management</div>
</div>
<!-- class="sect2" -->
<a id="g1691118"></a>
<div id="ADFNS99951" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.2.3</span> Managing Commit Redo Action</h3>
<p><a id="sthref142"></a><a id="sthref143"></a><a id="sthref144"></a><a id="sthref145"></a>When a transaction updates Oracle Database, it generates a corresponding redo entry. Oracle Database buffers the redo entry to the redo log until the transaction completes. When the transaction commits, the <a id="sthref146"></a><a id="sthref147"></a><a id="sthref148"></a>log writer process (LGWR) writes redo records to disk for the buffered redo entries of all changes in the transaction. By default, Oracle Database writes the redo entries to disk before the call returns to the client. This action causes a latency in the commit, because the application must wait for the redo entries to be persistent on disk.</p>
<p>Oracle Database lets you change the handling of commit redo to fit the needs of your application. If your application requires very high transaction throughput and you are willing to trade commit durability for lower commit latency, then you can change the default <code dir="ltr">COMMIT</code> options so that the application need not wait for the database to write data to the online redo logs.</p>
<p><a href="#CIHGDFJC">Table 6-1</a> describes the <code dir="ltr">COMMIT</code> options.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
With the <code dir="ltr">NOWAIT</code> option, a failure that occurs after the commit message is received, but before the redo log records are written, can falsely indicate to a transaction that its changes are persistent.</div>
<div id="ADFNS135" class="tblhruleformal">
<p class="titleintable"><a id="sthref149"></a><a id="CIHGDFJC"></a>Table 6-1 COMMIT Statement Options</p>
<table class="cellalignment296" title="COMMIT Statement Options" summary="This table lists and describes the options that you can use for both the COMMIT statement and the COMMIT_WRITE initialization parameter." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t13">Option</th>
<th class="cellalignment294" id="r1c2-t13">Effect</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t13" headers="r1c1-t13">
<p><a id="sthref150"></a><code dir="ltr">WAIT</code><br/>
(default)</p>
</td>
<td class="cellalignment295" headers="r2c1-t13 r1c2-t13">
<p>Ensures that the <code dir="ltr">COMMIT</code> statement returns only after the corresponding redo information is persistent in the online redo log. When the client receives a successful return from this <code dir="ltr">COMMIT</code> statement, the transaction has been committed to durable media.</p>
<p>A failure that occurs after a successful write to the log might prevent the success message from returning to the client, in which case the client cannot tell whether the transaction committed.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t13" headers="r1c1-t13">
<p><a id="sthref151"></a><code dir="ltr">NOWAIT</code><br/>
(alternative to<br/>
<code dir="ltr">WAIT</code>)</p>
</td>
<td class="cellalignment295" headers="r3c1-t13 r1c2-t13">
<p>The <code dir="ltr">COMMIT</code> statement returns to the client regardless of whether the write to the redo log has completed. This behavior can increase transaction throughput.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t13" headers="r1c1-t13">
<p><a id="sthref152"></a><code dir="ltr">BATCH</code><br/>
(alternative to<br/>
<code dir="ltr">IMMEDIATE</code>)</p>
</td>
<td class="cellalignment295" headers="r4c1-t13 r1c2-t13">
<p>Buffers the redo information to the redo log with concurrently running transactions. After collecting sufficient redo information, initiates a disk write to the redo log. This behavior is called <a id="sthref153"></a><span class="bold">group commit</span>, because it writes redo information for multiple transactions to the log in a single I/O operation.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t13" headers="r1c1-t13">
<p><a id="sthref154"></a><code dir="ltr">IMMEDIATE</code><br/>
(default)</p>
</td>
<td class="cellalignment295" headers="r5c1-t13 r1c2-t13">
<p>LGWR writes the transaction redo information to the log. Because this operation option forces a disk I/O, it can reduce transaction throughput.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p>To change the <code dir="ltr">COMMIT</code> options, use either the <code dir="ltr">COMMIT</code> statement (described in <a class="olink SQLRF01110" href="../SQLRF/statements_4011.htm#SQLRF01110"><span class="italic">Oracle Database SQL Language Reference</span></a>) or the appropriate initialization parameter. For information about initialization parameters, see <a class="olink REFRN00102" href="../REFRN/GUID-4C578B21-DE2B-4210-8EB7-EF28D36CC1CB.htm#REFRN00102"><span class="italic">Oracle Database Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot change the default <code dir="ltr">IMMEDIATE</code> and <code dir="ltr">WAIT</code> action for distributed transactions.</div>
<p><a id="sthref155"></a>If your application uses Oracle Call Interface (OCI), then you can modify redo action by setting these flags in the <code dir="ltr">OCITransCommit</code> function in your application:</p>
<ul>
<li>
<p><code dir="ltr">OCI_TRANS_WRITEWAIT</code></p>
</li>
<li>
<p><code dir="ltr">OCI_TRANS_WRITENOWAIT</code></p>
</li>
<li>
<p><code dir="ltr">OCI_TRANS_WRITEBATCH</code></p>
</li>
<li>
<p><code dir="ltr">OCI_TRANS_WRITEIMMED</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<code dir="ltr">OCI_TRANS_WRITENOWAIT</code> can cause silent transaction loss with shutdown termination, startup force, and any instance or node failure. On an Oracle RAC system, asynchronously committed changes might not be immediately available to read on other instances.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI13112" href="../LNOCI/oci17msc006.htm#LNOCI13112"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for information about the <code dir="ltr">OCITransCommit</code> function</div>
<p>The specification of the <code dir="ltr">NOWAIT</code> and <code dir="ltr">BATCH</code> options has a small window of vulnerability in which Oracle Database can roll back a transaction that your application views as committed. Your application must be able to tolerate these scenarios:</p>
<ul>
<li>
<p>The database host fails, which causes the database to lose redo entries that were buffered but not yet written to the online redo logs.</p>
</li>
<li>
<p>A file I/O problem prevents LGWR from writing buffered redo entries to disk. If the redo logs are not multiplexed, then the commit is lost.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BEJDJDGF"></a>
<div id="ADFNS961" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.2.4</span> Determining Transaction Outcome After a Recoverable Outage</h3>
<p><a id="sthref156"></a>A <span class="bold">recoverable outage</span> is a system, hardware, communication, or storage failure that breaks the connection between your application (the client) and Oracle Database (the server). After an outage, your application receives a disconnection error message. The transaction that was running when the connection broke is the <a id="sthref157"></a><a id="sthref158"></a><span class="bold">in-flight transaction</span>, which may or may not have been committed or run to completion.</p>
<p>To recover from the outage, your application must determine the outcome of the in-flight transaction&mdash;whether it was committed and whether it made its intended session state changes. If the transaction was not committed, then the application can either resubmit the transaction or return the uncommitted status to the end user. If the transaction was committed, then the application can return the committed status, rather than the disconnection error, to the end user. If the transaction was both committed and completed, then the application may be able to continue by taking a new session and re-establishing the session state.</p>
<p>The Oracle Database feature that provides your application with the outcome of the in-flight transaction and can be used to ensure that it is not duplicated is <a id="sthref159"></a><a id="sthref160"></a>Transaction Guard, and its application program interface (API) is the PL/SQL procedure <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>.</p>
<p class="subhead2"><a id="ADFNS962"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJGHCDB">Understanding Transaction Guard</a></p>
</li>
<li>
<p><a href="#BEJHAAEG">Understanding DBMS_APP_CONT.GET_LTXID_OUTCOME</a></p>
</li>
<li>
<p><a href="#BEJGHHIJ">Using Transaction Guard</a></p>
</li>
</ul>
<a id="BEJGHCDB"></a>
<div id="ADFNS963" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">6.2.4.1</span> Understanding Transaction Guard</h4>
<p><span class="bold">Transaction Guard</span> is an Oracle Database tool that you can use to provide your application with the outcome of the in-flight transaction after an outage. The application can use Transaction Guard to provide the end user with a known outcome after an outage&mdash;committed or not committed&mdash;and, optionally, to replay the transaction if it did not commit and the states are correct.</p>
<p>Transaction Guard provides the transaction outcome through its API, the PL/SQL procedure <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>, described in <a href="#BEJHAAEG">Section 6.2.4.2</a>.</p>
<p>Transaction Guard relies on the <a id="sthref161"></a><a id="sthref162"></a><span class="bold">logical transaction identifier (LTXID)</span>, a globally unique identifier that identifies the last in-flight transaction on a session that failed. The database records the LTXID when the transaction is committed, and returns a new LTXID to the client with the commit message (for each client round trip). The client driver always holds the LTXID that will be used at the next <code dir="ltr">COMMIT</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Use Transaction Guard only to find the outcome of a session that failed due to a recoverable error, to replace the communication error with the real outcome.</p>
</li>
<li>
<p>Do not use Transaction Guard on your own session.</p>
</li>
<li>
<p>Do not use Transaction Guard on a live session.</p>
<p>To stop a live session, use <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code> <code dir="ltr">KILL</code> <code dir="ltr">SESSION</code> <code dir="ltr">IMMEDIATE</code> at the local or remote instance.</p>
</li>
</ul>
</div>
<a id="BEJIFEGH"></a>
<div id="ADFNS965" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.2.4.1.1</span> How Transaction Guard Uses the LTXID</h5>
<p>Transaction Guard uses the LTXID as follows:</p>
<ul>
<li>
<p>While a transaction is running, both Oracle Database (the server) and your application (the client) hold the LTXID to be used at the next <code dir="ltr">COMMIT</code>.</p>
</li>
<li>
<p>When the transaction is committed, Oracle Database records the LTXID with the transaction. If the LTXID has already been committed or has been blocked, then the database raises error, preventing duplication of the transaction.</p>
</li>
<li>
<p>The LTXID persists in Oracle Database for the time specified by the <code dir="ltr">RETENTION_TIMEOUT</code> parameter. The default is 24 hours. To change this value:</p>
<ul>
<li>
<p>When running Real Application Clusters, use Server Control Utility (SRVCTL), described in <a class="olink RACAD005" href="../RACAD/GUID-3ED4DBCE-A148-462B-8A79-534A3F0D6E7D.htm#RACAD005"><span class="italic">Oracle Real Application Clusters Administration and Deployment Guide</span></a>.</p>
</li>
<li>
<p>When not using Real Application Clusters, use the <code dir="ltr">DBMS_SERVICE</code> package, described in <a class="olink ARPLS092" href="../ARPLS/d_serv.htm#ARPLS092"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ul>
<p>If the transaction is remote or distributed, then its LTXID persists in the local database.</p>
<p>The LTXID is transferred to Data Guard and Active Data Guard in the standard redo apply.</p>
</li>
<li>
<p>After a recoverable error:</p>
<ul>
<li>
<p>If the transaction has not been committed, then Oracle Database blocks its LTXID to ensure that an earlier in-flight transaction with the same LTXID cannot be committed.</p>
<p>This behavior allows the application to return the uncommitted result to the user, who can then decide what to do, and also allows the application to safely replay the application if desirable.</p>
</li>
<li>
<p>If the transaction has been committed, then the application can return this result to the end user, and if the state is correct, the application may be able to continue.</p>
</li>
</ul>
</li>
<li>
<p>If the transaction is rolled back, then Oracle Database reuses its LTXID.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adfns_trans_idemp_guard.htm#BABEFIBC">Section 25.3.3, &#34;Transaction Guard Coverage,&#34;</a> for a list of the sources whose commits Transaction Guard supports</p>
</li>
<li>
<p><a href="adfns_trans_idemp_guard.htm#BABEEBDC">Section 25.3.4, &#34;Transaction Guard Exclusions,&#34;</a> for a list of the sources whose commits Transaction Guard does not support</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEJHAAEG"></a>
<div id="ADFNS968" class="sect3">
<h4 class="sect3"><span class="secnum">6.2.4.2</span> Understanding DBMS_APP_CONT.GET_LTXID_OUTCOME</h4>
<p>The PL/SQL procedure <a id="sthref163"></a><code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> is the API of Transaction Guard. After an outage, your application can reconnect to Oracle Database and then invoke this procedure to determine the outcome of the in-flight transaction.</p>
<p><code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> has these parameters:</p>
<div class="inftblinformal">
<table class="cellalignment296" title="DBMS_APP_CONT.GET_LTXID_OUTCOME Procedure Parameters" summary="Gives the name, data type, mode, and value of each parameter of the DBMS_APP_CONT.GET_LTXID_OUTCOME procedure." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t19">Parameter Name</th>
<th class="cellalignment294" id="r1c2-t19">Data Type</th>
<th class="cellalignment294" id="r1c3-t19">Parameter Mode</th>
<th class="cellalignment294" id="r1c4-t19">Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t19" headers="r1c1-t19"><code dir="ltr">CLIENT_LTXID</code></td>
<td class="cellalignment295" headers="r2c1-t19 r1c2-t19"><code dir="ltr">RAW</code></td>
<td class="cellalignment295" headers="r2c1-t19 r1c3-t19"><code dir="ltr">IN</code></td>
<td class="cellalignment295" headers="r2c1-t19 r1c4-t19">LTXID of the in-flight transaction</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t19" headers="r1c1-t19"><code dir="ltr">COMMITTED</code></td>
<td class="cellalignment295" headers="r3c1-t19 r1c2-t19"><code dir="ltr">BOOLEAN</code></td>
<td class="cellalignment295" headers="r3c1-t19 r1c3-t19"><code dir="ltr">OUT</code></td>
<td class="cellalignment295" headers="r3c1-t19 r1c4-t19"><code dir="ltr">TRUE</code> if the in-flight transaction was committed, <code dir="ltr">FALSE</code> otherwise</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t19" headers="r1c1-t19"><code dir="ltr">USER_CALL_COMPLETED</code></td>
<td class="cellalignment295" headers="r4c1-t19 r1c2-t19"><code dir="ltr">BOOLEAN</code></td>
<td class="cellalignment295" headers="r4c1-t19 r1c3-t19"><code dir="ltr">OUT</code></td>
<td class="cellalignment295" headers="r4c1-t19 r1c4-t19"><code dir="ltr">TRUE</code> if the in-flight transaction completed, <code dir="ltr">FALSE</code> otherwise</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="ADFNS969"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJHBAHC">CLIENT_LTXID Parameter</a></p>
</li>
<li>
<p><a href="#BEJFAJAF">COMMITTED Parameter</a></p>
</li>
<li>
<p><a href="#BEJGGIDE">USER_CALL_COMPLETED Parameter</a></p>
</li>
<li>
<p><a href="#BEJJAAJI">Exceptions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS73456" href="../ARPLS/d_app_cont.htm#ARPLS73456"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code></div>
<a id="BEJHBAHC"></a>
<div id="ADFNS970" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.2.4.2.1</span> CLIENT_LTXID Parameter</h5>
<p>Before your application (the client) can invoke <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> with the LTXID of the in-flight transaction, it must get the last LTXID in use at the client driver by using a client driver. The client driver holds the LTXID of the transaction next to be committed. In this case, the LTXID is for the in-flight transaction at the time of the outage. Use <code dir="ltr">getLTXID</code> for JDBC-Thin driver, <code dir="ltr">LogicalTransactionId</code> for ODP.NET, and <code dir="ltr">OCI_ATTR_GET</code> with LTXID for OCI and OCCI.</p>
<p>The JDBC-Thin driver also provides a callback that is triggered each time the LTXID at the client driver changes. The callback can be used to maintain the current LTXID to be used. The callback is particularly useful for application servers and applications that must block repeated executions.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Your application must get the LTXID immediately before passing it to <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>. Getting the LTXID in advance could lead to passing an earlier LTXID to <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>, causing the request to be rejected.</div>
<p>For information about the client driver for your client driver, see the documentation for your client driver. For example:</p>
<ul>
<li>
<p>For JDBC type 2 and type 4 drivers, see <a class="olink JJDBC28026" href="../JJDBC/overvw.htm#JJDBC28026"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a>.</p>
</li>
<li>
<p>For the OCI driver (including OCCI), see <a class="olink LNOCI72990" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=LNOCI72990"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a>.</p>
</li>
<li>
<p>For the ODP.NET driver, see <a class="olink ODPNT" href="../ODPNT/toc.htm"><span class="italic">Oracle Data Provider for .NET Developer&#39;s Guide for Microsoft Windows</span></a>.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BEJFAJAF"></a>
<div id="ADFNS971" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.2.4.2.2</span> COMMITTED Parameter</h5>
<p>After <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> returns control to your application, your application can check the value of the actual parameter that corresponds to the formal parameter <code dir="ltr">COMMITTED</code> to determine whether the in-flight transaction was committed.</p>
<p>If the value of the actual parameter is <code dir="ltr">TRUE</code>, then the transaction was committed.</p>
<p>If the value of the actual parameter is <code dir="ltr">FALSE</code>, then the transaction was not committed. Therefore, it is safe for the application to return the code <code dir="ltr">UNCOMMITTED</code> to the end user or use it to replay the transaction.</p>
<p>To ensure that an earlier session does not commit the transaction after the application returns <code dir="ltr">UNCOMMITTED</code>, <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> blocks the LTXID. Blocking the LTXID allows the end user to make a decision based on the uncommitted status, or the application to replay the transaction, and prevents duplicate transactions.</p>
</div>
<!-- class="sect4" -->
<a id="BEJGGIDE"></a>
<div id="ADFNS972" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.2.4.2.3</span> USER_CALL_COMPLETED Parameter</h5>
<p>Some transactions return information upon completion. For example: A transaction that uses commit on success (auto-commit) might returns the number of affected rows, or for a <code dir="ltr">SELECT</code> statement, the rows themselves; a transaction that invokes a PL/SQL subprogram that has <code dir="ltr">OUT</code> parameters returns the values of those parameters; and a transaction that invokes a PL/SQL function returns the function value. Also, a transaction that invokes a PL/SQL subprogram might execute a <code dir="ltr">COMMIT</code> statement and then do more work.</p>
<p>If your application needs information that the in-flight transaction returns upon completion, or session state changes that the transaction does after committing its database changes, then your application must determine whether the in-flight transaction completed, which it can do by checking the value of the actual parameter that corresponds to the formal parameter <code dir="ltr">USER_CALL_COMPLETED</code>.</p>
<p>If the value of the actual parameter is <code dir="ltr">TRUE</code>, then the transaction completed, and your application has the information and work that it must continue.</p>
<p>If the value of the actual parameter is <code dir="ltr">FALSE</code>, then the call from the client may not have completed. Therefore, your application might not have the information and work that it must continue.</p>
</div>
<!-- class="sect4" -->
<a id="BEJJAAJI"></a>
<div id="ADFNS973" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.2.4.2.4</span> Exceptions</h5>
<p>If your application (the client) and Oracle Database (the server) are no longer synchronized, then the <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> procedure raises one of these exceptions:</p>
<div class="inftblinformal">
<table class="cellalignment296" title="DBMS_APP_CONT.GET_LTXID_OUTCOME Exceptions" summary="This table lists and explains the exceptions that the DBMS_APP_CONT.GET_LTXID_OUTCOME procedure can raise." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t22">Exception</th>
<th class="cellalignment294" id="r1c2-t22">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t22" headers="r1c1-t22"><code dir="ltr">ORA-14950 - SERVER_AHEAD</code></td>
<td class="cellalignment295" headers="r2c1-t22 r1c2-t22">The server is ahead of the client; that is, the LTXID that your application passed to <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> identifies a transaction that is older than the in-flight transaction.
<p>Your application must get the LTXID immediately before passing it to <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t22" headers="r1c1-t22"><code dir="ltr">ORA-14951 - CLIENT_AHEAD</code></td>
<td class="cellalignment295" headers="r3c1-t22 r1c2-t22">The client is ahead of the server. Either the server was &#34;flashed back&#34; to an earlier state (see <a href="adfns_flashback.htm#g1026131">Chapter 16, &#34;Using Oracle Flashback Technology&#34;</a>), was recovered using media recovery, or is a standby database that was opened earlier and has lost data (for information about media recovery and standby databases, see <a class="olink SBYDB" href="../SBYDB/toc.htm"><span class="italic">Oracle Data Guard Concepts and Administration</span></a>).</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t22" headers="r1c1-t22"><code dir="ltr">ORA-14906 - SAME_SESSION</code></td>
<td class="cellalignment295" headers="r4c1-t22 r1c2-t22">Executing <code dir="ltr">GET_LTXID_OUTCOME</code> is not supported on the session that owns the LTXID, because the execution would block further processing on that session.</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t22" headers="r1c1-t22"><code dir="ltr">ORA-14909 - COMMIT_BLOCKED</code></td>
<td class="cellalignment295" headers="r5c1-t22 r1c2-t22">Your session has been blocked from committing by another user with the same username using <code dir="ltr">GET_LTXID_OUTCOME</code>. <code dir="ltr">GET_LTXID_OUTCOME</code> should be called only on dead sessions. Blocking a live session is better achieved using <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code> <code dir="ltr">KILL</code> <code dir="ltr">SESSION</code> <code dir="ltr">IMMEDIATE</code>. For help, contact your application administrator.</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t22" headers="r1c1-t22"><code dir="ltr">ORA-14952 GENERAL ERROR</code></td>
<td class="cellalignment295" headers="r6c1-t22 r1c2-t22"><code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> cannot determine the outcome of the in-flight transaction. An error occurred during transaction processing, and the error stack shows the error detail.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEJGHHIJ"></a>
<div id="ADFNS974" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">6.2.4.3</span> Using Transaction Guard</h4>
<p>After your application (the client) receives an error message, it must follow these steps to use Transaction Guard:</p>
<ol>
<li>
<p>Determine if the error is due to an outage (<span class="bold">recoverable</span>).</p>
<p>For instructions, see the documentation for your client driver&mdash;<code dir="ltr">OCI_ATTRIBUTE</code> for OCI, OCCI, and ODP.NET; <code dir="ltr">isRecoverable</code> for JDBC.</p>
</li>
<li id="BEJGHDBC">
<p>If the error is recoverable, then use the API of the client driver to get the logical transaction identifier (LTXID) of the in-flight transaction.</p>
<p>For instructions, see the documentation for your client driver.</p>
</li>
<li>
<p>Reconnect to the database.</p>
<p>The session that your application acquires can be either new or pooled.</p>
</li>
<li>
<p>Invoke <code dir="ltr">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> with the LTXID from step&nbsp;<a href="#BEJGHDBC">2</a>.</p>
</li>
<li>
<p>Check the value of the actual parameter that corresponds to the formal parameter <code dir="ltr">COMMITTED</code>.</p>
<p>If the value is <code dir="ltr">TRUE</code>, then tell the application that the in-flight transaction was committed. The application can return this result to the user, or continue if the state is correct.</p>
<p>If the value is <code dir="ltr">FALSE</code>, then the application can return <code dir="ltr">UNCOMMITTED</code> or a similar message to the user so that the user can choose the next step. Optionally, the application can replay the transaction for the user. For example:</p>
<ol>
<li>
<p>If necessary, clean up state changes on the client side.</p>
</li>
<li>
<p>Resubmit the in-flight transaction.</p>
</li>
</ol>
<p>If you do not resubmit the in-flight transaction, and the application needs neither information that the in-flight transaction returns upon completion nor work that the transaction does after committing its database changes, then continue. Otherwise, check the value of the actual parameter that corresponds to the formal parameter <code dir="ltr">USER_CALL_COMPLETED</code>.</p>
<p>If the value is <code dir="ltr">TRUE</code>, then continue.</p>
<p>If the value is <code dir="ltr">FALSE</code>, then tell the application user that the application cannot continue.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1024718"></a>
<div id="ADFNS00202" class="sect1">
<h2 class="sect1"><span class="secnum">6.3</span> Ensuring Repeatable Reads with Read-Only Transactions</h2>
<p>By default, Oracle Database guarantees statement-level read consistency, but not transaction-level read consistency. With <a id="sthref164"></a><a id="sthref165"></a><span class="bold">statement-level read consistency</span>, queries in a statement produce consistent data for the duration of the statement, not reflecting changes by other statements. With <a id="sthref166"></a><a id="sthref167"></a><span class="bold">transaction-level read consistency</span> (<a id="sthref168"></a><a id="sthref169"></a><span class="bold">repeatable reads</span>), queries in the transaction produce consistent data for the duration of the transaction, not reflecting changes by other transactions.</p>
<p>To ensure <a id="sthref170"></a><a id="sthref171"></a>transaction-level read consistency for a transaction that does not include DML statements, specify that the transaction is read-only. The queries in a <a id="sthref172"></a><a id="sthref173"></a>read-only transaction see only changes committed before the transaction began, so query results are consistent for the duration of the transaction.</p>
<p>A read-only transaction provides transaction-level read consistency without acquiring additional data locks. Therefore, while the read-only transaction is querying data, other transactions can query and update the same data.</p>
<p><a id="sthref174"></a>A read-only transaction begins with this statement:</p>
<pre dir="ltr">SET TRANSACTION READ ONLY [ NAME <span class="italic">string</span> ];
</pre>
<p>Only DDL statements can precede the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> statement. After the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> statement successfully runs, the transaction can include only <code dir="ltr">SELECT</code> (without <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>), <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, or non-DML statements (such as <code dir="ltr">SET</code> <code dir="ltr">ROLE</code>, <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code>, and <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code>). A <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, or DDL statement ends the read-only transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01705" href="../SQLRF/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement</div>
<p>Long-running queries sometimes fail because undo information required for consistent read (CR) operations is no longer available. This situation occurs when active transactions overwrite committed undo blocks.</p>
<p>Automatic undo management lets your database administrator (DBA) explicitly control how long the database retains undo information, using the parameter <a id="sthref175"></a><code dir="ltr">UNDO_RETENTION</code>. For example, if <code dir="ltr">UNDO_RETENTION</code> is 30 minutes, then the database retains all committed undo information for at least 30 minutes, ensuring that all queries running for 30 minutes or less do not encounter the OER error &#34;snapshot too old.&#34;</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT221" href="../CNCPT/consist.htm#CNCPT221"><span class="italic">Oracle Database Concepts</span></a> for more information about read consistency</p>
</li>
<li>
<p><a class="olink ADMIN014" href="../ADMIN/schema.htm#ADMIN014"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about long-running queries and resumable space allocation</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1024830"></a>
<div id="ADFNS00203" class="sect1">
<h2 class="sect1"><span class="secnum">6.4</span> Locking Tables Explicitly</h2>
<p><a id="sthref176"></a><a id="sthref177"></a>Oracle Database has default locking mechanisms that ensure data concurrency, data integrity, and <a id="sthref178"></a><a id="sthref179"></a>statement-level read consistency (for information about these, see <a class="olink CNCPT1331" href="../CNCPT/consist.htm#CNCPT1331"><span class="italic">Oracle Database Concepts</span></a>). However, you can override these mechanisms by locking tables explicitly. Locking tables explicitly is useful in situations such as these:</p>
<ul>
<li>
<p>A transaction in your application needs exclusive access to a resource, so that the transaction does not have to wait for other transactions to complete.</p>
</li>
<li>
<p>Your application needs <a id="sthref180"></a><a id="sthref181"></a>transaction-level read consistency (<a id="sthref182"></a>repeatable reads).</p>
<p>For other ways to ensure transaction-level read consistency, see <a href="#i1024718">Section 6.3, &#34;Ensuring Repeatable Reads with Read-Only Transactions,&#34;</a> and <a href="#i1025370">Section 6.6, &#34;Using Serializable Transactions for Concurrency Control.&#34;</a></p>
</li>
</ul>
<p>To override default locking at the transaction level, use any of these SQL statements:</p>
<ul>
<li>
<p><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> (described in <a class="olink SQLRF01605" href="../SQLRF/statements_9016.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> with the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause (described in <a class="olink SQLRF01702" href="../SQLRF/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> with the <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> or <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> <code dir="ltr">SERIALIZABLE</code> option (described in <a class="olink SQLRF01705" href="../SQLRF/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
<p>Locks acquired by these statements are released after the transaction is committed or rolled back.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF00901" href="../SQLRF/statements_2015.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ISOLATION_LEVEL</code> parameter of the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statement</p>
</li>
</ul>
</div>
<p>The initialization parameter <a id="sthref183"></a><a id="sthref184"></a><a id="sthref185"></a><code dir="ltr">DML_LOCKS</code> (described in <a class="olink REFRN10051" href="../REFRN/GUID-2C73E7B3-5F50-4C3C-B77F-B0F195D65225.htm#REFRN10051"><span class="italic">Oracle Database Reference</span></a>) determines the maximum number of DML locks. Although its default value is usually enough, you might need to increase it if you use explicit locks.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
If you override the default locking of Oracle Database at any level, ensure that data integrity is guaranteed, data concurrency is acceptable, and deadlocks are either impossible or appropriately handled.</div>
<p class="subhead2"><a id="ADFNS976"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1692678">Privileges Required to Acquire Table Locks</a></p>
</li>
<li>
<p><a href="#i1024882">Choosing a Locking Strategy</a></p>
</li>
<li>
<p><a href="#i1024981">Letting Oracle Database Control Table Locking</a></p>
</li>
<li>
<p><a href="#i1025003">Explicitly Acquiring Row Locks</a></p>
</li>
<li>
<p><a href="#BEJFACAJ">Examples of Concurrency Under Explicit Locking</a></p>
</li>
</ul>
<a id="g1692678"></a>
<div id="ADFNS99944" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.4.1</span> Privileges Required to Acquire Table Locks</h3>
<p>No special privileges are required to acquire any type of table lock on a table in your own schema. To acquire a table lock on a table in another schema, you must have either the <code dir="ltr">LOCK</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege or any object privilege (for example, <code dir="ltr">SELECT</code> or <code dir="ltr">UPDATE</code>) for the table.</p>
</div>
<!-- class="sect2" -->
<a id="i1024882"></a>
<div id="ADFNS99943" class="sect2">
<h3 class="sect2"><span class="secnum">6.4.2</span> Choosing a Locking Strategy</h3>
<p>A transaction explicitly acquires the specified table locks when a <a id="sthref186"></a><a id="sthref187"></a><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement is executed. A <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement explicitly overrides default locking. When a <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement is issued on a view, the underlying base tables are locked. This statement acquires exclusive table locks for the <code dir="ltr">employees</code> and <code dir="ltr">departments</code> tables on behalf of the containing transaction:</p>
<pre dir="ltr">LOCK TABLE employees, departments IN EXCLUSIVE MODE NOWAIT;
</pre>
<p>You can specify several tables or views to lock in the same mode; however, only a single <a id="sthref188"></a>lock mode can be specified for each <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a table is locked, all rows of the table are locked. No other user can modify the table. For information about locking individual rows, see <a href="#i1025003">Section 6.4.4</a>.</div>
<p>In the <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement, you can also indicate how long you want to wait for the table lock:</p>
<ul>
<li>
<p>If you do not want to wait, specify either <a id="sthref189"></a><code dir="ltr">NOWAIT</code> or <a id="sthref190"></a><code dir="ltr">WAIT 0</code>.</p>
<p>You acquire the table lock only if it is immediately available; otherwise, an error notifies you that the lock is unavailable now.</p>
</li>
<li>
<p>To wait up to <span class="italic">n</span> seconds to acquire the table lock, specify <code dir="ltr">WAIT</code>&nbsp;<code dir="ltr"><span class="codeinlineitalic">n</span></code>, where <span class="italic">n</span> is greater than 0 and less than or equal to 100000.</p>
<p>If the table lock is still unavailable after <span class="italic">n</span> seconds, an error notifies you that the lock is unavailable now.</p>
</li>
<li>
<p>To wait indefinitely to acquire the lock, specify neither <code dir="ltr">NOWAIT</code> nor <code dir="ltr">WAIT</code>.</p>
<p>The database waits indefinitely until the table is available, locks it, and returns control to you. When the database is running DDL statements concurrently with DML statements, a timeout or deadlock can sometimes result. The database detects such timeouts and deadlocks and returns an error.</p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS977"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033397">When to Lock with ROW SHARE MODE and ROW EXCLUSIVE MODE</a></p>
</li>
<li>
<p><a href="#g1033404">When to Lock with SHARE MODE</a></p>
</li>
<li>
<p><a href="#g1033427">When to Lock with SHARE ROW EXCLUSIVE MODE</a></p>
</li>
<li>
<p><a href="#g1033439">When to Lock with EXCLUSIVE MODE</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01605" href="../SQLRF/statements_9016.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement syntax</div>
<a id="g1033397"></a>
<div id="ADFNS99942" class="sect3">
<h4 class="sect3"><span class="secnum">6.4.2.1</span> When to Lock with ROW SHARE MODE and ROW EXCLUSIVE MODE</h4>
<p><a id="sthref191"></a><a id="sthref192"></a><code dir="ltr">ROW</code> <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> and <a id="sthref193"></a><code dir="ltr">ROW</code> <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">MODE</code> table locks offer the highest degree of concurrency. You might use these locks if:</p>
<ul>
<li>
<p>Your transaction must prevent another transaction from acquiring an intervening share, share row, or exclusive table lock for a table before your transaction can update that table.</p>
<p>If another transaction acquires an intervening share, share row, or exclusive table lock, no other transactions can update the table until the locking transaction commits or rolls back.</p>
</li>
<li>
<p>Your transaction must prevent a table from being altered or dropped before your transaction can modify that table.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="g1033404"></a>
<div id="ADFNS99941" class="sect3">
<h4 class="sect3"><span class="secnum">6.4.2.2</span> When to Lock with SHARE MODE</h4>
<p><a id="sthref194"></a><code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> table locks are rather restrictive data locks. You might use these locks if:</p>
<ul>
<li>
<p>Your transaction only queries the table, and requires a consistent set of the table data for the duration of the transaction.</p>
</li>
<li>
<p>You can hold up other transactions that try to update the locked table, until all transactions that hold <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> locks on the table either commit or roll back.</p>
</li>
<li>
<p>Other transactions might acquire concurrent <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> table locks on the same table, also giving them the option of transaction-level read consistency.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Your transaction might not update the table later in the same transaction. However, if multiple transactions concurrently hold share table locks for the same table, no transaction can update the table (even if row locks are held as the result of a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement). Therefore, if concurrent share table locks on the same table are common, updates cannot proceed and deadlocks are common. In this case, use share row exclusive or exclusive table locks instead.</div>
</li>
</ul>
<p><span class="bold">Scenario:</span> Tables <code dir="ltr">employees</code> and <code dir="ltr">budget_tab</code> require a consistent set of data in a third table, <code dir="ltr">departments</code>. For a given department number, you want to update the information in <code dir="ltr">employees</code> and <code dir="ltr">budget_tab</code>, and ensure that no members are added to the department between these two transactions.</p>
<p><span class="bold">Solution:</span> Lock the <code dir="ltr">departments</code> table in <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code>, as shown in <a href="#CHDBHJJD">Example 6-1</a>. Because the <code dir="ltr">departments</code> table is rarely updated, locking it probably does not cause many other transactions to wait long.</p>
<div id="ADFNS137" class="example">
<p class="titleinexample"><a id="CHDBHJJD"></a>Example 6-1 LOCK TABLE with SHARE MODE</p>
<pre dir="ltr">-- Create and populate table:
 
DROP TABLE budget_tab;
CREATE TABLE budget_tab (
  sal     NUMBER(8,2),
  deptno  NUMBER(4)
);
 
INSERT INTO budget_tab (sal, deptno)
  SELECT salary, department_id
  FROM employees;
 
-- Lock departments and update employees and budget_tab:
 
<span class="bold">LOCK TABLE departments IN SHARE MODE;</span>
 
<span class="bold">UPDATE employees</span>
  SET salary = salary * 1.1
  WHERE department_id IN
    (SELECT department_id FROM departments WHERE location_id = 1700);
 
<span class="bold">UPDATE budget_tab</span>
SET sal = sal * 1.1
WHERE deptno IN
  (SELECT department_id FROM departments WHERE location_id = 1700);
 
<span class="bold">COMMIT;</span>  -- COMMIT releases lock
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="g1033427"></a>
<div id="ADFNS99940" class="sect3">
<h4 class="sect3"><span class="secnum">6.4.2.3</span> When to Lock with SHARE ROW EXCLUSIVE MODE</h4>
<p><a id="sthref195"></a>You might use a <code dir="ltr">SHARE</code> <code dir="ltr">ROW</code> <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">MODE</code> table lock if:</p>
<ul>
<li>
<p>Your transaction requires both transaction-level read consistency for the specified table and the ability to update the locked table.</p>
</li>
<li>
<p>You do not care if other transactions acquire explicit row locks (using <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>), which might make <code dir="ltr">UPDATE</code> and <code dir="ltr">INSERT</code> statements in the locking transaction wait and might cause deadlocks.</p>
</li>
<li>
<p>You want only a single transaction to have this action.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="g1033439"></a>
<div id="ADFNS99939" class="sect3">
<h4 class="sect3"><span class="secnum">6.4.2.4</span> When to Lock with EXCLUSIVE MODE</h4>
<p><a id="sthref196"></a>You might use an <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">MODE</code> table if:</p>
<ul>
<li>
<p>Your transaction requires immediate update access to the locked table. When your transaction holds an exclusive table lock, other transactions cannot lock specific rows in the locked table.</p>
</li>
<li>
<p>Your transaction also ensures transaction-level read consistency for the locked table until the transaction is committed or rolled back.</p>
</li>
<li>
<p>You are not concerned about low levels of data concurrency, making transactions that request exclusive table locks wait in line to update the table sequentially.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1024981"></a>
<div id="ADFNS99938" class="sect2">
<h3 class="sect2"><span class="secnum">6.4.3</span> Letting Oracle Database Control Table Locking</h3>
<p><a id="sthref197"></a><a id="sthref198"></a>If you let Oracle Database control table locking, your application needs less programming logic, but also has less control than if you manage the table locks yourself.</p>
<p>Issuing the statement <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> <code dir="ltr">SERIALIZABLE</code> or <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> <code dir="ltr">SERIALIZABLE</code> preserves ANSI serializability without changing the underlying locking protocol. This technique gives concurrent access to the table while providing ANSI serializability. Getting table locks greatly reduces concurrency.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01705" href="../SQLRF/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement</p>
</li>
<li>
<p><a class="olink SQLRF00901" href="../SQLRF/statements_2015.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statements</p>
</li>
</ul>
</div>
<p>Change the settings for these parameters only when an instance is shut down. If multiple instances are accessing a single database, then all instances must use the same setting for these parameters.</p>
</div>
<!-- class="sect2" -->
<a id="i1025003"></a>
<div id="ADFNS99937" class="sect2">
<h3 class="sect2"><span class="secnum">6.4.4</span> Explicitly Acquiring Row Locks</h3>
<p><a id="sthref199"></a><a id="sthref200"></a>You can override default locking with a <a id="sthref201"></a><code dir="ltr">SELECT</code> statement that includes the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause. This statement acquires exclusive row locks for selected rows (as an <code dir="ltr">UPDATE</code> statement does), in anticipation of updating the selected rows in a subsequent statement.</p>
<p>You can use a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement to lock a row without changing it. For example, several triggers in <a class="olink LNPLS020" href="../LNPLS/overview.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> show how to implement referential integrity. In the <code dir="ltr">EMP_DEPT_CHECK</code> trigger, the row that contains the referenced parent key value is locked to guarantee that it remains for the duration of the transaction; if the parent key is updated or deleted, referential integrity is violated.</p>
<p><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statements are often used by interactive programs that let a user modify fields of one or more specific rows (which might take some time); row locks are acquired so that only a single interactive program user is updating the rows at any given time.</p>
<p>If a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement is used when defining a cursor, the rows in the return set are locked when the cursor is opened (before the first fetch) rather than being locked as they are fetched from the cursor. Locks are released only when the transaction that opened the cursor is committed or rolled back, not when the cursor is closed.</p>
<p>Each row in the return set of a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement is locked individually; the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement waits until the other transaction releases the conflicting row lock. If a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement locks many rows in a table, and if the table experiences much update activity, it might be faster to acquire an <code dir="ltr">EXCLUSIVE</code> table lock instead.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The return set for a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> might change while the query is running; for example, if columns selected by the query are updated or rows are deleted after the query started. When this happens, <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> acquires locks on the rows that did not change, gets a read-consistent snapshot of the table using these locks, and then restarts the query to acquire the remaining locks.
<p>If your application uses the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement and cannot guarantee that a conflicting locking request will not result in user-caused deadlocks&mdash;for example, through ensuring that concurrent DML statements on a table never affect the return set of the query of a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement&mdash;then code the application always to handle such a deadlock (ORA-00060) in an appropriate manner.</p>
</div>
<p>By default, the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement waits until the requested row lock is acquired. To change this behavior, use the <code dir="ltr">NOWAIT</code>, <code dir="ltr">WAIT</code>, or <code dir="ltr">SKIP</code> <code dir="ltr">LOCKED</code> clause of the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement. For information about these clauses, see <a class="olink SQLRF01702" href="../SQLRF/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="BEJFACAJ"></a>
<div id="ADFNS99936" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.4.5</span> Examples of Concurrency Under Explicit Locking</h3>
<p><a href="#BEJHACAH">Table 6-2</a> shows how Oracle Database maintains data <a id="sthref202"></a>concurrency, integrity, and consistency when the <a id="sthref203"></a><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement and the <a id="sthref204"></a><code dir="ltr">SELECT</code> statement with the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause are used. For brevity, the message text for ORA-00054 (&#34;resource busy and acquire with <code dir="ltr">NOWAIT</code> specified&#34;) is not included. User-entered text is <span class="bold">bold</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In tables compressed with Hybrid Columnar Compression (HCC), DML statements lock compression units rather than rows. HCC, a feature of certain Oracle storage systems, is described in <a class="olink CNCPT89198" href="../CNCPT/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</div>
<div id="ADFNS138" class="tblformal">
<p class="titleintable"><a id="sthref205"></a><a id="BEJHACAH"></a>Table 6-2 Examples of Concurrency Under Explicit Locking</p>
<table class="cellalignment293" title="Examples of Concurrency Under Explicit Locking" summary="This table shows how Oracle Database maintains data concurrency, integrity, and consistency when the LOCK TABLE statement and the SELECT statement with the FOR UPDATE clause are used. For brevity, the message text for ORA-00054 (&#34;resource busy and acquire with NOWAIT specified&#34;) is not included. User-entered text is bold." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t33">Transaction 1</th>
<th class="cellalignment294" id="r1c2-t33">Time Point</th>
<th class="cellalignment294" id="r1c3-t33">Transaction 2</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW SHARE MODE;</span>

Statement processed.
</pre></td>
<td class="cellalignment295" headers="r2c1-t33 r1c2-t33">
<p>1</p>
</td>
<td class="cellalignment295" headers="r2c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r3c1-t33 r1c2-t33">
<p>2</p>
</td>
<td class="cellalignment295" headers="r3c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">DROP TABLE hr.departments;</span>

DROP TABLE hr.departments
* 
ORA-00054
</pre>
<p>(Exclusive DDL lock not possible because Transaction 1 has table locked.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r4c1-t33 r1c2-t33">
<p>3</p>
</td>
<td class="cellalignment295" headers="r4c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r5c1-t33 r1c2-t33">
<p>4</p>
</td>
<td class="cellalignment295" headers="r5c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = &#39;NEW YORK&#39;</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 2 locked same rows.)</p>
</td>
<td class="cellalignment295" headers="r6c1-t33 r1c2-t33">
<p>5</p>
</td>
<td class="cellalignment295" headers="r6c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r7c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r7c1-t33 r1c2-t33">
<p>6</p>
</td>
<td class="cellalignment295" headers="r7c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">ROLLBACK;</span>
</pre>
<p>(Releases row locks.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r8c1-t33" headers="r1c1-t33">
<pre dir="ltr">1 row processed.

<span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment295" headers="r8c1-t33 r1c2-t33">
<p>7</p>
</td>
<td class="cellalignment295" headers="r8c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r9c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE;</span>
 
Statement processed.
</pre></td>
<td class="cellalignment295" headers="r9c1-t33 r1c2-t33">
<p>8</p>
</td>
<td class="cellalignment295" headers="r9c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r10c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r10c1-t33 r1c2-t33">
<p>9</p>
</td>
<td class="cellalignment295" headers="r10c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r11c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r11c1-t33 r1c2-t33">
<p>10</p>
</td>
<td class="cellalignment295" headers="r11c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r12c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r12c1-t33 r1c2-t33">
<p>11</p>
</td>
<td class="cellalignment295" headers="r12c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r13c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r13c1-t33 r1c2-t33">
<p>12</p>
</td>
<td class="cellalignment295" headers="r13c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = &#39;NEW YORK&#39;</span>
<span class="bold">WHERE department_id = 20;</span>
 
1 row processed.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r14c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r14c1-t33 r1c2-t33">
<p>13</p>
</td>
<td class="cellalignment295" headers="r14c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">ROLLBACK;</span>
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r15c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
<td class="cellalignment295" headers="r15c1-t33 r1c2-t33">
<p>14</p>
</td>
<td class="cellalignment295" headers="r15c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r16c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r16c1-t33 r1c2-t33">
<p>15</p>
</td>
<td class="cellalignment295" headers="r16c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = &#39;NEW YORK&#39;</span>
<span class="bold">WHERE department_id = 20;</span>
 
1 row processed.
</pre>
<p>(Waits because Transaction 1 locked same rows.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r17c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment295" headers="r17c1-t33 r1c2-t33">
<p>16</p>
</td>
<td class="cellalignment295" headers="r17c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r18c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r18c1-t33 r1c2-t33">
<p>17</p>
</td>
<td class="cellalignment295" headers="r18c1-t33 r1c3-t33">
<pre dir="ltr">1 row processed.
</pre>
<p>(Conflicting locks were released.)</p>
<pre dir="ltr"><span class="bold">ROLLBACK;</span>
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r19c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW SHARE MODE</span>
 
Statement processed.
</pre></td>
<td class="cellalignment295" headers="r19c1-t33 r1c2-t33">
<p>18</p>
</td>
<td class="cellalignment295" headers="r19c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r20c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r20c1-t33 r1c2-t33">
<p>19</p>
</td>
<td class="cellalignment295" headers="r20c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r21c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r21c1-t33 r1c2-t33">
<p>20</p>
</td>
<td class="cellalignment295" headers="r21c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r22c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r22c1-t33 r1c2-t33">
<p>21</p>
</td>
<td class="cellalignment295" headers="r22c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE;</span>
 
Statement processed.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r23c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r23c1-t33 r1c2-t33">
<p>22</p>
</td>
<td class="cellalignment295" headers="r23c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r24c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r24c1-t33 r1c2-t33">
<p>23</p>
</td>
<td class="cellalignment295" headers="r24c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r25c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r25c1-t33 r1c2-t33">
<p>24</p>
</td>
<td class="cellalignment295" headers="r25c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = &#39;NEW YORK&#39;</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 1 has conflicting table lock.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r26c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment295" headers="r26c1-t33 r1c2-t33">
<p>25</p>
</td>
<td class="cellalignment295" headers="r26c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r27c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r27c1-t33 r1c2-t33">
<p>26</p>
</td>
<td class="cellalignment295" headers="r27c1-t33 r1c3-t33">
<pre dir="ltr">1 row processed.
</pre>
<p>(Conflicting table lock released.)</p>
<pre dir="ltr"><span class="bold">ROLLBACK;</span>
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r28c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE;</span>
 
Statement processed.
</pre></td>
<td class="cellalignment295" headers="r28c1-t33 r1c2-t33">
<p>27</p>
</td>
<td class="cellalignment295" headers="r28c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r29c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r29c1-t33 r1c2-t33">
<p>28</p>
</td>
<td class="cellalignment295" headers="r29c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r30c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r30c1-t33 r1c2-t33">
<p>29</p>
</td>
<td class="cellalignment295" headers="r30c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r31c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r31c1-t33 r1c2-t33">
<p>30</p>
</td>
<td class="cellalignment295" headers="r31c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r32c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r32c1-t33 r1c2-t33">
<p>31</p>
</td>
<td class="cellalignment295" headers="r32c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r33c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r33c1-t33 r1c2-t33">
<p>32</p>
</td>
<td class="cellalignment295" headers="r33c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r34c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r34c1-t33 r1c2-t33">
<p>33</p>
</td>
<td class="cellalignment295" headers="r34c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r35c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r35c1-t33 r1c2-t33">
<p>34</p>
</td>
<td class="cellalignment295" headers="r35c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r36c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r36c1-t33 r1c2-t33">
<p>35</p>
</td>
<td class="cellalignment295" headers="r36c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = &#39;NEW YORK&#39;</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 1 has conflicting table lock.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r37c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = &#39;NEW YORK&#39;</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 2 locked same rows.)</p>
</td>
<td class="cellalignment295" headers="r37c1-t33 r1c2-t33">
<p>36</p>
</td>
<td class="cellalignment295" headers="r37c1-t33 r1c3-t33">
<p>(Deadlock.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r38c1-t33" headers="r1c1-t33">
<pre dir="ltr">Cancel operation.

<span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment295" headers="r38c1-t33 r1c2-t33">
<p>37</p>
</td>
<td class="cellalignment295" headers="r38c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r39c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r39c1-t33 r1c2-t33">
<p>38</p>
</td>
<td class="cellalignment295" headers="r39c1-t33 r1c3-t33">
<pre dir="ltr">1 row processed.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r40c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE;</span>
</pre></td>
<td class="cellalignment295" headers="r40c1-t33 r1c2-t33">
<p>39</p>
</td>
<td class="cellalignment295" headers="r40c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r41c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r41c1-t33 r1c2-t33">
<p>40</p>
</td>
<td class="cellalignment295" headers="r41c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r42c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r42c1-t33 r1c2-t33">
<p>41</p>
</td>
<td class="cellalignment295" headers="r42c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r43c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r43c1-t33 r1c2-t33">
<p>42</p>
</td>
<td class="cellalignment295" headers="r43c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r44c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r44c1-t33 r1c2-t33">
<p>43</p>
</td>
<td class="cellalignment295" headers="r44c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r45c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r45c1-t33 r1c2-t33">
<p>44</p>
</td>
<td class="cellalignment295" headers="r45c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW SHARE MODE</span>
<span class="bold">NOWAIT;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r46c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r46c1-t33 r1c2-t33">
<p>45</p>
</td>
<td class="cellalignment295" headers="r46c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r47c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r47c1-t33 r1c2-t33">
<p>46</p>
</td>
<td class="cellalignment295" headers="r47c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
</pre>
<p>(Waits because Transaction 1 has conflicting table lock.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r48c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET department_id = 30</span>
<span class="bold">WHERE department_id = 20;</span>
 
1 row processed.
</pre></td>
<td class="cellalignment295" headers="r48c1-t33 r1c2-t33">
<p>47</p>
</td>
<td class="cellalignment295" headers="r48c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r49c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">COMMIT;</span>
</pre></td>
<td class="cellalignment295" headers="r49c1-t33 r1c2-t33">
<p>48</p>
</td>
<td class="cellalignment295" headers="r49c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r50c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r50c1-t33 r1c2-t33">
<p>49</p>
</td>
<td class="cellalignment295" headers="r50c1-t33 r1c3-t33">
<pre dir="ltr">0 rows selected.
</pre>
<p>(Transaction 1 released conflicting lock.)</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r51c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">SET TRANSACTION READ ONLY;</span>
</pre></td>
<td class="cellalignment295" headers="r51c1-t33 r1c2-t33">
<p>50</p>
</td>
<td class="cellalignment295" headers="r51c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r52c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
BOSTON
</pre></td>
<td class="cellalignment295" headers="r52c1-t33 r1c2-t33">
<p>51</p>
</td>
<td class="cellalignment295" headers="r52c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r53c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r53c1-t33 r1c2-t33">
<p>52</p>
</td>
<td class="cellalignment295" headers="r53c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = &#39;NEW YORK&#39;</span>
<span class="bold">WHERE department_id = 10</span>;
 
1 row processed.
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r54c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
BOSTON
</pre>
<p>(Transaction 1 does not see uncommitted data.)</p>
</td>
<td class="cellalignment295" headers="r54c1-t33 r1c2-t33">
<p>53</p>
</td>
<td class="cellalignment295" headers="r54c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r55c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment295" headers="r55c1-t33 r1c2-t33">
<p>54</p>
</td>
<td class="cellalignment295" headers="r55c1-t33 r1c3-t33">
<pre dir="ltr"><span class="bold">COMMIT;</span>
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r56c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
BOSTON
</pre>
<p>(Same result even after Transaction 2 commits.)</p>
</td>
<td class="cellalignment295" headers="r56c1-t33 r1c2-t33">
<p>55</p>
</td>
<td class="cellalignment295" headers="r56c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r57c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">COMMIT;</span>
</pre></td>
<td class="cellalignment295" headers="r57c1-t33 r1c2-t33">
<p>56</p>
</td>
<td class="cellalignment295" headers="r57c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r58c1-t33" headers="r1c1-t33">
<pre dir="ltr"><span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
NEW YORK
</pre>
<p>(Sees committed data.)</p>
</td>
<td class="cellalignment295" headers="r58c1-t33 r1c2-t33">
<p>57</p>
</td>
<td class="cellalignment295" headers="r58c1-t33 r1c3-t33">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1025030"></a>
<div id="ADFNS1002" class="sect1">
<h2 class="sect1"><span class="secnum">6.5</span> Using Oracle Lock Management Services (User Locks)</h2>
<p><a id="i1025635"></a>Your applications can use <a id="sthref206"></a>Oracle Lock Management services (<a id="sthref207"></a>user locks) by invoking subprograms the <a id="sthref208"></a><code dir="ltr">DBMS_LOCK</code> package. An application can request a lock of a specific mode, give it a unique name (recognizable in another subprogram in the same or another instance), change the lock mode, and release it. Because a reserved user lock is an Oracle Database lock, it has all the features of a database lock, such as deadlock detection. Ensure that any user locks used in distributed transactions are released upon <code dir="ltr">COMMIT</code>, otherwise an <a id="sthref209"></a><a id="sthref210"></a>undetected deadlock can occur.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS021" href="../ARPLS/d_lock.htm#ARPLS021"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information about the <code dir="ltr">DBMS_LOCK</code> package</div>
<p class="subhead2"><a id="ADFNS978"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1025052">When to Use User Locks</a></p>
</li>
<li>
<p><a href="#i1025438">Viewing and Monitoring Locks</a></p>
</li>
</ul>
<a id="i1025052"></a>
<div id="ADFNS99935" class="sect2">
<h3 class="sect2"><span class="secnum">6.5.1</span> When to Use User Locks</h3>
<p>User locks can help:</p>
<ul>
<li>
<p>Provide exclusive access to a device, such as a terminal</p>
</li>
<li>
<p>Provide application-level enforcement of read locks</p>
</li>
<li>
<p>Detect when a lock is released and clean up after the application</p>
</li>
<li>
<p>Synchronize applications and enforce sequential processing</p>
</li>
</ul>
<p><a href="#BEJFEIIH">Example 6-2</a> shows how the Pro*COBOL precompiler uses locks to ensure that there are no conflicts when multiple people must access a single device.</p>
<div id="ADFNS139" class="example">
<p class="titleinexample"><a id="BEJFEIIH"></a>Example 6-2 How the Pro*COBOL Precompiler Uses Locks</p>
<pre dir="ltr">****************************************************************** 
* Print Check                                                    * 
* Any cashier may issue a refund to a customer returning goods.  * 
* Refunds under $50 are given in cash, more than $50 by check.   * 
* This code prints the check. One printer is opened by all       * 
* the cashiers to avoid the overhead of opening and closing it   * 
* for every check, meaning that lines of output from multiple    * 
* cashiers can become interleaved if you do not ensure exclusive * 
* access to the printer. The DBMS_LOCK package is used to        * 
* ensure exclusive access.                                       * 
****************************************************************** 
CHECK-PRINT 
*    Get the lock &#34;handle&#34; for the printer lock. 
   MOVE &#34;CHECKPRINT&#34; TO LOCKNAME-ARR. 
   MOVE 10 TO LOCKNAME-LEN. 
   EXEC SQL EXECUTE 
      BEGIN DBMS_LOCK.ALLOCATE_UNIQUE ( :LOCKNAME, :LOCKHANDLE ); 
      END; END-EXEC. 
*   Lock the printer in exclusive mode (default mode).
   EXEC SQL EXECUTE 
      BEGIN DBMS_LOCK.REQUEST ( :LOCKHANDLE ); 
      END; END-EXEC. 
*   You now have exclusive use of the printer, print the check. 
  ... 
*   Unlock the printer so other people can use it 
EXEC SQL EXECUTE 
      BEGIN DBMS_LOCK.RELEASE ( :LOCKHANDLE ); 
      END; END-EXEC.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1025438"></a>
<div id="ADFNS99934" class="sect2">
<h3 class="sect2"><span class="secnum">6.5.2</span> Viewing and Monitoring Locks</h3>
<p><a href="#BEJFHIIJ">Table 6-3</a> describes the Oracle Database facilities that display locking information for ongoing transactions within an instance.</p>
<div id="ADFNS140" class="tblformal">
<p class="titleintable"><a id="sthref211"></a><a id="BEJFHIIJ"></a>Table 6-3 Ways to Display Locking Information</p>
<table class="cellalignment293" title=" Ways to Display Locking Information" summary="This table describes the Oracle Database facilities that display locking information for on-going transactions within an instance." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t35">Tool</th>
<th class="cellalignment294" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t35" headers="r1c1-t35">
<p>Performance Monitoring Data Dictionary Views</p>
</td>
<td class="cellalignment295" headers="r2c1-t35 r1c2-t35">
<p>See <a class="olink ADMIN11256" href="../ADMIN/monitoring.htm#ADMIN11256"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a>.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t35" headers="r1c1-t35">
<p><code dir="ltr">UTLLOCKT</code>.<code dir="ltr">SQL</code></p>
</td>
<td class="cellalignment295" headers="r3c1-t35 r1c2-t35">
<p><a id="sthref212"></a>The <code dir="ltr">UTLLOCKT</code>.<code dir="ltr">SQL</code> script displays a simple character lock wait-for graph in tree structured fashion. Using any SQL tool (such as SQL*Plus) to run the script, it prints the sessions in the system that are waiting for locks and the corresponding blocking locks. The location of this script file is operating system dependent. (You must have run the <code dir="ltr">CATBLOCK</code>.<code dir="ltr">SQL</code> script before using <code dir="ltr">UTLLOCKT</code>.<code dir="ltr">SQL</code>.)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1025370"></a>
<div id="ADFNS00204" class="sect1">
<h2 class="sect1"><span class="secnum">6.6</span> Using Serializable Transactions for Concurrency Control</h2>
<p><a id="sthref213"></a><a id="sthref214"></a>By default, Oracle Database permits concurrently running transactions to modify, add, or delete rows in the same table, and in the same data block. When transaction A changes a table, the changes are invisible to concurrently running transactions until transaction A commits them. If transaction A tries to update or delete a row that transaction B has locked (by issuing a DML or <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement), then the DML statement that A issued waits until B either commits or rolls back the transaction. This concurrency model, which provides higher concurrency and thus better performance, is appropriate for most applications.</p>
<p>However, some rare applications require serializable transactions. <span class="bold">Serializable transactions</span> run concurrently in serialized mode. In <span class="bold">serialized mode</span>, concurrent transactions can make only the database changes that they could make if they were running serially (that is, one at a time). If a serialized transaction tries to change data that another transaction changed after the serialized transaction began, then error ORA-08177 occurs.</p>
<p>When a serializable transaction fails with ORA-08177, the application can take any of these actions:</p>
<ul>
<li>
<p>Commit the work executed to that point.</p>
</li>
<li>
<p>Run additional, different, statements, perhaps after rolling back to a prior savepoint in the transaction.</p>
</li>
<li>
<p>Roll back the transaction and then rerun it.</p>
<p>The transaction gets a transaction snapshot and the operation is likely to succeed.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
To minimize the performance overhead of rolling back and re running transactions, put DML statements that might conflict with concurrent transactions near the beginning of the transaction.</div>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Serializable transactions do not work with deferred segment creation or interval partitioning. Trying to insert data into an empty table with no segment created, or into a partition of an interval partitioned table that does not yet have a segment, causes an error.</div>
<p class="subhead2"><a id="ADFNS979"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJDDAGA">Transaction Interaction and Isolation Level</a></p>
</li>
<li>
<p><a href="#i1007165">Setting Isolation Levels</a></p>
</li>
<li>
<p><a href="#g1033864">Serializable Transactions and Referential Integrity</a></p>
</li>
<li>
<p><a href="#g1033897">READ COMMITTED and SERIALIZABLE Isolation Levels</a></p>
</li>
</ul>
<a id="BEJDDAGA"></a>
<div id="ADFNS99871" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">6.6.1</span> Transaction Interaction and Isolation Level</h3>
<p>The ANSI/ISO SQL standard defines three kinds of <a id="sthref215"></a>transaction interaction:</p>
<div class="inftblinformal">
<table class="cellalignment296" title="ANSI/ISO SQL Transaction Interactions" summary="This table lists and defines the three kinds of transaction interactions that the ANSI/ISO SQL standard defines." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t38">Transaction Interaction</th>
<th class="cellalignment294" id="r1c2-t38">Definition</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t38" headers="r1c1-t38"><a id="sthref216"></a>Dirty read</td>
<td class="cellalignment295" headers="r2c1-t38 r1c2-t38">Transaction A reads uncommitted changes made by transaction B.</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t38" headers="r1c1-t38"><a id="sthref217"></a>Unrepeatable read</td>
<td class="cellalignment295" headers="r3c1-t38 r1c2-t38">Transaction A reads data, transaction B changes the data and commits the changes, and transaction A rereads the data and sees the changes.</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t38" headers="r1c1-t38"><a id="sthref218"></a>Phantom read</td>
<td class="cellalignment295" headers="r4c1-t38 r1c2-t38">Transaction A runs a query, transaction B inserts new rows and commits the change, and transaction A repeats the query and sees the new rows.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>The kinds of interactions that a transaction can have is determined by its isolation level. The ANSI/ISO SQL standard defines four transaction isolation levels. <a href="#g1026777">Table 6-4</a> shows what kind of interactions are possible at each <a id="sthref219"></a><a id="sthref220"></a>isolation level.</p>
<div id="ADFNS141" class="tblformal">
<p class="titleintable"><a id="sthref221"></a><a id="g1026777"></a>Table 6-4 ANSI/ISO SQL Isolation Levels and Possible Transaction Interactions</p>
<table class="cellalignment293" title=" ANSI/ISO SQL Isolation Levels and Possible Transaction Interactions" summary="This table lists the four transaction isolation levels that the ANSI/ISO SQL standard defines and shows the kinds of transaction interactions possible at each level." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t39">Isolation Level</th>
<th class="cellalignment294" id="r1c2-t39">Dirty Read</th>
<th class="cellalignment294" id="r1c3-t39">Unrepeatable Read</th>
<th class="cellalignment294" id="r1c4-t39">Phantom Read</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t39" headers="r1c1-t39">
<p><a id="sthref222"></a><code dir="ltr">READ</code> <code dir="ltr">UNCOMMITTED</code></p>
</td>
<td class="cellalignment295" headers="r2c1-t39 r1c2-t39">
<p>Possible</p>
</td>
<td class="cellalignment295" headers="r2c1-t39 r1c3-t39">
<p>Possible</p>
</td>
<td class="cellalignment295" headers="r2c1-t39 r1c4-t39">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t39" headers="r1c1-t39">
<p><a id="sthref223"></a><code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code></p>
</td>
<td class="cellalignment295" headers="r3c1-t39 r1c2-t39">
<p>Not possible</p>
</td>
<td class="cellalignment295" headers="r3c1-t39 r1c3-t39">
<p>Possible</p>
</td>
<td class="cellalignment295" headers="r3c1-t39 r1c4-t39">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t39" headers="r1c1-t39">
<p><a id="sthref224"></a><code dir="ltr">REPEATABLE</code> <code dir="ltr">READ</code></p>
</td>
<td class="cellalignment295" headers="r4c1-t39 r1c2-t39">
<p>Not possible</p>
</td>
<td class="cellalignment295" headers="r4c1-t39 r1c3-t39">
<p>Not possible</p>
</td>
<td class="cellalignment295" headers="r4c1-t39 r1c4-t39">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t39" headers="r1c1-t39">
<p><a id="sthref225"></a><code dir="ltr">SERIALIZABLE</code></p>
</td>
<td class="cellalignment295" headers="r5c1-t39 r1c2-t39">
<p>Not possible</p>
</td>
<td class="cellalignment295" headers="r5c1-t39 r1c3-t39">
<p>Not possible</p>
</td>
<td class="cellalignment295" headers="r5c1-t39 r1c4-t39">
<p>Not possible</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a href="#g1026806">Table 6-5</a> shows which ANSI/ISO SQL transaction isolation levels Oracle Database provides.</p>
<div id="ADFNS142" class="tblformal">
<p class="titleintable"><a id="sthref226"></a><a id="g1026806"></a>Table 6-5 ANSI/ISO SQL Isolation Levels Provided by Oracle Database</p>
<table class="cellalignment293" title=" ANSI/ISO SQL Isolation Levels Provided by Oracle Database" summary="This table describes the action of Oracle Database with respect to the isolation levels that the ANSI/ISO SQL standard SQL92 defines." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t40">Isolation Level</th>
<th class="cellalignment294" id="r1c2-t40">Provided by Oracle Database</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t40" headers="r1c1-t40">
<p><a id="sthref227"></a><code dir="ltr">READ</code> <code dir="ltr">UNCOMMITTED</code></p>
</td>
<td class="cellalignment295" headers="r2c1-t40 r1c2-t40">
<p>No. Oracle Database never permits &#34;dirty reads.&#34; Some other database products use this undesirable technique to improve throughput, but it is not required for high throughput with Oracle Database.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t40" headers="r1c1-t40">
<p><a id="sthref228"></a><code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code></p>
</td>
<td class="cellalignment295" headers="r3c1-t40 r1c2-t40">
<p>Yes, by default. In fact, because an Oracle Database query sees only data that was committed at the beginning of the query (the snapshot time), Oracle Database offers more consistency than the ANSI/ISO SQL standard for <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation requires.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t40" headers="r1c1-t40">
<p><a id="sthref229"></a><code dir="ltr">REPEATABLE</code> <code dir="ltr">READ</code></p>
</td>
<td class="cellalignment295" headers="r4c1-t40 r1c2-t40">
<p>Yes, if you set the transaction isolation level to <code dir="ltr">SERIALIZABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t40" headers="r1c1-t40">
<p><a id="sthref230"></a><code dir="ltr">SERIALIZABLE</code></p>
</td>
<td class="cellalignment295" headers="r5c1-t40 r1c2-t40">
<p>Yes, if you set the transaction isolation level to <code dir="ltr">SERIALIZABLE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a href="#i1025588">Figure 6-1</a> shows how an arbitrary transaction (that is, one that is either <code dir="ltr">SERIALIZABLE</code> or <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code>) <a id="sthref231"></a><a id="sthref232"></a>interacts with a serializable transaction.</p>
<div id="ADFNS143" class="figure">
<p class="titleinfigure"><a id="i1025588"></a>Figure 6-1 Interaction Between Serializable Transaction and Another Transaction</p>
<img width="460" height="596" src="img/adfns053.gif" alt="Description of Figure 6-1 follows"/><br/>
<a id="sthref233" href="img_text/adfns053.htm">Description of &#39;&#39;Figure 6-1 Interaction Between Serializable Transaction and Another Transaction&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="i1007165"></a>
<div id="ADFNS99932" class="sect2">
<h3 class="sect2"><span class="secnum">6.6.2</span> Setting Isolation Levels</h3>
<p><a id="sthref234"></a>To set the transaction isolation level for every transaction in your session, use the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statement, described in <a class="olink SQLRF00901" href="../SQLRF/statements_2015.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>To set the transaction isolation level for a specific transaction, use the <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> clause of the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement. The <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement, described in <a class="olink SQLRF01705" href="../SQLRF/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a>, must be the first statement in the transaction.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you set the transaction isolation level to <code dir="ltr">SERIALIZABLE</code>, then you must use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement to set the <code dir="ltr">INITRANS</code> parameter to at least 3. Use higher values for tables for which many transactions update the same blocks. For more information about <code dir="ltr">INITRANS</code>, see <a class="olink SQLRF52296" href="../SQLRF/clauses007.htm#SQLRF52296"><span class="italic">Oracle Database SQL Language Reference</span></a>.</div>
</div>
<!-- class="sect2" -->
<a id="g1033864"></a>
<div id="ADFNS99996" class="sect2">
<h3 class="sect2"><span class="secnum">6.6.3</span> Serializable Transactions and Referential Integrity</h3>
<p><a id="sthref235"></a><a id="sthref236"></a>Because Oracle Database does not use <a id="sthref237"></a>read locks, even in <code dir="ltr">SERIALIZABLE</code> transactions, data read by one transaction can be overwritten by another. Therefore, transactions that perform database consistency checks at the application level must not assume that the data they read does not change during the transaction (even though such changes are invisible to the transaction). Code your application-level consistency checks carefully, even when using <code dir="ltr">SERIALIZABLE</code> transactions.</p>
<p>In <a href="#i1020116">Figure 6-2</a>, transactions A and B (which are either <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> or <code dir="ltr">SERIALIZABLE</code>) perform application-level checks to maintain the referential integrity of the parent/child relationship between two tables. Transaction A queries the parent table to check that it has a row with a specific primary key value before inserting corresponding child rows into the child table. Transaction B queries the child table to check that no child rows exist for a specific primary key value before deleting the corresponding parent row from the parent table. Both transactions assume (but do not ensure) that the data they read does not change before the transaction completes.</p>
<div id="ADFNS144" class="figure">
<p class="titleinfigure"><a id="i1020116"></a>Figure 6-2 Referential Integrity Check</p>
<img width="426" height="331" src="img/adfns054.gif" alt="Description of Figure 6-2 follows"/><br/>
<a id="sthref238" href="img_text/adfns054.htm">Description of &#39;&#39;Figure 6-2 Referential Integrity Check&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The query by transaction A does not prevent transaction B from deleting the parent row, and the query by transaction B does not prevent transaction A from inserting child rows. Therefore, this can happen:</p>
<ol>
<li>
<p>Transaction A queries the parent table and finds the specified parent row.</p>
</li>
<li>
<p>Transaction B queries the child table and finds no child rows for the specified parent row.</p>
</li>
<li id="BEJDJJFC">
<p>Having found the specified parent row, transaction A inserts the corresponding child rows into the child table.</p>
</li>
<li>
<p>Having found no child rows for the specified parent row, transaction B deletes the specified parent row from the parent table.</p>
<p>Now the child rows that transaction A inserted in step&nbsp;<a href="#BEJDJJFC">3</a> have no parent row.</p>
</li>
</ol>
<p>The preceding result can occur even if both A and B are <code dir="ltr">SERIALIZABLE</code> transactions, because neither transaction prevents the other from changing the data that it reads to check consistency.</p>
<p>Ensuring that data queried by one transaction is not concurrently changed or deleted by another requires more transaction isolation than the ANSI/ISO SQL standard <code dir="ltr">SERIALIZABLE</code> isolation level provides. However, in Oracle Database:</p>
<ul>
<li>
<p>Transaction A can use a <a id="sthref239"></a><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement to query and lock the parent row, thereby preventing transaction B from deleting it.</p>
<p>For information about the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause of the <code dir="ltr">SELECT</code> statement, see <a class="olink SQLRF55370" href="../SQLRF/statements_10002.htm#SQLRF55370"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Transaction B can prevent transaction A from finding the parent row (thereby preventing A from inserting the child rows) by reversing the order of its processing steps. That is, transaction B can:</p>
<ol>
<li>
<p>Delete the parent row.</p>
</li>
<li>
<p>Query the child table.</p>
</li>
<li>
<p>If the deleted parent row has child rows in the child table, then roll back the deletion of the parent row.</p>
</li>
</ol>
</li>
</ul>
<p>Alternatively, you can enforce referential integrity with a <a id="sthref240"></a><a id="sthref241"></a>trigger. Instead of having transaction A query the parent table, define on the child table a row-level <code dir="ltr">BEFORE</code> <code dir="ltr">INSERT</code> trigger that does this:</p>
<ul>
<li>
<p>Queries the parent table with a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement, thereby ensuring that if the parent row exists, then it remains in the database for the duration of the transaction that inserts the child rows.</p>
</li>
<li>
<p>Rejects the insertion of the child rows if the parent row does not exist.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS770" href="../LNPLS/triggers.htm#LNPLS770"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about using triggers to maintain referential integrity between parent and child tables</div>
<p>A trigger runs SQL statements in the context of the triggering statement (that is, the triggering and triggered statements see the database in the same state). Therefore, if a <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> transaction runs the triggering statement, then the triggered statements see the database as it was when the triggering statement began to execute. If a <code dir="ltr">SERIALIZABLE</code> transaction runs the triggering statement, then the triggered statements see the database as it was at the beginning of the transaction. In either case, using <a id="sthref242"></a><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> in the trigger correctly enforces referential integrity.</p>
</div>
<!-- class="sect2" -->
<a id="g1033897"></a>
<div id="ADFNS99999" class="sect2">
<h3 class="sect2"><span class="secnum">6.6.4</span> READ COMMITTED and SERIALIZABLE Isolation Levels</h3>
<p>Oracle Database provides two transaction isolation levels, <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> and <code dir="ltr">SERIALIZABLE</code>. Both levels provide a high degree of consistency and concurrency, reduce contention, and are designed for real-world applications. This topic compares them and explains how to choose between them.</p>
<p class="subhead2"><a id="ADFNS980"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033487">Transaction Set Consistency Differences</a></p>
</li>
<li>
<p><a href="#g1033520">Choosing Transaction Isolation Levels</a></p>
</li>
</ul>
<a id="g1033487"></a>
<div id="ADFNS99997" class="sect3">
<h4 class="sect3"><span class="secnum">6.6.4.1</span> Transaction Set Consistency Differences</h4>
<p>An operation (query or transaction) is <a id="sthref243"></a><span class="glossaryterm">transaction set consistent</span> if all of its read operations return data written by the same set of committed transactions. When an operation is not transaction set consistent, some of its read operations reflect the changes of one set of transactions and others reflect the changes of other sets of transactions; that is, the operation sees the database in a state that reflects no single set of committed transactions.</p>
<p class="subhead2"><a id="ADFNS981"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJHEJBE">Oracle Database</a></p>
</li>
<li>
<p><a href="#BEJJHEJE">Other Database Systems</a></p>
</li>
</ul>
<a id="BEJHEJBE"></a>
<div id="ADFNS982" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.6.4.1.1</span> Oracle Database</h5>
<p>Oracle Database transactions with <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation level are transaction set consistent on an individual-statement basis, because all rows that a query reads must be committed before the query begins.</p>
<p>Oracle Database transactions with <code dir="ltr">SERIALIZABLE</code> isolation level are transaction set consistent on an individual-transaction basis, because all statements in a <code dir="ltr">SERIALIZABLE</code> transaction run on an image of the database as it was at the beginning of the transaction.</p>
</div>
<!-- class="sect4" -->
<a id="BEJJHEJE"></a>
<div id="ADFNS983" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.6.4.1.2</span> Other Database Systems</h5>
<p>In other database systems, a single query with <code dir="ltr">READ</code> <code dir="ltr">UNCOMMITTED</code> isolation level is not transaction set consistent, because it might see only a subset of the changes made by another transaction. For example, a join of a master table with a detail table can see a master record inserted by another transaction, but not the corresponding details inserted by that transaction (or the reverse). <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation level avoids this problem, providing more consistency than read-locking systems do.</p>
<p>In read-locking systems, at the cost of preventing concurrent updates, the <code dir="ltr">REPEATABLE</code> <code dir="ltr">READ</code> isolation level provides transaction set consistency at the statement level, but not at the transaction level. Due to the absence of phantom read protection, two queries in the same transaction can see data committed by different sets of transactions. In these systems, only the throughput-limiting and deadlock-susceptible <code dir="ltr">SERIALIZABLE</code> isolation level provides transaction set consistency at the transaction level.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="g1033520"></a>
<div id="ADFNS99998" class="sect3">
<h4 class="sect3"><span class="secnum">6.6.4.2</span> Choosing Transaction Isolation Levels</h4>
<p><a id="sthref244"></a><a id="sthref245"></a>The choice of transaction isolation level depends on performance and consistency needs and application coding requirements. There is a trade-off between concurrency (transaction throughput) and consistency. Consider the application and workload when choosing isolation levels for its transactions. Different transactions can have different isolation levels.</p>
<p>For environments with many concurrent users rapidly submitting transactions, consider expected transaction arrival rate, response time demands, and required degree of consistency.</p>
<p><a id="sthref246"></a><code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation can provide considerably more concurrency with a somewhat increased risk of inconsistent results (from unrepeatable and phantom reads) for some transactions.</p>
<p><a id="sthref247"></a><code dir="ltr">SERIALIZABLE</code> isolation provides somewhat more consistency (by protecting against phantoms and unrepeatable reads), which might be important where a read/write transaction runs a query more than once. However, <code dir="ltr">SERIALIZABLE</code> isolation requires applications to check for the &#34;cannot serialize access&#34; error, and this checking can significantly reduce throughput in an environment with many concurrent transactions accessing the same data for update.</p>
<p>As explained in <a href="#g1033864">Section 6.6.3</a> reads do not block writes in either <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> or <code dir="ltr">SERIALIZABLE</code> transactions.</p>
<p><a href="#g1026829">Table 6-6</a> summarizes the similarities and differences between <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> and <code dir="ltr">SERIALIZABLE</code> transactions.</p>
<div id="ADFNS145" class="tblformal">
<p class="titleintable"><a id="sthref248"></a><a id="g1026829"></a>Table 6-6 Comparison of READ COMMITTED and SERIALIZABLE Transactions</p>
<table class="cellalignment293" title=" Comparison of READ COMMITTED and SERIALIZABLE Transactions" summary="This table summarizes the key similarities and differences between READ COMMITTED and SERIALIZABLE transactions." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t43">Operation</th>
<th class="cellalignment294" id="r1c2-t43">READ COMMITTED</th>
<th class="cellalignment294" id="r1c3-t43">SERIALIZABLE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t43" headers="r1c1-t43">
<p>Dirty write</p>
</td>
<td class="cellalignment295" headers="r2c1-t43 r1c2-t43">
<p>Not Possible</p>
</td>
<td class="cellalignment295" headers="r2c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t43" headers="r1c1-t43">
<p>Dirty read</p>
</td>
<td class="cellalignment295" headers="r3c1-t43 r1c2-t43">
<p>Not Possible</p>
</td>
<td class="cellalignment295" headers="r3c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t43" headers="r1c1-t43">
<p>Unrepeatable read</p>
</td>
<td class="cellalignment295" headers="r4c1-t43 r1c2-t43">
<p>Possible</p>
</td>
<td class="cellalignment295" headers="r4c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t43" headers="r1c1-t43">
<p>Phantom read</p>
</td>
<td class="cellalignment295" headers="r5c1-t43 r1c2-t43">
<p>Possible</p>
</td>
<td class="cellalignment295" headers="r5c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t43" headers="r1c1-t43">
<p>Compliant with ANSI/ISO SQL 92</p>
</td>
<td class="cellalignment295" headers="r6c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment295" headers="r6c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r7c1-t43" headers="r1c1-t43">
<p>Read snapshot time</p>
</td>
<td class="cellalignment295" headers="r7c1-t43 r1c2-t43">
<p>Statement</p>
</td>
<td class="cellalignment295" headers="r7c1-t43 r1c3-t43">
<p>Transaction</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r8c1-t43" headers="r1c1-t43">
<p>Transaction set consistency</p>
</td>
<td class="cellalignment295" headers="r8c1-t43 r1c2-t43">
<p>Statement level</p>
</td>
<td class="cellalignment295" headers="r8c1-t43 r1c3-t43">
<p>Transaction level</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r9c1-t43" headers="r1c1-t43">
<p>Row-level locking</p>
</td>
<td class="cellalignment295" headers="r9c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment295" headers="r9c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r10c1-t43" headers="r1c1-t43">
<p>Readers block writers</p>
</td>
<td class="cellalignment295" headers="r10c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment295" headers="r10c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r11c1-t43" headers="r1c1-t43">
<p>Writers block readers</p>
</td>
<td class="cellalignment295" headers="r11c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment295" headers="r11c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r12c1-t43" headers="r1c1-t43">
<p>Different-row writers block writers</p>
</td>
<td class="cellalignment295" headers="r12c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment295" headers="r12c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r13c1-t43" headers="r1c1-t43">
<p>Same-row writers block writers</p>
</td>
<td class="cellalignment295" headers="r13c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment295" headers="r13c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r14c1-t43" headers="r1c1-t43">
<p>Waits for blocking transaction</p>
</td>
<td class="cellalignment295" headers="r14c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment295" headers="r14c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r15c1-t43" headers="r1c1-t43">
<p>Subject to &#34;cannot serialize access&#34; error</p>
</td>
<td class="cellalignment295" headers="r15c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment295" headers="r15c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r16c1-t43" headers="r1c1-t43">
<p>Error after blocking transaction terminates</p>
</td>
<td class="cellalignment295" headers="r16c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment295" headers="r16c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r17c1-t43" headers="r1c1-t43">
<p>Error after blocking transaction commits</p>
</td>
<td class="cellalignment295" headers="r17c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment295" headers="r17c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEJECCJJ"></a>
<div id="ADFNS187" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">6.7</span> Nonblocking and Blocking DDL Statements</h2>
<p>The distinction between <a id="sthref249"></a><a id="sthref250"></a>nonblocking and <a id="sthref251"></a><a id="sthref252"></a>blocking DDL statements matters only for DDL statements that change either tables or indexes (which depend on tables).</p>
<p>When a session issues a DDL statement that affects object X, the session waits until every concurrent DML statement that references X is either committed or rolled back.</p>
<p>While the session waits, concurrent sessions might issue new DML statements. If the DDL statement is nonblocking, then the new DML statements execute immediately. If the DDL statement is blocking, then the new DML statements execute after the DDL statement completes, either successfully or with an error.</p>
<p>The <a id="sthref253"></a><code dir="ltr">DDL_LOCK_TIMOUT</code> parameter affects blocking DDL statements (but not nonblocking DDL statements). Therefore, a blocking DDL statement can complete with error ORA-00054 (resource busy and acquire with <code dir="ltr">NOWAIT</code> specified or timeout expired). For information about the <code dir="ltr">DDL_LOCK_TIMOUT</code> parameter, see <a class="olink REFRN10267" href="../REFRN/GUID-72D43EF8-F7AF-4011-8D64-73ABC4FB2154.htm#REFRN10267"><span class="italic">Oracle Database Reference</span></a>.</p>
<p>A DDL statement that applies to a partition of a table is blocking for that partition but nonblocking for other partitions of the same table.</p>
<p>For a list of nonblocking DDL statements, see <a class="olink SQLRF55501" href="../SQLRF/ap_locks.htm#SQLRF55501"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If supplemental logging is enabled at database level (for a multitenant container database or pluggable database), then the database treats nonblocking DDL statements like blocking DDL statements. For information about enabling and disabling supplemental logging, see <a class="olink SQLRF52506" href="../SQLRF/statements_1006.htm#SQLRF52506"><span class="italic">Oracle Database SQL Language Reference</span></a>.</div>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Do not issue a nonblocking DDL statement in an autonomous transaction. For information about autonomous transactions, see <a href="#i1007356">&#34;Autonomous Transactions.&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i1007356"></a>
<div id="ADFNS00205" class="sect1">
<h2 class="sect1"><span class="secnum">6.8</span> Autonomous Transactions</h2>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Do not issue a <a id="sthref254"></a><a id="sthref255"></a>nonblocking DDL statement in an <a id="sthref256"></a>autonomous transaction. For information about nonblocking DDL statements, see <a href="#BEJECCJJ">&#34;Nonblocking and Blocking DDL Statements.&#34;</a></div>
<p>An <a id="sthref257"></a><a id="sthref258"></a><span class="glossaryterm">autonomous transaction</span> (AT) is an independent transaction started by another transaction, the <a id="sthref259"></a><a id="sthref260"></a><a id="sthref261"></a><span class="glossaryterm">main transaction</span> (MT). An autonomous transaction lets you suspend the main transaction, do SQL operations, commit or roll back those operations, and then resume the main transaction.</p>
<p>For example, in a stock purchase transaction, you might want to commit customer information regardless of whether the purchase succeeds. Or, you might want to log error messages to a debug table even if the transaction rolls back. Autonomous transactions let you do such tasks.</p>
<p>An autonomous transaction runs within an <span class="glossaryterm">autonomous scope</span>; that is, within the scope of an <span class="bold">autonomous routine</span>&mdash;a routine that you mark with the <code dir="ltr">AUTONOMOUS_TRANSACTION</code> pragma. In this context, a <span class="bold">routine</span> is one of these:</p>
<ul>
<li>
<p>Schema-level (not nested) anonymous PL/SQL block</p>
</li>
<li>
<p>Standalone, package, or nested subprogram</p>
</li>
<li>
<p>Method of an ADT</p>
</li>
<li>
<p>Noncompound trigger</p>
</li>
</ul>
<p>An autonomous routine can commit multiple autonomous transactions.</p>
<p><a href="#i1025816">Figure 6-3</a> shows how control flows from the main transaction (<code dir="ltr">proc1</code>) to an autonomous routine (<code dir="ltr">proc2</code>) and back again. The autonomous routine commits two transactions (AT1 and AT2) before control returns to the main transaction.</p>
<div id="ADFNS146" class="figure">
<p class="titleinfigure"><a id="i1025816"></a>Figure 6-3 Transaction Control Flow</p>
<img width="513" height="233" src="img/adfns055.gif" alt="Description of Figure 6-3 follows"/><br/>
<a id="sthref262" href="img_text/adfns055.htm">Description of &#39;&#39;Figure 6-3 Transaction Control Flow&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>When you enter the executable section of an autonomous transaction, the main transaction suspends. When you exit the transaction, the main transaction resumes. <code dir="ltr">COMMIT</code> and <code dir="ltr">ROLLBACK</code> end the active autonomous transaction but do not exit the autonomous transaction. As <a href="#i1025816">Figure 6-3</a> shows, when one transaction ends, the next SQL statement begins another transaction.</p>
<p>More characteristics of autonomous transactions:</p>
<ul>
<li>
<p>The changes an autonomous transaction effects do not depend on the state or the eventual disposition of the main transaction. For example:</p>
<ul>
<li>
<p>An autonomous transaction does not see changes made by the main transaction.</p>
</li>
<li>
<p>When an autonomous transaction commits or rolls back, it does not affect the outcome of the main transaction.</p>
</li>
</ul>
</li>
<li>
<p>The changes an autonomous transaction effects are visible to other transactions as soon as that autonomous transaction commits. Therefore, users can access the updated information without having to wait for the main transaction to commit.</p>
</li>
<li>
<p>Autonomous transactions can start other autonomous transactions.</p>
</li>
</ul>
<p><a href="#i1020443">Figure 6-4</a> shows some possible sequences that autonomous transactions can follow.</p>
<div id="ADFNS147" class="figure">
<p class="titleinfigure"><a id="i1020443"></a>Figure 6-4 Possible Sequences of Autonomous Transactions</p>
<img width="586" height="584" src="img/adfns056.gif" alt="Description of Figure 6-4 follows"/><br/>
<a id="sthref263" href="img_text/adfns056.htm">Description of &#39;&#39;Figure 6-4 Possible Sequences of Autonomous Transactions&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead2"><a id="ADFNS984"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJDBBEA">Examples of Autonomous Transactions</a></p>
</li>
<li>
<p><a href="#BEJICBBD">Declaring Autonomous Routines</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS00609" href="../LNPLS/static.htm#LNPLS00609"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for detailed information about autonomous transactions</div>
<a id="BEJDBBEA"></a>
<div id="ADFNS99929" class="sect2">
<h3 class="sect2"><span class="secnum">6.8.1</span> Examples of Autonomous Transactions</h3>
<p>This section shows examples of autonomous transactions.</p>
<p class="subhead2"><a id="ADFNS1053"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033531">Ordering a Product</a></p>
</li>
<li>
<p><a href="#g1033537">Withdrawing Money from a Bank Account</a></p>
</li>
</ul>
<p>As these examples show, there are four possible outcomes when you use autonomous and main transactions (see <a href="#g1026901">Table 6-7</a>). There is no dependency between the outcome of an autonomous transaction and that of a main transaction.</p>
<div id="ADFNS148" class="tblformal">
<p class="titleintable"><a id="sthref264"></a><a id="g1026901"></a>Table 6-7 Possible Transaction Outcomes</p>
<table class="cellalignment293" title=" Possible Transaction Outcomes" summary="This table summarizes the four possible outcomes of autonomous and main transactions." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t48">Autonomous Transaction</th>
<th class="cellalignment294" id="r1c2-t48">Main Transaction</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t48" headers="r1c1-t48">
<p>Commits</p>
</td>
<td class="cellalignment295" headers="r2c1-t48 r1c2-t48">
<p>Commits</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t48" headers="r1c1-t48">
<p>Commits</p>
</td>
<td class="cellalignment295" headers="r3c1-t48 r1c2-t48">
<p>Rolls back</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t48" headers="r1c1-t48">
<p>Rolls back</p>
</td>
<td class="cellalignment295" headers="r4c1-t48 r1c2-t48">
<p>Commits</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t48" headers="r1c1-t48">
<p>Rolls back</p>
</td>
<td class="cellalignment295" headers="r5c1-t48 r1c2-t48">
<p>Rolls back</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<a id="g1033531"></a>
<div id="ADFNS99928" class="sect3">
<h4 class="sect3"><span class="secnum">6.8.1.1</span> Ordering a Product</h4>
<p><a href="#i1019975">Figure 6-5</a> shows an example of a customer ordering a product. The customer information (such as name, address, phone) is committed to a customer information table&mdash;even though the sale does not go through.</p>
<div id="ADFNS149" class="figure">
<p class="titleinfigure"><a id="i1019975"></a>Figure 6-5 Example: A Buy Order</p>
<img width="320" height="220" src="img/adfns057.gif" alt="Description of Figure 6-5 follows"/><br/>
<a id="sthref265" href="img_text/adfns057.htm">Description of &#39;&#39;Figure 6-5 Example: A Buy Order&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="g1033537"></a>
<div id="ADFNS99927" class="sect3">
<h4 class="sect3"><span class="secnum">6.8.1.2</span> Withdrawing Money from a Bank Account</h4>
<p>In this example, a customer tries to withdraw money from a bank account. In the process, a main transaction invokes one of two autonomous transaction scopes (AT Scope&nbsp;1 or AT Scope 2).</p>
<p>The possible scenarios for this transaction are:</p>
<ul>
<li>
<p><a href="#g1693454">Section 6.8.1.2.1, &#34;Scenario 1: Sufficient Funds&#34;</a></p>
</li>
<li>
<p><a href="#g1693442">Section 6.8.1.2.2, &#34;Scenario 2: Insufficient Funds with Overdraft Protection&#34;</a></p>
</li>
<li>
<p><a href="#g1693412">Section 6.8.1.2.3, &#34;Scenario 3: Insufficient Funds Without Overdraft Protection&#34;</a></p>
</li>
</ul>
<a id="g1693454"></a>
<div id="ADFNS150" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.8.1.2.1</span> Scenario 1: Sufficient Funds</h5>
<p>There are sufficient funds to cover the withdrawal, so the bank releases the funds (see <a href="#i1007457">Figure 6-6</a>).</p>
<div id="ADFNS151" class="figure">
<p class="titleinfigure"><a id="i1007457"></a>Figure 6-6 Bank Withdrawal&mdash;Sufficient Funds</p>
<img width="416" height="367" src="img/adfns058.gif" alt="Description of Figure 6-6 follows"/><br/>
<a id="sthref266" href="img_text/adfns058.htm">Description of &#39;&#39;Figure 6-6 Bank Withdrawal&mdash;Sufficient Funds&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<a id="g1693442"></a>
<div id="ADFNS152" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.8.1.2.2</span> Scenario 2: Insufficient Funds with Overdraft Protection</h5>
<p>There are insufficient funds to cover the withdrawal, but the customer has overdraft protection, so the bank releases the funds (see <a href="#i1007467">Figure 6-7</a>).</p>
<div id="ADFNS153" class="figure">
<p class="titleinfigure"><a id="i1007467"></a>Figure 6-7 Bank Withdrawal&mdash;Insufficient Funds with Overdraft Protection</p>
<img width="416" height="391" src="img/adfns059.gif" alt="Description of Figure 6-7 follows"/><br/>
<a id="sthref267" href="img_text/adfns059.htm">Description of &#39;&#39;Figure 6-7 Bank Withdrawal&mdash;Insufficient Funds with Overdraft Protection&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<a id="g1693412"></a>
<div id="ADFNS154" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">6.8.1.2.3</span> Scenario 3: Insufficient Funds Without Overdraft Protection</h5>
<p>There are insufficient funds to cover the withdrawal and the customer does not have overdraft protection, so the bank withholds the requested funds (see <a href="#i1007477">Figure 6-8</a>).</p>
<div id="ADFNS155" class="figure">
<p class="titleinfigure"><a id="i1007477"></a>Figure 6-8 Bank Withdrawal&mdash;Insufficient Funds Without Overdraft Protection</p>
<img width="416" height="391" src="img/adfns060.gif" alt="Description of Figure 6-8 follows"/><br/>
<a id="sthref268" href="img_text/adfns060.htm">Description of &#39;&#39;Figure 6-8 Bank Withdrawal&mdash;Insufficient Funds Without Overdraft Protection&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BEJICBBD"></a>
<div id="ADFNS99926" class="sect2">
<h3 class="sect2"><span class="secnum">6.8.2</span> Declaring Autonomous Routines</h3>
<p>To declare an autonomous routine, use <code dir="ltr">PRAGMA</code> <code dir="ltr">AUTONOMOUS_TRANSACTION</code>, which instructs the PL/SQL compiler to mark the routine as autonomous.</p>
<p>In <a href="#BEJHCBDJ">Example 6-3</a>, the function <code dir="ltr">balance</code> is autonomous.</p>
<div id="ADFNS156" class="example">
<p class="titleinexample"><a id="BEJHCBDJ"></a>Example 6-3 Marking a Package Subprogram as Autonomous</p>
<pre dir="ltr">-- Create table for package to use:
 
DROP TABLE accounts;
CREATE TABLE accounts (account INTEGER, balance REAL);
 
-- Create package:
 
CREATE OR REPLACE PACKAGE banking AS
  FUNCTION balance (acct_id INTEGER) RETURN REAL;
  -- Additional functions and packages
END banking;
/
CREATE OR REPLACE PACKAGE BODY banking AS
  FUNCTION balance (acct_id INTEGER) RETURN REAL IS
    <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION</span>;
    my_bal  REAL;
  BEGIN
    SELECT balance INTO my_bal FROM accounts WHERE account=acct_id;
    RETURN my_bal;
  END;
  -- Additional functions and packages
END banking;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01302" href="../LNPLS/autotransaction_pragma.htm#LNPLS01302"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about <code dir="ltr">PRAGMA</code> <code dir="ltr">AUTONOMOUS_TRANSACTION</code></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007522"></a>
<div id="ADFNS00206" class="sect1">
<h2 class="sect1"><span class="secnum">6.9</span> Resuming Execution After Storage Allocation Errors</h2>
<p>When a long-running transaction is interrupted by a storage allocation error, the application can suspend the statement that encountered the problem, correct the problem, and then resume executing the statement. This capability, called <a id="sthref269"></a><a id="sthref270"></a><a id="sthref271"></a><a id="sthref272"></a><span class="glossaryterm">resumable storage allocation</span>, avoids time-consuming rollbacks. It also makes it unnecessary to split the operation into smaller pieces and write code to track its progress.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN014" href="../ADMIN/schema.htm#ADMIN014"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about resumable storage allocation</div>
<p class="subhead2"><a id="ADFNS985"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033977">What Operations Have Resumable Storage Allocation?</a></p>
</li>
<li>
<p><a href="#g1033989">Handling Suspended Storage Allocation</a></p>
</li>
</ul>
<a id="g1033977"></a>
<div id="ADFNS99925" class="sect2">
<h3 class="sect2"><span class="secnum">6.9.1</span> What Operations Have Resumable Storage Allocation?</h3>
<p>Queries, DML statements, and some DDL statements have resumable storage allocation after these kinds of errors:</p>
<ul>
<li>
<p>Out-of-space errors, such as ORA-01653.</p>
</li>
<li>
<p>Space-limit errors, such as ORA-01628.</p>
</li>
<li>
<p>Space-quota errors, such as ORA-01536.</p>
</li>
</ul>
<p>Resumable storage allocation is possible whether the operation is performed directly by a SQL statement or within SQL*Loader, a stored subprogram, an anonymous PL/SQL block, or an OCI call such as <code dir="ltr">OCIStmtExecute</code>.</p>
<p>In dictionary-managed tablespaces, you cannot resume an index- or table-creating operation that encounters the limit for rollback segments or the maximum number of extents. You must use locally managed tablespaces and automatic undo management in combination with resumable storage allocation.</p>
</div>
<!-- class="sect2" -->
<a id="g1033989"></a>
<div id="ADFNS99924" class="sect2">
<h3 class="sect2"><span class="secnum">6.9.2</span> Handling Suspended Storage Allocation</h3>
<p>When a statement in an application is suspended because of a storage allocation error, the application does not receive an error code. Therefore, either the application must use an <code dir="ltr">AFTER</code> <code dir="ltr">SUSPEND</code> trigger or the DBA must periodically check for suspended statements.</p>
<p>After the problem is corrected (usually by the DBA), the suspended statement automatically resumes execution. If the timeout period expires before the problem is corrected, then the statement raises a <code dir="ltr">SERVERERROR</code> exception.</p>
<p class="subhead2"><a id="ADFNS986"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJDJAHA">Using an AFTER SUSPEND Trigger in the Application</a></p>
</li>
<li>
<p><a href="#BEJCIHHI">Checking for Suspended Statements</a></p>
</li>
</ul>
<a id="BEJDJAHA"></a>
<div id="ADFNS99870" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">6.9.2.1</span> Using an AFTER SUSPEND Trigger in the Application</h4>
<p>In the application, an <a id="sthref273"></a><a id="sthref274"></a><code dir="ltr">AFTER</code> <code dir="ltr">SUSPEND</code> trigger can get information about the problem by invoking subprograms in the <code dir="ltr">DBMS_RESUMABLE</code> package (described in <a class="olink ARPLS143" href="../ARPLS/d_resuma.htm#ARPLS143"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>). Then the trigger can send the information to an operator, using email (for example).</p>
<p>To reduce the chance of out-of-space errors within the trigger itself, declare the trigger as an <a id="sthref275"></a><a id="sthref276"></a><a id="sthref277"></a>autonomous transaction. As an autonomous transaction, the trigger uses a rollback segment in the <code dir="ltr">SYSTEM</code> tablespace. If the trigger encounters a deadlock condition because of locks held by the suspended statement, then the trigger terminates and the application receives the original error code, as if the statement were never suspended. If the trigger encounters an out-of-space condition, then both the trigger and the suspended statement are rolled back. To prevent rollback, use an exception handler in the trigger to wait for the statement to resume.</p>
<p>For general information about triggers, see <a class="olink LNPLS020" href="../LNPLS/overview.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>The trigger in <a href="#CHDFBBJE">Example 6-4</a> handles storage errors within the database. For some kinds of errors, the trigger terminates the statement and alerts the DBA, using e-mail. For other errors, which might be temporary, the trigger specifies that the statement waits for eight hours before resuming, expecting the storage problem to be fixed by then. To run this example, you must connect to the database as <code dir="ltr">SYSDBA</code>.</p>
<div id="ADFNS157" class="example">
<p class="titleinexample"><a id="CHDFBBJE"></a>Example 6-4 AFTER SUSPEND Trigger Handles Suspended Storage Allocation</p>
<pre dir="ltr">-- Create table used by trigger body
 
DROP TABLE rbs_error;
CREATE TABLE rbs_error (
  SQL_TEXT VARCHAR2(64),
  ERROR_MSG VARCHAR2(64),
  SUSPEND_TIME VARCHAR2(64)
);
 
-- Resumable Storage Allocation

CREATE OR REPLACE TRIGGER suspend_example
  <span class="bold">AFTER SUSPEND</span>
  <span class="bold">ON DATABASE</span>
DECLARE
  cur_sid           NUMBER;
  cur_inst          NUMBER;
  err_type          VARCHAR2(64);
  object_owner      VARCHAR2(64);
  object_type       VARCHAR2(64);
  table_space_name  VARCHAR2(64);
  object_name       VARCHAR2(64);
  sub_object_name   VARCHAR2(64);
  msg_body          VARCHAR2(64);
  ret_value         BOOLEAN;
  error_txt         VARCHAR2(64);
  mail_conn         UTL_SMTP.CONNECTION;
BEGIN
 SELECT DISTINCT(SID) INTO cur_sid FROM V$MYSTAT;
 cur_inst := USERENV(&#39;instance&#39;);
 ret_value := <span class="bold">DBMS_RESUMABLE.SPACE_ERROR_INFO</span>
              <span class="bold">(err_type,</span>
              <span class="bold">object_owner,</span>
              <span class="bold">object_type,</span>
              <span class="bold">table_space_name,</span>
              <span class="bold">object_name,</span>
              <span class="bold">sub_object_name);</span>
 IF object_type = &#39;ROLLBACK SEGMENT&#39; THEN
   INSERT INTO rbs_error
     (SELECT SQL_TEXT, ERROR_MSG, SUSPEND_TIME
      FROM DBA_RESUMABLE
      WHERE SESSION_ID = cur_sid
      AND INSTANCE_ID = cur_inst);

    SELECT ERROR_MSG INTO error_txt
    FROM DBA_RESUMABLE
    WHERE SESSION_ID = cur_sid
    AND INSTANCE_ID = cur_inst;

    msg_body :=
     &#39;Space error occurred: Space limit reached for rollback segment &#39;
     || object_name || &#39; on &#39; || to_char(SYSDATE, &#39;Month dd, YYYY, HH:MIam&#39;)
     || &#39;. Error message was: &#39; || error_txt;

    mail_conn := UTL_SMTP.OPEN_CONNECTION(&#39;localhost&#39;, 25);
    UTL_SMTP.HELO(mail_conn, &#39;localhost&#39;);
    UTL_SMTP.MAIL(mail_conn, &#39;sender@localhost&#39;);
    UTL_SMTP.RCPT(mail_conn, &#39;recipient@localhost&#39;);
    UTL_SMTP.DATA(mail_conn, msg_body);
    UTL_SMTP.QUIT(mail_conn);
    <span class="bold">DBMS_RESUMABLE.ABORT(cur_sid);</span>
  ELSE
    <span class="bold">DBMS_RESUMABLE.SET_TIMEOUT(3600*8);</span>
  END IF;
  COMMIT;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BEJCIHHI"></a>
<div id="ADFNS99869" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">6.9.2.2</span> Checking for Suspended Statements</h4>
<p>If the application does not use an <code dir="ltr">AFTER</code> <code dir="ltr">SUSPEND</code> trigger, then the DBA must periodically check for suspended statements, using the static data dictionary view <code dir="ltr">DBA_RESUMABLE</code> (described in <a class="olink REFRN23228" href="../REFRN/GUID-2565A230-A1AA-4D48-B893-E5F9BE6782EE.htm#REFRN23228"><span class="italic">Oracle Database Reference</span></a>).</p>
<p>The DBA can get additional information from the dynamic performance view <code dir="ltr">V$_SESSION_WAIT</code> (described in <a class="olink REFRN30229" href="../REFRN/GUID-4EDAB293-F3FC-40FE-BC75-4FEE6A4D7705.htm#REFRN30229"><span class="italic">Oracle Database Reference</span></a>).</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment286">
<tr>
<td class="cellalignment295">
<table class="cellalignment291">
<tr>
<td class="cellalignment290"><a href="adfns_part_sql.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment290"><a href="adfns_sqltypes.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment298">
<table class="cellalignment289">
<tr>
<td class="cellalignment290"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment290"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment290"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment290"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment290"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment290"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>