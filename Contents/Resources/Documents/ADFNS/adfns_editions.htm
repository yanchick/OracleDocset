<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-67"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Using%20Edition-Based%20Redefinition"></a><title>Using Edition-Based Redefinition</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1080"/>
<meta name="dcterms.created" content="2016-05-05T16:23:35Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Development Guide"/>
<meta name="dcterms.identifier" content="E41452-07"/>
<meta name="dcterms.isVersionOf" content="ADFNS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="adfns_dependencies.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adfns_trans_idemp_guard.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41452-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">35/38</span> <!-- End Header -->
<div id="ADFNS020" class="chapter"><a id="CEGGJDAE"></a>
<h1 class="chapter"><span class="secnum">24</span> Using Edition-Based Redefinition</h1>
<p><a id="sthref1122"></a><a id="sthref1123"></a><a id="sthref1124"></a><span class="bold">Edition-based redefinition (EBR)</span> lets you upgrade the database component of an application while it is in use, thereby minimizing or eliminating downtime.</p>
<p>To upgrade an application while it is in use, you copy the database objects that comprise the application and redefine the copied objects in isolation. Your changes do not affect users of the application&mdash;they continue to run the unchanged application. When you are sure that your changes are correct, you make the upgraded application available to all users.</p>
<p>Using EBR means using one or more of its component features. The features you use, and the downtime, depend on these factors:</p>
<ul>
<li>
<p>What kind of database objects you redefine</p>
</li>
<li>
<p>How available the database objects must be to users while you are redefining them</p>
</li>
<li>
<p>Whether you make the upgraded application available to some users while others continue to use the older version of the application</p>
</li>
</ul>
<p>You always use the <span class="bold">edition</span> feature to copy the database objects and redefine the copied objects in isolation; that is why the procedure that this chapter describes for upgrading applications online is called edition-based redefinition (EBR).</p>
<p>If every object that you will redefine is <span class="bold">editioned</span> (defined in <a href="#CHDGBJHF">Section 24.1.1</a>), then the edition is the only feature you use.</p>
<p>Tables are not editioned objects. If you change the structure of one or more tables, then you also use the <span class="bold">editioning view</span> feature.</p>
<p>If other users must be able to change data in the tables while you are changing their structure, then you also use <span class="bold">forward crossedition triggers</span>. If the pre- and post-upgrade applications will be in ordinary use at the same time (<a id="sthref1125"></a><span class="bold">hot rollover</span>), then you also use <span class="bold">reverse crossedition triggers</span>. Crossedition triggers are not a permanent part of the application&mdash;you drop them when all users are using the post-upgrade application.</p>
<p>An EBR operation that you can perform on an application in one edition while the application runs in other editions is a <a id="sthref1126"></a><span class="bold">live operation</span>.</p>
<p class="subhead2"><a id="ADFNS1278"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDEIJDH">Editions</a></p>
</li>
<li>
<p><a href="#CHDJEECI">Editioning Views</a></p>
</li>
<li>
<p><a href="#CHDJCDFF">Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#CHDCEEEA">Displaying Information About EBR Features</a></p>
</li>
<li>
<p><a href="#BABEHGAF">Using EBR to Upgrade an Application</a></p>
</li>
</ul>
<a id="CHDEIJDH"></a>
<div id="ADFNS0201" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">24.1</span> Editions</h2>
<p><a id="sthref1127"></a>Editions are nonschema objects; as such, they do not have owners. Editions are created in a single namespace, and multiple editions can coexist in the database.</p>
<p>The database must have at least one edition. Every newly created or upgraded Oracle Database starts with one edition named <a id="sthref1128"></a><a id="sthref1129"></a><code dir="ltr">ora$base</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In a multitenant container database (CDB), the scope of an <a id="sthref1130"></a>edition, <a id="sthref1131"></a>editioning view, or <a id="sthref1132"></a>crossedition trigger is the pluggable database (PDB) in which the feature was created. In a non-CDB, the scope of each of these features is the entire database. For information about CDBs and PDBs, see <a class="olink ADMIN13506" href="../ADMIN/part_cdb.htm#ADMIN13506"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a>.</div>
<p class="subhead2"><a id="ADFNS1279"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDGBJHF">Editioned and Noneditioned Objects</a></p>
</li>
<li>
<p><a href="#CHDGIGIF">Creating an Edition</a></p>
</li>
<li>
<p><a href="#CHDEDBFB">Editioned Objects and Copy-on-Change</a></p>
</li>
<li>
<p><a href="#BABJFDCH">Making an Edition Available to Some Users</a></p>
</li>
<li>
<p><a href="#BABJFDDG">Making an Edition Available to All Users</a></p>
</li>
<li>
<p><a href="#CHDFGIAA">Current Edition and Session Edition</a></p>
</li>
<li>
<p><a href="#CHDEEIBA">Retiring an Edition</a></p>
</li>
<li>
<p><a href="#CHDJCDCA">Dropping an Edition</a></p>
</li>
</ul>
<a id="CHDGBJHF"></a>
<div id="ADFNS99923" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.1</span> Editioned and Noneditioned Objects</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
The terms <span class="bold">user</span> and <span class="bold">schema</span> are synonymous. The <span class="bold">owner</span> of a schema object is the user/schema that owns it.</div>
<p>An <a id="sthref1133"></a><span class="bold">editioned object</span> has both a schema object type that is editionable in its owner and the <code dir="ltr">EDITIONABLE</code> property. An edition has its own copy of an editioned object, and only that copy is visible to the edition.</p>
<p>A <a id="sthref1134"></a><span class="bold">noneditioned object</span> has either a schema object type that is noneditionable in its owner or the <code dir="ltr">NONEDITIONABLE</code> property. An edition cannot have its own copy of a noneditioned object. A noneditioned object is visible to all editions.</p>
<p>An object is <a id="sthref1135"></a><a id="sthref1136"></a><span class="bold">potentially editioned</span> if enabling editions for its type in its owner would make it an editioned object (for details, see <a href="#g5086786">Section 24.1.1.4, &#34;Enabling Editions for a User&#34;</a>).</p>
<p>An editioned object belongs to both a schema and an edition, and is uniquely identified by its <code dir="ltr">OBJECT_NAME</code>, <code dir="ltr">OWNER</code>, and <code dir="ltr">EDITION_NAME</code>. A noneditioned object belongs only to a schema, and is uniquely identified by its <code dir="ltr">OBJECT_NAME</code> and <code dir="ltr">OWNER</code>&mdash;its <code dir="ltr">EDITION_NAME</code> is <code dir="ltr">NULL</code>. (Strictly speaking, the <code dir="ltr">NAMESPACE</code> of an object is also required to uniquely identify the object, but you can ignore this fact, because any statement that references the object implicitly or explicitly specifies its <code dir="ltr">NAMESPACE</code>.)</p>
<p>You can display the <code dir="ltr">OBJECT_NAME</code>, <code dir="ltr">OWNER</code>, and <code dir="ltr">EDITION_NAME</code> of an object with the static data dictionary views <code dir="ltr">*_OBJECTS</code> and <code dir="ltr">*_OBJECTS_AE</code>.</p>
<p>You need not know the <code dir="ltr">EDITION_NAME</code> of an object to refer to that object (and if you do know it, you cannot specify it). The context of the reference implicitly specifies the edition. If the context is a data definition language (DDL) statement, then the edition is the current edition of the session that issued the command (for information about the current edition, see <a href="#CHDFGIAA">Section 24.1.6</a>). If the context is source code, then the edition is the one in which the object is actual (see <a href="#CHDEDBFB">Section 24.1.3</a>).</p>
<p class="subhead2"><a id="ADFNS1280"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABIFIII">Name Resolution for Editioned and Noneditioned Objects</a></p>
</li>
<li>
<p><a href="#BABECJFE">Noneditioned Objects That Can Depend on Editioned Objects</a></p>
</li>
<li>
<p><a href="#g5086774">Editionable and Noneditionable Schema Object Types</a></p>
</li>
<li>
<p><a href="#g5086786">Enabling Editions for a User</a></p>
</li>
<li>
<p><a href="#BABBDHIF">EDITIONABLE and NONEDITIONABLE Properties</a></p>
</li>
<li>
<p><a href="#BABBCBDC">Rules for Editioned Objects</a></p>
</li>
</ul>
<a id="BABIFIII"></a>
<div id="ADFNS1036" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.1.1</span> Name Resolution for Editioned and Noneditioned Objects</h4>
<p><a id="sthref1137"></a>To try to resolve an object name, Oracle Database uses the procedure described in <a href="adfns_dependencies.htm#i3136">Section 23.7</a>. For the procedure to succeed, all pieces of the object name must be visible in the current edition.</p>
<p>During name resolution for an <a id="sthref1138"></a>editioned object, both editioned objects in the current edition and noneditioned objects are visible.</p>
<p>During name resolution for a <a id="sthref1139"></a>noneditioned object, only noneditioned objects are visible. Therefore, if you try to create a noneditioned object that references an editioned object (except in the cases described in <a href="#BABECJFE">Section 24.1.1.2</a>), the creation fails with an error.</p>
<p>When you change a referenced editioned object, all of its dependents (direct and indirect) become invalid. When an invalid object is referenced, the database tries to validate that object.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDFGIAA">Section 24.1.6, &#34;Current Edition and Session Edition&#34;</a></p>
</li>
<li>
<p><a href="adfns_dependencies.htm#CHDFADFI">Chapter 23, &#34;Understanding Schema Object Dependency,&#34;</a> for general information about dependencies among schema objects, including invalidation, revalidation, and name resolution</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABECJFE"></a>
<div id="ADFNS1324" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.1.2</span> Noneditioned Objects That Can Depend on Editioned Objects</h4>
<p>Ordinarily, a <a id="sthref1140"></a>noneditioned object cannot depend on an editioned object, because the editioned object is invisible during name resolution. However, if a noneditioned object specifies an edition to search for editioned objects during name resolution&mdash;an <a id="sthref1141"></a><span class="bold">evaluation edition</span>&mdash;then it <span class="italic">can</span> depend on editioned objects. To specify an evaluation edition, a noneditioned object must be one of the following:</p>
<ul>
<li>
<p>Materialized view</p>
</li>
<li>
<p>Virtual column</p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS1325"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABGCGFG">Materialized Views</a></p>
</li>
<li>
<p><a href="#BABDAJEF">Virtual Columns</a></p>
</li>
</ul>
<a id="BABGCGFG"></a>
<div id="ADFNS1326" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.1.1.2.1</span> Materialized Views</h5>
<p>A <a id="sthref1142"></a><a id="sthref1143"></a>materialized view is a noneditioned object that can specify an <a id="sthref1144"></a>evaluation edition, thereby enabling it to depend on editioned objects. A materialized view that depends on editioned objects may be eligible for query rewrite only in a specific range of editions, which you specify in the <code dir="ltr"><span class="codeinlineitalic">query_rewrite_clause</span></code>.</p>
<p>The simplified syntax for creating a materialized view is:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW [ <span class="italic">schema</span>.] <span class="italic">materialized_view</span> <span class="italic">other_clauses</span>
[ <span class="italic">evaluation_edition_clause</span> ] [ <span class="italic">query_rewrite_clause</span> ] AS <span class="italic">subquery</span>
</pre>
<p>Where <code dir="ltr"><span class="codeinlineitalic">evaluation_edition_clause</span></code> is:</p>
<pre dir="ltr">EVALUATE USING { CURRENT EDITION | EDITION <span class="italic">edition</span> | NULL EDITION }
</pre>
<p>And <code dir="ltr"><span class="codeinlineitalic">query_rewrite_clause</span></code> is:</p>
<pre dir="ltr">{ DISABLE | ENABLE } QUERY REWRITE
[ <span class="italic">unusable_before_clause</span> ] [ <span class="italic">unusable_beginning_clause</span> ]
</pre>
<p>Where <a id="sthref1145"></a><code dir="ltr"><span class="codeinlineitalic">unusable_before_clause</span></code> is:</p>
<pre dir="ltr">UNUSABLE BEFORE { CURRENT EDITION | EDITION <span class="italic">edition</span> }
</pre>
<p>And <code dir="ltr"><span class="codeinlineitalic">unusable_beginning_clause</span></code> is:</p>
<pre dir="ltr">UNUSABLE BEGINNING WITH { CURRENT EDITION | EDITION <span class="italic">edition</span> | NULL EDITION }
</pre>
<p><code dir="ltr">CURRENT</code> <code dir="ltr">EDITION</code> is the edition in which the DDL statement runs. Specifying <code dir="ltr">NULL</code> <code dir="ltr">EDITION</code> is equivalent to omitting the clause that includes it. If you omit <code dir="ltr"><span class="codeinlineitalic">evaluation_edition_clause</span></code>, then editioned objects are invisible during name resolution.</p>
<p>For the complete syntax and semantics of the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement, see <a class="olink SQLRF01302" href="../SQLRF/statements_6002.htm#SQLRF01302"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>To disable, enable, or change the evaluation edition or unusable editions, use the <code dir="ltr">ALTER</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement, described in <a class="olink SQLRF00808" href="../SQLRF/statements_2002.htm#SQLRF00808"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>To display the evaluation editions and unusable editions of materialized views, use the static data dictionary views <code dir="ltr">*_MVIEWS</code> (described in <a class="olink REFRN20139" href="../REFRN/GUID-8B9432B5-6B66-411A-936E-590D9D7671E9.htm#REFRN20139"><span class="italic">Oracle Database Reference</span></a>).</p>
<p>Dropping the evaluation edition invalidates the materialized view. Dropping an edition where the materialized view is usable does not invalidate the materialized view.</p>
</div>
<!-- class="sect4" -->
<a id="BABDAJEF"></a>
<div id="ADFNS1328" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.1.1.2.2</span> Virtual Columns</h5>
<p>A <a id="sthref1146"></a><a id="sthref1147"></a>virtual column (also called a &#34;<a id="sthref1148"></a><a id="sthref1149"></a>generated column&#34;) does not consume disk space. The database generates the values in a virtual column on demand by evaluating an expression. The expression can invoke PL/SQL functions (which can be editioned objects). A virtual column can specify an <a id="sthref1150"></a>evaluation edition, thereby enabling it to depend on an expression that invokes editioned PL/SQL functions.</p>
<p>The syntax for creating a virtual column is:</p>
<pre dir="ltr"><span class="italic">column</span> [ <span class="italic">datatype</span> ] [ GENERATED ALWAYS ] AS ( <span class="italic">column_expression</span> )
[ VIRTUAL ] [ <span class="italic">evaluation_edition_clause</span> ]
[ unusable_before_clause ] [ unusable_beginning_clause ]
[ <span class="italic">inline_constraint</span> ]...
</pre>
<p>Where <code dir="ltr"><span class="codeinlineitalic">evaluation_edition_clause</span></code> is as described in <a href="#BABGCGFG">Section 24.1.1.2.1</a>.</p>
<p>The database does not maintain dependencies on the functions that a virtual column invokes. Therefore, if you drop the evaluation edition, or if a virtual column depends on a noneditioned function and the function becomes editioned, then any of the following can raise an exception:</p>
<ul>
<li>
<p>Trying to query the virtual column</p>
</li>
<li>
<p>Trying to update a row that includes the virtual column</p>
</li>
<li>
<p>A trigger that tries to access the virtual column</p>
</li>
</ul>
<p>For the complete syntax and semantics of the virtual column definition, see <a class="olink SQLRF54465" href="../SQLRF/statements_7002.htm#SQLRF54465"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>To display the evaluation editions of virtual columns, use the static data dictionary views <code dir="ltr">*_TAB_COLS</code> (described in <a class="olink REFRN20276" href="../REFRN/GUID-85036F42-140A-406B-BE11-0AC49A00DBA3.htm#REFRN20276"><span class="italic">Oracle Database Reference</span></a>).</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="g5086774"></a>
<div id="ADFNS898" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.1.3</span> Editionable and Noneditionable Schema Object Types</h4>
<p>Before a schema object type can be editionable in a schema, it must be <a id="sthref1151"></a><a id="sthref1152"></a>editionable in the database. The schema object types that are editionable in the database are determined by the value of the <code dir="ltr">COMPATIBLE</code> initialization parameter (described in <a class="olink ADMIN11112" href="../ADMIN/create.htm#ADMIN11112"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a>) and are shown by the dynamic performance view <code dir="ltr">V$EDITIONABLE_TYPES</code> (described in <a class="olink REFRN30660" href="../REFRN/GUID-8E01D26A-AEDD-4D3E-AFB8-1A7645718907.htm#REFRN30660"><span class="italic">Oracle Database Reference</span></a>).</p>
<p>If the value of <code dir="ltr">COMPATIBLE</code> is 12 or greater, then these schema object types are editionable in the database:</p>
<ul>
<li>
<p><code dir="ltr">SYNONYM</code></p>
</li>
<li>
<p><code dir="ltr">VIEW</code></p>
</li>
<li>
<p>SQL translation profile</p>
</li>
<li>
<p>All PL/SQL object types:</p>
<ul>
<li>
<p><code dir="ltr">FUNCTION</code></p>
</li>
<li>
<p><code dir="ltr">LIBRARY</code></p>
</li>
<li>
<p><code dir="ltr">PACKAGE</code> and <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code></p>
</li>
<li>
<p><code dir="ltr">PROCEDURE</code></p>
</li>
<li>
<p><code dir="ltr">TRIGGER</code></p>
</li>
<li>
<p><code dir="ltr">TYPE</code> and <code dir="ltr">TYPE</code> <code dir="ltr">BODY</code></p>
</li>
</ul>
</li>
</ul>
<p>All other schema object types are <a id="sthref1153"></a><a id="sthref1154"></a>noneditionable in the database and in every schema, and objects of that type are always noneditioned. <code dir="ltr">TABLE</code> is an example of a noneditionable schema object type. Tables are always noneditioned objects.</p>
<p>If a schema object type is editionable in the database, then it can be editionable in schemas. For details, see <a href="#g5086786">Section 24.1.1.4</a>.</p>
</div>
<!-- class="sect3" -->
<a id="g5086786"></a>
<div id="ADFNS99878" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.1.4</span> Enabling Editions for a User</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Enabling editions is not a live operation.</p>
</li>
<li>
<p>When a database is upgraded from Release&nbsp;11.2 to Release&nbsp;12.1, users who were enabled for editions in the pre-upgrade database are enabled for editions in the post-upgrade database and the default schema object types are editionable in their schemas. The default schema object types are displayed by the static data dictionary view <code dir="ltr">DBA_EDITIONED_TYPES</code> (described in <a class="olink REFRN23867" href="../REFRN/GUID-AF15E002-099C-4CA1-9FC4-A70E5507DD78.htm#REFRN23867"><span class="italic">Oracle Database Reference</span></a>). Users who were not enabled for editions in the pre-upgrade database are not enabled for editions in the post-upgrade database and no schema object types are editionable in their schemas.</p>
</li>
<li>
<p>To see which users already have editions enabled, see the <code dir="ltr">EDITIONS_ENABLED</code> column of the static data dictionary view <code dir="ltr">DBA_USERS</code> (described in <a class="olink REFRN23302" href="../REFRN/GUID-309FCCB2-2E8D-4371-9FC5-7F3B10E2A8C0.htm#REFRN23302"><span class="italic">Oracle Database Reference</span></a>) or <code dir="ltr">USER_USERS</code> (described in <a class="olink REFRN26302" href="../REFRN/GUID-8BA93748-F8D0-4868-AD67-0CD6EA68EC4E.htm#REFRN26302"><span class="italic">Oracle Database Reference</span></a>).</p>
</li>
</ul>
</div>
<p><a id="sthref1155"></a><a id="sthref1156"></a><a id="sthref1157"></a>To enable editions for a user, use the <code dir="ltr">ENABLE</code> <code dir="ltr">EDITIONS</code> clause of either the <code dir="ltr">CREATE</code> <code dir="ltr">USER</code> or <code dir="ltr">ALTER</code> <code dir="ltr">USER</code> statement.</p>
<p>With the <code dir="ltr">ALTER</code> <code dir="ltr">USER</code> statement, you can specify the schema object types that become editionable in the schema:</p>
<pre dir="ltr">ALTER USER <span class="italic">user</span> ENABLE EDITIONS [ FOR <span class="italic">type</span> [, <span class="italic">type</span> ]... ]
</pre>
<p>Any type that you omit from the <code dir="ltr">FOR</code> list is noneditionable in the schema, despite being editionable in the database. (If a type is noneditionable in the database, then it is always noneditionable in every schema.)</p>
<p>If you omit the <code dir="ltr">FOR</code> list from the <code dir="ltr">ALTER</code> <code dir="ltr">USER</code> statement, or use the <code dir="ltr">CREATE</code> <code dir="ltr">USER</code> statement to enable editions for a user, then the types that become editionable in the schema are those shown for that schema by the static data dictionary view <code dir="ltr">DBA_EDITIONED_TYPES</code> (described in <a class="olink REFRN23867" href="../REFRN/GUID-AF15E002-099C-4CA1-9FC4-A70E5507DD78.htm#REFRN23867"><span class="italic">Oracle Database Reference</span></a>).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic">Oracle Database SQL Language Reference</span> for the complete syntax and semantics of the <a class="olink SQLRF01503" href="../SQLRF/statements_8003.htm#SQLRF01503"><code dir="ltr">CREATE</code> <code dir="ltr">USER</code></a>and <a class="olink SQLRF01103" href="../SQLRF/statements_4003.htm#SQLRF01103"><code dir="ltr">ALTER</code> <code dir="ltr">USER</code></a> statements</div>
<p>Enabling editions is retroactive and irreversible. When you enable editions for a user, that user is editions-enabled forever. When you enable editions for a schema object type in a schema, that type is editions-enabled forever in that schema. Every object that an editions-enabled user owns or will own becomes an editioned object if its type is editionable in the schema and it has the <code dir="ltr">EDITIONABLE</code> property. For information about the <code dir="ltr">EDITIONABLE</code> property, see <a href="#BABBDHIF">Section 24.1.1.5</a>.</p>
<p class="subhead2"><a id="ADFNS1281"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABJAHFI">Potentially Editioned Objects with Noneditioned Dependents</a></p>
</li>
<li>
<p><a href="#BABEJGGG">Users Who Cannot Have Editions Enabled</a></p>
</li>
</ul>
<a id="BABJAHFI"></a>
<div id="ADFNS1282" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.1.1.4.1</span> Potentially Editioned Objects with Noneditioned Dependents</h5>
<p>If a <a id="sthref1158"></a><a id="sthref1159"></a>potentially editioned object has a noneditioned dependent, then you can enable editions for the owner of the potentially editioned object only if one of the following is true:</p>
<ul>
<li>
<p>Enabling editions for the owner of the potentially editioned object would cause the noneditioned dependent to become editioned.</p>
</li>
<li>
<p>You specify <a id="sthref1160"></a><code dir="ltr">FORCE</code>:</p>
<pre dir="ltr">ALTER USER <span class="italic">user</span> ENABLE EDITIONS [ FOR <span class="italic">type</span> [, <span class="italic">type</span> ]... ] <span class="bold">FORCE</span>;
</pre>
<p>The preceding statement enables editions for the specified user and invalidates noneditioned dependents of editioned objects. For information about invalidation of dependent objects, see <a href="adfns_dependencies.htm#CHDJIIFC">Section 23.4</a>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the preceding statement invalidates a noneditioned dependent object that contains an <a id="sthref1161"></a><a id="sthref1162"></a>Abstract Data Type (ADT), and you drop the edition that contains the editioned object on which the invalidated object depends, then you cannot recompile the invalidated object. Therefore, the object remains invalid.</div>
<p><code dir="ltr">FORCE</code> is useful in the following situation: You must editions-enable users <code dir="ltr">A</code> and <code dir="ltr">B</code>. User <code dir="ltr">A</code> owns potentially editioned objects <code dir="ltr">a1</code> and <code dir="ltr">a2</code>. User <code dir="ltr">B</code> owns potentially editioned objects <code dir="ltr">b1</code> and <code dir="ltr">b2</code>. Object <code dir="ltr">a1</code> depends on object <code dir="ltr">b1</code>. Object <code dir="ltr">b2</code> depends on object <code dir="ltr">a2</code>. Editions-enable users <code dir="ltr">A</code> and <code dir="ltr">B</code> like this:</p>
<ol>
<li>
<p>Using <code dir="ltr">FORCE</code>, enable editions for user <code dir="ltr">A</code>:</p>
<pre dir="ltr">ALTER USER A ENABLE EDITIONS FORCE;
</pre>
<p>Now <code dir="ltr">a1</code> and <code dir="ltr">a2</code> are editioned objects, and noneditioned object <code dir="ltr">b2</code> (which depends on <code dir="ltr">a2</code>) is invalid.</p>
</li>
<li>
<p>Enable editions for user <code dir="ltr">B</code>:</p>
<pre dir="ltr">ALTER USER B ENABLE EDITIONS;
</pre>
<p>Now <code dir="ltr">b1</code> and <code dir="ltr">b2</code> are editioned objects; however, <code dir="ltr">b2</code> is still invalid.</p>
</li>
<li>
<p>Recompile <code dir="ltr">b2</code>, using the appropriate <code dir="ltr">ALTER</code> statement with <code dir="ltr">COMPILE</code>. For a PL/SQL object, also specify <code dir="ltr">REUSE</code> <code dir="ltr">SETTINGS</code>.</p>
<p>For example, if <code dir="ltr">b2</code> is a procedure, use this statement:</p>
<pre dir="ltr">ALTER PROCEDURE b2 COMPILE REUSE SETTINGS
</pre>
<p>For information about the <code dir="ltr">ALTER</code> statements for PL/SQL objects, see <a class="olink LNPLS99974" href="../LNPLS/sqlstatements.htm#LNPLS99974"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>For information about the <code dir="ltr">ALTER</code> statements for SQL objects, see <a class="olink SQLRF008" href="../SQLRF/statements_1.htm#SQLRF008"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
</ol>
<p><code dir="ltr">FORCE</code> is unnecessary in the following situation: You must editions-enable user <code dir="ltr">C</code>, who owns potentially editioned object <code dir="ltr">c1</code>. Object <code dir="ltr">c1</code> has dependent <code dir="ltr">d1</code>, a potentially editioned object owned by user <code dir="ltr">D</code>. User <code dir="ltr">D</code> owns no potentially editioned objects that have dependents owned by <code dir="ltr">C</code>. If you editions-enable <code dir="ltr">D</code> first, making <code dir="ltr">d1</code> an editioned object, then you can editions-enable <code dir="ltr">C</code> without violating the rule that a noneditioned object cannot depend on an editioned object.</p>
</div>
<!-- class="sect4" -->
<a id="BABEJGGG"></a>
<div id="ADFNS1283" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.1.1.4.2</span> Users Who Cannot Have Editions Enabled</h5>
<p>You cannot enable editions for these users:</p>
<ul>
<li>
<p>Oracle-supplied users</p>
</li>
<li>
<p>Common users in a CDB</p>
<p>For information about common users in a CDB, see <a class="olink ADMIN13508" href="../ADMIN/cdb_intro.htm#ADMIN13508"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a>.</p>
</li>
<li>
<p>A user who owns one or more <a id="sthref1163"></a>evolved ADTs.</p>
<p>Trying to do so causes error ORA-38820. If an ADT has no table dependents, you can use the <code dir="ltr">ALTER</code> <code dir="ltr">TYPE</code> <code dir="ltr">RESET</code> statement to reset its version to 1, so that it is no longer considered to be evolved. (Resetting the version of an ADT to 1 invalidates its dependents.) For the syntax of the <code dir="ltr">ALTER</code> <code dir="ltr">TYPE</code> <code dir="ltr">RESET</code> statement, see <a class="olink LNPLS99995" href="../LNPLS/alter_type.htm#LNPLS99995"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABBDHIF"></a>
<div id="ADFNS1284" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.1.5</span> EDITIONABLE and NONEDITIONABLE Properties</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a database is upgraded from Release&nbsp;11.2 to Release&nbsp;12.1, objects in user-created schemas get the <code dir="ltr">EDITIONABLE</code> property and public synonyms get the <code dir="ltr">NONEDITIONABLE</code> property.</div>
<p>The <code dir="ltr">CREATE</code> and <code dir="ltr">ALTER</code> statements for the schema object types that are editionable in the database let you specify that the object you are creating or altering is <a id="sthref1164"></a><code dir="ltr">EDITIONABLE</code> or <a id="sthref1165"></a><code dir="ltr">NONEDITIONABLE</code>.</p>
<p>The <code dir="ltr">DBMS_SQL_TRANSLATOR.CREATE_PROFILE</code> procedure lets you specify that the SQL translation profile that you are creating is <code dir="ltr">EDITIONABLE</code> or <code dir="ltr">NONEDITIONABLE</code>.</p>
<p>To see which objects are <code dir="ltr">EDITIONABLE</code>, see the <code dir="ltr">EDITIONABLE</code> column of the static data dictionary view <code dir="ltr">*_OBJECTS</code> (described in <a class="olink REFRN20146" href="../REFRN/GUID-AA6DEF8B-F04F-482A-8440-DBCB18F6C976.htm#REFRN20146"><span class="italic">Oracle Database Reference</span></a>) or <code dir="ltr">*_OBJECTS_AE</code> (described in <a class="olink REFRN20578" href="../REFRN/GUID-B7C1E515-2B54-43CC-ABDB-957E82336229.htm#REFRN20578"><span class="italic">Oracle Database Reference</span></a>).</p>
<p class="subhead2"><a id="ADFNS1285"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABDICIG">Creating New EDITIONABLE and NONEDITIONABLE Objects</a></p>
</li>
<li>
<p><a href="#BABHDFAI">Replacing or Altering EDITIONABLE and NONEDITIONABLE Objects</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS99979" href="../LNPLS/sqlstatements.htm#LNPLS99979"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for the syntax and semantics of the <code dir="ltr">CREATE</code> and <code dir="ltr">ALTER</code> statements for PL/SQL schema objects</p>
</li>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax and semantics of the <code dir="ltr">CREATE</code> and <code dir="ltr">ALTER</code> statements for SQL schema objects</p>
</li>
<li>
<p><a class="olink ARPLS73547" href="../ARPLS/d_sql_trans.htm#ARPLS73547"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code dir="ltr">DBMS_SQL_TRANSLATOR.CREATE_PROFILE</code> procedure</p>
</li>
</ul>
</div>
<a id="BABDICIG"></a>
<div id="ADFNS1286" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.1.1.5.1</span> Creating New EDITIONABLE and NONEDITIONABLE Objects</h5>
<p>When you create a new schema object whose type is editionable in the database, you can specify the property <code dir="ltr">EDITIONABLE</code> or <code dir="ltr">NONEDITIONABLE</code>. If you omit the property, then the object is <code dir="ltr">EDITIONABLE</code> by default unless it is one of the following:</p>
<ul>
<li>
<p><code dir="ltr">PUBLIC</code> <code dir="ltr">SYNONYM</code>, which is <code dir="ltr">NONEDITIONABLE</code> by default</p>
</li>
<li>
<p><code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code>, which inherits the property of the package specification</p>
</li>
<li>
<p><code dir="ltr">TYPE</code> <code dir="ltr">BODY</code>, which inherits the property of the type specification</p>
</li>
</ul>
<p>For <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code> or <code dir="ltr">TYPE</code> <code dir="ltr">BODY</code>, if you specify a property, then it must match the property of the corresponding package or type specification.</p>
<p>When you create an <code dir="ltr">EDITIONABLE</code> object of a type that is editionable in its schema, the new object is an <a id="sthref1166"></a>editioned object that is visible only in the edition that is current when the object is created. (For information about the current edition, see <a href="#CHDFGIAA">Section 24.1.6</a>.) Creating an editioned object is a live operation with respect to the editions in which the new object is invisible.</p>
<p>When you create either an object with the <code dir="ltr">NONEDITIONABLE</code> property or an object whose type is noneditionable in its schema, the new object is a <a id="sthref1167"></a>noneditioned object, which is visible to all editions.</p>
<p>Suppose that in the current edition, your schema has no schema object named <code dir="ltr">obj</code>, but in another edition, your schema has an editioned object named <code dir="ltr">obj</code>. You can create an object named <code dir="ltr">obj</code> in your schema in the current edition, but it must be an editioned object (that is, uniquely identified by its <code dir="ltr">OBJECT_NAME</code>, <code dir="ltr">OWNER</code>, and <code dir="ltr">EDITION_NAME</code>). The type of the new object (which can be different from the type of the existing editioned object with the same name) must be editionable in your schema and the new object must have the <code dir="ltr">EDITIONABLE</code> property. See <a href="#BABHACJF">Example 24-2</a> and <a href="#BABEADAA">Example 24-3</a>.</p>
</div>
<!-- class="sect4" -->
<a id="BABHDFAI"></a>
<div id="ADFNS1287" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.1.1.5.2</span> Replacing or Altering EDITIONABLE and NONEDITIONABLE Objects</h5>
<p>When you replace or alter an existing object (with the <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> or <code dir="ltr">ALTER</code> statement):</p>
<ul>
<li>
<p>If the schema is not enabled for editions, then you can change the property of the object from <code dir="ltr">EDITIONABLE</code> to <code dir="ltr">NONEDITIONABLE</code>, or the reverse.</p>
</li>
<li>
<p>If the schema is enabled for editions for the type of the object being replaced or altered, then you cannot change the property of the object from <code dir="ltr">EDITIONABLE</code> to <code dir="ltr">NONEDITIONABLE</code>, or the reverse.</p>
</li>
</ul>
<p>Altering an editioned object is a live operation with respect to the editions in which the altered object is invisible.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABBCBDC"></a>
<div id="ADFNS1288" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.1.6</span> Rules for Editioned Objects</h4>
<ul>
<li>
<p>A noneditioned object usually cannot depend on an editioned object (for more information, see <a href="#BABIFIII">Section 24.1.1.1</a>).</p>
</li>
<li>
<p>An Abstract Data Type (ADT) cannot be both editioned and evolved.</p>
<p>For information about type evolution, see <a class="olink ADOBJ00603" href="../ADOBJ/adobjadv.htm#ADOBJ00603"><span class="italic">Oracle Database Object-Relational Developer&#39;s Guide</span></a>.</p>
</li>
<li>
<p>An editioned object cannot be the starting or ending point of a <a id="sthref1168"></a><code dir="ltr">FOREIGN</code> <code dir="ltr">KEY</code> constraint.</p>
<p>This rule affects only editioned <a id="sthref1169"></a>views. An editioned view can be either an ordinary view or an editioning view.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGIGIF"></a>
<div id="ADFNS899" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.2</span> Creating an Edition</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends against creating editions in the Root of a CDB. For information about CDBs, see <a class="olink ADMIN13508" href="../ADMIN/cdb_intro.htm#ADMIN13508"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a>.</div>
<p><a id="sthref1170"></a>To create an edition, use the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">EDITION</code>.</p>
<p>You must create the edition as the child of an existing edition. The parent of the first edition created with a <code dir="ltr">CREATE</code> <code dir="ltr">EDITION</code> statement is <a id="sthref1171"></a><a id="sthref1172"></a><code dir="ltr">ora$base</code>. This statement creates the edition <code dir="ltr">e2</code> as the child of <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">CREATE EDITION e2
</pre>
<p>(<a href="#BABFFCHG">Example 24-1</a> and others use the preceding statement.)</p>
<p>An edition can have at most one child.</p>
<p>The <a id="sthref1173"></a><a id="sthref1174"></a><span class="bold">descendents</span> of an edition are its child, its child&#39;s child, and so on. The <a id="sthref1175"></a><a id="sthref1176"></a><span class="bold">ancestors</span> of an edition are its parent, its parent&#39;s parent, and so on. The <a id="sthref1177"></a><a id="sthref1178"></a><span class="bold">root edition</span> has no parent, and a <a id="sthref1179"></a><a id="sthref1180"></a><span class="bold">leaf edition</span> has no child.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF20017" href="../SQLRF/statements_5010.htm#SQLRF20017"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">CREATE</code> <code dir="ltr">EDITION</code> statement, including the privileges required to use it</div>
</div>
<!-- class="sect2" -->
<a id="CHDEDBFB"></a>
<div id="ADFNS99922" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.3</span> Editioned Objects and Copy-on-Change</h3>
<p>When you create an edition, all editioned objects in its parent edition are copied to it. Changes to an editioned object in one edition do not affect copies of that editioned object in other editions.</p>
<p>The preceding paragraph describes what happens conceptually. In practice, to optimize performance, Oracle Database copies an editioned object from an ancestor edition to a descendent edition only when the descendent edition changes the object. This strategy is called <a id="sthref1181"></a><span class="bold">copy-on-change</span>.</p>
<p>An editioned object that was conceptually (but not actually) copied to a descendent edition is called an <a id="sthref1182"></a><a id="sthref1183"></a><span class="bold">inherited object</span>. When a user of the descendent edition references an inherited object in a DDL statement, Oracle Database actually copies the object to the descendent edition. This copying operation is called <a id="sthref1184"></a><span class="bold">actualization</span>, and it creates an <a id="sthref1185"></a><a id="sthref1186"></a><span class="bold">actual object</span> in the descendent edition.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is one exception to the actualization rule in the preceding paragraph: When a <a id="sthref1187"></a><code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> <code dir="ltr"><span class="codeinlineitalic">object</span></code> statement replaces an inherited object with an identical object (that is, an object with the same source code and settings), Oracle Database <span class="italic">does not</span> create an actual object in the descendent edition.</div>
<p><a href="#BABFFCHG">Example 24-1</a> creates a procedure named <code dir="ltr">hello</code> in the edition <code dir="ltr">ora$base</code>, and then creates the edition <code dir="ltr">e2</code> as a child of <code dir="ltr">ora$base</code>. When <code dir="ltr">e2</code> invokes <code dir="ltr">hello</code>, it invokes the inherited procedure in <code dir="ltr">ora$base</code>. Then <code dir="ltr">e2</code> changes <code dir="ltr">hello</code>, actualizing it. Now when <code dir="ltr">e2</code> invokes <code dir="ltr">hello</code>, it invokes its own actual procedure. The procedure <code dir="ltr">hello</code> in the edition <code dir="ltr">ora$base</code> remains unchanged.</p>
<div id="ADFNS900" class="example">
<p class="titleinexample"><a id="BABFFCHG"></a>Example 24-1 Editioned Objects and Copy-on-Change</p>
<ol>
<li>
<p>Assume that this procedure is an editioned object in <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE hello IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;Hello, edition 1.&#39;);
  END hello;
/
</pre></li>
<li>
<p>In <code dir="ltr">ora$base</code>, invoke the procedure:</p>
<pre dir="ltr">BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">Hello, edition 1.</span>
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Create a child edition:</p>
<pre dir="ltr">CREATE EDITION e2;
</pre>
<p>Conceptually, the procedure is copied to the child edition, and only the copy is visible in the child edition. The copy is an inherited object, not an actual object.</p>
</li>
<li>
<p>Use the child edition:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = e2;
</pre>
<p>For information about <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code>, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li>
<p>Invoke the procedure:</p>
<pre dir="ltr">BEGIN hello(); END;
/
</pre>
<p>Conceptually, the child edition invokes its own copy of the procedure (which is identical to the procedure in the parent edition, <code dir="ltr">ora$base</code>). However, the child edition actually invokes the procedure in the parent edition. Result:</p>
<pre dir="ltr"><span class="bold">Hello, edition 1.</span>
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Change the procedure:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE hello IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;Hello, edition <span class="bold">2</span>.&#39;);
  END hello;
/
</pre>
<p>Oracle Database actualizes the procedure in the child edition, and the change affects only the actual object in the child edition, not the procedure in the parent edition.</p>
</li>
<li>
<p>Invoke the procedure:</p>
<pre dir="ltr">BEGIN hello(); END;
/
</pre>
<p>The child edition invokes its own actual procedure:</p>
<pre dir="ltr"><span class="bold">Hello, edition 2.</span>

PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Return to the parent edition:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = ora$base;
</pre></li>
<li>
<p>Invoke the procedure and see that it has not changed:</p>
<pre dir="ltr">BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">Hello, edition 1.</span>
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p><a href="#BABHACJF">Example 24-2</a> creates a procedure named <code dir="ltr">goodbye</code> in the edition <code dir="ltr">ora$base</code>, and then creates edition <code dir="ltr">e2</code> as a child of <code dir="ltr">ora$base</code>. After <code dir="ltr">e2</code> drops <code dir="ltr">goodbye</code>, it can no longer invoke it, but <code dir="ltr">ora$base</code> can still invoke it. (For more information about the <code dir="ltr">DROP</code> <code dir="ltr">PROCEDURE</code> statement, including the privileges required to use it, see <a class="olink LNPLS99991" href="../LNPLS/drop_procedure.htm#LNPLS99991"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.)</p>
<div id="ADFNS901" class="example">
<p class="titleinexample"><a id="BABHACJF"></a>Example 24-2 Dropping an Editioned Object</p>
<ol>
<li>
<p>Assume that this procedure is an editioned object in <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE goodbye IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;Good-bye!&#39;);
  END goodbye;
/
</pre></li>
<li>
<p>Invoke the procedure:</p>
<pre dir="ltr">BEGIN goodbye; END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Create edition <code dir="ltr">e2</code> as a child of <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">CREATE EDITION e2;
</pre>
<p>In <code dir="ltr">e2</code>, the procedure is an inherited object.</p>
</li>
<li>
<p>Use edition <code dir="ltr">e2</code>:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = e2;
</pre>
<p><code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code> must be a top-level SQL statement. For more information, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li>
<p>In <code dir="ltr">e2</code>, invoke the procedure:</p>
<pre dir="ltr">BEGIN goodbye; END;
/
</pre>
<p><code dir="ltr">e2</code> invokes the procedure in <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>In <code dir="ltr">e2</code>, drop the procedure:</p>
<pre dir="ltr">DROP PROCEDURE goodbye;
</pre></li>
<li>
<p>In <code dir="ltr">e2</code>, try to invoke the dropped procedure:</p>
<pre dir="ltr">BEGIN goodbye; END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">BEGIN goodbye; END;
      *
ERROR at line 1:
ORA-06550: line 1, column 7:
PLS-00201: identifier &#39;GOODBYE&#39; must be declared
ORA-06550: line 1, column 7:
PL/SQL: Statement ignored
</pre></li>
<li>
<p>Return to <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = ora$base;
</pre></li>
<li>
<p>In <code dir="ltr">ora$base</code>, invoke the procedure:</p>
<pre dir="ltr">BEGIN goodbye; END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>Because <code dir="ltr">e2</code> dropped the procedure <code dir="ltr">goodbye</code>:</p>
<ul>
<li>
<p>Its descendents do not inherit the procedure <code dir="ltr">goodbye</code>.</p>
</li>
<li>
<p>No object named <code dir="ltr">goodbye</code> is visible in <code dir="ltr">e2</code>, so <code dir="ltr">e2</code> can create an object named <code dir="ltr">goodbye</code>, but it must be an editioned object (for details, see <a href="#BABDICIG">Section 24.1.1.5.1</a>). If <code dir="ltr">e2</code> creates a new editioned object named <code dir="ltr">goodbye</code>, then the descendents of <code dir="ltr">e2</code> inherit that object.</p>
</li>
</ul>
<p>In <a href="#BABEADAA">Example 24-3</a>, <code dir="ltr">e2</code> creates a function named <code dir="ltr">goodbye</code> and then an edition named <code dir="ltr">e3</code> as a child of <code dir="ltr">e2</code>. When <code dir="ltr">e3</code> tries to invoke the <span class="italic">procedure</span> <code dir="ltr">goodbye</code> (which <code dir="ltr">e2</code> dropped), an error occurs, but <code dir="ltr">e3</code> successfully invokes the <span class="italic">function</span> <code dir="ltr">goodbye</code> (which <code dir="ltr">e2</code> created).</p>
<div id="ADFNS902" class="example">
<p class="titleinexample"><a id="BABEADAA"></a>Example 24-3 Creating an Object with the Name of a Dropped Inherited Object</p>
<ol>
<li>
<p>Return to <code dir="ltr">e2</code>:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = e2;
</pre>
<p>For information about <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code>, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li>
<p>In <code dir="ltr">e2</code>, create a function named <code dir="ltr">goodbye</code>:</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION goodbye
  RETURN BOOLEAN
IS
BEGIN
  RETURN(TRUE);
END goodbye;
/
</pre>
<p>This function must be an editioned object. It has the <code dir="ltr">EDITIONABLE</code> property by default. If the type <code dir="ltr">FUNCTION</code> is not editionable in the schema, then you must use the <code dir="ltr">ALTER</code> <code dir="ltr">USER</code> statement to make it so (for instructions, see <a href="#g5086786">Section 24.1.1.4</a>).</p>
</li>
<li>
<p>Create edition <code dir="ltr">e3</code>:</p>
<pre dir="ltr">CREATE EDITION e3 AS CHILD OF e2;
</pre>
<p>Edition <code dir="ltr">e3</code> inherits the function <code dir="ltr">goodbye</code>.</p>
</li>
<li>
<p>Use edition <code dir="ltr">e3</code>:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = e3;
</pre></li>
<li>
<p>In <code dir="ltr">e3</code>, try to invoke the <span class="italic">procedure</span> <code dir="ltr">goodbye</code>:</p>
<pre dir="ltr">BEGIN
  goodbye;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">ERROR at line 2:
ORA-06550: line 2, column 3:
PLS-00306: wrong number or types of arguments in call to &#39;GOODBYE&#39;
ORA-06550: line 2, column 3:
PL/SQL: Statement ignored
</pre></li>
<li>
<p>In <code dir="ltr">e3</code>, invoke <span class="italic">function</span> <code dir="ltr">goodbye</code>:</p>
<pre dir="ltr">BEGIN
  IF goodbye THEN
    DBMS_OUTPUT.PUT_LINE(&#39;Good-bye!&#39;);
  END IF;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABJFDCH"></a>
<div id="ADFNS903" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.4</span> Making an Edition Available to Some Users</h3>
<p><a id="sthref1188"></a>As the creator of the edition, you automatically have the <code dir="ltr">USE</code> privilege <code dir="ltr">WITH</code> <code dir="ltr">GRANT</code> <code dir="ltr">OPTION</code> on it. To grant the <code dir="ltr">USE</code> privilege on the edition to other users, use the SQL statement <code dir="ltr">GRANT</code> <code dir="ltr">USE</code> <code dir="ltr">ON</code> <code dir="ltr">EDITION</code>. For information about the <code dir="ltr">GRANT</code> statement, see <a class="olink SQLRF01603" href="../SQLRF/statements_9014.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABJFDDG"></a>
<div id="ADFNS99876" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.5</span> Making an Edition Available to All Users</h3>
<p><a id="sthref1189"></a>To make an edition available to all users, either:</p>
<ul>
<li>
<p>Grant the <code dir="ltr">USE</code> privilege on the edition to <code dir="ltr">PUBLIC</code>:</p>
<pre dir="ltr">GRANT USE ON EDITION <span class="italic">edition_name</span> TO PUBLIC
</pre>
<p>For information about the <code dir="ltr">GRANT</code> statement, see <a class="olink SQLRF01603" href="../SQLRF/statements_9014.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Make the edition the database default edition:</p>
<pre dir="ltr">ALTER DATABASE DEFAULT EDITION = <span class="italic">edition_name</span>
</pre>
<p>This has the side effect of allowing all users to use the edition, because it effectively grants the <code dir="ltr">USE</code> privilege on <code dir="ltr"><span class="codeinlineitalic">edition_name</span></code> to <code dir="ltr">PUBLIC</code>.</p>
<p>For information about the <code dir="ltr">ALTER</code> <code dir="ltr">DATABASE</code> statement, see <a class="olink SQLRF00802" href="../SQLRF/statements_1006.htm#SQLRF00802"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFGIAA"></a>
<div id="ADFNS99921" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.6</span> Current Edition and Session Edition</h3>
<p><a id="sthref1190"></a><a id="sthref1191"></a><a id="sthref1192"></a><a id="sthref1193"></a>Each database session uses exactly one edition at a time. The edition that a database session is using at any one time is called its <span class="bold">current edition</span>. When a database session begins, its current edition is its <span class="bold">session edition</span>, which is the edition in which it begins. If you change the session edition, the current edition changes to the same thing. However, there are situations in which the current edition and session edition differ.</p>
<p class="subhead2"><a id="ADFNS1292"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDECHDA">Your Initial Session Edition</a></p>
</li>
<li>
<p><a href="#CHDBFJGF">Changing Your Session Edition</a></p>
</li>
<li>
<p><a href="#CHDCBIJG">Displaying the Names of the Current and Session Editions</a></p>
</li>
<li>
<p><a href="#CHDGIDBB">When the Current Edition Might Differ from the Session Edition</a></p>
</li>
</ul>
<a id="CHDECHDA"></a>
<div id="ADFNS904" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.6.1</span> Your Initial Session Edition</h4>
<p>When you connect to the database, you can specify your initial session edition. Your initial session edition can be the database default edition or any edition on which you have the <code dir="ltr">USE</code> privilege. To see the names of the editions that are available to you, use this query:</p>
<pre dir="ltr">SELECT EDITION_NAME FROM ALL_EDITIONS;
</pre>
<p>How you specify your initial session edition at connection time depends on how you connect to the database&mdash;see the documentation for your interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN13170" href="../ADMIN/general.htm#ADMIN13170"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about setting the database default edition</p>
</li>
<li>
<p><a class="olink SQPUG013" href="../SQPUG/ch_three.htm#SQPUG013"><span class="italic">SQL*Plus User&#39;s Guide and Reference</span></a> for information about connecting to the database with SQL*Plus</p>
</li>
<li>
<p><a class="olink LNOCI08100" href="../LNOCI/oci08sca.htm#LNOCI08100"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for information about connecting to the database with Oracle Call Interface (OCI)</p>
</li>
<li>
<p><a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for information about connecting to the database with JDBC</p>
</li>
</ul>
</div>
<p>As of Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), if you do not specify your session edition at connection time, then:</p>
<ul>
<li>
<p>If you use a database service to connect to the database, and an initial session edition was specified for that service, then the initial session edition for the service is your initial session edition.</p>
</li>
<li>
<p>Otherwise, your initial session edition is the database default edition.</p>
</li>
</ul>
<p>As of Release&nbsp;11.2.0.2, when you create or modify a database service, you can specify its initial session edition.</p>
<p>To create or modify a database service, Oracle recommends using the <code dir="ltr">srvctl</code> <code dir="ltr">add</code> <code dir="ltr">service</code> or <code dir="ltr">srvctl</code> <code dir="ltr">modify</code> <code dir="ltr">service</code> command. To specify the default initial session edition of the service, use the <code dir="ltr">-edition</code> option.</p>
<p>Alternatively, you can create or modify a database service with the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">CREATE_SERVICE</code> or <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">MODIFY_SERVICE</code> procedure, and specify the default initial session edition of the service with the <code dir="ltr">EDITION</code> attribute.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As of Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.1), the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">CREATE_SERVICE</code> and <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">MODIFY_SERVICE</code> procedures are deprecated in databases managed by Oracle Clusterware and Oracle Restart.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN12956" href="../ADMIN/restart.htm#ADMIN12956"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about the <code dir="ltr">-edition</code> option of the <code dir="ltr">srvctl</code> <code dir="ltr">add</code> <code dir="ltr">service</code> command</p>
</li>
<li>
<p><a class="olink ADMIN12980" href="../ADMIN/restart.htm#ADMIN12980"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about the <code dir="ltr">-edition</code> option of the <code dir="ltr">srvctl</code> <code dir="ltr">modify</code> <code dir="ltr">service</code> command</p>
</li>
<li>
<p><a class="olink ARPLS68021" href="../ARPLS/d_serv.htm#ARPLS68021"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code dir="ltr">EDITION</code> attribute of the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">CREATE_SERVICE</code> procedure</p>
</li>
<li>
<p><a class="olink ARPLS68027" href="../ARPLS/d_serv.htm#ARPLS68027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code dir="ltr">EDITION</code> attribute of the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">MODIFY_SERVICE</code> procedure</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDBFJGF"></a>
<div id="ADFNS905" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.6.2</span> Changing Your Session Edition</h4>
<p>After connecting to the database, you can change your session edition with the SQL statement <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code>. You can change your session edition to the database default edition or any edition on which you have the <code dir="ltr">USE</code> privilege. When you change your session edition, your current edition changes to that same edition.</p>
<p>These statements from <a href="#BABFFCHG">Example 24-1</a> and <a href="#BABHACJF">Example 24-2</a> change the session edition (and current edition) first to <code dir="ltr">e2</code> and later to <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = e2
...
ALTER SESSION SET EDITION = ora$base
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code> must be a top-level SQL statement. To defer an edition change (in a logon trigger, for example), use the <code dir="ltr">DBMS_SESSION</code>.<code dir="ltr">SET_EDITION_DEFERRED</code> procedure.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF00901" href="../SQLRF/statements_2015.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code> statement</p>
</li>
<li>
<p><a class="olink ARPLS72968" href="../ARPLS/d_sessio.htm#ARPLS72968"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_SESSION</code>.<code dir="ltr">SET_EDITION_DEFERRED</code> procedure</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDCBIJG"></a>
<div id="ADFNS906" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.6.3</span> Displaying the Names of the Current and Session Editions</h4>
<p>This statement returns the name of the current edition:</p>
<pre dir="ltr">SELECT SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_EDITION_NAME&#39;) FROM DUAL;
</pre>
<p>This statement returns the name of the session edition:</p>
<pre dir="ltr">SELECT SYS_CONTEXT(&#39;USERENV&#39;, &#39;SESSION_EDITION_NAME&#39;) FROM DUAL;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF06117" href="../SQLRF/functions199.htm#SQLRF06117"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">SYS_CONTEXT</code> function</div>
</div>
<!-- class="sect3" -->
<a id="CHDGIDBB"></a>
<div id="ADFNS907" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.1.6.4</span> When the Current Edition Might Differ from the Session Edition</h4>
<p>The current edition might differ from the session edition in these situations:</p>
<ul>
<li>
<p>A crossedition trigger fires.</p>
<p>For details, see <a href="#CHDFBHBI">Section 24.3.3, &#34;Crossedition Trigger Interaction with Editions.&#34;</a></p>
</li>
<li>
<p>You run a statement by calling the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure, specifying the edition in which the statement is to run, as in <a href="#CHDBCBEF">Example 24-4</a>.</p>
<p>While the statement is running, the current edition is the specified edition, but the session edition does not change. For information about the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure, see <a class="olink ARPLS68277" href="../ARPLS/d_sql.htm#ARPLS68277"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ul>
<p><a href="#CHDBCBEF">Example 24-4</a> creates a function that returns the names of the session edition and current edition. Then it creates a child edition, which invokes the function twice. The first time, the session edition and current edition are the same. The second time, they are not, because a different edition is passed as a parameter to the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure.</p>
<div id="ADFNS908" class="example">
<p class="titleinexample"><a id="CHDBCBEF"></a>Example 24-4 Current Edition Differs from Session Edition</p>
<ol>
<li>
<p>Create function that returns the names of the session edition and current edition:</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION session_and_current_editions
  RETURN VARCHAR2
IS
BEGIN
  RETURN
  &#39;Session: &#39;|| SYS_CONTEXT(&#39;USERENV&#39;, &#39;SESSION_EDITION_NAME&#39;) ||
  &#39; / &#39; ||
  &#39;Current: &#39;|| SYS_CONTEXT(&#39;USERENV&#39;, &#39;CURRENT_EDITION_NAME&#39;);
END session_and_current_editions;
/
</pre></li>
<li>
<p>Create child edition:</p>
<pre dir="ltr">CREATE EDITION e2 AS CHILD OF ora$base;
</pre></li>
<li>
<p>Use child edition:</p>
<pre dir="ltr"><span class="bold">ALTER SESSION SET EDITION = e2;</span>
</pre></li>
<li>
<p>Invoke function:</p>
<pre dir="ltr">BEGIN
  DBMS_OUTPUT.PUT_LINE (session_and_current_editions());
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">Session: E2 / Current: E2</span>
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Invoke function again:</p>
<pre dir="ltr">DECLARE
  c     NUMBER := DBMS_SQL.OPEN_CURSOR();
  v     VARCHAR2(200);
  dummy NUMBER;
  <span class="bold">stmt  CONSTANT VARCHAR2(32767)</span>
    <span class="bold">:= &#39;SELECT session_and_current_editions() FROM DUAL&#39;;</span>
BEGIN
  <span class="bold">DBMS_SQL.PARSE</span> (c =&gt; c,
                  <span class="bold">statement =&gt; stmt</span>,
                  language_flag =&gt; DBMS_SQL.NATIVE,
                  <span class="bold">edition =&gt; &#39;ora$base&#39;</span>);
 
  DBMS_SQL.DEFINE_COLUMN (c, 1, v, 200);
  dummy := DBMS_SQL.EXECUTE_AND_FETCH (c, true);
  DBMS_SQL.COLUMN_VALUE (c, 1, v);
  DBMS_SQL.CLOSE_CURSOR(c);
  DBMS_OUTPUT.PUT_LINE (v);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">Session: E2 / Current: ORA$BASE</span>
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEEIBA"></a>
<div id="ADFNS99920" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.7</span> Retiring an Edition</h3>
<p><a id="sthref1194"></a>After making a new edition (an upgraded application) available to all users, retire the old edition (the original application), so that no user except <code dir="ltr">SYS</code> can use the old edition.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the old edition is the database default edition, make another edition the database default edition before you retire the old edition:
<pre dir="ltr">ALTER DATABASE DEFAULT EDITION = <span class="italic">edition_name</span>
</pre>
<p>For information about the <code dir="ltr">ALTER</code> <code dir="ltr">DATABASE</code> statement, see <a class="olink SQLRF00802" href="../SQLRF/statements_1006.htm#SQLRF00802"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<p>To retire an edition, you must revoke the <code dir="ltr">USE</code> privilege on the edition from every grantee. To list the grantees, use this query, where :<code dir="ltr">e</code> is a placeholder for the name of the edition to be dropped:</p>
<pre dir="ltr">SELECT GRANTEE, PRIVILEGE
FROM DBA_TAB_PRIVS
WHERE TABLE_NAME = :e
/
</pre>
<p>For information about the <code dir="ltr">REVOKE</code> statement, see <a class="olink SQLRF01609" href="../SQLRF/statements_9022.htm#SQLRF01609"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>When you retire an edition, update the <a id="sthref1195"></a>evaluation editions and <a id="sthref1196"></a>unusable editions of noneditioned objects accordingly. For information about changing evaluation editions and unused editions, see <a href="#BABECJFE">Section 24.1.1.2, &#34;Noneditioned Objects That Can Depend on Editioned Objects.&#34;</a></p>
</div>
<!-- class="sect2" -->
<a id="CHDJCDCA"></a>
<div id="ADFNS99919" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.1.8</span> Dropping an Edition</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the edition includes crossedition triggers, see <a href="#BABGHBBF">Section 24.3.6, &#34;Dropping the Crossedition Triggers,&#34;</a> before you drop the edition.</div>
<p><a id="sthref1197"></a>To drop an edition, use the <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> statement, described in <a class="olink SQLRF20019" href="../SQLRF/statements_8015.htm#SQLRF20019"><span class="italic">Oracle Database SQL Language Reference</span></a>. If the edition has actual objects, you must specify the <code dir="ltr">CASCADE</code> clause, which drops the actual objects.</p>
<p>If a <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> <code dir="ltr"><span class="codeinlineitalic">edition</span></code> <code dir="ltr">CASCADE</code> statement is interrupted before finishing normally (from a power failure, for example), the static data dictionary view <code dir="ltr">*_EDITIONS</code> shows that the value of <code dir="ltr">USABLE</code> for <code dir="ltr"><span class="codeinlineitalic">edition</span></code> is <code dir="ltr">NO</code>. The only operation that you can perform on such an unusable <code dir="ltr"><span class="codeinlineitalic">edition</span></code> is <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> <code dir="ltr">CASCADE</code>.</p>
<p>You drop an edition in these situations:</p>
<ul>
<li>
<p>You want to roll back the application upgrade.</p>
</li>
<li>
<p>(Optional) You have retired the edition.</p>
</li>
</ul>
<p>You can drop an edition only if all of these statements are true:</p>
<ul>
<li>
<p>The edition is either the root edition or a leaf edition.</p>
</li>
<li>
<p>If the edition is the root, it has no objects that its descendents inherit. (That is, each object inherited from the root edition was either actualized or dropped.)</p>
</li>
<li>
<p>The edition is not in use (that is, it is not the current edition or session edition of a session).</p>
</li>
<li>
<p>The edition is not the database default edition.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
After you have dropped an edition, you cannot recompile a <a id="sthref1198"></a>noneditioned object that depends on an editioned object if both of the following are true:
<ul>
<li>
<p>The noneditioned object contains an ADT.</p>
</li>
<li>
<p>The noneditioned object was invalidated when the owner of the editioned object on which it depends was enabled for editions using <code dir="ltr">FORCE</code>.</p>
</li>
</ul>
</div>
<p>To explicitly actualize an inherited object in the child edition:</p>
<ol>
<li>
<p>Make the child edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li>
<p>Recompile the object, using the appropriate <code dir="ltr">ALTER</code> statement with <code dir="ltr">COMPILE</code>. For a PL/SQL object, also specify <code dir="ltr">REUSE</code> <code dir="ltr">SETTINGS</code>.</p>
<p>For example, this statement actualizes the procedure <code dir="ltr">p1</code>:</p>
<pre dir="ltr">ALTER PROCEDURE p1 COMPILE REUSE SETTINGS
</pre>
<p>For information about the <code dir="ltr">ALTER</code> statements for PL/SQL objects, see <a class="olink LNPLS99974" href="../LNPLS/sqlstatements.htm#LNPLS99974"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>For information about the <code dir="ltr">ALTER</code> statements for SQL objects, see <a class="olink SQLRF008" href="../SQLRF/statements_1.htm#SQLRF008"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
</ol>
<p>When you drop an edition, update the <a id="sthref1199"></a>evaluation editions and <a id="sthref1200"></a>unusable editions of noneditioned objects accordingly. For information about changing evaluation editions and unused editions, see <a href="#BABECJFE">Section 24.1.1.2, &#34;Noneditioned Objects That Can Depend on Editioned Objects.&#34;</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF00818" href="../SQLRF/statements_2001.htm#SQLRF00818"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">LIBRARY</code> statement</p>
</li>
<li>
<p><a class="olink SQLRF01104" href="../SQLRF/statements_4004.htm#SQLRF01104"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99999" href="../LNPLS/alter_function.htm#LNPLS99999"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">FUNCTION</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99998" href="../LNPLS/alter_package.htm#LNPLS99998"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">PACKAGE</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99997" href="../LNPLS/alter_procedure.htm#LNPLS99997"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">PROCEDURE</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99996" href="../LNPLS/alter_trigger.htm#LNPLS99996"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99995" href="../LNPLS/alter_type.htm#LNPLS99995"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">TYPE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJEECI"></a>
<div id="ADFNS0202" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">24.2</span> Editioning Views</h2>
<p><a id="sthref1201"></a>On a noneditioning view, the only type of trigger that you can define is an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger. On an editioning view, you can define every type of trigger that you can define on a table (except crossedition triggers, which are temporary, and <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers). Therefore, and because they can be editioned, editioning views let you treat their base tables as if the base tables were editioned. However, you cannot add indexes or constraints to an editioning view; if your upgraded application requires new indexes or constraints, you must add them to the base table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you will change a base table or an index on a base table, then see <a href="adfns_sqlproc.htm#BEJECCJJ">&#34;Nonblocking and Blocking DDL Statements.&#34;</a></div>
<p>An editioning view selects a subset of the columns from a single base table and, optionally, provides aliases for them. In providing aliases, the editioning view maps physical column names (used by the base table) to logical column names (used by the application). An editioning view is like an API for a table.</p>
<p>There is no performance penalty for accessing a table through an editioning view, rather than directly. That is, if a SQL <code dir="ltr">SELECT</code>, <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, or <code dir="ltr">MERGE</code> statement uses one or more editioning views, one or more times, and you replace each editioning view name with the name of its base table and adjust the column names if necessary, performance does not change.</p>
<p>The static data dictionary view <code dir="ltr">*_EDITIONING_VIEWS</code> describes every editioning view in the database that is visible in the session edition. <code dir="ltr">*_EDITIONING_VIEWS_AE</code> describes every actual object in every editioning view in the database, in every edition.</p>
<p class="subhead2"><a id="ADFNS1293"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDHIDGF">Creating an Editioning View</a></p>
</li>
<li>
<p><a href="#CHDEGDGI">Partition-Extended Editioning View Names</a></p>
</li>
<li>
<p><a href="#CHDFDBDE">Changing the Writability of an Editioning View</a></p>
</li>
<li>
<p><a href="#CHDIAEIE">Replacing an Editioning View</a></p>
</li>
<li>
<p><a href="#CHDCABBF">Dropping or Renaming the Base Table</a></p>
</li>
<li>
<p><a href="#BABIECFF">Adding Indexes and Constraints to the Base Table</a></p>
</li>
<li>
<p><a href="#CHDBHHEC">SQL Optimizer Index Hints</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic">Oracle Database Reference</span> for more information about the static data dictionary views <a class="olink REFRN20668" href="../REFRN/GUID-353835AA-A5CB-456F-BEA9-59F3DA7DE0CB.htm#REFRN20668"><code dir="ltr">*_EDITIONING_VIEWS</code></a> and <a class="olink REFRN20683" href="../REFRN/GUID-51F9C24B-7135-47D8-A3C6-E73F551A2391.htm#REFRN20683"><code dir="ltr">*_EDITIONING_VIEWS_AE</code></a>.</div>
<a id="CHDHIDGF"></a>
<div id="ADFNS99916" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.2.1</span> Creating an Editioning View</h3>
<p><a id="sthref1202"></a>Before an editioning view is created, its owner must be editions-enabled and the schema object type <code dir="ltr">VIEW</code> must be editionable in its owner. (For instructions, see <a href="#g5086786">Section 24.1.1.4</a>.)</p>
<p>To create an editioning view, use the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> with the keyword <code dir="ltr">EDITIONING</code>. To make the editioning view read-only, specify <code dir="ltr">WITH</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code>; to make it read-write, omit <code dir="ltr">WITH</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code>. Do not specify <code dir="ltr">NONEDITIONABLE</code>, or an error occurs.</p>
<p>If an editioning view is <a id="sthref1203"></a><a id="sthref1204"></a><span class="bold">read-only</span>, users of the unchanged application can see the data in the base table, but cannot change it. The base table has <a id="sthref1205"></a><a id="sthref1206"></a><span class="bold">semi-availability</span>. Semi-availability is acceptable for applications such as online dictionaries, which users read but do not change. Make the editioning view read-only if you do not define <a id="sthref1207"></a>crossedition triggers on the base table.</p>
<p>If an editioning view is <a id="sthref1208"></a><a id="sthref1209"></a><span class="bold">read-write</span>, users of the unchanged application can both see and change the data in the base table. The base table has <a id="sthref1210"></a><a id="sthref1211"></a><span class="bold">maximum availability</span>. Maximum availability is required for applications such as online stores, where users submit purchase orders. If you define <a id="sthref1212"></a>crossedition triggers on the base table, make the editioning view read-write.</p>
<p>Because an editioning view must do no more than select a subset of the columns from the base table and provide aliases for them, the <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> statement that creates an editioning view has restrictions. Violating the restrictions causes the creation of the view to fail, even if you specify <code dir="ltr">FORCE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01504" href="../SQLRF/statements_8004.htm#SQLRF01504"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about using the <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> statement to create editioning views, including the restrictions</div>
</div>
<!-- class="sect2" -->
<a id="CHDEGDGI"></a>
<div id="ADFNS913" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.2.2</span> Partition-Extended Editioning View Names</h3>
<p><a id="sthref1213"></a><a id="sthref1214"></a>An editioning view defined on a partitioned table can have a partition-extended name, with partition and subpartition names that refer to the partitions and subpartitions of the base table.</p>
<p>The data manipulation language (DML) statements that support partition-extended table names also support partition-extended editioning view names. These statements are:</p>
<ul>
<li>
<p><code dir="ltr">DELETE</code></p>
</li>
<li>
<p><code dir="ltr">INSERT</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code></p>
</li>
<li>
<p><code dir="ltr">UPDATE</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00223" href="../SQLRF/sql_elements008.htm#SQLRF00223"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about referring to partitioned tables</div>
</div>
<!-- class="sect2" -->
<a id="CHDFDBDE"></a>
<div id="ADFNS99915" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.2.3</span> Changing the Writability of an Editioning View</h3>
<p><a id="sthref1215"></a><a id="sthref1216"></a>To change an existing editioning view from read-only to read-write, use the SQL statement <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> <code dir="ltr">READ</code> <code dir="ltr">WRITE</code>. To change an existing editioning view from read-write to read-only, use the SQL statement <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01104" href="../SQLRF/statements_4004.htm#SQLRF01104"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> statement</div>
</div>
<!-- class="sect2" -->
<a id="CHDIAEIE"></a>
<div id="ADFNS911" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.2.4</span> Replacing an Editioning View</h3>
<p><a id="sthref1217"></a>To replace an editioning view, use the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> with the <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> clause and the keyword <code dir="ltr">EDITIONING</code>.</p>
<p>You can replace an editioning view only with another editioning view. Any triggers defined on the replaced editioning view are retained.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCABBF"></a>
<div id="ADFNS912" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.2.5</span> Dropping or Renaming the Base Table</h3>
<p><a id="sthref1218"></a>If you drop or rename the base table on which an editioning view is defined, the editioning view is not dropped, but the editioning view and its dependents become invalid. However, any triggers defined on the editioning view remain.</p>
</div>
<!-- class="sect2" -->
<a id="BABIECFF"></a>
<div id="ADFNS914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.2.6</span> Adding Indexes and Constraints to the Base Table</h3>
<p>If your upgraded application requires new <a id="sthref1219"></a>indexes or <a id="sthref1220"></a>constraints, you must add them to the base table. You cannot add them to the editioning view.</p>
<p>If the new indexes might negatively impact the old edition (the original application), make them invisible. In the crossedition triggers that must use the new indexes, specify them in <code dir="ltr">INDEX</code> hints.</p>
<p>When all users are using only the upgraded application:</p>
<ul>
<li>
<p>If the new indexes were used only by the crossedition triggers, drop them.</p>
</li>
<li>
<p>If the new indexes are helpful in the upgraded application, make them visible.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adfns_indexes.htm#i1007888">Section 9.1, &#34;Guidelines for Managing Indexes&#34;</a></p>
</li>
<li>
<p><a class="olink SQLRF50405" href="../SQLRF/sql_elements006.htm#SQLRF50405"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code dir="ltr">INDEX</code> hints</p>
</li>
<li>
<p><a href="#CHDBHHEC">Section 24.2.7, &#34;SQL Optimizer Index Hints&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDBHHEC"></a>
<div id="ADFNS918" class="sect2">
<h3 class="sect2"><span class="secnum">24.2.7</span> SQL Optimizer Index Hints</h3>
<p><a id="sthref1221"></a><a id="sthref1222"></a><a id="sthref1223"></a>SQL optimizer index hints are specified in terms of the logical names of the columns participating in the index. Any SQL optimizer index hints specified on an editioning view using logical column names must be mapped to an index on the corresponding physical column in the base table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00219" href="../SQLRF/sql_elements006.htm#SQLRF00219"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about using hints</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJCDFF"></a>
<div id="ADFNS0203" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">24.3</span> Crossedition Triggers</h2>
<p><a id="sthref1224"></a>The most important difference between crossedition triggers and noncrossedition triggers is how they interact with editions. A crossedition trigger is visible only in the edition in which it is actual, never in a descendent edition. Forward crossedition triggers move data from columns used by the old edition to columns used by the new edition; reverse crossedition triggers do the reverse.</p>
<p>Other important differences are:</p>
<ul>
<li>
<p>Crossedition triggers can be ordered with triggers defined on other tables, while noncrossedition triggers can be ordered only with other triggers defined on the same table.</p>
</li>
<li>
<p>Crossedition triggers are temporary&mdash;you drop them after you have made the restructured tables available to all users.</p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS1294"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABHEHAH">Forward Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#BABGHHJB">Reverse Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#CHDFBHBI">Crossedition Trigger Interaction with Editions</a></p>
</li>
<li>
<p><a href="#CHDBJEFC">Creating a Crossedition Trigger</a></p>
</li>
<li>
<p><a href="#CHDGAGCH">Transforming Data from Pre- to Post-Upgrade Representation</a></p>
</li>
<li>
<p><a href="#BABGHBBF">Dropping the Crossedition Triggers</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS020" href="../LNPLS/overview.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for general information about triggers</div>
<a id="BABHEHAH"></a>
<div id="ADFNS99910" class="sect2">
<h3 class="sect2"><span class="secnum">24.3.1</span> Forward Crossedition Triggers</h3>
<p><a id="sthref1225"></a><a id="sthref1226"></a>The DML changes that you make to the table in the post-upgrade edition are written only to new columns or new tables, never to columns that users of pre-upgrade (ancestor) editions might be reading or writing. However, if the user of an ancestor edition changes the table data, the editioning view that you see must accurately reflect these changes. This is accomplished with forward crossedition triggers.</p>
<p>A forward crossedition trigger defines a <a id="sthref1227"></a><span class="bold">transform</span>, which is a rule for transforming an old row to one or more new rows. An <span class="bold">old row</span> is a row of data in the pre-upgrade representation. A <span class="bold">new row</span> is a row of data in the post-upgrade representation. The name of the trigger refers to the trigger itself and to the transform that the trigger defines.</p>
</div>
<!-- class="sect2" -->
<a id="BABGHHJB"></a>
<div id="ADFNS99909" class="sect2">
<h3 class="sect2"><span class="secnum">24.3.2</span> Reverse Crossedition Triggers</h3>
<p>If the pre- and post-upgrade editions will be in ordinary use at the same time (hot rollover), use <a id="sthref1228"></a><a id="sthref1229"></a>reverse crossedition triggers to ensure that when users of the post-upgrade edition make changes to the table data, the changes are accurately reflected in the pre-upgrade editions.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFBHBI"></a>
<div id="ADFNS99908" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.3.3</span> Crossedition Trigger Interaction with Editions</h3>
<p><a id="sthref1230"></a><a id="sthref1231"></a>The most important difference between crossedition triggers and noncrossedition triggers is how they interact with editions.</p>
<p>In this topic, the <span class="bold">current edition</span> is the edition in which the triggering DML statement runs. The current edition might differ from the session edition (for details, see <a href="#CHDGIDBB">Section 24.1.6.4</a>).</p>
<p class="subhead2"><a id="ADFNS694"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDDICFE">Which Triggers Are Visible</a></p>
</li>
<li>
<p><a href="#CHDFAEHG">What Kind of Triggers Can Fire</a></p>
</li>
<li>
<p><a href="#CHDCGHCD">Firing Order</a></p>
</li>
<li>
<p><a href="#CHDJGGAB">Crossedition Trigger Execution</a></p>
</li>
</ul>
<a id="CHDDICFE"></a>
<div id="ADFNS921" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.3.3.1</span> Which Triggers Are Visible</h4>
<p><a id="sthref1232"></a><a id="sthref1233"></a>Editions inherit noncrossedition triggers in the same way that they inherit other editioned objects (see <a href="#CHDEDBFB">Section 24.1.3, &#34;Editioned Objects and Copy-on-Change&#34;</a>).</p>
<p>Editions do not inherit crossedition triggers. A crossedition trigger might fire in response to a DML statement that another edition runs, but its name is visible only in the edition in which it was created. Therefore, an edition can reuse the name of a crossedition trigger created in an ancestor edition. Reusing the name of a crossedition trigger does not change the conditions under which the older trigger fires.</p>
<p>Crossedition triggers that appear in static data dictionary views are actual objects in the current edition.</p>
</div>
<!-- class="sect3" -->
<a id="CHDFAEHG"></a>
<div id="ADFNS922" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.3.3.2</span> What Kind of Triggers Can Fire</h4>
<p><a id="sthref1234"></a>What kind of triggers can fire depends on the category of the triggering DML statement.</p>
<p class="subhead2"><a id="ADFNS695"></a>Categories:</p>
<ul>
<li>
<p><a href="#BABIEBCG">Section 24.3.3.2.1, &#34;Forward Crossedition Trigger SQL&#34;</a></p>
</li>
<li>
<p><a href="#BABFBFHH">Section 24.3.3.2.2, &#34;Reverse Crossedition Trigger SQL&#34;</a></p>
</li>
<li>
<p><a href="#BABFEJAH">Section 24.3.3.2.3, &#34;Application SQL&#34;</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">APPEND</code> hint on a SQL <code dir="ltr">INSERT</code> statement does not prevent crossedition triggers from firing. For information about the <code dir="ltr">APPEND</code> hint, see <a class="olink SQLRF50901" href="../SQLRF/sql_elements006.htm#SQLRF50901"><span class="italic">Oracle Database SQL Language Reference</span></a>.</div>
<a id="BABIEBCG"></a>
<div id="ADFNS1295" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.3.3.2.1</span> Forward Crossedition Trigger SQL</h5>
<p><a id="sthref1235"></a><a id="sthref1236"></a><a id="sthref1237"></a><span class="bold">Forward crossedition trigger SQL</span> is SQL that is executed in either of these ways:</p>
<ul>
<li>
<p>Directly from the body of a forward crossedition trigger</p>
<p>This category includes SQL in an invoked subprogram only if the subprogram is local to the forward crossedition trigger.</p>
</li>
<li>
<p>By invoking the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure with a non-<code dir="ltr">NULL</code> value for the <code dir="ltr">apply_crossedition_trigger</code> parameter</p>
<p>The only valid non-<code dir="ltr">NULL</code> value for the <code dir="ltr">apply_crossedition_trigger</code> parameter is the unqualified name of a forward crossedition trigger. For more information about the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure, see <a class="olink ARPLS058" href="../ARPLS/d_sql.htm#ARPLS058"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ul>
<p>If a forward crossedition trigger invokes a subprogram in another compilation unit, the SQL in the subprogram is forward crossedition trigger SQL only if it is invoked by the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure with a non-<code dir="ltr">NULL</code> value for the <code dir="ltr">apply_crossedition_trigger</code> parameter.</p>
<p>Forward crossedition trigger SQL can fire only triggers that satisfy all of these conditions:</p>
<ul>
<li>
<p>They are forward crossedition triggers.</p>
</li>
<li>
<p>They were created either in the current edition or in a descendent of the current edition.</p>
</li>
<li>
<p>They explicitly follow the running forward crossedition trigger.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BABFBFHH"></a>
<div id="ADFNS1296" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.3.3.2.2</span> Reverse Crossedition Trigger SQL</h5>
<p><a id="sthref1238"></a><a id="sthref1239"></a><a id="sthref1240"></a><span class="bold">Reverse crossedition trigger SQL</span> is SQL that is executed directly from the body of a reverse crossedition trigger. This category includes SQL in an invoked subprogram only if the subprogram is local to the reverse crossedition trigger.</p>
<p>Reverse crossedition trigger SQL can fire only triggers that satisfy all of these conditions:</p>
<ul>
<li>
<p>They are reverse crossedition triggers.</p>
</li>
<li>
<p>They were created either in the current edition or in an ancestor of the current edition.</p>
</li>
<li>
<p>They explicitly precede the running reverse crossedition trigger.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BABFEJAH"></a>
<div id="ADFNS1297" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.3.3.2.3</span> Application SQL</h5>
<p><a id="sthref1241"></a><a id="sthref1242"></a><span class="bold">Application SQL</span> is all SQL except crossedition trigger SQL, including these DML statements:</p>
<ul>
<li>
<p>Dynamic SQL DML statements coded with the <code dir="ltr">DBMS_SQL</code> package (for information about these statements, see <a class="olink LNPLS01108" href="../LNPLS/dynamic.htm#LNPLS01108"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>).</p>
</li>
<li>
<p>DML statements executed by Java stored procedures and external procedures (even when these procedures are invoked by <code dir="ltr">CALL</code> triggers)</p>
</li>
</ul>
<p>Application SQL fires both noncrossedition and crossedition triggers, according to these rules:</p>
<div class="inftblinformal">
<table class="cellalignment296" title="Conditions Under Which Triggers Can Fire" summary="This table summarizes the conditions under which the different kinds of triggers can fire." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t32">Kind of Trigger</th>
<th class="cellalignment294" id="r1c2-t32">Conditions Under Which Trigger Can Fire</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t32" headers="r1c1-t32">Noncrossedition</td>
<td class="cellalignment295" headers="r2c1-t32 r1c2-t32">Trigger is both visible and enabled in the current edition.</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t32" headers="r1c1-t32">Forward crossedition</td>
<td class="cellalignment295" headers="r3c1-t32 r1c2-t32">Trigger was created in a descendent of the current edition.</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t32" headers="r1c1-t32">Reverse crossedition</td>
<td class="cellalignment295" headers="r4c1-t32 r1c2-t32">Trigger was created either in the current edition or in an ancestor of the current edition.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDCGHCD"></a>
<div id="ADFNS926" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.3.3.3</span> Firing Order</h4>
<p><a id="sthref1243"></a><a id="sthref1244"></a>For a trigger to fire in response to a specific DML statement, the trigger must:</p>
<ul>
<li>
<p>Be the right kind (see <a href="#CHDFAEHG">Section 24.3.3.2, &#34;What Kind of Triggers Can Fire&#34;</a>)</p>
</li>
<li>
<p>Satisfy the selection criteria (for example, the type of DML statement and the <code dir="ltr">WHEN</code> clause)</p>
</li>
<li>
<p>Be enabled</p>
</li>
</ul>
<p>For the triggers that meet these requirements, firing order depends on the <code dir="ltr">FOLLOWS</code> and <code dir="ltr">PRECEDES</code> clauses, the trigger type, and the edition.</p>
<p class="subhead2"><a id="ADFNS1057"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABBADEG">FOLLOWS and PRECEDES Clauses</a></p>
</li>
<li>
<p><a href="#BABFFCAH">Trigger Type and Edition</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS99985" href="../LNPLS/triggers.htm#LNPLS99985"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for general information about trigger firing order</div>
<a id="BABBADEG"></a>
<div id="ADFNS927" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.3.3.3.1</span> FOLLOWS and PRECEDES Clauses</h5>
<p>When triggers A and B are to be fired at the same timing point, A fires before B fires if either of these is true:</p>
<ul>
<li>
<p>A explicitly precedes B.</p>
</li>
<li>
<p>B explicitly follows A.</p>
</li>
</ul>
<p>This rule is independent of conditions such as:</p>
<ul>
<li>
<p>Whether the triggers are enabled or disabled</p>
</li>
<li>
<p>Whether the columns specified in the <code dir="ltr">UPDATE</code> <code dir="ltr">OF</code> clause are modified</p>
</li>
<li>
<p>Whether the <code dir="ltr">WHEN</code> clauses are satisfied</p>
</li>
<li>
<p>Whether the triggers are associated with the same kinds of DML statements (<code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code>)</p>
</li>
<li>
<p>Whether the triggers have overlapping timing points</p>
</li>
</ul>
<p>The firing order of triggers that do not explicitly follow or precede each other is unpredictable.</p>
</div>
<!-- class="sect4" -->
<a id="BABFFCAH"></a>
<div id="ADFNS928" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.3.3.3.2</span> Trigger Type and Edition</h5>
<p>For each timing point associated with a triggering DML statement, eligible triggers fire in this order. In categories <a href="#g5068739">1</a> through <a href="#g5068945">3</a>, <code dir="ltr">FOLLOWS</code> relationships apply; in categories <a href="#g5069005">4</a> and <a href="#g5069209">5</a>, <code dir="ltr">PRECEDES</code> relationships apply.</p>
<ol>
<li id="g5068739">
<p>Noncrossedition triggers</p>
</li>
<li>
<p>Forward crossedition triggers created in the current edition</p>
</li>
<li id="g5068945">
<p>Forward crossedition triggers created in descendents of the current edition, in the order that the descendents were created (child, grandchild, and so on)</p>
</li>
<li id="g5069005">
<p>Reverse crossedition triggers created in the current edition</p>
</li>
<li id="g5069209">
<p>Reverse crossedition triggers created in the ancestors of the current edition, in the reverse order that the ancestors were created (parent, grandparent, and so on)</p>
</li>
</ol>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDJGGAB"></a>
<div id="ADFNS929" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.3.3.4</span> Crossedition Trigger Execution</h4>
<p><a id="sthref1245"></a>A crossedition trigger runs using the edition in which it was created. Any code that the crossedition trigger calls (including package references, PL/SQL subprogram calls, and SQL statements) also runs in the edition in which the crossedition trigger was created.</p>
<p>If a PL/SQL package is actual in multiple editions, then the package variables and other state are private in each edition, even within a single session. Because each crossedition trigger and the code that it calls run using the edition in which the crossedition trigger was created, the same session can instantiate two or more versions of the package, with the same name.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBJEFC"></a>
<div id="ADFNS99912" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.3.4</span> Creating a Crossedition Trigger</h3>
<p><a id="sthref1246"></a>Before a crossedition trigger is created, its owner must be editions-enabled and the schema object type <code dir="ltr">TRIGGER</code> must be editionable in its owner. (For instructions, see <a href="#g5086786">Section 24.1.1.4</a>.)</p>
<p>Create a crossedition trigger with the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code>, observing these rules:</p>
<ul>
<li>
<p>A crossedition trigger must be defined on a table, not a view.</p>
</li>
<li>
<p>A crossedition trigger must have the <code dir="ltr">EDITIONABLE</code> property.</p>
</li>
<li>
<p>A crossedition trigger must be a DML trigger (simple or compound).</p>
<p>The DML statement in a crossedition trigger body can be either a static SQL statement (described in <a class="olink LNPLS00601" href="../LNPLS/static.htm#LNPLS00601"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>) or a native dynamic SQL statement (described in <a class="olink LNPLS01102" href="../LNPLS/dynamic.htm#LNPLS01102"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>).</p>
</li>
<li>
<p>A crossedition trigger is forward unless you specify <code dir="ltr">REVERSE</code>. (Specifying <code dir="ltr">FORWARD</code> is optional.)</p>
</li>
<li>
<p>The <code dir="ltr">FOLLOWS</code> clause is allowed only when creating a forward crossedition trigger or a noncrossedition trigger. (The <code dir="ltr">FOLLOWS</code> clause indicates that the trigger being created is to fire after the specified triggers fire.)</p>
</li>
<li>
<p>The <code dir="ltr">PRECEDES</code> clause is allowed only when creating a reverse crossedition trigger. (The <code dir="ltr">PRECEDES</code> clause indicates that the trigger being created is to fire before the specified triggers fire.)</p>
</li>
<li>
<p>The triggers specified in the <code dir="ltr">FOLLOWS</code> or <code dir="ltr">PRECEDES</code> clause must exist, but need not be enabled or successfully compiled.</p>
</li>
<li>
<p>Like a noncrossedition trigger, a crossedition trigger is created in the enabled state unless you specify <code dir="ltr">DISABLE</code>. (Specifying <code dir="ltr">ENABLE</code> is optional.)</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Create crossedition triggers in the disabled state, and enable them after you are sure that they compile successfully. If you create them in the enabled state, and they fail to compile, the failure affects users of the existing application.</div>
</li>
<li>
<p>The operation in a crossedition trigger body must be <span class="bold">idempotent</span> (that is, performing the operation multiple times is redundant; it does not change the result).</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01374" href="../LNPLS/create_trigger.htm#LNPLS01374"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about using the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement to create crossedition triggers</div>
<a id="BABIEHHA"></a>
<div id="ADFNS1298" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">24.3.4.1</span> Coding the Forward Crossedition Trigger Body</h4>
<p>The operation in the body of a forward crossedition trigger must be idempotent, because it is impossible to predict:</p>
<ul>
<li>
<p>The context in which the body will first run for an old row.</p>
<p>The possibilities are:</p>
<ul>
<li>
<p>When a user of an ancestor edition runs a DML statement that fires the trigger (a <span class="bold">serendipitous change</span>)</p>
</li>
<li>
<p>When you <span class="bold">apply the transform</span> that the trigger defines</p>
<p>For information about applying transforms, see <a href="#CHDGAGCH">Section 24.3.5</a>.</p>
</li>
</ul>
</li>
<li>
<p>How many times the body will run for each old row.</p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS1299"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABJCHCC">Handling Data Transformation Collisions</a></p>
</li>
<li>
<p><a href="#BABIFCCJ">Handling Changes to Other Tables</a></p>
</li>
</ul>
<a id="BABJCHCC"></a>
<div id="ADFNS1300" class="sect4">
<h5 class="sect4"><span class="secnum">24.3.4.1.1</span> Handling Data Transformation Collisions</h5>
<p>If a forward crossedition trigger populates a new table (rather than new columns of a table), its body must handle data transformation collisions.</p>
<p>For example, suppose that a column of the new table has a <a id="sthref1247"></a><a id="sthref1248"></a><code dir="ltr">UNIQUE</code> constraint. A <a id="sthref1249"></a>serendipitous change fires the forward crossedition trigger, which inserts a row in the new table. Later, another serendipitous change fires the forward crossedition trigger, or you apply the transform defined by the trigger. The trigger tries to insert a row in the new table, violating the <code dir="ltr">UNIQUE</code> constraint.</p>
<p>If your collision-handling strategy depends on why the trigger is running, you can determine the reason with the function <a id="sthref1250"></a><code dir="ltr">APPLYING_CROSSEDITION_TRIGGER</code>. When called directly from a trigger body, this function returns the <code dir="ltr">BOOLEAN</code> value <code dir="ltr">TRUE</code> if the trigger is running because of a <a id="sthref1251"></a>serendipitous change and <code dir="ltr">FALSE</code> if the trigger is running because you are applying the transform. (<code dir="ltr">APPLYING_CROSSEDITION_TRIGGER</code> is defined in the package <code dir="ltr">DBMS_STANDARD</code>. It has no parameters.)</p>
<p>To ignore collisions and insert the rows that do not collide with existing rows, put the <a id="sthref1252"></a><code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code> hint in the <code dir="ltr">INSERT</code> statement.</p>
<p>If you do not want to ignore such collisions, but want to know where they occur so that you can handle them, put the <a id="sthref1253"></a><code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code> hint in the <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement, specifying either an index or set of columns. Then, when a unique key violation occurs for that index or set of columns, ORA-38911 is reported instead of ORA-00001. You can write an exception handler for ORA-38911.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although they have the syntax of hints, <code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code> and <code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code> are mandates. The optimizer always uses them.</div>
<p><a href="#BABEDEFI">Example 24-5</a> creates a crossedition trigger that uses the <code dir="ltr">APPLYING_CROSSEDITION_TRIGGER</code> function and the <code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code> and <code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code> hints to handle data transformation collisions. The trigger transforms old rows in <code dir="ltr">table1</code> to new rows in <code dir="ltr">table2</code>. The tables were created as follows:</p>
<pre dir="ltr">CREATE TABLE table1 (key NUMBER, value VARCHAR2(20));

CREATE TABLE table2 (key NUMBER, value VARCHAR2(20), last_updated TIMESTAMP);
CREATE UNIQUE INDEX i2 on table2(key);
</pre>
<div id="ADFNS1304" class="example">
<p class="titleinexample"><a id="BABEDEFI"></a>Example 24-5 Crossedition Trigger that Handles Data Transformation Collisions</p>
<pre dir="ltr">CREATE OR REPLACE TRIGGER trigger1
  BEFORE INSERT OR UPDATE ON table1
  FOR EACH ROW
  CROSSEDITION
DECLARE
  row_already_present  EXCEPTION;
  PRAGMA EXCEPTION_INIT(row_already_present, -38911);
BEGIN
  IF <span class="bold">APPLYING_CROSSEDITION_TRIGGER</span> THEN
    /* Trigger is running because of serendipitous change.
       Insert new row into table2 unless it is already there. */
    <span class="bold">INSERT /*+ IGNORE_ROW_ON_DUPKEY_INDEX(table2(key)) */</span>
    INTO table2
    VALUES(:new.key, :new.value, to_date(&#39;1900-01-01&#39;, &#39;YYYY-MM-DD&#39;));
  ELSE
    /* Trigger is running because you are applying transform.
       If tranform has not yet inserted new row in table2, insert new row;
       otherwise, update new row. */
    BEGIN
      <span class="bold">INSERT /*+ CHANGE_DUPKEY_ERROR_INDEX(table2(key)) */</span>
      INTO table2
      VALUES(:new.key, :new.value, SYSTIMESTAMP);
    EXCEPTION WHEN row_already_present THEN
      UPDATE table2
      SET value = :new.value, last_updated = SYSTIMESTAMP
      WHERE key = :new.key;
    END;
  END IF;
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF30052" href="../SQLRF/sql_elements006.htm#SQLRF30052"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code></p>
</li>
<li>
<p><a class="olink SQLRF30053" href="../SQLRF/sql_elements006.htm#SQLRF30053"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code></p>
</li>
<li>
<p><a class="olink SQLRF00219" href="../SQLRF/sql_elements006.htm#SQLRF00219"><span class="italic">Oracle Database SQL Language Reference</span></a> for general information about hints</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="BABIFCCJ"></a>
<div id="ADFNS1305" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><span class="secnum">24.3.4.1.2</span> Handling Changes to Other Tables</h5>
<p>If the body of a forward crossedition trigger includes explicit SQL statements that change tables other than the one on which the trigger is defined, and if the rows of those tables do not have a one-to-one correspondence with the rows of the table on which the trigger is defined, then the body code must implement a locking mechanism that correctly handles these situations:</p>
<ul>
<li>
<p>Two or more users of ancestor editions simultaneously issue DML statements for the table on which the trigger is defined.</p>
</li>
<li>
<p>At least one user of an ancestor edition issues a DML statement for the table on which the trigger is defined.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGAGCH"></a>
<div id="ADFNS99907" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.3.5</span> Transforming Data from Pre- to Post-Upgrade Representation</h3>
<p>After redefining the database objects that comprise the application that you are upgrading (in the new edition), you must transform the application data from its pre-upgrade representation (in the old edition) to its post-upgrade representation (in the new edition). The rules for this transformation are called <span class="bold">transforms</span>, and they are defined by forward crossedition triggers. (For general information about forward crossedition triggers, see <a href="#BABHEHAH">Section 24.3.1</a>.)</p>
<p>Some old rows might have been transformed to new rows by <a id="sthref1254"></a><span class="bold">serendipitous changes</span>; that is, by changes that users of the pre-upgrade application made, which fired forward crossedition triggers. However, any rows that were not transformed by serendipitous changes are still in their pre-upgrade representation. To ensure that all old rows are transformed to new rows, you must <a id="sthref1255"></a><span class="bold">apply the transforms</span> that you defined on the tables that store the application data.</p>
<p>There are three ways to apply a transform:</p>
<ul>
<li>
<p>Fire the trigger that defines the transform on every row of the table, one row at a time.</p>
</li>
<li>
<p>Instead of firing the trigger, run a SQL statement that does what the trigger would do, but faster, and then fire any triggers that follow that trigger.</p>
<p>This second way is recommended over the first way if you have replaced an entire table or created a new table.</p>
</li>
<li>
<p>Invoke the procedure <code dir="ltr">DBMS_EDITIONS_UTILITIES</code>.<code dir="ltr">SET_NULL_COLUMN_VALUES_TO_EXPR</code> to use a metadata operation to apply the transform to the new column.</p>
<p>This third way has the fastest installation time, but there are restrictions on the expression that represents the transform, and queries of the new column are slower until the metadata is replaced by actual data.</p>
<p>Metadata is replaced by actual data:</p>
<ul>
<li>
<p>In an individual column element that is updated.</p>
</li>
<li>
<p>In every element of a column whose table is &#34;compacted&#34; using online table redefinition.</p>
</li>
</ul>
<p>For the syntax, semantics, and restrictions of the <code dir="ltr">DBMS_EDITIONS_UTILITIES</code>.<code dir="ltr">SET_NULL_COLUMN_VALUES_TO_EXPR</code> procedure, see <a class="olink ARPLS73756" href="../ARPLS/d_editions_utl.htm#ARPLS73756"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ul>
<p>For the first two ways of applying the transform, invoke either the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure or the subprograms in the <a id="sthref1256"></a><code dir="ltr">DBMS_PARALLEL_EXECUTE</code> package. The latter is recommended if you have a lot of data. The subprograms enable you to incrementally update the data in a large table in parallel, in two high-level steps:</p>
<ol>
<li>
<p>Group sets of rows in the table into smaller chunks.</p>
</li>
<li>
<p>Apply the desired <code dir="ltr">UPDATE</code> statement to the chunks in parallel, committing each time you have finished processing a chunk.</p>
</li>
</ol>
<p>The advantages are:</p>
<ul>
<li>
<p>You lock only one set of rows at a time, for a relatively short time, instead of locking the entire table.</p>
</li>
<li>
<p>You do not lose work that has been done if something fails before the entire operation finishes.</p>
</li>
</ul>
<p>For both the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure and the <code dir="ltr">DBMS_PARALLEL_EXECUTE</code> subprograms, the actual parameter values for <code dir="ltr">apply_crossedition_trigger</code>, <code dir="ltr">fire_apply_trigger</code>, and <code dir="ltr">sql_stmt</code> are the same:</p>
<ul>
<li>
<p>For <code dir="ltr">apply_crossedition_trigger</code>, specify the name of the forward crossedition trigger that defines the transform to be applied.</p>
</li>
<li>
<p>To fire the trigger on every row of the table, one row at a time:</p>
<ul>
<li>
<p>For the value of <code dir="ltr">fire_apply_trigger</code>, specify <code dir="ltr">TRUE</code>.</p>
</li>
<li>
<p>For <code dir="ltr">sql_stmt</code>, supply a SQL statement whose only significant effect is to select the forward crossedition trigger to be fired; for example, an <code dir="ltr">UPDATE</code> statement that sets some column to its own existing value in each row.</p>
</li>
</ul>
</li>
<li>
<p>To run a SQL statement that does what the trigger would do, and then fire any triggers that follow that trigger:</p>
<ul>
<li>
<p>For the value of <code dir="ltr">fire_apply_trigger</code>, specify <code dir="ltr">FALSE</code>.</p>
</li>
<li>
<p>For <code dir="ltr">sql_stmt</code>, supply a SQL statement that does what the forward crossedition trigger would do, but faster&mdash;for example, a PL/SQL anonymous block that calls one or more PL/SQL subprograms.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS058" href="../ARPLS/d_sql.htm#ARPLS058"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure</p>
</li>
<li>
<p><a class="olink ARPLS233" href="../ARPLS/d_parallel_ex.htm#ARPLS233"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_PARALLEL_EXECUTE</code> package</p>
</li>
</ul>
</div>
<a id="BABJEAFE"></a>
<div id="ADFNS1306" class="sect3">
<h4 class="sect3"><span class="secnum">24.3.5.1</span> Preventing Lost Updates</h4>
<p>To prevent lost updates when applying a transform, use this procedure:</p>
<ol>
<li>
<p>Enable crossedition triggers.</p>
</li>
<li>
<p>Wait until pending changes to the affected tables are either committed or rolled back.</p>
<p>Use the procedure <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">WAIT_ON_PENDING_DML</code>, described in <a class="olink ARPLS73275" href="../ARPLS/d_util.htm#ARPLS73275"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li>
<p>Apply the transform.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
This scenario, where the forward crossedition trigger changes only the table on which it is defined, is sufficient to illustrate the risk. Suppose that Session One issues an <code dir="ltr">UPDATE</code> statement against the table when the crossedition trigger is not yet enabled; and that Session Two then enables the crossedition trigger and immediately applies the transformation.
<p>A race condition can now occur when both Session One and Session Two will change the same row (row <span class="italic">n</span>). Chance determines which session reaches row <span class="italic">n</span> first. Both updates succeed, even if the session that reaches row <span class="italic">n</span> second must wait until the session that reached it first commits its change and releases its lock.</p>
<p>The problem occurs when Session Two wins the race. Because its SQL statement was compiled after the trigger was enabled, the program that implements the statement also implements the trigger action; therefore, the intended post-upgrade column values are set for row <span class="italic">n</span>. Now Session One reaches row <span class="italic">n</span>, and because its SQL statement was compiled before the trigger was enabled, the program that implements the statement does not implement the trigger action. Therefore, the values that Session Two set in the post-upgrade columns do not change&mdash;they reflect the values that the source columns had before Session One updated row <span class="italic">n</span>. That is, the intended side-effect of Session One&#39;s update is lost.</p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGHBBF"></a>
<div id="ADFNS930" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.3.6</span> Dropping the Crossedition Triggers</h3>
<p><a id="sthref1257"></a>To drop a crossedition trigger, use the <code dir="ltr">DROP</code> <code dir="ltr">TRIGGER</code> statement, described in <a class="olink LNPLS99990" href="../LNPLS/drop_trigger.htm#LNPLS99990"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>. Alternatively, you can drop crossedition triggers by dropping the edition in which they are actual, by using the <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> statement with the <code dir="ltr">CASCADE</code> clause. For information about dropping editions, see <a href="#CHDJCDCA">Section 24.1.8</a>.</p>
<p>You drop crossedition triggers in these situations:</p>
<ul>
<li>
<p>You are rolling back the application upgrade (dropping the post-upgrade edition).</p>
<p>Before dropping the post-upgrade edition, you must disable or drop any <a id="sthref1258"></a>constraints on the new columns.</p>
</li>
<li>
<p>You have finished the application upgrade and made the post-upgrade edition available to all users.</p>
<p>When all sessions are using the post-upgrade edition, you can drop the forward crossedition triggers. However, before dropping the reverse crossedition triggers, you must disable or drop any constraints on the old columns.</p>
</li>
</ul>
<p>To disable or drop constraints, use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement with the <code dir="ltr">DISABLE</code> <code dir="ltr">CONSTRAINT</code> or <code dir="ltr">DROP</code> <code dir="ltr">CONSTRAINT</code> clause. For information about the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement, see <a class="olink SQLRF01001" href="../SQLRF/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCEEEA"></a>
<div id="ADFNS0204" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">24.4</span> Displaying Information About EBR Features</h2>
<p class="subhead2"><a id="ADFNS1307"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABCAJAE">Displaying Information About Editions</a></p>
</li>
<li>
<p><a href="#BABDEBCB">Displaying Information About Editioning Views</a></p>
</li>
<li>
<p><a href="#BABDACCE">Displaying Information About Crossedition Triggers</a></p>
</li>
</ul>
<a id="BABCAJAE"></a>
<div id="ADFNS1308" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.4.1</span> Displaying Information About Editions</h3>
<p><a id="sthref1259"></a><a href="#g4932472">Table 24-1</a> briefly describes the static data dictionary views that display information about editions. For more information about a specific view, see <a class="olink REFRN002" href="../REFRN/GUID-8865F65B-EF6D-44A5-B0A1-3179EFF0C36A.htm#REFRN002"><span class="italic">Oracle Database Reference</span></a>.</p>
<div id="ADFNS932" class="tblformal">
<p class="titleintable"><a id="sthref1260"></a><a id="g4932472"></a>Table 24-1 *_ Dictionary Views with Edition Information</p>
<table class="cellalignment293" title="*_ Dictionary Views with Edition Information" summary="This table summarizes the DBA_ dictionary views that provide information about Editions." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t40">View</th>
<th class="cellalignment294" id="r1c2-t40">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20634" href="../REFRN/GUID-6B9705F4-91C2-41BB-9F36-40C323CA76E7.htm#REFRN20634"><code dir="ltr">*_EDITIONS</code></a></p>
</td>
<td class="cellalignment295" headers="r2c1-t40 r1c2-t40">
<p>Describes every edition in the database.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20635" href="../REFRN/GUID-ED446E20-0F56-4A4E-8CF7-2C41AF3457BE.htm#REFRN20635"><code dir="ltr">*_EDITION_COMMENTS</code></a></p>
</td>
<td class="cellalignment295" headers="r3c1-t40 r1c2-t40">
<p>Shows the comments associated with every edition in the database.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN23867" href="../REFRN/GUID-AF15E002-099C-4CA1-9FC4-A70E5507DD78.htm#REFRN23867"><code dir="ltr">*_EDITIONED_TYPES</code></a></p>
</td>
<td class="cellalignment295" headers="r4c1-t40 r1c2-t40">
<p>Lists the schema object types that are editioned by default in each schema.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20146" href="../REFRN/GUID-AA6DEF8B-F04F-482A-8440-DBCB18F6C976.htm#REFRN20146"><code dir="ltr">*_OBJECTS</code></a></p>
</td>
<td class="cellalignment295" headers="r5c1-t40 r1c2-t40">
<p>Describes every object in the database that is visible in the current edition. For each object, this view shows whether it is editionable.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t40" headers="r1c1-t40">
<p><a id="g4936767"></a><a class="olink REFRN20578" href="../REFRN/GUID-B7C1E515-2B54-43CC-ABDB-957E82336229.htm#REFRN20578"><code dir="ltr">*_OBJECTS_AE</code></a></p>
</td>
<td class="cellalignment295" headers="r6c1-t40 r1c2-t40">
<p>Describes every object in the database, in every edition. For each object, this view shows whether it is editionable.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r7c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20065" href="../REFRN/GUID-2237BC4D-F34A-48C5-8181-85426077E65B.htm#REFRN20065"><code dir="ltr">*_ERRORS</code></a></p>
</td>
<td class="cellalignment295" headers="r7c1-t40 r1c2-t40">
<p>Describes every error in the database in the current edition.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r8c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20577" href="../REFRN/GUID-CD531FB0-C1DF-4C60-8371-431AB6A28265.htm#REFRN20577"><code dir="ltr">*_ERRORS_AE</code></a></p>
</td>
<td class="cellalignment295" headers="r8c1-t40 r1c2-t40">
<p>Describes every error in the database, in every edition.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r9c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20302" href="../REFRN/GUID-DDD25C8F-7EC9-46BC-ABEA-529C64FA09E2.htm#REFRN20302"><code dir="ltr">*_USERS</code></a></p>
</td>
<td class="cellalignment295" headers="r9c1-t40 r1c2-t40">
<p>Describes every user in the database. Useful for showing which users have editions enabled.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r10c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20465" href="../REFRN/GUID-0091C6CB-6852-4253-8FE7-7F0FF053C652.htm#REFRN20465"><code dir="ltr">*_SERVICES</code></a></p>
</td>
<td class="cellalignment295" headers="r10c1-t40 r1c2-t40">
<p>Describes every service in the database. The <code dir="ltr">EDITIONS</code> column shows the default initial current edition.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r11c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20139" href="../REFRN/GUID-8B9432B5-6B66-411A-936E-590D9D7671E9.htm#REFRN20139"><code dir="ltr">*_MVIEWS</code></a></p>
</td>
<td class="cellalignment295" headers="r11c1-t40 r1c2-t40">
<p>Describes every materialized view. If the materialized view refers to editioned objects, then this view shows the evaluation edition and the range of editions where the materialized view is eligible for query rewrite.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r12c1-t40" headers="r1c1-t40">
<p><a class="olink REFRN20276" href="../REFRN/GUID-85036F42-140A-406B-BE11-0AC49A00DBA3.htm#REFRN20276"><code dir="ltr">*_TAB_COLS</code></a></p>
</td>
<td class="cellalignment295" headers="r12c1-t40 r1c2-t40">
<p>Describes every column of every table, view, and cluster. For each virtual column, this view shows the evaluation edition and the usable range.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">*_OBJECTS</code> and <code dir="ltr">*_OBJECTS_AE</code> include dependent objects that are invalidated by operations in <a href="adfns_dependencies.htm#g1008856">Table 23-2</a> only after one of the following:
<ul>
<li>
<p>A reference to the object (either during compilation or execution)</p>
</li>
<li>
<p>An invocation of <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">COMPILE_SCHEMA</code> (described in <a class="olink ARPLS380" href="../ARPLS/u_recomp.htm#ARPLS380"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>)</p>
</li>
<li>
<p>An invocation of any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS380" href="../ARPLS/u_recomp.htm#ARPLS380"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>)</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABDEBCB"></a>
<div id="ADFNS1309" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.4.2</span> Displaying Information About Editioning Views</h3>
<p><a id="sthref1261"></a><a href="#g4942508">Table 24-2</a> briefly describes the static data dictionary views that display information about editioning views. For more information about a specific view, see <a class="olink REFRN002" href="../REFRN/GUID-8865F65B-EF6D-44A5-B0A1-3179EFF0C36A.htm#REFRN002"><span class="italic">Oracle Database Reference</span></a>.</p>
<div id="ADFNS933" class="tblformal">
<p class="titleintable"><a id="sthref1262"></a><a id="g4942508"></a>Table 24-2 *_ Dictionary Views with Editioning View Information</p>
<table class="cellalignment293" title="*_ Dictionary Views with Editioning View Information" summary="This table summarizes the DBA_ dictionary views that provide information about Editioning Views." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t42">View</th>
<th class="cellalignment294" id="r1c2-t42">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t42" headers="r1c1-t42">
<p><a class="olink REFRN20305" href="../REFRN/GUID-0FE29B36-0882-47AE-A54E-A01FC9C4100A.htm#REFRN20305"><code dir="ltr">*_VIEWS</code></a></p>
</td>
<td class="cellalignment295" headers="r2c1-t42 r1c2-t42">
<p>Describes every view in the database that is visible in the current edition, including editioning views.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t42" headers="r1c1-t42">
<p><a class="olink REFRN20668" href="../REFRN/GUID-353835AA-A5CB-456F-BEA9-59F3DA7DE0CB.htm#REFRN20668"><code dir="ltr">*_EDITIONING_VIEWS</code></a></p>
</td>
<td class="cellalignment295" headers="r3c1-t42 r1c2-t42">
<p>Describes every editioning view in the database that is visible in the current edition. Useful for showing relationships between editioning views and their base tables. Join with <a href="#g4936767"><code dir="ltr">*_OBJECTS_AE</code></a> for additional information.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t42" headers="r1c1-t42">
<p><a class="olink REFRN20681" href="../REFRN/GUID-B031703E-5B52-4219-9372-4EFCACD29713.htm#REFRN20681"><code dir="ltr">*_EDITIONING_VIEWS_AE</code></a></p>
</td>
<td class="cellalignment295" headers="r4c1-t42 r1c2-t42">
<p>Describes every actual object in every editioning view in the database, in every edition.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t42" headers="r1c1-t42">
<p><a class="olink REFRN20669" href="../REFRN/GUID-5636A801-29AD-4520-AB4A-792D6C0297DA.htm#REFRN20669"><code dir="ltr">*_EDITIONING_VIEW_COLS</code></a></p>
</td>
<td class="cellalignment295" headers="r5c1-t42 r1c2-t42">
<p>Describes the columns of every editioning view in the database that is visible in the current edition. Useful for showing relationships between the columns of editioning views and the table columns to which they map. Join with <a href="#g4936767"><code dir="ltr">*_OBJECTS_AE</code></a>, <code dir="ltr">*_TAB_COL</code>, or both, for additional information.</p>
</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t42" headers="r1c1-t42">
<p><a class="olink REFRN20683" href="../REFRN/GUID-51F9C24B-7135-47D8-A3C6-E73F551A2391.htm#REFRN20683"><code dir="ltr">*_EDITIONING_VIEW_COLS_AE</code></a></p>
</td>
<td class="cellalignment295" headers="r6c1-t42 r1c2-t42">
<p>Describes the columns of every editioning view in the database, in every edition.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Each row of <code dir="ltr">*_EDITIONING_VIEWS</code> matches exactly one row of <code dir="ltr">*_VIEWS</code>, and each row of <code dir="ltr">*_VIEWS</code> that has <code dir="ltr">EDITIONING_VIEW</code> = <code dir="ltr">&#39;Y&#39;</code> matches exactly one row of <code dir="ltr">*_EDITIONING_VIEWS</code>. Therefore, in this example, the <code dir="ltr">WHERE</code> clause is redundant:</p>
<pre dir="ltr">SELECT ...
  FROM DBA_EDITIONING_VIEWS INNER JOIN DBA_VIEWS
  USING (OWNER, VIEW_NAME)
  <span class="bold">WHERE EDITIONING_VIEW = &#39;Y&#39;</span>
  AND ...
</pre>
<p>The row of <code dir="ltr">*_VIEWS</code> that matches a row of <code dir="ltr">*_EDITIONING_VIEWS</code> has <code dir="ltr">EDITIONING_VIEW</code> = <code dir="ltr">&#39;Y</code>&#39; by definition. Conversely, no row of <code dir="ltr">*_VIEWS</code> that has <code dir="ltr">EDITIONING_VIEW</code> = <code dir="ltr">&#39;N&#39;</code> has a counterpart in <code dir="ltr">*_ EDITIONING_VIEWS</code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABDACCE"></a>
<div id="ADFNS1310" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.4.3</span> Displaying Information About Crossedition Triggers</h3>
<p><a id="sthref1263"></a>The static data dictionary views that display information about triggers are described in <a class="olink REFRN002" href="../REFRN/GUID-8865F65B-EF6D-44A5-B0A1-3179EFF0C36A.htm#REFRN002"><span class="italic">Oracle Database Reference</span></a>. Crossedition triggers that appear in static data dictionary views are actual objects in the current edition.</p>
<p>Child cursors cannot be shared if the set of <a id="sthref1264"></a><a id="sthref1265"></a>crossedition triggers that might run differs. The dynamic performance views <code dir="ltr">V$SQL_SHARED_CURSOR</code> and <code dir="ltr">GV$SQL_SHARED_CURSOR</code> have a <code dir="ltr">CROSSEDITION_TRIGGER_MISMATCH</code> column that tells whether this is true. For information about <code dir="ltr">V$SQL_SHARED_CURSOR</code>, see <a class="olink REFRN30254" href="../REFRN/GUID-4993A6DE-5658-4745-B43E-F5AD9DB8DCCC.htm#REFRN30254"><span class="italic">Oracle Database Reference</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABEHGAF"></a>
<div id="ADFNS1311" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">24.5</span> Using EBR to Upgrade an Application</h2>
<p>To use EBR to upgrade your application online, you must first ready your application:</p>
<ol>
<li id="BABIBAFI">
<p>Editions-enable the appropriate users and the appropriate schema object types in their schemas.</p>
<p>In schemas where you will create editioning views (in the next step), the type <code dir="ltr">VIEW</code> must be editionable.</p>
<p>For instructions, see <a href="#g5086786">Section 24.1.1.4</a>.</p>
</li>
<li>
<p>Prepare your application to use editioning views.</p>
<p>For instructions, see <a href="#BABCFGHJ">Section 24.5.1</a>.</p>
</li>
</ol>
<p>With the editioning views in place, you can use EBR to upgrade your application online as often as necessary. For each upgrade:</p>
<ul>
<li>
<p>If the type of every object that you will redefine is editionable (tables are not editionable), then use the procedure in <a href="#CHDIGDGF">Section 24.5.2, &#34;Procedure for EBR Using Only Editions.&#34;</a></p>
</li>
<li>
<p>If you will change the structure of one or more tables, and while you are doing so, other users <span class="italic">need not</span> be able to change data in those tables, then use the procedure in <a href="#CHDDFEJC">Section 24.5.3, &#34;Procedure for EBR Using Editioning Views.&#34;</a></p>
</li>
<li>
<p>If you will change the structure of one or more tables, and while you are doing so, other users must be able to change data in those tables, then use the procedure in <a href="#BABGGADB">Section 24.5.4, &#34;Procedure for EBR Using Crossedition Triggers.&#34;</a></p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS1312"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABCFGHJ">Preparing Your Application to Use Editioning Views</a></p>
</li>
<li>
<p><a href="#CHDIGDGF">Procedure for EBR Using Only Editions</a></p>
</li>
<li>
<p><a href="#CHDDFEJC">Procedure for EBR Using Editioning Views</a></p>
</li>
<li>
<p><a href="#BABGGADB">Procedure for EBR Using Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#BABFDHIG">Rolling Back the Application Upgrade</a></p>
</li>
<li>
<p><a href="#BABFIAEF">Reclaiming Space Occupied by Unused Table Columns</a></p>
</li>
<li>
<p><a href="#BABFFEDD">Example: Using EBR to Upgrade an Application</a></p>
</li>
</ul>
<a id="BABCFGHJ"></a>
<div id="ADFNS99917" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.5.1</span> Preparing Your Application to Use Editioning Views</h3>
<p><a id="sthref1266"></a>An application that uses one or more tables must cover each table with an editioning view. An editioning view <a id="sthref1267"></a><span class="bold">covers</span> a table when all of these statements are true:</p>
<ul>
<li>
<p>Every ordinary object in the application references the table only through the editioning view. (An <span class="bold">ordinary object</span> is any object except an editioning view or crossedition trigger. Editioning views and crossedition triggers must reference tables.)</p>
</li>
<li>
<p>Application users are granted object privileges only on the editioning view, not on the table.</p>
</li>
<li>
<p><a id="sthref1268"></a><a id="sthref1269"></a>Oracle Virtual Private Database (VPD) policies are attached only to the editioning view, not to the table. (<a id="sthref1270"></a><a id="sthref1271"></a>Regular auditing and <a id="sthref1272"></a>fine-grained auditing (FGA) policies are attached only to the table.)</p>
</li>
</ul>
<p>When the editioning view is actualized, a copy of the VPD policy is attached to the actualized editioning view. (A policy is uniquely identified by its name and the object to which it is attached.) If the policy function is also actualized, the copy of the policy uses the actualized policy function; otherwise, it uses the original policy function.</p>
<p>The static data dictionary views <code dir="ltr">*_POLICIES</code>, which describe the VPD policies, can have different results in different editions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DBSEG007" href="../DBSEG/vpd.htm#DBSEG007"><span class="italic">Oracle Database Security Guide</span></a> for information about VPD, including that static data dictionary views that show information about VPD policies</p>
</li>
<li>
<p><a class="olink REFRN20164" href="../REFRN/GUID-1CAC5A1B-0497-4EC6-ABF1-455C57E82A46.htm#REFRN20164"><span class="italic">Oracle Database Reference</span></a> for information about <code dir="ltr">*_POLICIES</code></p>
</li>
</ul>
</div>
<p>If an existing application does not use editioning views, prepare it to use them by following this procedure for each table that it uses:</p>
<ol>
<li>
<p>Give the table a new name (so that you can give its current name to its editioning view).</p>
<p>Oracle recommends choosing a new name that is related to the original name and reflects the change history. For example, if the original table name is <code dir="ltr">Data</code>, the new table name might be <code dir="ltr">Data_1</code>.</p>
</li>
<li id="BABGCHAC">
<p>(Optional) Give each column of the table a new name.</p>
<p>Again, Oracle recommends choosing new names that are related to the original names and reflect the change history. For example, <code dir="ltr">Name</code> and <code dir="ltr">Number</code> might be changed to <code dir="ltr">Name_1</code> and <code dir="ltr">Number_1</code>.</p>
<p>Any triggers that depend on renamed columns are now invalid. For details, see the entry for <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr"><span class="codeinlineitalic">table</span></code> <code dir="ltr">RENAME</code> <code dir="ltr"><span class="codeinlineitalic">column</span></code> in <a href="adfns_dependencies.htm#g1008856">Table 23-2</a>.</p>
</li>
<li>
<p>Create the editioning view, giving it the original name of the table.</p>
<p>For instructions, see <a href="#CHDHIDGF">Section 24.2.1</a>.</p>
<p>Because the editioning view has the name that the table had, objects that reference that name now reference the editioning view.</p>
</li>
<li>
<p>If triggers are defined on the table, drop them, and rerun the code that created them.</p>
<p>Now the triggers that were defined on the table are defined on the editioning view.</p>
</li>
<li>
<p>If VPD policies are attached to the table, drop the policies and policy functions and rerun the code that created them.</p>
<p>Now the VPD policies that were attached to the table are attached to the editioning view.</p>
</li>
<li id="BABHGIGB">
<p>Revoke all object privileges on the table from all application users.</p>
<p>To see which application users have which object privileges on the table, use this query:</p>
<pre dir="ltr">SELECT GRANTEE, PRIVILEGE
FROM DBA_TAB_PRIVS
WHERE TABLE_NAME=&#39;<span class="italic">table_name</span>&#39;;
</pre></li>
<li id="BABBGFEE">
<p>For every privilege revoked in step&nbsp;<a href="#BABHGIGB">6</a>, grant the same privilege on the editioning view.</p>
</li>
<li id="BABEDGHI">
<p>For each user who owns a private synonym that refers to the table, enable editions, specifying that the type <code dir="ltr">SYNONYM</code> is editionable in the schema (for instructions, see <a href="#g5086786">Section 24.1.1.4</a>).</p>
</li>
<li id="BABCGJIB">
<p>Notify the owners of private synonyms that refer to the table that they must re-create those synonyms.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CHDIGDGF"></a>
<div id="ADFNS99918" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.5.2</span> Procedure for EBR Using Only Editions</h3>
<p>Use this procedure only if every object that you will redefine is editioned (as defined in <a href="#CHDGBJHF">Section 24.1.1</a>). Tables are never editioned objects.</p>
<ol>
<li id="BABIIJJI">
<p>Create a new edition.</p>
<p>For instructions, see <a href="#CHDGIGIF">Section 24.1.2</a>.</p>
</li>
<li>
<p>Make the new edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li id="BABIDGGJ">
<p>Make the necessary changes to the editioned objects of the application.</p>
</li>
<li>
<p>Ensure that all objects are valid.</p>
<p>Query the static data dictionary <code dir="ltr">*_OBJECTS_AE</code>, which describes every actual object in the database, in every edition. If invalid objects remain, recompile them, using any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS380" href="../ARPLS/u_recomp.htm#ARPLS380"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li>
<p>Check that the changes work as intended.</p>
<p>If so, go to step&nbsp;<a href="#BABIABAI">6</a>.</p>
<p>If not, either make further changes (return to step&nbsp;<a href="#BABIDGGJ">3</a>) or roll back the application upgrade (for instructions, see <a href="#BABFDHIG">Section 24.5.5</a>).</p>
</li>
<li id="BABIABAI">
<p>Make the new edition (the upgraded application) available to all users.</p>
<p>For instructions, see <a href="#BABJFDDG">Section 24.1.5</a>.</p>
</li>
<li id="BABFGDFG">
<p>Retire the old edition (the original application), so that all users except <code dir="ltr">SYS</code> use only the upgraded application.</p>
<p>For instructions, see <a href="#CHDEEIBA">Section 24.1.7</a>.</p>
</li>
</ol>
<p><a href="#CHDGEDCC">Example 24-6</a> shows how to use the preceding procedure to change a very simple PL/SQL procedure.</p>
<div id="ADFNS910" class="example">
<p class="titleinexample"><a id="CHDGEDCC"></a>Example 24-6 EBR of Very Simple Procedure</p>
<ol>
<li>
<p>Create PL/SQL procedure for this example:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE hello IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;Hello, edition 1.&#39;);
END hello;
/
</pre></li>
<li>
<p>Invoke PL/SQL procedure:</p>
<pre dir="ltr">BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Hello, edition 1.
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Do EBR of procedure:</p>
<ol>
<li>
<p>Create new edition:</p>
<pre dir="ltr">CREATE EDITION e2 AS CHILD OF ora$base;
</pre>
<p>Result:</p>
<pre dir="ltr">Edition created.
</pre></li>
<li>
<p>Make new edition your session edition:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = e2;
</pre>
<p>Result:</p>
<pre dir="ltr">Session altered.
</pre></li>
<li>
<p>Change procedure:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE hello IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;Hello, edition 2.&#39;);
END hello;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Procedure created.
</pre></li>
<li>
<p>Check that change works as intended:</p>
<pre dir="ltr">BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Hello, edition 2.
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Make new edition available to all users (requires system privileges):</p>
<pre dir="ltr">ALTER DATABASE DEFAULT EDITION = e2;
</pre></li>
<li>
<p>Retire old edition (requires system privileges):</p>
<p>List grantees:</p>
<pre dir="ltr">SELECT GRANTEE, PRIVILEGE
FROM DBA_TAB_PRIVS
WHERE TABLE_NAME = UPPER(&#39;ora$base&#39;)
/
</pre>
<p>Result:</p>
<pre dir="ltr">GRANTEE                        PRIVILEGE
------------------------------ ---------
PUBLIC                         USE
 
1 row selected.
</pre>
<p>Revoke use on old edition from all grantees:</p>
<pre dir="ltr">REVOKE USE ON EDITION ora$base FROM PUBLIC;
</pre></li>
</ol>
</li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDDFEJC"></a>
<div id="ADFNS99914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.5.3</span> Procedure for EBR Using Editioning Views</h3>
<p>Use this procedure only if you will change the structure of one or more tables, and while you are doing so, other users <span class="italic">need not</span> be able to change data in those tables.</p>
<ol>
<li id="BABEDHHJ">
<p>Create a new edition.</p>
<p>For instructions, see <a href="#CHDGIGIF">Section 24.1.2</a>.</p>
</li>
<li>
<p>Make the new edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li>
<p>In the new edition, if the editioning views are read-only, make them read-write.</p>
<p>For instructions, see <a href="#CHDFDBDE">Section 24.2.3</a>.</p>
</li>
<li>
<p>In every edition except the new edition, make the editioning views read-only.</p>
</li>
<li id="BABIFHFC">
<p>Make the necessary changes to the objects of the application.</p>
</li>
<li>
<p>Ensure that all objects are valid.</p>
<p>Query the static data dictionary <code dir="ltr">*_OBJECTS_AE</code>, which describes every actual object in the database, in every edition. If invalid objects remain, recompile them, using any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS380" href="../ARPLS/u_recomp.htm#ARPLS380"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li>
<p>Check that the changes work as intended.</p>
<p>If so, go to step&nbsp;<a href="#BABDECFA">8</a>.</p>
<p>If not, either make further changes (return to step&nbsp;<a href="#BABIFHFC">5</a>) or roll back the application upgrade (for instructions, see <a href="#BABFDHIG">Section 24.5.5</a>).</p>
</li>
<li id="BABDECFA">
<p>Make the upgraded application available to all users.</p>
<p>For instructions, see <a href="#BABJFDDG">Section 24.1.5</a>.</p>
</li>
<li id="BABHFGED">
<p>Retire the old edition (the original application), so that all users except <code dir="ltr">SYS</code> use only the upgraded application.</p>
<p>For instructions, see <a href="#CHDEEIBA">Section 24.1.7</a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABGGADB"></a>
<div id="ADFNS99906" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.5.4</span> Procedure for EBR Using Crossedition Triggers</h3>
<p>Use this procedure only if you will change the structure of one or more tables, and while you are doing so, other users must be able to change data in those tables.</p>
<ol>
<li id="BABEGGDA">
<p>Create a new edition.</p>
<p>For instructions, see <a href="#CHDGIGIF">Section 24.1.2</a>.</p>
</li>
<li id="BABIFJDC">
<p>Make the new edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li id="BABCEBJI">
<p>Make the permanent changes to the objects of the application.</p>
<p>For example, add new columns to the tables and create any new permanent subprograms.</p>
<p>Objects that depend on objects that you changed might now be invalid. For more information, see <a href="adfns_dependencies.htm#g1008856">Table 23-2</a>.</p>
</li>
<li>
<p>Ensure that all objects are valid.</p>
<p>Query the static data dictionary <code dir="ltr">*_OBJECTS_AE</code>, which describes every actual object in the database, in every edition. If invalid objects remain, recompile them, using any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS380" href="../ARPLS/u_recomp.htm#ARPLS380"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li id="BABCHBFB">
<p>Create the temporary objects&mdash;the crossedition triggers (in the disabled state) and any subprograms that they need.</p>
<p>For instructions, see <a href="#CHDBJEFC">Section 24.3.4</a>.</p>
<p>You need reverse crossedition triggers only if you do step <a href="#BABDHEFG">10</a>, which is optional.</p>
</li>
<li id="BABBHAFA">
<p>When the crossedition triggers compile successfully, enable them.</p>
<p>Use the <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement with the <code dir="ltr">ENABLE</code> option. For information about this statement, see <a class="olink LNPLS99996" href="../LNPLS/alter_trigger.htm#LNPLS99996"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Wait until pending changes are either committed or rolled back.</p>
<p>Use the procedure <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">WAIT_ON_PENDING_DML</code>, described in <a class="olink ARPLS73275" href="../ARPLS/d_util.htm#ARPLS73275"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li id="BABDHHED">
<p>Apply the transforms.</p>
<p>For instructions, see <a href="#CHDGAGCH">Section 24.3.5</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is impossible to predict whether this step visits an existing row before a user of an ancestor edition updates, inserts, or deletes data from that row.</div>
</li>
<li id="BABGCFIC">
<p>Check that the changes work as intended.</p>
<p>If so, go to step&nbsp;<a href="#BABDHEFG">10</a>.</p>
<p>If not, either make further changes (return to step&nbsp;<a href="#BABCEBJI">3</a>) or roll back the application upgrade (for instructions, see <a href="#BABFDHIG">Section 24.5.5</a>).</p>
</li>
<li id="BABDHEFG">
<p>(Optional) Grant the <code dir="ltr">USE</code> privilege on your session edition to the early users of the upgraded application.</p>
<p>For instructions, see <a href="#BABJFDCH">Section 24.1.4</a>.</p>
</li>
<li id="BABECJBE">
<p>Make the upgraded application available to all users.</p>
<p>For instructions, see <a href="#BABJFDDG">Section 24.1.5</a>.</p>
</li>
<li id="BABFFFAG">
<p>Disable or drop the constraints and then drop the crossedition triggers.</p>
<p>For instructions, see <a href="#BABGHBBF">Section 24.3.6</a>.</p>
</li>
<li id="BABIIIHE">
<p>Retire the old edition (the original application), so that all users except <code dir="ltr">SYS</code> use only the upgraded application.</p>
<p>For instructions, see <a href="#CHDEEIBA">Section 24.1.7</a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABFDHIG"></a>
<div id="ADFNS1313" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.5.5</span> Rolling Back the Application Upgrade</h3>
<p>To roll back the application upgrade:</p>
<ol>
<li>
<p>Change your session edition to something other than the new edition that you created for the upgrade.</p>
<p>For instructions, see <a href="#CHDBFJGF">Section 24.1.6.2</a>.</p>
</li>
<li>
<p>Drop the new edition that you created for the upgrade.</p>
<p>For instructions, see <a href="#CHDJCDCA">Section 24.1.8</a>.</p>
</li>
<li>
<p>If you created new table columns during the upgrade, reclaim the space that they occupy (for instructions, see <a href="#BABFIAEF">Section 24.5.6</a>).</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABFIAEF"></a>
<div id="ADFNS1314" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">24.5.6</span> Reclaiming Space Occupied by Unused Table Columns</h3>
<p>If you roll back an upgrade for which you created new table columns,</p>
<p>To reclaim the space that unused columns occupy:</p>
<ol>
<li>
<p>Set the values of the unused columns to <code dir="ltr">NULL</code>.</p>
<p>To avoid locking out other users while doing this operation, use the <code dir="ltr">DBMS_PARALLEL_EXECUTE</code> procedure (described in <a class="olink ARPLS233" href="../ARPLS/d_parallel_ex.htm#ARPLS233"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li>
<p>Set the unused columns to <code dir="ltr">UNUSED</code>.</p>
<p>Use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement (described in <a class="olink SQLRF01001" href="../SQLRF/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a>) with the <code dir="ltr">SET</code> <code dir="ltr">UNUSED</code> clause (described in <a class="olink SQLRF53205" href="../SQLRF/statements_3001.htm#SQLRF53205"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
</li>
<li>
<p>Shrink the table.</p>
<p>Use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement (described in <a class="olink SQLRF01001" href="../SQLRF/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a>) with the <code dir="ltr">SHRINK</code> <code dir="ltr">SPACE</code> clause (described in <a class="olink SQLRF53181" href="../SQLRF/statements_3001.htm#SQLRF53181"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABFFEDD"></a>
<div id="ADFNS99913" class="sect2">
<h3 class="sect2"><span class="secnum">24.5.7</span> Example: Using EBR to Upgrade an Application</h3>
<p>This example uses an edition, an editioning view, a forward crossedition trigger, and a reverse crossedition trigger.</p>
<p class="subhead2"><a id="ADFNS1315"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABCHJHF">Existing Application</a></p>
</li>
<li>
<p><a href="#BABGFBHF">Preparing the Application to Use Editioning Views</a></p>
</li>
<li>
<p><a href="#BABFGCBC">Using EBR to Upgrade the Application</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before you can use EBR to upgrade an application, you must enable editions for every schema that the application uses. For instructions, see <a href="#g5086786">Section 24.1.1.4</a>.</div>
<a id="BABCHJHF"></a>
<div id="ADFNS934" class="sect3">
<h4 class="sect3"><span class="secnum">24.5.7.1</span> Existing Application</h4>
<p>The existing application&mdash;the application to be upgraded&mdash;consists of a single table on which a trigger is defined. The application was created as in <a href="#BABEDAGA">Example 24-7</a>.</p>
<div id="ADFNS935" class="example">
<p class="titleinexample"><a id="BABEDAGA"></a>Example 24-7 Creating the Existing Application</p>
<ol>
<li>
<p>Create table:</p>
<pre dir="ltr">CREATE TABLE Contacts(
  ID            NUMBER(6,0) CONSTRAINT Contacts_PK PRIMARY KEY,
  Name          VARCHAR2(47),
  Phone_Number  VARCHAR2(20)
);
</pre></li>
<li>
<p>Populate table (not shown).</p>
</li>
<li>
<p>Prepare to create trigger on table:</p>
<pre dir="ltr">ALTER TABLE Contacts ENABLE VALIDATE CONSTRAINT Contacts_PK;
 
DECLARE Max_ID INTEGER;
BEGIN
  SELECT MAX(ID) INTO Max_ID FROM Contacts;
  EXECUTE IMMEDIATE &#39;
    CREATE SEQUENCE Contacts_Seq
      START WITH &#39;||To_Char(Max_ID + 1);
END;
/
</pre></li>
<li>
<p>Create trigger:</p>
<pre dir="ltr">CREATE TRIGGER Contacts_BI
  BEFORE INSERT ON Contacts FOR EACH ROW
BEGIN
  :NEW.ID := Contacts_Seq.NEXTVAL;
END;
/
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p><a href="#BABJEBDB">Example 24-8</a> shows how the table <code dir="ltr">Contacts</code> looks after being populated with data.</p>
<div id="ADFNS936" class="example">
<p class="titleinexample"><a id="BABJEBDB"></a>Example 24-8 Viewing Data in Existing Table</p>
<p>Query:</p>
<pre dir="ltr">SELECT * FROM Contacts
ORDER BY Name;
 
</pre>
<p>Result:</p>
<pre dir="ltr">        ID NAME                                            PHONE_NUMBER
---------- ----------------------------------------------- --------------------
       174 Abel, Ellen                                     011.44.1644.429267
       166 Ande, Sundar                                    011.44.1346.629268
       130 Atkinson, Mozhe                                 650.124.6234
       105 Austin, David                                   590.423.4569
       204 Baer, Hermann                                   515.123.8888
       116 Baida, Shelli                                   515.127.4563
       167 Banda, Amit                                     011.44.1346.729268
       172 Bates, Elizabeth                                011.44.1343.529268
       192 Bell, Sarah                                     650.501.1876
       151 Bernstein, David                                011.44.1344.345268
       129 Bissot, Laura                                   650.124.5234
       169 Bloom, Harrison                                 011.44.1343.829268
       185 Bull, Alexis                                    650.509.2876
       187 Cabrio, Anthony                                 650.509.4876
       148 Cambrault, Gerald                               011.44.1344.619268
       154 Cambrault, Nanette                              011.44.1344.987668
       110 Chen, John                                      515.124.4269
       ...
       120 Weiss, Matthew                                  650.123.1234
       200 Whalen, Jennifer                                515.123.4444
       149 Zlotkey, Eleni                                  011.44.1344.429018

107 rows selected.
</pre></div>
<!-- class="example" -->
<p>Suppose that you must redefine <code dir="ltr">Contacts</code>, replacing the <code dir="ltr">Name</code> column with the columns <code dir="ltr">First_Name</code> and <code dir="ltr">Last_Name</code>, and adding the column <code dir="ltr">Country_Code</code>. Also suppose that while you are making this structural change, other users must be able to change the data in <code dir="ltr">Contacts</code>.</p>
<p>You need all features of EBR: the edition, which is always needed; the editioning view, because you are redefining a table; and crossedition triggers, because other users must be able to change data in the table while you are redefining it.</p>
</div>
<!-- class="sect3" -->
<a id="BABGFBHF"></a>
<div id="ADFNS937" class="sect3">
<h4 class="sect3"><span class="secnum">24.5.7.2</span> Preparing the Application to Use Editioning Views</h4>
<p><a href="#BABJFGJD">Example 24-9</a> shows how to create the editioning view from which other users will access the table <code dir="ltr">Contacts</code> while you are redefining it in the new edition.</p>
<div id="ADFNS938" class="example">
<p class="titleinexample"><a id="BABJFGJD"></a>Example 24-9 Creating an Editioning View for the Existing Table</p>
<ol>
<li>
<p>Give table a new name (so that you can give its current name to editioning view):</p>
<pre dir="ltr">ALTER TABLE Contacts RENAME TO Contacts_Table;
</pre></li>
<li>
<p>(Optional) Give columns of table new names:</p>
<pre dir="ltr">ALTER TABLE Contacts_Table
  RENAME COLUMN Name TO Name_1;

ALTER TABLE Contacts_Table
  RENAME COLUMN Phone_Number TO Phone_Number_1;
</pre></li>
<li>
<p>Create editioning view:</p>
<pre dir="ltr">CREATE OR REPLACE EDITIONING VIEW Contacts AS
  SELECT
    ID                 ID,
    Name_1             Name,
    Phone_Number_1     Phone_Number
  FROM Contacts_Table;
</pre></li>
<li id="BABHBBHF">
<p>Move trigger <code dir="ltr">Contacts_BI</code> from table to editioning view:</p>
<pre dir="ltr">DROP TRIGGER Contacts_BI;
 
CREATE TRIGGER Contacts_BI
  BEFORE INSERT ON Contacts FOR EACH ROW
BEGIN
  :NEW.ID := Contacts_Seq.NEXTVAL;
END;
/
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABFGCBC"></a>
<div id="ADFNS939" class="sect3">
<h4 class="sect3"><span class="secnum">24.5.7.3</span> Using EBR to Upgrade the Application</h4>
<p><a href="#BABBAEFA">Example 24-10</a> shows how to create an edition in which to upgrade the existing application (in <a href="#BABCHJHF">Section 24.5.7.1</a>), make the new edition the session edition, and check that the new edition really is the session edition.</p>
<div id="ADFNS940" class="example">
<p class="titleinexample"><a id="BABBAEFA"></a>Example 24-10 Creating Edition in Which to Upgrade the Application</p>
<ol>
<li>
<p>Create new edition:</p>
<pre dir="ltr">CREATE EDITION Post_Upgrade AS CHILD OF Ora$Base;
</pre></li>
<li>
<p>Make new edition your session edition:</p>
<pre dir="ltr">ALTER SESSION SET EDITION = Post_Upgrade;
</pre></li>
<li>
<p>Check session edition:</p>
<pre dir="ltr">SELECT
SYS_CONTEXT(&#39;Userenv&#39;, &#39;Current_Edition_Name&#39;) &#34;Current_Edition&#34;
FROM DUAL;
</pre>
<p>Result:</p>
<pre dir="ltr">Current_Edition
-----------------------------------------------------------------------------
POST_UPGRADE
 
1 row selected.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABBJGBJ">Example 24-11</a> shows how to add the new columns to the physical table and recompile the trigger that was invalidated by adding the columns. Then, it shows how to replace the editioning view <code dir="ltr">Contacts</code> so that it selects the columns of the table by their desired logical names.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because you will change the base table, see <a href="adfns_sqlproc.htm#BEJECCJJ">&#34;Nonblocking and Blocking DDL Statements.&#34;</a></div>
<div id="ADFNS941" class="example">
<p class="titleinexample"><a id="BABBJGBJ"></a>Example 24-11 Changing the Table and Replacing the Editioning View</p>
<ol>
<li>
<p>Add new columns to physical table:</p>
<pre dir="ltr">ALTER TABLE Contacts_Table ADD (
  First_Name_2     varchar2(20),
  Last_Name_2      varchar2(25),
  Country_Code_2   varchar2(20),
  Phone_Number_2   varchar2(20)
);
</pre>
<p>(This is nonblocking DDL.)</p>
</li>
<li>
<p>Recompile invalidated trigger:</p>
<pre dir="ltr">ALTER TRIGGER Contacts_BI COMPILE REUSE SETTINGS;
</pre></li>
<li>
<p>Replace editioning view so that it selects replacement columns with their desired logical names:</p>
<pre dir="ltr">CREATE OR REPLACE EDITIONING VIEW Contacts AS
  SELECT
    ID                 ID,
    First_Name_2       First_Name,
    Last_Name_2        Last_Name,
    Country_Code_2     Country_Code,
    Phone_Number_2     Phone_Number
  FROM Contacts_Table;
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABEGFDD">Example 24-12</a> shows how to create two procedures for the forward crossedition trigger to use, create both the forward and reverse crossedition triggers in the disabled state, and enable them.</p>
<div id="ADFNS942" class="example">
<p class="titleinexample"><a id="BABEGFDD"></a>Example 24-12 Creating and Enabling the Crossedition Triggers</p>
<ol>
<li>
<p>Create first procedure that forward crossedition trigger uses:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE Set_First_And_Last_Name (
  Name        IN  VARCHAR2,
  First_Name  OUT VARCHAR2,
  Last_Name   OUT VARCHAR2)
IS
  Comma_Pos NUMBER := INSTR(Name, &#39;,&#39;);
BEGIN
  IF Comma_Pos IS NULL OR Comma_Pos &lt; 2 THEN
    RAISE Program_Error;
  END IF;
 
  Last_Name := SUBSTR(Name, 1, Comma_Pos-1);
  Last_Name := RTRIM(Ltrim(Last_Name));
 
  First_Name := SUBSTR(Name, Comma_Pos+1);
  First_Name := RTRIM(LTRIM(First_Name));
END Set_First_And_Last_Name;
/
</pre></li>
<li>
<p>Create second procedure that forward crossedition trigger uses:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE Set_Country_Code_And_Phone_No (
  Phone_Number     IN  VARCHAR2,
  Country_Code     OUT VARCHAR2,
  Phone_Number_V2  OUT VARCHAR2)
IS
  Char_To_Number_Error EXCEPTION;
  PRAGMA EXCEPTION_INIT(Char_To_Number_Error, -06502);
  Bad_Phone_Number EXCEPTION;
  Nmbr VARCHAR2(30) := REPLACE(Phone_Number, &#39;.&#39;, &#39;-&#39;);
 
  FUNCTION Is_US_Number(Nmbr IN VARCHAR2)
    RETURN BOOLEAN
  IS
    Len NUMBER := LENGTH(Nmbr);
    Dash_Pos NUMBER := INSTR(Nmbr, &#39;-&#39;);
    n PLS_INTEGER;
  BEGIN
    IF Len IS NULL OR Len &lt;&gt; 12 THEN
      RETURN FALSE;
    END IF;
    IF Dash_Pos IS NULL OR Dash_Pos &lt;&gt; 4 THEN
      RETURN FALSE;
    END IF;
    BEGIN
      n := TO_NUMBER(SUBSTR(Nmbr, 1, 3));
    EXCEPTION WHEN Char_To_Number_Error THEN
      RETURN FALSE;
    END;
 
    Dash_Pos := INSTR(Nmbr, &#39;-&#39;, 5);
 
    IF Dash_Pos IS NULL OR Dash_Pos &lt;&gt; 8 THEN
      RETURN FALSE;
    END IF;
 
    BEGIN
      n := TO_NUMBER(SUBSTR(Nmbr, 5, 3));
    EXCEPTION WHEN Char_To_Number_Error THEN
      RETURN FALSE;
    END;
 
    BEGIN
      n := TO_NUMBER(SUBSTR(Nmbr, 9));
    EXCEPTION WHEN Char_To_Number_Error THEN
      RETURN FALSE;
    END;
 
    RETURN TRUE;
  END Is_US_Number;
 
BEGIN
  IF Nmbr LIKE &#39;011-%&#39; THEN
    DECLARE
      Dash_Pos NUMBER := INSTR(Nmbr, &#39;-&#39;, 5);
    BEGIN
      Country_Code := &#39;+&#39;|| TO_NUMBER(SUBSTR(Nmbr, 5, Dash_Pos-5));
      Phone_Number_V2 := SUBSTR(Nmbr, Dash_Pos+1);
    EXCEPTION WHEN Char_To_Number_Error THEN
      raise Bad_Phone_Number;
    END;
  ELSIF Is_US_Number(Nmbr) THEN
    Country_Code := &#39;+1&#39;;
    Phone_Number_V2 := Nmbr;
  ELSE
    RAISE Bad_Phone_Number;
  END IF;
EXCEPTION WHEN Bad_Phone_Number THEN
  Country_Code := &#39;+0&#39;;
  Phone_Number_V2 := &#39;000-000-0000&#39;;
END Set_Country_Code_And_Phone_No;
/
</pre></li>
<li>
<p>Create forward crossedition trigger in disabled state:</p>
<pre dir="ltr">CREATE OR REPLACE TRIGGER Contacts_Fwd_Xed
  BEFORE INSERT OR UPDATE ON Contacts_Table
  FOR EACH ROW
  <span class="bold">FORWARD CROSSEDITION</span>
  <span class="bold">DISABLE</span>
BEGIN
  Set_First_And_Last_Name(
    :NEW.Name_1,
    :NEW.First_Name_2,
    :NEW.Last_Name_2
  );
  Set_Country_Code_And_Phone_No(
    :NEW.Phone_Number_1,
    :NEW.Country_Code_2,
    :NEW.Phone_Number_2
  );
END Contacts_Fwd_Xed;
/
</pre></li>
<li>
<p>Enable forward crossedition trigger:</p>
<pre dir="ltr">ALTER TRIGGER Contacts_Fwd_Xed <span class="bold">ENABLE</span>;
</pre></li>
<li>
<p>Create reverse crossedition trigger in disabled state:</p>
<pre dir="ltr">CREATE OR REPLACE TRIGGER Contacts_Rvrs_Xed
  BEFORE INSERT OR UPDATE ON Contacts_Table
  FOR EACH ROW
  <span class="bold">REVERSE CROSSEDITION</span>
  <span class="bold">DISABLE</span>
BEGIN
  :NEW.Name_1 := :NEW.Last_Name_2||&#39;, &#39;||:NEW.First_Name_2;
  :NEW.Phone_Number_1 :=
  CASE :New.Country_Code_2
    WHEN &#39;+1&#39; THEN
      REPLACE(:NEW.Phone_Number_2, &#39;-&#39;, &#39;.&#39;)
    ELSE
      &#39;011.&#39;||LTRIM(:NEW.Country_Code_2, &#39;+&#39;)||&#39;.&#39;||
      REPLACE(:NEW.Phone_Number_2, &#39;-&#39;, &#39;.&#39;)
  END;
END Contacts_Rvrs_Xed;
/
</pre></li>
<li>
<p>Enable reverse crossedition trigger:</p>
<pre dir="ltr">ALTER TRIGGER Contacts_Rvrs_Xed <span class="bold">ENABLE</span>;
</pre></li>
<li>
<p>Wait until pending changes are either committed or rolled back:</p>
<pre dir="ltr">DECLARE
  scn              NUMBER  := NULL;
  timeout CONSTANT INTEGER := NULL;
BEGIN
  IF NOT DBMS_UTILITY.WAIT_ON_PENDING_DML(Tables  =&gt; &#39;Contacts_Table&#39;,
                                          timeout =&gt; timeout,
                                          scn     =&gt; scn)
  THEN
    RAISE_APPLICATION_ERROR(-20000,
     &#39;Wait_On_Pending_DML() timed out. CETs were enabled before SCN: &#39;||SCN);
  END IF;
END;
/
</pre>
<p>For information about the <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">WAIT_ON_PENDING_DML</code> procedure, see <a class="olink ARPLS73275" href="../ARPLS/d_util.htm#ARPLS73275"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ol>
</div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABHAFBD">Example 24-13</a> shows how to apply the transforms.</p>
<div id="ADFNS943" class="example">
<p class="titleinexample"><a id="BABHAFBD"></a>Example 24-13 Applying the Transforms</p>
<pre dir="ltr">DECLARE
  c NUMBER := DBMS_SQL.OPEN_CURSOR();
  x NUMBER;
BEGIN
  DBMS_SQL.PARSE(
    c                          =&gt; c,
    Language_Flag              =&gt; DBMS_SQL.NATIVE,
    Statement                  =&gt; &#39;UPDATE Contacts_Table SET ID = ID&#39;,
    Apply_Crossedition_Trigger =&gt; &#39;Contacts_Fwd_Xed&#39;
  );
  x := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
  COMMIT;
END;
/
 
</pre></div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABHACHI">Example 24-14</a> shows how to check that the change worked as intended. Compare <a href="#BABHACHI">Example 24-14</a> to <a href="#BABJEBDB">Example 24-8</a>.</p>
<div id="ADFNS944" class="example">
<p class="titleinexample"><a id="BABHACHI"></a>Example 24-14 Viewing Data in Changed Table</p>
<ol>
<li>
<p>Format columns for readability:</p>
<pre dir="ltr">COLUMN ID FORMAT 999
COLUMN Last_Name FORMAT A15
COLUMN First_Name FORMAT A15
COLUMN Country_Code FORMAT A12
COLUMN Phone_Number FORMAT A12
</pre></li>
<li>
<p>Query:</p>
<pre dir="ltr">SELECT * FROM Contacts
ORDER BY Last_Name;
</pre>
<p>Result:</p>
<pre dir="ltr">  ID FIRST_NAME      LAST_NAME       COUNTRY_CODE PHONE_NUMBER
---- --------------- --------------- ------------ ------------
 174 Ellen           Abel            +44          1644-429267
 166 Sundar          Ande            +44          1346-629268
 130 Mozhe           Atkinson        +1           650-124-6234
 105 David           Austin          +1           590-423-4569
 204 Hermann         Baer            +1           515-123-8888
 116 Shelli          Baida           +1           515-127-4563
 167 Amit            Banda           +44          1346-729268
 172 Elizabeth       Bates           +44          1343-529268
 192 Sarah           Bell            +1           650-501-1876
 151 David           Bernstein       +44          1344-345268
 129 Laura           Bissot          +1           650-124-5234
 169 Harrison        Bloom           +44          1343-829268
 185 Alexis          Bull            +1           650-509-2876
 187 Anthony         Cabrio          +1           650-509-4876
 154 Nanette         Cambrault       +44          1344-987668
 148 Gerald          Cambrault       +44          1344-619268
 110 John            Chen            +1           515-124-4269
       ...
 120 Matthew         Weiss           +1           650-123-1234
 200 Jennifer        Whalen          +1           515-123-4444
 149 Eleni           Zlotkey         +44          1344-429018
 
107 rows selected.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>If the change worked as intended, you can now follow steps <a href="#BABDHEFG">10</a> through <a href="#BABIIIHE">13</a> of the procedure in <a href="#BABGGADB">Section 24.5.4</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment286">
<tr>
<td class="cellalignment295">
<table class="cellalignment291">
<tr>
<td class="cellalignment290"><a href="adfns_dependencies.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment290"><a href="adfns_trans_idemp_guard.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment298">
<table class="cellalignment289">
<tr>
<td class="cellalignment290"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment290"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment290"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment290"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment290"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment290"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>