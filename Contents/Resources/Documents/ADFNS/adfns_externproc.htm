<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-69"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Developing%20Applications%20with%20Multiple%20Programming%20Languages"></a><title>Developing Applications with Multiple Programming Languages</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1080"/>
<meta name="dcterms.created" content="2016-05-05T16:23:35Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Development Guide"/>
<meta name="dcterms.identifier" content="E41452-07"/>
<meta name="dcterms.isVersionOf" content="ADFNS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="adfns_environments.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adfns_xa.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41452-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">29/38</span> <!-- End Header -->
<script>
<!-- // <![CDATA[
window.name='adfns_externproc'
// ]]> -->
</script> <script>
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="ADFNS010" class="chapter"><a id="g1040439"></a> <a id="i1018255"></a>
<h1 class="chapter"><span class="secnum">18</span> Developing Applications with Multiple Programming Languages</h1>
<p>This chapter explains how you can develop database applications that call external procedures written in other programming languages.</p>
<p class="subhead2"><a id="ADFNS1089"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1006233">Overview of Multilanguage Programs</a></p>
</li>
<li>
<p><a href="#i1019726">What Is an External Procedure?</a></p>
</li>
<li>
<p><a href="#BEJFBFIE">Overview of Call Specification for External Procedures</a></p>
</li>
<li>
<p><a href="#i1006311">Loading External Procedures</a></p>
</li>
<li>
<p><a href="#i1006405">Publishing External Procedures</a></p>
</li>
<li>
<p><a href="#i1006482">Publishing Java Class Methods</a></p>
</li>
<li>
<p><a href="#i1006510">Publishing External C Procedures</a></p>
</li>
<li>
<p><a href="#i1006521">Locations of Call Specifications</a></p>
</li>
<li>
<p><a href="#i1006699">Passing Parameters to External C Procedures with Call Specifications</a></p>
</li>
<li>
<p><a href="#i1007572">Running External Procedures with CALL Statements</a></p>
</li>
<li>
<p><a href="#i1007710">Handling Errors and Exceptions in Multilanguage Programs</a></p>
</li>
<li>
<p><a href="#i1007728">Using Service Routines with External C Procedures</a></p>
</li>
<li>
<p><a href="#i1008070">Doing Callbacks with External C Procedures</a></p>
</li>
</ul>
<a id="i1006233"></a>
<div id="ADFNS1401" class="sect1">
<h2 class="sect1"><span class="secnum">18.1</span> Overview of Multilanguage Programs</h2>
<p><a id="sthref906"></a>Oracle Database lets you work in different languages:</p>
<ul>
<li>
<p>PL/SQL, as described in the <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
<li>
<p>C, through the Oracle Call Interface (OCI), as described in the <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a></p>
</li>
<li>
<p>C++, through the Oracle C++ Call Interface (OCCI), as described in the <a class="olink LNCPP" href="../LNCPP/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer&#39;s Guide</span></a></p>
</li>
<li>
<p>C or C++, through the Pro*C/C++ precompiler, as described in the <a class="olink LNPCC" href="../LNPCC/toc.htm"><span class="italic">Pro*C/C++ Programmer&#39;s Guide</span></a></p>
</li>
<li>
<p>COBOL, through the Pro*COBOL precompiler, as described in the <a class="olink LNPCB" href="../LNPCB/toc.htm"><span class="italic">Pro*COBOL Programmer&#39;s Guide</span></a></p>
</li>
<li>
<p>Visual Basic, through Oracle Provider for OLE DB, as described in <a class="olink OLEDB003" href="../OLEDB/using.htm#OLEDB003"><span class="italic">Oracle Provider for OLE DB Developer&#39;s Guide for Microsoft Windows</span></a>.</p>
</li>
<li>
<p>.NET , through Oracle Data Provider for .NET, as described in <a class="olink ODPNT" href="../ODPNT/toc.htm"><span class="italic">Oracle Data Provider for .NET Developer&#39;s Guide for Microsoft Windows</span></a></p>
</li>
<li>
<p>Java, through the JDBC and SQLJ client-side application programming interfaces (APIs). See <a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> and <a class="olink JSQLJ" href="../JSQLJ/toc.htm"><span class="italic">Oracle Database SQLJ Developer&#39;s Guide</span></a>.</p>
</li>
<li>
<p>Java in the database, as described in <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a>. This includes the use of Java stored procedures (Java methods published to SQL and stored in the database), as described in a chapter in <a class="olink JJDEV13234" href="../JJDEV/chfive.htm#JJDEV13234"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a>.</p>
<p>The JPublisher utility is also available for generating Java classes to represent database entities, such as SQL objects and PL/SQL packages, in a Java client program; publishing from SQL, PL/SQL, and server-side Java to web services; and enabling the invocation of external web services from inside the database. See <a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a>.</p>
</li>
</ul>
<p>How can you choose between these different implementation possibilities? Each of these languages offers different advantages: ease of use, the availability of programmers with specific expertise, the need for portability, and the existence of legacy code are powerful determinants.</p>
<p>The choice might narrow depending on how your application must work with Oracle Database:</p>
<ul>
<li>
<p>PL/SQL is a powerful development tool, specialized for SQL transaction processing.</p>
</li>
<li>
<p>Some computation-intensive tasks are executed most efficiently in a lower level language, such as C.</p>
</li>
<li>
<p>For both portability and security, you might select Java.</p>
</li>
<li>
<p>For familiarity with Microsoft programming languages, you might select .NET.</p>
</li>
</ul>
<p>Most significantly for performance, only PL/SQL and Java methods run within the address space of the server. C/C++ and .NET methods are dispatched as external procedures, and run on the server system but outside the address space of the database server. Pro*COBOL and Pro*C/C++ are precompilers, and Visual Basic accesses Oracle Database through Oracle Provider for OLE DB and subsequently OCI, which is implemented in C.</p>
<p>Taking all these factors into account suggests that there might be situations in which you might need to implement your application in multiple languages. For example, because Java runs within the address space of the server, you might want to import existing Java applications into the database, and then leverage this technology by calling Java functions from PL/SQL and SQL.</p>
<p>PL/SQL external procedures enable you to write C procedure calls as PL/SQL bodies. These C procedures are callable directly from PL/SQL, and from SQL through PL/SQL procedure calls. The database provides a special-purpose interface, the call specification, that lets you call external procedures from other languages. While this service is designed for intercommunication between SQL, PL/SQL, C, and Java, it is accessible from any base language that can call these languages. For example, your procedure can be written in a language other than Java or C, and if C can call your procedure, then SQL or PL/SQL can use it. Therefore, if you have a candidate C++ procedure, use a C++ <code>extern</code> <code dir="ltr">&#34;C&#34;</code> statement in that procedure to make it callable by C.</p>
<p>Therefore, the strengths and capabilities of different languages are available to you, regardless of your programmatic environment. You are not restricted to one language with its inherent limitations. External procedures promote reusability and modularity because you can deploy specific languages for specific purposes.</p>
</div>
<!-- class="sect1" -->
<a id="i1019726"></a>
<div id="ADFNS1402" class="sect1">
<h2 class="sect1"><span class="secnum">18.2</span> What Is an External Procedure?</h2>
<p>An <span class="glossaryterm"><a id="sthref907"></a>external procedure</span> is a procedure stored in a <a id="sthref908"></a><a id="sthref909"></a>dynamic link library (DLL). You register the procedure with the base language, and then call it to perform special-purpose processing.</p>
<p>For example, when you work in PL/SQL, the language loads the library dynamically at runtime, and then calls the procedure as if it were a PL/SQL procedure. These procedures participate fully in the current transaction and can call back to the database to perform SQL operations.</p>
<p>The procedures are loaded only when necessary, so memory is conserved. The decoupling of the call specification from its implementation body means that the procedures can be enhanced without affecting the calling programs.</p>
<p>External procedures let you:</p>
<ul>
<li>
<p>Isolate execution of client applications and processes from the database instance to ensure that problems on the client side do not adversely affect the database</p>
</li>
<li>
<p>Move computation-bound programs from client to server where they run faster (because they avoid the round trips of network communication)</p>
</li>
<li>
<p>Interface the database server with external systems and data sources</p>
</li>
<li>
<p>Extend the functionality of the database server itself</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The external library (DLL file) must be statically linked. In other words, it must not reference external symbols from other external libraries (DLL files). Oracle Database does not resolve such symbols, so they can cause your external procedure to fail.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DBSEG656" href="../DBSEG/app_devs.htm#DBSEG656"><span class="italic">Oracle Database Security Guide</span></a> for information about securing external procedures</div>
</div>
<!-- class="sect1" -->
<a id="BEJFBFIE"></a>
<div id="ADFNS1403" class="sect1">
<h2 class="sect1"><span class="secnum">18.3</span> Overview of Call Specification for External Procedures</h2>
<p><a id="sthref910"></a><a id="sthref911"></a>You publish external procedures through <span class="bold">call specifications</span>, which provide a superset of the <code dir="ltr">AS</code> <code dir="ltr">EXTERNAL</code> function through the <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> clause. <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> call specifications allow the publishing of external C procedures. (Java class methods are not external procedures, but they still use call specifications.)</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
To support legacy applications, call specifications also enable you to publish with the <code dir="ltr">AS</code> <code dir="ltr">EXTERNAL</code> clause. For application development, however, using the <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> clause is recommended.</div>
<p>In general, call specifications enable:</p>
<ul>
<li>
<p>Dispatching the appropriate C or Java target procedure</p>
</li>
<li>
<p>Data type conversions</p>
</li>
<li>
<p>Parameter mode mappings</p>
</li>
<li>
<p>Automatic memory allocation and cleanup</p>
</li>
<li>
<p>Purity constraints to be specified, where necessary, for package functions called from SQL.</p>
</li>
<li>
<p>Calling Java methods or C procedures from database triggers</p>
</li>
<li>
<p>Location flexibility: you can put <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> call specifications in package or type specifications, or package (or type) bodies to optimize performance and hide implementation details</p>
</li>
</ul>
<p>To use an existing program as an external procedure, load, publish, and then call it.</p>
</div>
<!-- class="sect1" -->
<a id="i1006311"></a>
<div id="ADFNS1404" class="sect1">
<h2 class="sect1"><span class="secnum">18.4</span> Loading External Procedures</h2>
<p><a id="sthref912"></a>To make your external C procedures or Java methods available to PL/SQL, you must first load them.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can load external C procedures only on platforms that support either DLLs or dynamically loadable shared libraries (such as Solaris .<code dir="ltr">so</code> libraries).</div>
<p><a id="sthref913"></a>When an application calls an external C procedure, Oracle Database or Oracle Listener starts the external procedure agent, <code dir="ltr">extproc</code>. Using the network connection established by Oracle Database or Oracle Listener, the application passes this information to <code dir="ltr">extproc</code>:</p>
<ul>
<li>
<p>Name of DLL or shared library</p>
</li>
<li>
<p>Name of external procedure</p>
</li>
<li>
<p>Any parameters for the external procedure</p>
</li>
</ul>
<p>Then <code dir="ltr">extproc</code> loads the DLL or the shared library, runs the external procedure, and passes any values that the external procedure returns back to the application. The application and <code dir="ltr">extproc</code> must reside on the same computer.</p>
<p><code dir="ltr">extproc</code> can call procedures in any library that complies with the calling standard used. For more information about the calling standard, see <a href="#i1019187">Section 18.5.2.4, &#34;CALLING STANDARD.&#34;</a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The default configuration for external procedures no longer requires a network listener to work with Oracle Database and <code dir="ltr">extproc</code>. Oracle Database now spawns <code dir="ltr">extproc</code> directly, eliminating the risk that Oracle Listener might spawn <code dir="ltr">extproc</code> unexpectedly. This default configuration is recommended for maximum security.
<p>You must change this default configuration, so that Oracle Listener spawns <code dir="ltr">extproc</code>, if you use any of these:</p>
<ul>
<li>
<p>A multithreaded <code dir="ltr">extproc</code> agent</p>
</li>
<li>
<p>Oracle Database in shared mode on Windows</p>
</li>
<li>
<p>An <code dir="ltr">AGENT</code> clause in the <code dir="ltr">LIBRARY</code> specification or an <code dir="ltr">AGENT</code> <code dir="ltr">IN</code> clause in the <code dir="ltr">PROCEDURE</code> specification that redirects external procedures to a different <code dir="ltr">extproc</code> agent</p>
</li>
</ul>
<p>Changing the default configuration requires additional network configuration steps.</p>
</div>
<p>To configure your database to use external procedures that are written in C, or that can be called from C applications, you or your database administrator must follow these steps:</p>
<ol>
<li>
<p><a href="#CIHJIJEJ">Define the C Procedures</a></p>
</li>
<li>
<p><a href="#CIHHAJJJ">Set Up the Environment</a></p>
</li>
<li>
<p><a href="#CIHHEIDC">Identify the DLL</a></p>
</li>
<li>
<p><a href="#CIHJBJBB">Publish the External Procedures</a></p>
</li>
</ol>
<a id="CIHJIJEJ"></a>
<div id="ADFNS702" class="sect2">
<h3 class="sect2"><span class="secnum">18.4.1</span> Define the C Procedures</h3>
<p>Define the C procedures using one of these prototypes:</p>
<ul>
<li>
<p>Kernighan &amp; Ritchie style prototypes; for example:</p>
<pre dir="ltr">void C_findRoot(x)
 float x;
...
</pre></li>
<li>
<p>ISO/ANSI prototypes other than numeric data types that are less than full width (such as <code dir="ltr">float</code>, <code dir="ltr">short</code>, <code dir="ltr">char</code>); for example:</p>
<pre dir="ltr">void C_findRoot(double x)
...
</pre></li>
<li>
<p>Other data types that do not change size under default argument promotions.</p>
<p>This example changes size under default argument promotions:</p>
<pre dir="ltr">void C_findRoot(float x)
...
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHHAJJJ"></a>
<div id="ADFNS703" class="sect2">
<h3 class="sect2"><span class="secnum">18.4.2</span> Set Up the Environment</h3>
<p>When you use the default configuration for external procedures, Oracle Database spawns <code dir="ltr">extproc</code> directly. You need not make configuration changes for <code dir="ltr">listener</code>.<code dir="ltr">ora</code> and <code dir="ltr">tnsnames</code>.<code dir="ltr">ora</code>. Define the environment variables to be used by external procedures in the file <code dir="ltr">extproc</code>.<code dir="ltr">ora</code> (located at <code dir="ltr">$ORACLE_HOME/hs/admin</code> on UNIX operating systems and at <code dir="ltr">ORACLE_HOME\hs\admin</code> on Windows), using this syntax:</p>
<pre dir="ltr">SET <span class="italic">name</span>=<span class="italic">value</span> (<span class="italic">environment_variable_name</span> <span class="italic">value</span>)
</pre>
<p>Set the <code dir="ltr">EXTPROC_DLLS</code> environment variable, which restricts the DLLs that <code dir="ltr">extproc</code> can load, to one of these values:</p>
<ul>
<li>
<p><code dir="ltr">NULL</code>; for example:</p>
<pre dir="ltr">SET EXTPROC_DLLS=
</pre>
<p>This setting, the default, allows <code dir="ltr">extproc</code> to load only the DLLs that are in directory <code dir="ltr">$ORACLE_HOME</code>/<code dir="ltr">bin</code> or <code dir="ltr">$ORACLE_HOME</code>/<code dir="ltr">lib</code>.</p>
</li>
<li>
<p><code dir="ltr">ONLY:</code> followed by a colon-separated (semicolon-separated on Windows systems) list of DLLs; for example:</p>
<pre dir="ltr">SET EXTPROC_DLLS=ONLY:DLL1:DLL2
</pre>
<p>This setting allows <code dir="ltr">extproc</code> to load only the DLLs named DLL1 and DLL2. This setting provides maximum security.</p>
</li>
<li>
<p>A colon-separated (semicolon-separated on Windows systems) list of DLLs; for example:</p>
<pre dir="ltr">SET EXTPROC_DLLS=DLL1:DLL2
</pre>
<p>This setting allows <code dir="ltr">extproc</code> to load the DLLs named DLL1 and DLL2 and the DLLs that are in directory <code dir="ltr">$ORACLE_HOME</code>/<code dir="ltr">bin</code> or <code dir="ltr">$ORACLE_HOME</code>/<code dir="ltr">lib</code>.</p>
</li>
<li>
<p><code dir="ltr">ANY</code>; for example:</p>
<pre dir="ltr">SET EXTPROC_DLLS=ANY
</pre>
<p>This setting allows <code dir="ltr">extproc</code> to load any DLL.</p>
</li>
</ul>
<p>Set the <code dir="ltr">ENFORCE_CREDENTIAL</code> environment variable, which enforces the usage of credentials when spawning an <code dir="ltr">extproc</code> process. The <code dir="ltr">ENFORCE_CREDENTIAL</code> value can be <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code> (the default). For a discussion of <code dir="ltr">ENFORCE_CREDENTIAL</code> and the expected behaviors of an <code dir="ltr">extproc</code> process based on possible authentication and impersonation scenarios, see the information about securing external procedures in <a class="olink DBSEG755" href="../DBSEG/app_devs.htm#DBSEG755"><span class="italic">Oracle Database Security Guide</span></a>.</p>
<p>To change the default configuration for external procedures and have your <code dir="ltr">extproc</code> agent spawned by Oracle Listener, configure your database to use external procedures that are written in C, or can be called from C applications, as follows.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To use credentials for <span class="bold">extproc</span>, you cannot use Oracle Listener to spawn the <code dir="ltr">extproc</code> agent.</div>
<ol>
<li>
<p>Set configuration parameters for the agent, named <code dir="ltr">extproc</code> by default, in the configuration files <code dir="ltr">tnsnames</code>.<code dir="ltr">ora</code> and <code dir="ltr">listener</code>.<code dir="ltr">ora</code>. This establishes the connection for the external procedure agent, <code dir="ltr">extproc</code>, when the database is started.</p>
</li>
<li>
<p>Start a listener process exclusively for external procedures.</p>
<p>The Listener sets a few required environment variables (such as <code dir="ltr">ORACLE_HOME</code>, <code dir="ltr">ORACLE_SID</code>, and <code dir="ltr">LD_LIBRARY_PATH</code>) for <code dir="ltr">extproc</code>. It can also define specific environment variables in the <code dir="ltr">ENVS</code> section of its <code dir="ltr">listener</code>.<code dir="ltr">ora</code> entry, and these variables are passed to the agent process. Otherwise, it provides the agent with a &#34;clean&#34; environment. The environment variables set for the agent are independent of those set for the client and server. Therefore, external procedures, which run in the agent process, cannot read environment variables set for the client or server processes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is possible for you to set and read environment variables themselves by using the standard C procedures <code dir="ltr">setenv</code> and <code dir="ltr">getenv</code>, respectively. Environment variables, set this way, are specific to the agent process, which means that they can be read by all functions executed in that process, but not by any other process running on the same host.</div>
</li>
<li>
<p>Determine whether the agent for your external procedure is to run in dedicated mode (the default) or multithreaded mode.</p>
<p>In dedicated mode, one &#34;dedicated&#34; agent is launched for each session. In multithreaded mode, a single multithreaded <code dir="ltr">extproc</code> agent is launched. The multithreaded <code dir="ltr">extproc</code> agent handles calls using different threads for different users. In a configuration where many users can call the external procedures, using a multithreaded <code dir="ltr">extproc</code> agent is recommended to conserve system resources.</p>
<p>If the agent is to run in dedicated mode, additional configuration of the agent process is not necessary.</p>
<p>If the agent is to run in multithreaded mode, your database administrator must configure the database system to start the agent in multithreaded mode (as a multithreaded <code dir="ltr">extproc</code> agent). To do this configuration, use the agent control utility, <code dir="ltr">agtctl</code>. For example, start <code dir="ltr">extproc</code> using this command:</p>
<pre dir="ltr">agtctl startup extproc <span class="codeinlineitalic">agent_sid</span> 
</pre>
<p>where <code dir="ltr"><span class="codeinlineitalic">agent_sid</span></code> is the system identifier that this <code dir="ltr">extproc</code> agent services. An entry for this system identifier is typically added as an entry in the file <code dir="ltr">tnsnames</code>.<code dir="ltr">ora</code>. For more information about using <code dir="ltr">agtctl</code> for <code dir="ltr">extproc</code> administration, see <a class="olink LNOCI953" href="../LNOCI/ociafextproc.htm#LNOCI953">Administering the Multithreaded extproc Agent in</a> Oracle Call Interface Programmer&#39;s Guide.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If you use a multithreaded <code dir="ltr">extproc</code> agent, the library you call must be thread-safe&mdash;to avoid errors such as a damaged call stack.</p>
</li>
<li>
<p>The database server, the agent process, and the listener process that spawns the agent process must all reside on the same host.</p>
</li>
<li>
<p>By default, the agent process runs on the same database instance as your main application. In situations where reliability is critical, you might want to run the agent process for the external procedure on a separate database instance (still on the same host), so that any problems in the agent do not affect the primary database server. To do so, specify the separate database instance using a database link.</p>
</li>
</ul>
</div>
<p><a class="olink LNOCI949" href="../LNOCI/ociafextproc.htm#LNOCI949">Figure F-1</a> in <span class="italic">Oracle Call Interface Programmer&#39;s Guide</span> illustrates the architecture of the multithreaded <code dir="ltr">extproc</code> agent.</p>
</div>
<!-- class="sect2" -->
<a id="CIHHEIDC"></a>
<div id="ADFNS704" class="sect2">
<h3 class="sect2"><span class="secnum">18.4.3</span> Identify the DLL</h3>
<p>In this context, a DLL is any dynamically loadable operating-system file that stores external procedures.</p>
<p>For security reasons, your DBA controls access to the DLL. Using the <code dir="ltr">CREATE</code> <code dir="ltr">LIBRARY</code> statement, the DBA creates a schema object called an alias library, which represents the DLL. Then, if you are an authorized user, the DBA grants you <code dir="ltr">EXECUTE</code> privileges on the <span class="bold">alias</span> library. Alternatively, the DBA might grant you <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">LIBRARY</code> privileges, in which case you can create your own alias libraries using this syntax:</p>
<pre dir="ltr">CREATE LIBRARY [<span class="italic">schema_name</span>.]<span class="italic">library_name</span>
  {IS | AS} &#39;<span class="italic">file_path</span>&#39;
  [AGENT &#39;<span class="italic">agent_link</span>&#39;];
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">ANY</code> privileges are very powerful and must not be granted lightly. For more information, see:
<ul>
<li>
<p><a class="olink DBSEG004" href="../DBSEG/authorization.htm#DBSEG004"><span class="italic">Oracle Database Security Guide</span></a> for information about managing system privileges, including <code dir="ltr">ANY</code></p>
</li>
<li>
<p><a class="olink DBSEG009" href="../DBSEG/guidelines.htm#DBSEG009"><span class="italic">Oracle Database Security Guide</span></a> for guidelines for securing user accounts and privileges</p>
</li>
</ul>
</div>
<p>Oracle recommends that you specify the path to the DLL using a directory object, rather than only the DLL name. In this example, you create alias library <code dir="ltr">c_utils</code>, which represents DLL <code dir="ltr">utils</code>.<code dir="ltr">so</code>:</p>
<pre dir="ltr">CREATE LIBRARY C_utils AS &#39;utils.so&#39; IN <span class="italic">DLL_DIRECTORY</span>;
</pre>
<p>where <code dir="ltr"><span class="codeinlineitalic">DLL_DIRECTORY</span></code> is a directory object that refers to <code dir="ltr">&#39;/DLLs&#39;</code>.</p>
<p>As an alternative, you can specify the full path to the DLL, as in this example:</p>
<pre dir="ltr">CREATE LIBRARY C_utils AS &#39;/DLLs/utils.so&#39;;
</pre>
<p>To allow flexibility in specifying the DLLs, you can specify the root part of the path as an environment variable using the notation <code dir="ltr">${</code><code dir="ltr"><span class="codeinlineitalic">VAR_NAME</span></code><code dir="ltr">}</code>, and set up that variable in the <code dir="ltr">ENVS</code> section of the <code dir="ltr">listener</code>.<code dir="ltr">ora</code> entry.</p>
<p>In this example, the agent specified by the name <code dir="ltr">agent_link</code> is used to run any external procedure in the library <code dir="ltr">C_Utils</code>:</p>
<pre dir="ltr">create or replace database link agent_link using &#39;agent_tns_alias&#39;;
create or replace library C_utils is
  &#39;${EP_LIB_HOME}/utils.so&#39; agent &#39;agent_link&#39;;
</pre>
<p>The environment variable <code dir="ltr">EP_LIB_HOME</code> is expanded by the agent to the appropriate path for that instance, such as <code dir="ltr">/usr/bin/dll</code>. Variable <code dir="ltr">EP_LIB_HOME</code> must be set in the file <code dir="ltr">listener</code>.<code dir="ltr">ora</code>, for the agent to be able to access it.</p>
<p>For security reasons, <code dir="ltr">extproc</code>, by default, loads only DLLs that are in directory <code dir="ltr">$ORACLE_HOME/bin</code> or <code dir="ltr">$ORACLE_HOME/lib</code>. Also, only local sessions&mdash;that is, Oracle Database client processes that run on the same system&mdash;are allowed to connect to <code dir="ltr">extproc</code>.</p>
<p>To load DLLs from other directories, set the environment variable <code dir="ltr">EXTPROC_DLLS</code>. The value for this environment variable is a colon-separated (semicolon-separated on Windows systems) list of DLL names qualified with the complete path. For example:</p>
<pre dir="ltr">EXTPROC_DLLS=/private1/home/johndoe/dll/myDll.so:/private1/home/johndoe/dll/newDll.so
</pre>
<p>While you can set up environment variables for <code dir="ltr">extproc</code> through the <code dir="ltr">ENVS</code> parameter in the file <code dir="ltr">listener</code>.<code dir="ltr">ora</code>, you can also set up environment variables in the <code dir="ltr">extproc</code> initialization file <code dir="ltr">extproc</code>.<code dir="ltr">ora</code> in directory <code dir="ltr">$ORACLE_HOME/hs/admin</code>. When both <code dir="ltr">extproc</code>.<code dir="ltr">ora</code> and <code dir="ltr">ENVS</code> parameter in <code dir="ltr">listener</code>.<code dir="ltr">ora</code> are used, the environment variables defined in <code dir="ltr">extproc</code>.<code dir="ltr">ora</code> take precedence. See the Oracle Net manual for more information about the <code dir="ltr">EXTPROC</code> feature.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In <code dir="ltr">extproc.ora</code> on a Windows system, specify the path using a drive letter and using a double backslash (<code dir="ltr">\\</code>) for each backslash in the path. (The first backslash in each double backslash serves as an escape character.)</div>
</div>
<!-- class="sect2" -->
<a id="CIHJBJBB"></a>
<div id="ADFNS705" class="sect2">
<h3 class="sect2"><span class="secnum">18.4.4</span> Publish the External Procedures</h3>
<p>You find or write an external C procedure, and add it to the DLL. When the procedure is in the DLL, you publish it using the call specification mechanism described in <a href="#i1006405">Section 18.5, &#34;Publishing External Procedures.&#34;</a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006405"></a>
<div id="ADFNS1405" class="sect1">
<h2 class="sect1"><span class="secnum">18.5</span> Publishing External Procedures</h2>
<p><a id="sthref914"></a>Oracle Database can use only external procedures that are published through a call specification, which maps names, parameter types, and return types for your Java class method or C external procedure to their SQL counterparts. It is written like any other PL/SQL stored procedure except that, in its body, instead of declarations and a <code dir="ltr">BEGIN</code> <code dir="ltr">END</code> block, you code the <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> clause.</p>
<p>The <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> clause specifies:</p>
<ul>
<li>
<p>Which language the procedure is written in</p>
</li>
<li>
<p>For a Java method:</p>
<ul>
<li>
<p>The signature of the Java method</p>
</li>
</ul>
</li>
<li>
<p>For a C procedure:</p>
<ul>
<li>
<p>The alias library corresponding to the DLL for a C procedure</p>
</li>
<li>
<p>The name of the C procedure in a DLL</p>
</li>
<li>
<p>Various options for specifying how parameters are passed</p>
</li>
<li>
<p>Which parameter (if any) holds the name of the external procedure agent, <code dir="ltr">extproc</code>, for running the procedure on a different system</p>
</li>
</ul>
</li>
</ul>
<p>You begin the declaration using the normal <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> syntax for a procedure, function, package specification, package body, type specification, or type body.</p>
<p>The call specification follows the name and parameter declarations. Its syntax is:</p>
<pre dir="ltr">{IS | AS} LANGUAGE {C | JAVA}
</pre>
<p>This is then followed by either:</p>
<pre dir="ltr">NAME  <span class="italic">java_string_literal_name</span>
</pre>
<p>Where <span class="italic">java_string_literal_name</span> is the signature of your Java method</p>
<p>Or by:</p>
<pre dir="ltr">{ LIBRARY <span class="italic">library_name</span> [ NAME <span class="italic">c_string_literal_name</span> ] |
  [ NAME <span class="italic">c_string_literal_name</span> ] LIBRARY <span class="italic">library_name</span> }
[ AGENT IN ( <span class="italic">argument</span> [, <span class="italic">argument</span>]... ) ]
[ WITH CONTEXT ]
[ PARAMETERS (<span class="italic">external_parameter</span>[, <span class="italic">external_parameter</span>]...) ];
</pre>
<p>Where <code dir="ltr">library_name</code> is the name of your alias library, <code dir="ltr">c_string_literal_name</code> is the name of your external C procedure, and <code dir="ltr">external_parameter</code> stands for:</p>
<pre dir="ltr">{  CONTEXT 
 | SELF [{TDO | property}]
 | {<span class="italic">parameter_name</span> | RETURN} [<span class="italic">property</span>] [BY REFERENCE] [<span class="italic">external_datatype</span>]}
</pre>
<p><code dir="ltr">property</code> stands for:</p>
<pre dir="ltr">{INDICATOR [{STRUCT | TDO}] | LENGTH | DURATION | MAXLEN | CHARSETID | CHARSETFORM}
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Unlike Java, C does not understand SQL types; therefore, the syntax is more intricate</div>
<p class="subhead2"><a id="ADFNS1091"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1039216">Section 18.5.1, &#34;AS LANGUAGE Clause for Java Class Methods&#34;</a></p>
</li>
<li>
<p><a href="#g1039222">Section 18.5.2, &#34;AS LANGUAGE Clause for External C Procedures&#34;</a></p>
</li>
</ul>
<a id="g1039216"></a>
<div id="ADFNS708" class="sect2">
<h3 class="sect2"><span class="secnum">18.5.1</span> AS LANGUAGE Clause for Java Class Methods</h3>
<p><a id="sthref915"></a><a id="sthref916"></a>The <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> clause is the interface between PL/SQL and a Java class method.</p>
</div>
<!-- class="sect2" -->
<a id="g1039222"></a>
<div id="ADFNS709" class="sect2">
<h3 class="sect2"><span class="secnum">18.5.2</span> AS LANGUAGE Clause for External C Procedures</h3>
<p><a id="sthref917"></a><a id="sthref918"></a>These subclauses tell PL/SQL where to locate the external C procedure, how to call it, and what to pass to it:</p>
<ul>
<li>
<p><a href="#g1038853">LIBRARY</a></p>
</li>
<li>
<p><a href="#g1038859">NAME</a></p>
</li>
<li>
<p><a href="#g1038869">LANGUAGE</a></p>
</li>
<li>
<p><a href="#i1019187">CALLING STANDARD</a></p>
</li>
<li>
<p><a href="#g1038877">WITH CONTEXT</a></p>
</li>
<li>
<p><a href="#g1038881">PARAMETERS</a></p>
</li>
<li>
<p><a href="#g1038885">&#34;AGENT IN&#34;</a></p>
</li>
</ul>
<p>Of the preceding subclauses, only <code dir="ltr">LIBRARY</code> is required.</p>
<a id="g1038853"></a>
<div id="ADFNS710" class="sect3">
<h4 class="sect3"><span class="secnum">18.5.2.1</span> LIBRARY</h4>
<p>Specifies a local alias library. (You cannot use a database link to specify a remote library.) The library name is a PL/SQL identifier. Therefore, if you enclose the name in double quotation marks, then it becomes case-sensitive. (By default, the name is stored in upper case.) You must have <code dir="ltr">EXECUTE</code> privileges on the alias library.</p>
</div>
<!-- class="sect3" -->
<a id="g1038859"></a>
<div id="ADFNS711" class="sect3">
<h4 class="sect3"><span class="secnum">18.5.2.2</span> NAME</h4>
<p>Specifies the external C procedure to be called. If you enclose the procedure name in double quotation marks, then it becomes case-sensitive. (By default, the name is stored in upper case.) If you omit this subclause, then the procedure name defaults to the upper-case name of the PL/SQL procedure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The terms <code dir="ltr">LANGUAGE</code> and <code dir="ltr">CALLING</code> <code dir="ltr">STANDARD</code> apply only to the superseded <code dir="ltr">AS</code> <code dir="ltr">EXTERNAL</code> clause.</div>
</div>
<!-- class="sect3" -->
<a id="g1038869"></a>
<div id="ADFNS712" class="sect3">
<h4 class="sect3"><span class="secnum">18.5.2.3</span> LANGUAGE</h4>
<p>Specifies the third-generation language in which the external procedure was written. If you omit this subclause, then the language name defaults to C.</p>
</div>
<!-- class="sect3" -->
<a id="i1019187"></a>
<div id="ADFNS713" class="sect3">
<h4 class="sect3"><span class="secnum">18.5.2.4</span> CALLING STANDARD</h4>
<p>Specifies the calling standard under which the external procedure was compiled. The supported calling standard is C. If you omit this subclause, then the calling standard defaults to C.</p>
</div>
<!-- class="sect3" -->
<a id="g1038877"></a>
<div id="ADFNS714" class="sect3">
<h4 class="sect3"><span class="secnum">18.5.2.5</span> WITH CONTEXT</h4>
<p>Specifies that a context pointer is passed to the external procedure. The context data structure is opaque to the external procedure but is available to service procedures called by the external procedure.</p>
</div>
<!-- class="sect3" -->
<a id="g1038881"></a>
<div id="ADFNS715" class="sect3">
<h4 class="sect3"><span class="secnum">18.5.2.6</span> PARAMETERS</h4>
<p>Specifies the positions and data types of parameters passed to the external procedure. It can also specify parameter properties, such as current length and maximum length, and the preferred parameter passing method (by value or by reference).</p>
</div>
<!-- class="sect3" -->
<a id="g1038885"></a>
<div id="ADFNS716" class="sect3">
<h4 class="sect3"><span class="secnum">18.5.2.7</span> AGENT IN</h4>
<p>Specifies which parameter holds the name of the agent process that runs this procedure. This is intended for situations where the external procedure agent, <code dir="ltr">extproc</code>, runs using multiple agent processes, to ensure robustness if the agent process of one external procedure fails. You can pass the name of the agent process (corresponding to the name of a database link), and if <code dir="ltr">tnsnames</code>.<code dir="ltr">ora</code> and <code dir="ltr">listener</code>.<code dir="ltr">ora</code> are set up properly across both instances, the external procedure is called on the other instance. Both instances must be on the same host.</p>
<p>This is similar to the <code dir="ltr">AGENT</code> clause of the <code dir="ltr">CREATE</code> <code dir="ltr">LIBRARY</code> statement; specifying the value at runtime through <code dir="ltr">AGENT</code> <code dir="ltr">IN</code> allows greater flexibility.</p>
<p>When the agent name is specified this way, it overrides any agent name declared in the alias library. If no agent name is specified, the default is the <code dir="ltr">extproc</code> agent on the same instance as the calling program.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006482"></a>
<div id="ADFNS1406" class="sect1">
<h2 class="sect1"><span class="secnum">18.6</span> Publishing Java Class Methods</h2>
<p><a id="sthref919"></a>Java classes and their methods are stored in RDBMS libunits in which you can load Java sources, binaries and resources using the <code dir="ltr">LOADJAVA</code> utility or the <code dir="ltr">CREATEJAVA</code> SQL statements. Libunits can be considered analogous to DLLs written, for example, in C&mdash;although they map one-to-one with Java classes, whereas DLLs can contain multiple procedures.</p>
<p>The <code dir="ltr">NAME</code>-clause string uniquely identifies the Java method. The PL/SQL function or procedure and Java must have corresponding parameters. If the Java method takes no parameters, then you must code an empty parameter list for it.</p>
<p>When you load Java classes into the RDBMS, they are not published to SQL automatically. This is because only selected public static methods can be explicitly published to SQL. However, all methods can be invoked from other Java classes residing in the database, provided they have proper authorization.</p>
<p>Suppose you want to publish this Java method named <code dir="ltr">J_calcFactorial</code>, which returns the factorial of its argument:</p>
<pre dir="ltr">package myRoutines.math;
public class Factorial {
   public static int J_calcFactorial (int n) {
      if (n == 1) return 1;
      else return n * J_calcFactorial(n - 1);
   }
}
</pre>
<p>This call specification publishes Java method <code dir="ltr">J_calcFactorial</code> as PL/SQL stored function <code dir="ltr">plsToJavaFac_func</code>, using SQL*Plus:</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION Plstojavafac_func (N NUMBER) RETURN NUMBER AS
   LANGUAGE JAVA
   NAME &#39;myRoutines.math.Factorial.J_calcFactorial(int) return int&#39;;
</pre></div>
<!-- class="sect1" -->
<a id="i1006510"></a>
<div id="ADFNS1407" class="sect1">
<h2 class="sect1"><span class="secnum">18.7</span> Publishing External C Procedures</h2>
<p><a id="sthref920"></a>In this example, you write a PL/SQL standalone function named <code dir="ltr">plsCallsCdivisor_func</code> that publishes C function <code dir="ltr">Cdivisor_func</code> as an external function:</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION Plscallscdivisor_func (
<span class="italic">/* Find greatest common divisor of x and y: */</span>
 x     PLS_INTEGER, 
 y     PLS_INTEGER) 
RETURN PLS_INTEGER 
AS LANGUAGE C
   LIBRARY C_utils
   NAME &#34;Cdivisor_func&#34;;<span class="italic"> /* Quotation marks preserve case. */</span>
</pre></div>
<!-- class="sect1" -->
<a id="i1006521"></a>
<div id="ADFNS1408" class="sect1">
<h2 class="sect1"><span class="secnum">18.8</span> Locations of Call Specifications</h2>
<p><a id="sthref921"></a>For both Java class methods and external C procedures, call specifications can be specified in any of these locations:</p>
<ul>
<li>
<p>Standalone PL/SQL procedures</p>
</li>
<li>
<p>PL/SQL Package Specifications</p>
</li>
<li>
<p>PL/SQL Package Bodies</p>
</li>
<li>
<p>ADT Specifications</p>
</li>
<li>
<p>ADT Bodies</p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS1321"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1681055">Example: Locating a Call Specification in a PL/SQL Package</a></p>
</li>
<li>
<p><a href="#CIHFIDGB">Example: Locating a Call Specification in a PL/SQL Package Body</a></p>
</li>
<li>
<p><a href="#CIHBFDFI">Example: Locating a Call Specification in an ADT Specification</a></p>
</li>
<li>
<p><a href="#CIHHIHCD">Example: Locating a Call Specification in an ADT Body</a></p>
</li>
<li>
<p><a href="#CIHIBJIG">Example: Java with AUTHID</a></p>
</li>
<li>
<p><a href="#CIHJEABC">Example: C with Optional AUTHID</a></p>
</li>
<li>
<p><a href="#CIHFCEJB">Example: Mixing Call Specifications in a Package</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
In these examples, the <code dir="ltr">AUTHID</code> and <code dir="ltr">SQL_NAME_RESOLVE</code> clauses might be required to fully stipulate a call specification.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS00812" href="../LNPLS/subprograms.htm#LNPLS00812"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about calling external procedures from PL/SQL</p>
</li>
<li>
<p><a class="olink SQLRF01108" href="../SQLRF/statements_4009.htm#SQLRF01108"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the SQL <code dir="ltr">CALL</code> statement</p>
</li>
</ul>
</div>
<a id="g1681055"></a>
<div id="ADFNS717" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.8.1</span> Example: Locating a Call Specification in a PL/SQL Package</h3>
<pre dir="ltr">CREATE OR REPLACE PACKAGE Demo_pack 
AUTHID DEFINER 
AS
   PROCEDURE plsToC_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE) 
   AS LANGUAGE C
      NAME &#34;C_demoExternal&#34;
      LIBRARY SomeLib
      WITH CONTEXT
      PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE);
END;
</pre></div>
<!-- class="sect2" -->
<a id="CIHFIDGB"></a>
<div id="ADFNS718" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.8.2</span> Example: Locating a Call Specification in a PL/SQL Package Body</h3>
<pre dir="ltr">CREATE OR REPLACE PACKAGE Demo_pack 
   AUTHID CURRENT_USER
AS 
   PROCEDURE plsToC_demoExternal_proc(x PLS_INTEGER, y VARCHAR2, z DATE);
END;
 
CREATE OR REPLACE PACKAGE BODY Demo_pack 
   SQL_NAME_RESOLVE CURRENT_USER
AS
   PROCEDURE plsToC_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE)
   AS LANGUAGE JAVA
      NAME &#39;pkg1.class4.methodProc1(int,java.lang.String,java.sql.Date)&#39;;
END;
</pre></div>
<!-- class="sect2" -->
<a id="CIHBFDFI"></a>
<div id="ADFNS719" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.8.3</span> Example: Locating a Call Specification in an ADT Specification</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
For examples in this topic to work, you must set up this data structure (which requires that you have the privilege <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">LIBRARY</code>):
<pre dir="ltr">CREATE OR REPLACE LIBRARY SOMELIB AS &#39;/tmp/lib.so&#39;;
</pre></div>
<pre dir="ltr">CREATE OR REPLACE TYPE Demo_typ 
AUTHID DEFINER 
AS OBJECT
   (Attribute1   VARCHAR2(2000), SomeLib varchar2(20),
   MEMBER PROCEDURE plsToC_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE) 
   AS LANGUAGE C
      NAME &#34;C_demoExternal&#34;
      LIBRARY SomeLib
      WITH CONTEXT
    --  PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE)
      PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE, SELF)
);
</pre></div>
<!-- class="sect2" -->
<a id="CIHHIHCD"></a>
<div id="ADFNS720" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.8.4</span> Example: Locating a Call Specification in an ADT Body</h3>
<pre dir="ltr">CREATE OR REPLACE TYPE Demo_typ 
AUTHID CURRENT_USER 
AS OBJECT
   (attribute1 NUMBER,
   MEMBER PROCEDURE plsToJ_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE)
);

CREATE OR REPLACE TYPE BODY Demo_typ 
AS
   MEMBER PROCEDURE plsToJ_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE)
   AS LANGUAGE JAVA
      NAME &#39;pkg1.class4.J_demoExternal(int,java.lang.String,java.sql.Date)&#39;;
END;
</pre></div>
<!-- class="sect2" -->
<a id="CIHIBJIG"></a>
<div id="ADFNS721" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.8.5</span> Example: Java with AUTHID</h3>
<p>Here is an example of a publishing a Java class method in a standalone PL/SQL procedure.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE plsToJ_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE)
   AUTHID CURRENT_USER 
AS LANGUAGE JAVA
   NAME &#39;pkg1.class4.methodProc1(int,java.lang.String,java.sql.Date)&#39;;
</pre></div>
<!-- class="sect2" -->
<a id="CIHJEABC"></a>
<div id="ADFNS722" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.8.6</span> Example: C with Optional AUTHID</h3>
<p>Here is an example of <code dir="ltr">AS</code> <code dir="ltr">EXTERNAL</code> publishing a C procedure in a standalone PL/SQL program, in which the <code dir="ltr">AUTHID</code> clause is optional. This maintains compatibility with the external procedures of Oracle Database version 8.0.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE plsToC_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE) 
AS 
   EXTERNAL
   LANGUAGE C
   NAME &#34;C_demoExternal&#34;
   LIBRARY SomeLib
   WITH CONTEXT
   PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE);
</pre></div>
<!-- class="sect2" -->
<a id="CIHFCEJB"></a>
<div id="ADFNS723" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.8.7</span> Example: Mixing Call Specifications in a Package</h3>
<pre dir="ltr">CREATE OR REPLACE PACKAGE Demo_pack 
AUTHID DEFINER 
AS 
   PROCEDURE plsToC_InBodyOld_proc (x PLS_INTEGER, y VARCHAR2, z DATE);
   PROCEDURE plsToC_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE); 
   PROCEDURE plsToC_InBody_proc (x PLS_INTEGER, y VARCHAR2, z DATE);
   PROCEDURE plsToJ_InBody_proc (x PLS_INTEGER, y VARCHAR2, z DATE);

   PROCEDURE plsToJ_InSpec_proc (x PLS_INTEGER, y VARCHAR2, z DATE)
   IS LANGUAGE JAVA
      NAME &#39;pkg1.class4.J_InSpec_meth(int,java.lang.String,java.sql.Date)&#39;;

PROCEDURE C_InSpec_proc (x PLS_INTEGER, y VARCHAR2, z DATE) 
   AS LANGUAGE C
      NAME &#34;C_demoExternal&#34;
      LIBRARY SomeLib
      WITH CONTEXT
      PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE);
END;

CREATE OR REPLACE PACKAGE BODY Demo_pack 
AS 
PROCEDURE plsToC_InBodyOld_proc (x PLS_INTEGER, y VARCHAR2, z DATE) 
   AS EXTERNAL
      LANGUAGE C
      NAME &#34;C_InBodyOld&#34;
      LIBRARY SomeLib
      WITH CONTEXT
      PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE); 
PROCEDURE plsToC_demoExternal_proc (x PLS_INTEGER, y VARCHAR2, z DATE) 
   AS LANGUAGE C
      NAME &#34;C_demoExternal&#34;
      LIBRARY SomeLib
      WITH CONTEXT
      PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE);
   
PROCEDURE plsToC_InBody_proc (x PLS_INTEGER, y VARCHAR2, z DATE) 
   AS LANGUAGE C
      NAME &#34;C_InBody&#34;
      LIBRARY SomeLib
      WITH CONTEXT
      PARAMETERS(CONTEXT, x INT, y STRING, z OCIDATE);
PROCEDURE plsToJ_InBody_proc (x PLS_INTEGER, y VARCHAR2, z DATE)
   IS LANGUAGE JAVA
      NAME &#39;pkg1.class4.J_InBody_meth(int,java.lang.String,java.sql.Date)&#39;;
END;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006699"></a>
<div id="ADFNS1409" class="sect1">
<h2 class="sect1"><span class="secnum">18.9</span> Passing Parameters to External C Procedures with Call Specifications</h2>
<p><a id="sthref922"></a>Call specifications allow a mapping between PL/SQL and C data types. See <a href="#i1021509">Section 18.9.1</a> for data type mappings.</p>
<p>Passing parameters to an external C procedure is complicated by several circumstances:</p>
<ul>
<li>
<p>The available set of PL/SQL data types does not correspond one-to-one with the set of C data types.</p>
</li>
<li>
<p>Unlike C, PL/SQL includes the RDBMS concept of nullity. Therefore, PL/SQL parameters can be <code dir="ltr">NULL</code>, whereas C parameters cannot.</p>
</li>
<li>
<p>The external procedure might need the current length or maximum length of <code dir="ltr">CHAR</code>, <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, <code dir="ltr">RAW</code>, and <code dir="ltr">VARCHAR2</code> parameters.</p>
</li>
<li>
<p>The external procedure might need character set information about <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR2</code>, and <code dir="ltr">CLOB</code> parameters.</p>
</li>
<li>
<p>PL/SQL might need the current length, maximum length, or null status of values returned by the external procedure.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The maximum number of parameters that you can pass to a C external procedure is 128. However, if you pass float or double parameters by value, then the maximum is less than 128. How much less depends on the number of such parameters and your operating system. To get a rough estimate, count each float or double passed by value as two parameters.</div>
<p class="subhead2"><a id="ADFNS1092"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1021509">Specifying Data Types</a></p>
</li>
<li>
<p><a href="#g1039264">External Data Type Mappings</a></p>
</li>
<li>
<p><a href="#g1039282">Passing Parameters BY VALUE or BY REFERENCE</a></p>
</li>
<li>
<p><a href="#g1039306">Declaring Formal Parameters</a></p>
</li>
<li>
<p><a href="#g1039328">Overriding Default Data Type Mapping</a></p>
</li>
<li>
<p><a href="#g1039337">Specifying Properties</a></p>
</li>
</ul>
<a id="i1021509"></a>
<div id="ADFNS724" class="sect2">
<h3 class="sect2"><span class="secnum">18.9.1</span> Specifying Data Types</h3>
<p>Do not pass parameters to an external procedure directly. Instead, pass them to the PL/SQL procedure that published the external procedure, specifying PL/SQL data types for the parameters. PL/SQL data types map to default external data types, as shown in <a href="#g1024826">Table 18-1</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The PL/SQL data types <code dir="ltr">BINARY_INTEGER</code> and <code dir="ltr">PLS_INTEGER</code> are identical. For simplicity, this guide uses &#34;<code dir="ltr">PLS_INTEGER</code>&#34; to mean both <code dir="ltr">BINARY_INTEGER</code> and <code dir="ltr">PLS_INTEGER</code>.</div>
<div id="ADFNS725" class="tblformal">
<p class="titleintable"><a id="sthref923"></a><a id="g1024826"></a>Table 18-1 Parameter Data Type Mappings</p>
<table class="cellalignment293" title=" Parameter Data Type Mappings" summary="Parameter Datatype Mappings" dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t19">PL/SQL Data Type</th>
<th class="cellalignment294" id="r1c2-t19">Supported External Types</th>
<th class="cellalignment294" id="r1c3-t19">Default External Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t19" headers="r1c1-t19">
<pre dir="ltr">BINARY_INTEGER
BOOLEAN
PLS_INTEGER
</pre></td>
<td class="cellalignment295" headers="r2c1-t19 r1c2-t19">
<pre dir="ltr">[UNSIGNED] CHAR
[UNSIGNED] SHORT
[UNSIGNED] INT
[UNSIGNED] LONG
SB1, SB2, SB4
UB1, UB2, UB4
SIZE_T
</pre></td>
<td class="cellalignment295" headers="r2c1-t19 r1c3-t19">
<pre dir="ltr">INT
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t19" headers="r1c1-t19">
<pre dir="ltr">NATURAL<a id="BEJEAFAE" href="#BEJEAFAE" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="tablefootnote">Foot 1 </sup></a>
NATURALN<a id="sthref924" href="#sthref924" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
POSITIVE<a id="sthref925" href="#sthref925" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
POSITIVEN<a id="sthref926" href="#sthref926" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
SIGNTYPE<a id="sthref927" href="#sthref927" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
</pre></td>
<td class="cellalignment295" headers="r3c1-t19 r1c2-t19">
<pre dir="ltr">[UNSIGNED] CHAR
[UNSIGNED] SHORT
[UNSIGNED] INT
[UNSIGNED] LONG
SB1, SB2, SB4
UB1, UB2, UB4
SIZE_T
</pre></td>
<td class="cellalignment295" headers="r3c1-t19 r1c3-t19">
<pre dir="ltr">UNSIGNED INT
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t19" headers="r1c1-t19">
<pre dir="ltr">FLOAT
REAL
</pre></td>
<td class="cellalignment295" headers="r4c1-t19 r1c2-t19">
<pre dir="ltr">FLOAT
</pre></td>
<td class="cellalignment295" headers="r4c1-t19 r1c3-t19">
<pre dir="ltr">FLOAT
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t19" headers="r1c1-t19">
<pre dir="ltr">DOUBLE PRECISION
</pre></td>
<td class="cellalignment295" headers="r5c1-t19 r1c2-t19">
<pre dir="ltr">DOUBLE
</pre></td>
<td class="cellalignment295" headers="r5c1-t19 r1c3-t19">
<pre dir="ltr">DOUBLE
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t19" headers="r1c1-t19">
<pre dir="ltr">CHAR 
CHARACTER
LONG
NCHAR
NVARCHAR2
ROWID
VARCHAR 
VARCHAR2 
</pre></td>
<td class="cellalignment295" headers="r6c1-t19 r1c2-t19">
<pre dir="ltr">STRING
OCISTRING
</pre></td>
<td class="cellalignment295" headers="r6c1-t19 r1c3-t19">
<pre dir="ltr">STRING
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r7c1-t19" headers="r1c1-t19">
<pre dir="ltr">LONG RAW 
RAW
</pre></td>
<td class="cellalignment295" headers="r7c1-t19 r1c2-t19">
<pre dir="ltr">RAW
OCIRAW
</pre></td>
<td class="cellalignment295" headers="r7c1-t19 r1c3-t19">
<pre dir="ltr">RAW
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r8c1-t19" headers="r1c1-t19">
<pre dir="ltr">BFILE 
BLOB 
CLOB
NCLOB
</pre></td>
<td class="cellalignment295" headers="r8c1-t19 r1c2-t19">
<pre dir="ltr">OCILOBLOCATOR
</pre></td>
<td class="cellalignment295" headers="r8c1-t19 r1c3-t19">
<pre dir="ltr">OCILOBLOCATOR
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r9c1-t19" headers="r1c1-t19">
<pre dir="ltr">NUMBER
DEC<a id="sthref928" href="#sthref928" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
DECIMAL<a id="sthref929" href="#sthref929" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
INT<a id="sthref930" href="#sthref930" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
INTEGER<a id="sthref931" href="#sthref931" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
NUMERIC<a id="sthref932" href="#sthref932" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
SMALLINT<a id="sthref933" href="#sthref933" onclick="footdisplay(1,&#34;This PL/SQL type compiles only if you use \u003ccode dir=\&#34;ltr\&#34;\u003eAS\u003c/code\u003e \u003ccode dir=\&#34;ltr\&#34;\u003eEXTERNAL\u003c/code\u003e in your call spec.&#34;)"><sup class="footnotenumber">Footref 1</sup></a>
</pre></td>
<td class="cellalignment295" headers="r9c1-t19 r1c2-t19">
<pre dir="ltr">OCINUMBER
</pre></td>
<td class="cellalignment295" headers="r9c1-t19 r1c3-t19">
<pre dir="ltr">OCINUMBER
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r10c1-t19" headers="r1c1-t19">
<pre dir="ltr">DATE
</pre></td>
<td class="cellalignment295" headers="r10c1-t19 r1c2-t19">
<pre dir="ltr">OCIDATE
</pre></td>
<td class="cellalignment295" headers="r10c1-t19 r1c3-t19">
<pre dir="ltr">OCIDATE
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r11c1-t19" headers="r1c1-t19">
<pre dir="ltr">TIMESTAMP
TIMESTAMP WITH TIME ZONE
TIMESTAMP WITH LOCAL TIME ZONE
</pre></td>
<td class="cellalignment295" headers="r11c1-t19 r1c2-t19">
<pre dir="ltr">OCIDateTime
</pre></td>
<td class="cellalignment295" headers="r11c1-t19 r1c3-t19">
<pre dir="ltr">OCIDateTime
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r12c1-t19" headers="r1c1-t19">
<pre dir="ltr">INTERVAL DAY TO SECOND
INTERVAL YEAR TO MONTH
</pre></td>
<td class="cellalignment295" headers="r12c1-t19 r1c2-t19">
<pre dir="ltr">OCIInterval
</pre></td>
<td class="cellalignment295" headers="r12c1-t19 r1c3-t19">
<pre dir="ltr">OCIInterval
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r13c1-t19" headers="r1c1-t19">
<pre dir="ltr">composite object types: ADTs
</pre></td>
<td class="cellalignment295" headers="r13c1-t19 r1c2-t19">
<pre dir="ltr">dvoid
</pre></td>
<td class="cellalignment295" headers="r13c1-t19 r1c3-t19">
<pre dir="ltr">dvoid
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r14c1-t19" headers="r1c1-t19">
<pre dir="ltr">composite object types: collections (associative arrays, varrays, nested tables)
</pre></td>
<td class="cellalignment295" headers="r14c1-t19 r1c2-t19">
<pre dir="ltr">OCICOLL
</pre></td>
<td class="cellalignment295" headers="r14c1-t19 r1c3-t19">
<pre dir="ltr">OCICOLL
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>This PL/SQL type compiles only if you use <code dir="ltr">AS</code> <code dir="ltr">EXTERNAL</code> in your call spec.</p>
</div>
<!-- class="sect2" -->
<a id="g1039264"></a>
<div id="ADFNS726" class="sect2">
<h3 class="sect2"><span class="secnum">18.9.2</span> External Data Type Mappings</h3>
<p>Each external data type maps to a C data type, and the data type conversions are performed implicitly. To avoid errors when declaring C prototype parameters, see <a href="#g1024886">Table 18-2</a>, which shows the C data type to specify for a given external data type and PL/SQL parameter mode. For example, if the external data type of an <code dir="ltr">OUT</code> parameter is <code dir="ltr">STRING</code>, then specify the data type char * in your C prototype.</p>
<div id="ADFNS727" class="tblformal">
<p class="titleintable"><a id="sthref934"></a><a id="g1024886"></a>Table 18-2 External Data Type Mappings</p>
<table class="cellalignment293" title=" External Data Type Mappings" summary="This table summarizes the external datatype mappings." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t20">External Data Type Corresponding to PL/SL Type</th>
<th class="cellalignment294" id="r1c2-t20">If Mode is IN or RETURN, Specify in C Prototype...</th>
<th class="cellalignment294" id="r1c3-t20">If Mode is IN by Reference or RETURN by Reference, Specify in C Prototype...</th>
<th class="cellalignment294" id="r1c4-t20">If Mode is IN OUT or OUT, Specify in C Prototype...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t20" headers="r1c1-t20">
<pre dir="ltr">CHAR
</pre></td>
<td class="cellalignment295" headers="r2c1-t20 r1c2-t20">
<pre dir="ltr">char
</pre></td>
<td class="cellalignment295" headers="r2c1-t20 r1c3-t20">
<pre dir="ltr">char *
</pre></td>
<td class="cellalignment295" headers="r2c1-t20 r1c4-t20">
<pre dir="ltr">char *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED CHAR
</pre></td>
<td class="cellalignment295" headers="r3c1-t20 r1c2-t20">
<pre dir="ltr">unsigned char
</pre></td>
<td class="cellalignment295" headers="r3c1-t20 r1c3-t20">
<pre dir="ltr">unsigned char *
</pre></td>
<td class="cellalignment295" headers="r3c1-t20 r1c4-t20">
<pre dir="ltr">unsigned char *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t20" headers="r1c1-t20">
<pre dir="ltr">SHORT
</pre></td>
<td class="cellalignment295" headers="r4c1-t20 r1c2-t20">
<pre dir="ltr">short
</pre></td>
<td class="cellalignment295" headers="r4c1-t20 r1c3-t20">
<pre dir="ltr">short *
</pre></td>
<td class="cellalignment295" headers="r4c1-t20 r1c4-t20">
<pre dir="ltr">short *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED SHORT
</pre></td>
<td class="cellalignment295" headers="r5c1-t20 r1c2-t20">
<pre dir="ltr">unsigned short
</pre></td>
<td class="cellalignment295" headers="r5c1-t20 r1c3-t20">
<pre dir="ltr">unsigned short *
</pre></td>
<td class="cellalignment295" headers="r5c1-t20 r1c4-t20">
<pre dir="ltr">unsigned short *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t20" headers="r1c1-t20">
<pre dir="ltr">INT
</pre></td>
<td class="cellalignment295" headers="r6c1-t20 r1c2-t20">
<pre dir="ltr">int
</pre></td>
<td class="cellalignment295" headers="r6c1-t20 r1c3-t20">
<pre dir="ltr">int *
</pre></td>
<td class="cellalignment295" headers="r6c1-t20 r1c4-t20">
<pre dir="ltr">int *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r7c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED INT
</pre></td>
<td class="cellalignment295" headers="r7c1-t20 r1c2-t20">
<pre dir="ltr">unsigned int
</pre></td>
<td class="cellalignment295" headers="r7c1-t20 r1c3-t20">
<pre dir="ltr">unsigned int *
</pre></td>
<td class="cellalignment295" headers="r7c1-t20 r1c4-t20">
<pre dir="ltr">unsigned int *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r8c1-t20" headers="r1c1-t20">
<pre dir="ltr">LONG
</pre></td>
<td class="cellalignment295" headers="r8c1-t20 r1c2-t20">
<pre dir="ltr">long
</pre></td>
<td class="cellalignment295" headers="r8c1-t20 r1c3-t20">
<pre dir="ltr">long *
</pre></td>
<td class="cellalignment295" headers="r8c1-t20 r1c4-t20">
<pre dir="ltr">long *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r9c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED LONG
</pre></td>
<td class="cellalignment295" headers="r9c1-t20 r1c2-t20">
<pre dir="ltr">unsigned long
</pre></td>
<td class="cellalignment295" headers="r9c1-t20 r1c3-t20">
<pre dir="ltr">unsigned long *
</pre></td>
<td class="cellalignment295" headers="r9c1-t20 r1c4-t20">
<pre dir="ltr">unsigned long *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r10c1-t20" headers="r1c1-t20">
<pre dir="ltr">CHAR
</pre></td>
<td class="cellalignment295" headers="r10c1-t20 r1c2-t20">
<pre dir="ltr">char
</pre></td>
<td class="cellalignment295" headers="r10c1-t20 r1c3-t20">
<pre dir="ltr">char *
</pre></td>
<td class="cellalignment295" headers="r10c1-t20 r1c4-t20">
<pre dir="ltr">char *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r11c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED CHAR
</pre></td>
<td class="cellalignment295" headers="r11c1-t20 r1c2-t20">
<pre dir="ltr">unsigned char
</pre></td>
<td class="cellalignment295" headers="r11c1-t20 r1c3-t20">
<pre dir="ltr">unsigned char *
</pre></td>
<td class="cellalignment295" headers="r11c1-t20 r1c4-t20">
<pre dir="ltr">unsigned char *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r12c1-t20" headers="r1c1-t20">
<pre dir="ltr">SHORT
</pre></td>
<td class="cellalignment295" headers="r12c1-t20 r1c2-t20">
<pre dir="ltr">short
</pre></td>
<td class="cellalignment295" headers="r12c1-t20 r1c3-t20">
<pre dir="ltr">short *
</pre></td>
<td class="cellalignment295" headers="r12c1-t20 r1c4-t20">
<pre dir="ltr">short *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r13c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED SHORT
</pre></td>
<td class="cellalignment295" headers="r13c1-t20 r1c2-t20">
<pre dir="ltr">unsigned short
</pre></td>
<td class="cellalignment295" headers="r13c1-t20 r1c3-t20">
<pre dir="ltr">unsigned short *
</pre></td>
<td class="cellalignment295" headers="r13c1-t20 r1c4-t20">
<pre dir="ltr">unsigned short *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r14c1-t20" headers="r1c1-t20">
<pre dir="ltr">INT
</pre></td>
<td class="cellalignment295" headers="r14c1-t20 r1c2-t20">
<pre dir="ltr">int
</pre></td>
<td class="cellalignment295" headers="r14c1-t20 r1c3-t20">
<pre dir="ltr">int *
</pre></td>
<td class="cellalignment295" headers="r14c1-t20 r1c4-t20">
<pre dir="ltr">int *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r15c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED INT
</pre></td>
<td class="cellalignment295" headers="r15c1-t20 r1c2-t20">
<pre dir="ltr">unsigned int
</pre></td>
<td class="cellalignment295" headers="r15c1-t20 r1c3-t20">
<pre dir="ltr">unsigned int *
</pre></td>
<td class="cellalignment295" headers="r15c1-t20 r1c4-t20">
<pre dir="ltr">unsigned int *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r16c1-t20" headers="r1c1-t20">
<pre dir="ltr">LONG
</pre></td>
<td class="cellalignment295" headers="r16c1-t20 r1c2-t20">
<pre dir="ltr">long
</pre></td>
<td class="cellalignment295" headers="r16c1-t20 r1c3-t20">
<pre dir="ltr">long *
</pre></td>
<td class="cellalignment295" headers="r16c1-t20 r1c4-t20">
<pre dir="ltr">long *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r17c1-t20" headers="r1c1-t20">
<pre dir="ltr">UNSIGNED LONG
</pre></td>
<td class="cellalignment295" headers="r17c1-t20 r1c2-t20">
<pre dir="ltr">unsigned long
</pre></td>
<td class="cellalignment295" headers="r17c1-t20 r1c3-t20">
<pre dir="ltr">unsigned long *
</pre></td>
<td class="cellalignment295" headers="r17c1-t20 r1c4-t20">
<pre dir="ltr">unsigned long *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r18c1-t20" headers="r1c1-t20">
<pre dir="ltr">SIZE_T
</pre></td>
<td class="cellalignment295" headers="r18c1-t20 r1c2-t20">
<pre dir="ltr">size_t
</pre></td>
<td class="cellalignment295" headers="r18c1-t20 r1c3-t20">
<pre dir="ltr">size_t *
</pre></td>
<td class="cellalignment295" headers="r18c1-t20 r1c4-t20">
<pre dir="ltr">size_t *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r19c1-t20" headers="r1c1-t20">
<pre dir="ltr">SB1
</pre></td>
<td class="cellalignment295" headers="r19c1-t20 r1c2-t20">
<pre dir="ltr">sb1
</pre></td>
<td class="cellalignment295" headers="r19c1-t20 r1c3-t20">
<pre dir="ltr">sb1 *
</pre></td>
<td class="cellalignment295" headers="r19c1-t20 r1c4-t20">
<pre dir="ltr">sb1 *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r20c1-t20" headers="r1c1-t20">
<pre dir="ltr">UB1
</pre></td>
<td class="cellalignment295" headers="r20c1-t20 r1c2-t20">
<pre dir="ltr">ub1
</pre></td>
<td class="cellalignment295" headers="r20c1-t20 r1c3-t20">
<pre dir="ltr">ub1 *
</pre></td>
<td class="cellalignment295" headers="r20c1-t20 r1c4-t20">
<pre dir="ltr">ub1 *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r21c1-t20" headers="r1c1-t20">
<pre dir="ltr">SB2
</pre></td>
<td class="cellalignment295" headers="r21c1-t20 r1c2-t20">
<pre dir="ltr">sb2
</pre></td>
<td class="cellalignment295" headers="r21c1-t20 r1c3-t20">
<pre dir="ltr">sb2 *
</pre></td>
<td class="cellalignment295" headers="r21c1-t20 r1c4-t20">
<pre dir="ltr">sb2 *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r22c1-t20" headers="r1c1-t20">
<pre dir="ltr">UB2
</pre></td>
<td class="cellalignment295" headers="r22c1-t20 r1c2-t20">
<pre dir="ltr">ub2
</pre></td>
<td class="cellalignment295" headers="r22c1-t20 r1c3-t20">
<pre dir="ltr">ub2 *
</pre></td>
<td class="cellalignment295" headers="r22c1-t20 r1c4-t20">
<pre dir="ltr">ub2 *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r23c1-t20" headers="r1c1-t20">
<pre dir="ltr">SB4
</pre></td>
<td class="cellalignment295" headers="r23c1-t20 r1c2-t20">
<pre dir="ltr">sb4
</pre></td>
<td class="cellalignment295" headers="r23c1-t20 r1c3-t20">
<pre dir="ltr">sb4 *
</pre></td>
<td class="cellalignment295" headers="r23c1-t20 r1c4-t20">
<pre dir="ltr">sb4 *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r24c1-t20" headers="r1c1-t20">
<pre dir="ltr">UB4
</pre></td>
<td class="cellalignment295" headers="r24c1-t20 r1c2-t20">
<pre dir="ltr">ub4
</pre></td>
<td class="cellalignment295" headers="r24c1-t20 r1c3-t20">
<pre dir="ltr">ub4 *
</pre></td>
<td class="cellalignment295" headers="r24c1-t20 r1c4-t20">
<pre dir="ltr">ub4 *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r25c1-t20" headers="r1c1-t20">
<pre dir="ltr">FLOAT
</pre></td>
<td class="cellalignment295" headers="r25c1-t20 r1c2-t20">
<pre dir="ltr">float
</pre></td>
<td class="cellalignment295" headers="r25c1-t20 r1c3-t20">
<pre dir="ltr">float *
</pre></td>
<td class="cellalignment295" headers="r25c1-t20 r1c4-t20">
<pre dir="ltr">float *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r26c1-t20" headers="r1c1-t20">
<pre dir="ltr">DOUBLE
</pre></td>
<td class="cellalignment295" headers="r26c1-t20 r1c2-t20">
<pre dir="ltr">double
</pre></td>
<td class="cellalignment295" headers="r26c1-t20 r1c3-t20">
<pre dir="ltr">double *
</pre></td>
<td class="cellalignment295" headers="r26c1-t20 r1c4-t20">
<pre dir="ltr">double *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r27c1-t20" headers="r1c1-t20">
<pre dir="ltr">STRING
</pre></td>
<td class="cellalignment295" headers="r27c1-t20 r1c2-t20">
<pre dir="ltr">char *
</pre></td>
<td class="cellalignment295" headers="r27c1-t20 r1c3-t20">
<pre dir="ltr">char *
</pre></td>
<td class="cellalignment295" headers="r27c1-t20 r1c4-t20">
<pre dir="ltr">char *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r28c1-t20" headers="r1c1-t20">
<pre dir="ltr">RAW
</pre></td>
<td class="cellalignment295" headers="r28c1-t20 r1c2-t20">
<pre dir="ltr">unsigned char *
</pre></td>
<td class="cellalignment295" headers="r28c1-t20 r1c3-t20">
<pre dir="ltr">unsigned char *
</pre></td>
<td class="cellalignment295" headers="r28c1-t20 r1c4-t20">
<pre dir="ltr">unsigned char *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r29c1-t20" headers="r1c1-t20">
<pre dir="ltr">OCILOBLOCATOR
</pre></td>
<td class="cellalignment295" headers="r29c1-t20 r1c2-t20">
<pre dir="ltr">OCILobLocator *
</pre></td>
<td class="cellalignment295" headers="r29c1-t20 r1c3-t20">
<pre dir="ltr">OCILobLocator **
</pre></td>
<td class="cellalignment295" headers="r29c1-t20 r1c4-t20">
<pre dir="ltr">OCILobLocator **
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r30c1-t20" headers="r1c1-t20">
<pre dir="ltr">OCINUMBER
</pre></td>
<td class="cellalignment295" headers="r30c1-t20 r1c2-t20">
<pre dir="ltr">OCINumber *
</pre></td>
<td class="cellalignment295" headers="r30c1-t20 r1c3-t20">
<pre dir="ltr">OCINumber *
</pre></td>
<td class="cellalignment295" headers="r30c1-t20 r1c4-t20">
<pre dir="ltr">OCINumber *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r31c1-t20" headers="r1c1-t20">
<pre dir="ltr">OCISTRING
</pre></td>
<td class="cellalignment295" headers="r31c1-t20 r1c2-t20">
<pre dir="ltr">OCIString *
</pre></td>
<td class="cellalignment295" headers="r31c1-t20 r1c3-t20">
<pre dir="ltr">OCIString *
</pre></td>
<td class="cellalignment295" headers="r31c1-t20 r1c4-t20">
<pre dir="ltr">OCIString *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r32c1-t20" headers="r1c1-t20">
<pre dir="ltr">OCIRAW
</pre></td>
<td class="cellalignment295" headers="r32c1-t20 r1c2-t20">
<pre dir="ltr">OCIRaw *
</pre></td>
<td class="cellalignment295" headers="r32c1-t20 r1c3-t20">
<pre dir="ltr">OCIRaw *
</pre></td>
<td class="cellalignment295" headers="r32c1-t20 r1c4-t20">
<pre dir="ltr">OCIRaw *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r33c1-t20" headers="r1c1-t20">
<pre dir="ltr">OCIDATE
</pre></td>
<td class="cellalignment295" headers="r33c1-t20 r1c2-t20">
<pre dir="ltr">OCIDate *
</pre></td>
<td class="cellalignment295" headers="r33c1-t20 r1c3-t20">
<pre dir="ltr">OCIDate *
</pre></td>
<td class="cellalignment295" headers="r33c1-t20 r1c4-t20">
<pre dir="ltr">OCIDate *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r34c1-t20" headers="r1c1-t20">
<pre dir="ltr">OCICOLL
</pre></td>
<td class="cellalignment295" headers="r34c1-t20 r1c2-t20">
<pre dir="ltr">OCIColl * or OCIArray * or OCITable *
</pre></td>
<td class="cellalignment295" headers="r34c1-t20 r1c3-t20">
<pre dir="ltr">OCIColl **
or OCIArray **
or OCITable **
</pre></td>
<td class="cellalignment295" headers="r34c1-t20 r1c4-t20">
<pre dir="ltr">OCIColl ** or OCIArray ** or OCITable **
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r35c1-t20" headers="r1c1-t20">
<pre dir="ltr">OCITYPE
</pre></td>
<td class="cellalignment295" headers="r35c1-t20 r1c2-t20">
<pre dir="ltr">OCIType *
</pre></td>
<td class="cellalignment295" headers="r35c1-t20 r1c3-t20">
<pre dir="ltr">OCIType *
</pre></td>
<td class="cellalignment295" headers="r35c1-t20 r1c4-t20">
<pre dir="ltr">OCIType *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r36c1-t20" headers="r1c1-t20">
<pre dir="ltr">TDO
</pre></td>
<td class="cellalignment295" headers="r36c1-t20 r1c2-t20">
<pre dir="ltr">OCIType *
</pre></td>
<td class="cellalignment295" headers="r36c1-t20 r1c3-t20">
<pre dir="ltr">OCIType *
</pre></td>
<td class="cellalignment295" headers="r36c1-t20 r1c4-t20">
<pre dir="ltr">OCIType *
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r37c1-t20" headers="r1c1-t20">
<pre dir="ltr">ADT
(final types)
</pre></td>
<td class="cellalignment295" headers="r37c1-t20 r1c2-t20">
<pre dir="ltr">dvoid*
</pre></td>
<td class="cellalignment295" headers="r37c1-t20 r1c3-t20">
<pre dir="ltr">dvoid*
</pre></td>
<td class="cellalignment295" headers="r37c1-t20 r1c4-t20">
<pre dir="ltr">dvoid*
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r38c1-t20" headers="r1c1-t20">
<pre dir="ltr">ADT (nonfinal types)
</pre></td>
<td class="cellalignment295" headers="r38c1-t20 r1c2-t20">
<pre dir="ltr">dvoid*
</pre></td>
<td class="cellalignment295" headers="r38c1-t20 r1c3-t20">
<pre dir="ltr">dvoid*
</pre></td>
<td class="cellalignment295" headers="r38c1-t20 r1c4-t20">
<pre dir="ltr">dvoid**
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Composite data types are not self describing. Their description is stored in a <span class="glossaryterm">Type Descriptor Object</span> (TDO). Objects and indicator structs for objects have no predefined OCI data type, but must use the data types generated by Oracle Database&#39;s <span class="glossaryterm">Object</span> <span class="glossaryterm">Type</span> <span class="glossaryterm">Translator</span> (OTT). The optional TDO argument for <code dir="ltr">INDICATOR</code>, and for composite objects, in general, has the C data type, OCIType *.</p>
<p><code dir="ltr">OCICOLL</code> for <code dir="ltr">REF</code> and collection arguments is optional and exists only for completeness. You cannot map a <code dir="ltr">REF</code> or collection type onto any other data type, or any other data type onto a <code dir="ltr">REF</code> or collection type.</p>
</div>
<!-- class="sect2" -->
<a id="g1039282"></a>
<div id="ADFNS728" class="sect2">
<h3 class="sect2"><span class="secnum">18.9.3</span> Passing Parameters BY VALUE or BY REFERENCE</h3>
<p>If you specify <code dir="ltr">BY</code> <code dir="ltr">VALUE</code>, then scalar <code dir="ltr">IN</code> and <code dir="ltr">RETURN</code> arguments are passed by value (which is also the default). Alternatively, you might have them passed by reference by specifying <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>.</p>
<p>By default, or if you specify <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>, then scalar <code dir="ltr">IN</code> <code dir="ltr">OUT</code>, and <code dir="ltr">OUT</code> arguments are passed by reference. Specifying <code dir="ltr">BY</code> <code dir="ltr">VALUE</code> for <code dir="ltr">IN</code> <code dir="ltr">OUT</code>, and <code dir="ltr">OUT</code> arguments is not supported for C. The usefulness of the <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>/<code dir="ltr">VALUE</code> clause is restricted to external data types that are, by default, passed by value. This is true for <code dir="ltr">IN</code>, and <code dir="ltr">RETURN</code> arguments of these external types:</p>
<pre dir="ltr">[UNSIGNED] CHAR
[UNSIGNED] SHORT
[UNSIGNED] INT
[UNSIGNED] LONG
SIZE_T
SB1
SB2
SB4
UB1
UB2
UB4
FLOAT
DOUBLE
</pre>
<p>All <code dir="ltr">IN</code> and <code dir="ltr">RETURN</code> arguments of external types not on this list, all <code dir="ltr">IN</code> <code dir="ltr">OUT</code> arguments, and all <code dir="ltr">OUT</code> arguments are passed by reference.</p>
</div>
<!-- class="sect2" -->
<a id="g1039306"></a>
<div id="ADFNS729" class="sect2">
<h3 class="sect2"><span class="secnum">18.9.4</span> Declaring Formal Parameters</h3>
<p>Generally, the PL/SQL procedure that publishes an external procedure declares a list of formal parameters, as this example shows:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You might need to set up this data structure for examples in this topic to work:
<pre dir="ltr">CREATE LIBRARY MathLib AS &#39;/tmp/math.so&#39;;
</pre></div>
<pre dir="ltr">CREATE OR REPLACE FUNCTION Interp_func (
<span class="italic">/* Find the value of y at x degrees using Lagrange interpolation: */ </span>
   x    IN FLOAT, 
   y    IN FLOAT) 
RETURN FLOAT AS 
   LANGUAGE C
   NAME &#34;Interp_func&#34;
   LIBRARY MathLib;
</pre>
<p>Each formal parameter declaration specifies a name, parameter mode, and PL/SQL data type (which maps to the default external data type). That might be all the information the external procedure needs. If not, then you can provide more information using the <code dir="ltr">PARAMETERS</code> clause, which lets you specify:</p>
<ul>
<li>
<p>Nondefault external data types</p>
</li>
<li>
<p>The current or maximum length of a parameter</p>
</li>
<li>
<p><code dir="ltr">NULL</code>/<code dir="ltr">NOT</code> <code dir="ltr">NULL</code> indicators for parameters</p>
</li>
<li>
<p>Character set IDs and forms</p>
</li>
<li>
<p>The position of parameters in the list</p>
</li>
<li>
<p>How <code dir="ltr">IN</code> parameters are passed (by value or by reference)</p>
</li>
</ul>
<p>If you decide to use the <code dir="ltr">PARAMETERS</code> clause, keep in mind:</p>
<ul>
<li>
<p>For every formal parameter, there must be a corresponding parameter in the <code dir="ltr">PARAMETERS</code> clause.</p>
</li>
<li>
<p>If you include the <code dir="ltr">WITH</code> <code dir="ltr">CONTEXT</code> clause, then you must specify the parameter <code dir="ltr">CONTEXT</code>, which shows the position of the context pointer in the parameter list.</p>
</li>
<li>
<p>If the external procedure is a function, then you might specify the <code dir="ltr">RETURN</code> parameter, but it must be in the last position. If <code dir="ltr">RETURN</code> is not specified, the default external type is used.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="g1039328"></a>
<div id="ADFNS730" class="sect2">
<h3 class="sect2"><span class="secnum">18.9.5</span> Overriding Default Data Type Mapping</h3>
<p>In some cases, you can use the <code dir="ltr">PARAMETERS</code> clause to override the default data type mappings. For example, you can remap the PL/SQL data type <code dir="ltr">BOOLEAN</code> from external data type <code dir="ltr">INT</code> to external data type <code dir="ltr">CHAR</code>.</p>
</div>
<!-- class="sect2" -->
<a id="g1039337"></a>
<div id="ADFNS731" class="sect2">
<h3 class="sect2"><span class="secnum">18.9.6</span> Specifying Properties</h3>
<p>You can also use the <code dir="ltr">PARAMETERS</code> clause to pass more information about PL/SQL formal parameters and function results to an external procedure. Do this by specifying one or more of these properties:</p>
<pre dir="ltr">INDICATOR [{STRUCT | TDO}]
LENGTH
DURATION
MAXLEN
CHARSETID
CHARSETFORM
SELF
</pre>
<p><a href="#g1025084">Table 18-3</a> shows the allowed and the default external data types, PL/SQL data types, and PL/SQL parameter modes allowed for a given property. <code dir="ltr">MAXLEN</code> (used to specify data returned from C back to PL/SQL) cannot be applied to an <code dir="ltr">IN</code> parameter.</p>
<div id="ADFNS732" class="tblformalwide">
<p class="titleintable"><a id="sthref935"></a><a id="g1025084"></a>Table 18-3 Properties and Data Types</p>
<table class="cellalignment296" title=" Properties and Data Types" summary="This table summarizes the properties of the PL/SQL datatypes." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t22">Property</th>
<th class="cellalignment294" id="r1c2-t22">Allowed External Types (C)</th>
<th class="cellalignment294" id="r1c3-t22">Default External Type (C)</th>
<th class="cellalignment294" id="r1c4-t22">Allowed PL/SQL Types</th>
<th class="cellalignment294" id="r1c5-t22">Allowed PL/SQL Modes</th>
<th class="cellalignment294" id="r1c6-t22">Default PL/SQL Passing Method</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t22" headers="r1c1-t22">
<pre dir="ltr">INDICATOR
</pre></td>
<td class="cellalignment295" headers="r2c1-t22 r1c2-t22">
<pre dir="ltr">SHORT
</pre></td>
<td class="cellalignment295" headers="r2c1-t22 r1c3-t22">
<pre dir="ltr">SHORT
</pre></td>
<td class="cellalignment295" headers="r2c1-t22 r1c4-t22">
<pre dir="ltr">all scalars
</pre></td>
<td class="cellalignment295" headers="r2c1-t22 r1c5-t22">
<pre dir="ltr">IN
IN OUT
OUT
RETURN
</pre></td>
<td class="cellalignment295" headers="r2c1-t22 r1c6-t22">
<pre dir="ltr">BY VALUE
BY REFERENCE
BY REFERENCE
BY REFERENCE
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t22" headers="r1c1-t22">
<pre dir="ltr">LENGTH
</pre></td>
<td class="cellalignment295" headers="r3c1-t22 r1c2-t22">
<pre dir="ltr">[UNSIGNED] SHORT
[UNSIGNED] INT
[UNSIGNED] LONG
</pre></td>
<td class="cellalignment295" headers="r3c1-t22 r1c3-t22">
<pre dir="ltr">INT
</pre></td>
<td class="cellalignment295" headers="r3c1-t22 r1c4-t22">
<pre dir="ltr">CHAR
LONG RAW
RAW
VARCHAR2
</pre></td>
<td class="cellalignment295" headers="r3c1-t22 r1c5-t22">
<pre dir="ltr">IN
IN OUT
OUT
RETURN
</pre></td>
<td class="cellalignment295" headers="r3c1-t22 r1c6-t22">
<pre dir="ltr">BY VALUE
BY REFERENCE
BY REFERENCE
BY REFERENCE
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t22" headers="r1c1-t22">
<pre dir="ltr">MAXLEN
</pre></td>
<td class="cellalignment295" headers="r4c1-t22 r1c2-t22">
<pre dir="ltr">[UNSIGNED] SHORT
[UNSIGNED] INT
[UNSIGNED] LONG
</pre></td>
<td class="cellalignment295" headers="r4c1-t22 r1c3-t22">
<pre dir="ltr">INT
</pre></td>
<td class="cellalignment295" headers="r4c1-t22 r1c4-t22">
<pre dir="ltr">CHAR
LONG RAW
RAW
VARCHAR2
</pre></td>
<td class="cellalignment295" headers="r4c1-t22 r1c5-t22">
<pre dir="ltr">IN OUT
OUT
RETURN
</pre></td>
<td class="cellalignment295" headers="r4c1-t22 r1c6-t22">
<pre dir="ltr">BY REFERENCE
BY REFERENCE
BY REFERENCE
</pre></td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t22" headers="r1c1-t22">
<pre dir="ltr">CHARSETID
CHARSETFORM
</pre></td>
<td class="cellalignment295" headers="r5c1-t22 r1c2-t22">
<pre dir="ltr">UNSIGNED SHORT
UNSIGNED INT
UNSIGNED LONG
</pre></td>
<td class="cellalignment295" headers="r5c1-t22 r1c3-t22">
<pre dir="ltr">UNSIGNED INT
</pre></td>
<td class="cellalignment295" headers="r5c1-t22 r1c4-t22">
<pre dir="ltr">CHAR
CLOB
VARCHAR2
</pre></td>
<td class="cellalignment295" headers="r5c1-t22 r1c5-t22">
<pre dir="ltr">IN
IN OUT
OUT
RETURN
</pre></td>
<td class="cellalignment295" headers="r5c1-t22 r1c6-t22">
<pre dir="ltr">BY VALUE
BY REFERENCE
BY REFERENCE
BY REFERENCE
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<p>In this example, the <code dir="ltr">PARAMETERS</code> clause specifies properties for the PL/SQL formal parameters and function result:</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION plsToCparse_func  (
   x   IN PLS_INTEGER,
   Y   IN OUT CHAR) 
RETURN CHAR AS LANGUAGE C
   LIBRARY c_utils 
   NAME &#34;C_parse&#34; 
   PARAMETERS (
      x,            -- stores value of x
      x INDICATOR,  -- stores null status of x 
      y,            -- stores value of y
      y LENGTH,     -- stores current length of y
      y MAXLEN,     -- stores maximum length of y
      RETURN INDICATOR,
      RETURN);
</pre>
<p>With this <code dir="ltr">PARAMETERS</code> clause, the C prototype becomes:</p>
<pre dir="ltr">char  *C_parse( int x, short x_ind, char *y, int *y_len, int *y_maxlen,
  short *retind );
</pre>
<p>The additional parameters in the C prototype correspond to the <code dir="ltr">INDICATOR</code> (for <code dir="ltr">x</code>), <code dir="ltr">LENGTH</code> (of <code dir="ltr">y</code>), and <code dir="ltr">MAXLEN</code> (of <code dir="ltr">y</code>), and the <code dir="ltr">INDICATOR</code> for the function result in the <code dir="ltr">PARAMETERS</code> clause. The parameter <code dir="ltr">RETURN</code> corresponds to the C function identifier, which stores the result value.</p>
<p class="subhead2"><a id="ADFNS1093"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1038898">INDICATOR</a></p>
</li>
<li>
<p><a href="#g1038934">LENGTH and MAXLEN</a></p>
</li>
<li>
<p><a href="#g1038970">CHARSETID and CHARSETFORM</a></p>
</li>
<li>
<p><a href="#g1039009">Repositioning Parameters</a></p>
</li>
<li>
<p><a href="#g1039016">SELF</a></p>
</li>
<li>
<p><a href="#g1039036">BY REFERENCE</a></p>
</li>
<li>
<p><a href="#g1038877">WITH CONTEXT</a></p>
</li>
<li>
<p><a href="#g1039060">Interlanguage Parameter Mode Mappings</a></p>
</li>
</ul>
<a id="g1038898"></a>
<div id="ADFNS733" class="sect3">
<h4 class="sect3"><span class="secnum">18.9.6.1</span> INDICATOR</h4>
<p>An <code dir="ltr">INDICATOR</code> is a parameter whose value indicates whether another parameter is <code dir="ltr">NULL</code>. PL/SQL does not need indicators, because the RDBMS concept of nullity is built into the language. However, an external procedure might need to determine if a parameter or function result is <code dir="ltr">NULL</code>. Also, an external procedure might need to signal the server that a returned value is <code dir="ltr">NULL</code>, and must be treated accordingly.</p>
<p>In such cases, you can use the property <code dir="ltr">INDICATOR</code> to associate an indicator with a formal parameter. If the PL/SQL procedure is a function, then you can also associate an indicator with the function result, as shown in <a href="#g1039337">Section 18.9.6, &#34;Specifying Properties.&#34;</a></p>
<p>To check the value of an indicator, you can use the constants <code dir="ltr">OCI_IND_NULL</code> and <code dir="ltr">OCI_IND_NOTNULL</code>. If the indicator equals <code dir="ltr">OCI_IND_NULL</code>, then the associated parameter or function result is <code dir="ltr">NULL</code>. If the indicator equals <code dir="ltr">OCI_IND_NOTNULL</code>, then the parameter or function result is not <code dir="ltr">NULL</code>.</p>
<p>For <code dir="ltr">IN</code> parameters, which are inherently read-only, <code dir="ltr">INDICATOR</code> is passed by value (unless you specify <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>) and is read-only (even if you specify <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>). For <code dir="ltr">OUT</code>, <code dir="ltr">IN</code> <code dir="ltr">OUT</code>, and <code dir="ltr">RETURN</code> parameters, <code dir="ltr">INDICATOR</code> is passed by reference by default.</p>
<p>The <code dir="ltr">INDICATOR</code> can also have a <code dir="ltr">STRUCT</code> or TDO option. Because specifying <code dir="ltr">INDICATOR</code> as a property of an object is not supported, and because arguments of objects have complete indicator structs instead of <code dir="ltr">INDICATOR</code> scalars, you must specify this by using the <code dir="ltr">STRUCT</code> option. You must use the type descriptor object (TDO) option for composite objects and collections,</p>
</div>
<!-- class="sect3" -->
<a id="g1038934"></a>
<div id="ADFNS734" class="sect3">
<h4 class="sect3"><span class="secnum">18.9.6.2</span> LENGTH and MAXLEN</h4>
<p>In PL/SQL, there is no standard way to indicate the length of a <code dir="ltr">RAW</code> or string parameter. However, you might want to pass the length of such a parameter to and from an external procedure. Using the properties <code dir="ltr">LENGTH</code> and <code dir="ltr">MAXLEN</code>, you can specify parameters that store the current length and maximum length of a formal parameter.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
With a parameter of type <code dir="ltr">RAW</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, you must use the property <code dir="ltr">LENGTH</code>. Also, if that parameter is <code dir="ltr">IN</code> <code dir="ltr">OUT</code> and <code dir="ltr">NULL</code> or <code dir="ltr">OUT</code> and <code dir="ltr">NULL</code>, then you must set the length of the corresponding C parameter to zero.</div>
<p>For <code dir="ltr">IN</code> parameters, <code dir="ltr">LENGTH</code> is passed by value (unless you specify <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>) and is read-only. For <code dir="ltr">OUT</code>, <code dir="ltr">IN</code> <code dir="ltr">OUT</code>, and <code dir="ltr">RETURN</code> parameters, <code dir="ltr">LENGTH</code> is passed by reference.</p>
<p><code dir="ltr">MAXLEN</code> does not apply to <code dir="ltr">IN</code> parameters. For <code dir="ltr">OUT</code>, <code dir="ltr">IN</code> <code dir="ltr">OUT</code>, and <code dir="ltr">RETURN</code> parameters, <code dir="ltr">MAXLEN</code> is passed by reference and is read-only.</p>
</div>
<!-- class="sect3" -->
<a id="g1038970"></a>
<div id="ADFNS735" class="sect3">
<h4 class="sect3"><span class="secnum">18.9.6.3</span> CHARSETID and CHARSETFORM</h4>
<p>Oracle Database provides globalization support, which lets you process single-byte and multibyte character data and convert between character sets. It also lets your applications run in different language environments.</p>
<p>By default, if the server and agent use the exact same <code dir="ltr">$ORACLE_HOME</code> value, the agent uses the same globalization support settings as the server (including any settings that were specified with <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statements).</p>
<p>If the agent is running in a separate <code dir="ltr">$ORACLE_HOME</code> (even if the same location is specified by two different aliases or symbolic links), the agent uses the same globalization support settings as the server except for the character set; the default character set for the agent is defined by the <code dir="ltr">NLS_LANG</code> and <code dir="ltr">NLS_NCHAR</code> environment settings for the agent.</p>
<p>The properties <code dir="ltr">CHARSETID</code> and <code dir="ltr">CHARSETFORM</code> identify the nondefault character set from which the character data being passed was formed. With <code dir="ltr">CHAR</code>, <code dir="ltr">CLOB</code>, and <code dir="ltr">VARCHAR2</code> parameters, you can use <code dir="ltr">CHARSETID</code> and <code dir="ltr">CHARSETFORM</code> to pass the character set ID and form to the external procedure.</p>
<p>For <code dir="ltr">IN</code> parameters, <code dir="ltr">CHARSETID</code> and <code dir="ltr">CHARSETFORM</code> are passed by value (unless you specify <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>) and are read-only (even if you specify <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code>). For <code dir="ltr">OUT</code>, <code dir="ltr">IN</code> <code dir="ltr">OUT</code>, and <code dir="ltr">RETURN</code> parameters, <code dir="ltr">CHARSETID</code> and <code dir="ltr">CHARSETFORM</code> are passed by reference and are read-only.</p>
<p>The OCI attribute names for these properties are <code dir="ltr">OCI_ATTR_CHARSET_ID</code> and <code dir="ltr">OCI_ATTR_CHARSET_FORM</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNOCI050" href="../LNOCI/oci05bnd.htm#LNOCI050"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for more information about <code dir="ltr">OCI_ATTR_CHARSET_ID</code> and <code dir="ltr">OCI_ATTR_CHARSET_FORM</code></p>
</li>
<li>
<p><a class="olink NLSPG465" href="../NLSPG/ch11charsetmig.htm#NLSPG465"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information about using national language data with the OCI</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="g1039009"></a>
<div id="ADFNS736" class="sect3">
<h4 class="sect3"><span class="secnum">18.9.6.4</span> Repositioning Parameters</h4>
<p>Remember, each formal parameter of the external procedure must have a corresponding parameter in the <code dir="ltr">PARAMETERS</code> clause. Their positions can differ, because PL/SQL associates them by name, not by position. However, the <code dir="ltr">PARAMETERS</code> clause and the C prototype for the external procedure must have the same number of parameters, and they must be in the same order.</p>
</div>
<!-- class="sect3" -->
<a id="g1039016"></a>
<div id="ADFNS737" class="sect3">
<h4 class="sect3"><span class="secnum">18.9.6.5</span> SELF</h4>
<p><code dir="ltr">SELF</code> is the always-present argument of an object type&#39;s member procedure, namely the object instance itself. In most cases, this argument is implicit and is not listed in the argument list of the PL/SQL procedure. However, <code dir="ltr">SELF</code> must be explicitly specified as an argument of the <code dir="ltr">PARAMETERS</code> clause.</p>
<p>For example, assume that you want to create a <code dir="ltr">Person</code> object, consisting of a person&#39;s name and date of birth, and then create a table of this object type. You eventually want to determine the age of each <code dir="ltr">Person</code> object in this table.</p>
<ol>
<li>
<p>In SQL*Plus, the <code dir="ltr">Person</code> object type can be created by:</p>
<pre dir="ltr">CREATE OR REPLACE TYPE Person1_typ AS OBJECT (
  Name_     VARCHAR2(30),
  B_date    DATE,
  MEMBER FUNCTION calcAge_func RETURN NUMBER
);
/
</pre></li>
<li>
<p>Declare the body of the member function as follows:</p>
<pre dir="ltr">CREATE OR REPLACE TYPE BODY Person1_typ AS
  MEMBER FUNCTION calcAge_func RETURN NUMBER
  AS LANGUAGE C
  NAME &#34;age&#34;
  LIBRARY agelib
  WITH CONTEXT
  PARAMETERS (
    CONTEXT,
    SELF,
    SELF INDICATOR STRUCT,
    SELF TDO,
    RETURN INDICATOR
  );
END;
/
</pre>
<p>(Typically, the member function is implemented in PL/SQL, but in this example it is an external procedure.)</p>
<p>The <code dir="ltr">calcAge_func</code> member function takes no arguments and returns a number. A member function is always called on an instance of the associated object type. The object instance itself always is an implicit argument of the member function. To refer to the implicit argument, the <code dir="ltr">SELF</code> keyword is used. This is incorporated into the external procedure syntax by supporting references to <code dir="ltr">SELF</code> in the parameters clause.</p>
</li>
<li>
<p>Create and populate the matching table.</p>
<pre dir="ltr">CREATE TABLE Person_tab OF Person1_typ;

INSERT INTO Person_tab
VALUES (&#39;BOB&#39;, TO_DATE(&#39;14-MAY-85&#39;));

INSERT INTO Person_tab
VALUES (&#39;JOHN&#39;, TO_DATE(&#39;22-DEC-71&#39;));
</pre></li>
<li>
<p>Retrieve the information of interest from the table.</p>
<pre dir="ltr">SELECT p.name, p.b_date, p.calcAge_func() FROM Person_tab p; 

NAME                           B_DATE    P.CALCAGE_ 
------------------------------ --------- ---------- 
BOB                            14-MAY-85          0 
JOHN                           22-DEC-71          0
 
</pre></li>
</ol>
<p>This is sample C code that implements the <code dir="ltr">external</code> member function and the Object-Type-Translator (OTT)-generated <code dir="ltr">struct</code> definitions:</p>
<pre dir="ltr">#include &lt;oci.h&gt;

struct PERSON 
{ 
    OCIString   *NAME; 
    OCIDate      B_DATE; 
}; 
typedef struct PERSON PERSON; 
 
struct PERSON_ind 
{ 
    OCIInd    _atomic; 
    OCIInd    NAME; 
    OCIInd    B_DATE; 
}; 
typedef struct PERSON_ind PERSON_ind; 
 
OCINumber *age (ctx, person_obj, person_obj_ind, tdo, ret_ind) 
OCIExtProcContext *ctx; 
PERSON         *person_obj; 
PERSON_ind     *person_obj_ind; 
OCIType        *tdo; 
OCIInd         *ret_ind; 
{ 
    sword      err; 
    text       errbuf[512]; 
    OCIEnv    *envh; 
    OCISvcCtx *svch; 
    OCIError  *errh; 
    OCINumber *age; 
    int        inum = 0;
    sword      status;
  
<span class="italic">    /* get OCI Environment */</span>
    err = OCIExtProcGetEnv( ctx, &amp;envh, &amp;svch, &amp;errh ); 

<span class="italic">    /* initialize return age to 0 */</span>
    age = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
    status = OCINumberFromInt(errh, &amp;inum, sizeof(inum), OCI_NUMBER_SIGNED,
                              age);
    if (status != OCI_SUCCESS)
    {
      OCIExtProcRaiseExcp(ctx, (int)1476);
      return (age);
    }

<span class="italic">    /* return NULL if the person object is null or the birthdate is null */</span>
    if ( person_obj_ind-&gt;_atomic == OCI_IND_NULL || 
         person_obj_ind-&gt;B_DATE  == OCI_IND_NULL ) 
    { 
        *ret_ind = OCI_IND_NULL;
        return (age); 
    } 

<span class="italic">    /* The actual implementation to calculate the age is left to the reader,</span>
<span class="italic">       but an easy way of doing this is a callback of the form:</span>
<span class="italic">            select trunc(months_between(sysdate, person_obj-&gt;b_date) / 12) </span>
<span class="italic">            from DUAL;   </span>
<span class="italic">    */ </span>
    *ret_ind = OCI_IND_NOTNULL;
    return (age);
} 
</pre></div>
<!-- class="sect3" -->
<a id="g1039036"></a>
<div id="ADFNS738" class="sect3">
<h4 class="sect3"><span class="secnum">18.9.6.6</span> BY REFERENCE</h4>
<p>In C, you can pass <code dir="ltr">IN</code> scalar parameters by value (the value of the parameter is passed) or by reference (a pointer to the value is passed). When an external procedure expects a pointer to a scalar, specify <code dir="ltr">BY</code> <code dir="ltr">REFERENCE</code> phrase to pass the parameter by reference:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE findRoot_proc (
   x IN DOUBLE PRECISION)
AS LANGUAGE C
   LIBRARY c_utils
   NAME &#34;C_findRoot&#34;
   PARAMETERS (
      x BY REFERENCE);
</pre>
<p>In this case, the C prototype is:</p>
<pre dir="ltr">void C_findRoot(double *x);
</pre>
<p>The default (used when there is no <code dir="ltr">PARAMETERS</code> clause) is:</p>
<pre dir="ltr">void C_findRoot(double x);
</pre></div>
<!-- class="sect3" -->
<div id="ADFNS739" class="sect3"><a id="sthref936"></a>
<h4 class="sect3"><span class="secnum">18.9.6.7</span> WITH CONTEXT</h4>
<p>By including the <code dir="ltr">WITH</code> <code dir="ltr">CONTEXT</code> clause, you can give an external procedure access to information about parameters, exceptions, memory allocation, and the user environment. The <code dir="ltr">WITH</code> <code dir="ltr">CONTEXT</code> clause specifies that a context pointer is passed to the external procedure. For example, if you write this PL/SQL function:</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION getNum_func (
   x IN REAL) 
RETURN PLS_INTEGER AS LANGUAGE C
   LIBRARY c_utils
   NAME &#34;C_getNum&#34;
   WITH CONTEXT
   PARAMETERS (
      CONTEXT,
      x BY REFERENCE,
      RETURN INDICATOR);
</pre>
<p>The C prototype is:</p>
<pre dir="ltr">int C_getNum(
   OCIExtProcContext *with_context, 
   float *x, 
   short *retind);
</pre>
<p>The context data structure is opaque to the external procedure; but, is available to service procedures called by the external procedure.</p>
<p>If you also include the <code dir="ltr">PARAMETERS</code> clause, then you must specify the parameter <code dir="ltr">CONTEXT</code>, which shows the position of the context pointer in the parameter list. If you omit the <code dir="ltr">PARAMETERS</code> clause, then the context pointer is the first parameter passed to the external procedure.</p>
</div>
<!-- class="sect3" -->
<a id="g1039060"></a>
<div id="ADFNS740" class="sect3">
<h4 class="sect3"><span class="secnum">18.9.6.8</span> Interlanguage Parameter Mode Mappings</h4>
<p>PL/SQL supports the <code dir="ltr">IN</code>, <code dir="ltr">IN</code> <code dir="ltr">OUT</code>, and <code dir="ltr">OUT</code> parameter modes, and the <code dir="ltr">RETURN</code> clause for procedures returning values.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007572"></a>
<div id="ADFNS1410" class="sect1">
<h2 class="sect1"><span class="secnum">18.10</span> Running External Procedures with CALL Statements</h2>
<p><a id="sthref937"></a><a id="sthref938"></a>Now that you have published your Java class method or external C procedure, you are ready to call it.</p>
<p>Do not call an external procedure directly. Instead, use the <code dir="ltr">CALL</code> statement to call the PL/SQL procedure that published the external procedure. See <a href="#i1021529">Section 18.10.2, &#34;CALL Statement Syntax.&#34;</a></p>
<p>Such calls, which you code in the same manner as a call to a regular PL/SQL procedure, can appear in:</p>
<ul>
<li>
<p>Anonymous blocks</p>
</li>
<li>
<p>Standalone and package procedures</p>
</li>
<li>
<p>Methods of an object type</p>
</li>
<li>
<p>Database triggers</p>
</li>
<li>
<p>SQL statements (calls to package functions only).</p>
</li>
</ul>
<p>Any PL/SQL block or procedure running on the server side, or on the client side, (for example, in a tool such as Oracle Forms) can call an external procedure. On the server side, the external procedure runs in a separate process address space, which safeguards your database. <a href="#i1007591">Figure 18-1</a> shows how Oracle Database and external procedures interact.</p>
<div id="ADFNS741" class="figure">
<p class="titleinfigure"><a id="i1007591"></a>Figure 18-1 Oracle Database and External Procedures</p>
<img width="452" height="190" src="img/adfns063.gif" alt="Description of Figure 18-1 follows"/><br/>
<a id="sthref939" href="img_text/adfns063.htm">Description of &#39;&#39;Figure 18-1 Oracle Database and External Procedures&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead2"><a id="ADFNS1094"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1039500">Preconditions for External Procedures</a></p>
</li>
<li>
<p><a href="#i1021529">CALL Statement Syntax</a></p>
</li>
<li>
<p><a href="#g1039546">Calling Java Class Methods</a></p>
</li>
<li>
<p><a href="#g1039557">Calling External C Procedures</a></p>
</li>
</ul>
<a id="g1039500"></a>
<div id="ADFNS742" class="sect2">
<h3 class="sect2"><span class="secnum">18.10.1</span> Preconditions for External Procedures</h3>
<p>Before calling external procedures, consider the privileges, permissions, and synonyms that exist in the execution environment.</p>
<p class="subhead2"><a id="ADFNS1095"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1039070">Privileges of External Procedures</a></p>
</li>
<li>
<p><a href="#g1039077">Managing Permissions</a></p>
</li>
<li>
<p><a href="#g1039086">Creating Synonyms for External Procedures</a></p>
</li>
</ul>
<a id="g1039070"></a>
<div id="ADFNS743" class="sect3">
<h4 class="sect3"><span class="secnum">18.10.1.1</span> Privileges of External Procedures</h4>
<p>When external procedures are called through <code dir="ltr">CALL</code> specifications, they run with definer&#39;s privileges, rather than invoker privileges.</p>
<p>A program running with invoker privileges is not bound to a particular schema. It runs at the calling site and accesses database items (such as tables and views) with the caller&#39;s visibility and permissions. However, a program running with definer&#39;s privileges is bound to the schema in which it is defined. It runs at the defining site, in the definer&#39;s schema, and accesses database items with the definer&#39;s visibility and permissions.</p>
</div>
<!-- class="sect3" -->
<a id="g1039077"></a>
<div id="ADFNS744" class="sect3">
<h4 class="sect3"><span class="secnum">18.10.1.2</span> Managing Permissions</h4>
<p>To call an external procedure, a user must have the <code dir="ltr">EXECUTE</code> privilege on its call specification. To grant this privilege, use the SQL statement <code dir="ltr">GRANT</code> (described in <a class="olink SQLRF01603" href="../SQLRF/statements_9014.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a>). For example, this statement allows the user johndoe to call the external procedure whose call specification is <code dir="ltr">plsToJ_demoExternal_proc</code>:</p>
<pre dir="ltr">GRANT EXECUTE ON plsToJ_demoExternal_proc TO johndoe;
</pre>
<p>Grant the <code dir="ltr">EXECUTE</code> privilege on a call specification only to users who must call the procedure.</p>
</div>
<!-- class="sect3" -->
<a id="g1039086"></a>
<div id="ADFNS745" class="sect3">
<h4 class="sect3"><span class="secnum">18.10.1.3</span> Creating Synonyms for External Procedures</h4>
<p>For convenience, you or your DBA can create synonyms for external procedures using the <code dir="ltr">CREATE</code> <code dir="ltr">PUBLIC</code> <code dir="ltr">SYNONYM</code> statement. In this example, your DBA creates a public synonym, which is accessible to all users. If <code dir="ltr">PUBLIC</code> is not specified, then the synonym is private and accessible only within its schema.</p>
<pre dir="ltr">CREATE PUBLIC SYNONYM Rfac FOR johndoe.RecursiveFactorial;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1021529"></a>
<div id="ADFNS746" class="sect2">
<h3 class="sect2"><span class="secnum">18.10.2</span> CALL Statement Syntax</h3>
<p>Call the external procedure through the SQL <code dir="ltr">CALL</code> statement. You can run the <code dir="ltr">CALL</code> statement interactively from SQL*Plus. The syntax is:</p>
<pre dir="ltr">CALL [schema.][{object_type_name | package_name}]procedure_name[@dblink_name]
   [(parameter_list)] [INTO :host_variable][INDICATOR][:indicator_variable];
</pre>
<p>This is equivalent to running a procedure <code dir="ltr">myproc</code> using a SQL statement of the form &#34;<code dir="ltr">SELECT</code> <code dir="ltr">myproc(</code>...<code dir="ltr">)</code> <code dir="ltr">FROM</code> <code dir="ltr">DUAL</code>,&#34; except that the overhead associated with performing the <code dir="ltr">SELECT</code> is not incurred.</p>
<p>For example, here is an anonymous PL/SQL block that uses dynamic SQL to call <code dir="ltr">plsToC_demoExternal_proc</code>, which you published. PL/SQL passes three parameters to the external C procedure <code dir="ltr">C_demoExternal_proc</code>.</p>
<pre dir="ltr">DECLARE
   xx NUMBER(4);
   yy VARCHAR2(10);
   zz DATE; 
 BEGIN 
 EXECUTE IMMEDIATE
 &#39;CALL plsToC_demoExternal_proc(:xxx, :yyy, :zzz)&#39; USING xx,yy,zz;
 END;
</pre>
<p>The semantics of the <code dir="ltr">CALL</code> statement are identical to the that of an equivalent <code dir="ltr">BEGIN</code> <code dir="ltr">END</code> block.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">CALL</code> is the only SQL statement that cannot be put, by itself, in a PL/SQL <code dir="ltr">BEGIN</code> <code dir="ltr">END</code> block. It can be part of an <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement within a <code dir="ltr">BEGIN</code> <code dir="ltr">END</code> block.</div>
</div>
<!-- class="sect2" -->
<a id="g1039546"></a>
<div id="ADFNS747" class="sect2">
<h3 class="sect2"><span class="secnum">18.10.3</span> Calling Java Class Methods</h3>
<p><a id="sthref940"></a>To call the <code dir="ltr">J_calcFactorial</code> class method published in <a href="#i1006482">Section 18.6, &#34;Publishing Java Class Methods&#34;</a>:</p>
<ol>
<li>
<p>Declare and initialize two SQL*Plus host variables:</p>
<pre dir="ltr">VARIABLE x NUMBER
VARIABLE y NUMBER
EXECUTE :x := 5;
</pre></li>
<li>
<p>Call <code dir="ltr">J_calcFactorial</code>:</p>
<pre dir="ltr">CALL J_calcFactorial(:x) INTO :y;
PRINT y
</pre></li>
</ol>
<p>Result:</p>
<pre dir="ltr">Y
------
   120
</pre></div>
<!-- class="sect2" -->
<a id="g1039557"></a>
<div id="ADFNS748" class="sect2">
<h3 class="sect2"><span class="secnum">18.10.4</span> Calling External C Procedures</h3>
<p><a id="sthref941"></a>To call an external C procedure, PL/SQL must find the path of the appropriate DLL. The PL/SQL engine retrieves the path from the data dictionary, based on the library alias from the <code dir="ltr">AS</code> <code dir="ltr">LANGUAGE</code> clause of the procedure declaration.</p>
<p>Next, PL/SQL alerts a Listener process which, in turn, spawns a session-specific agent. By default, this agent is named <code dir="ltr">extproc</code>, although you can specify other names in the <code dir="ltr">listener</code>.<code dir="ltr">ora</code> file. The Listener hands over the connection to the agent, and PL/SQL passes to the agent the name of the DLL, the name of the external procedure, and any parameters.</p>
<p>Then, the agent loads the DLL and runs the external procedure. Also, the agent handles service calls (such as raising an exception) and callbacks to Oracle Database. Finally, the agent passes to PL/SQL any values returned by the external procedure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although some DLL caching takes place, your DLL might not remain in the cache; therefore, do not store global variables in your DLL.</div>
<p>After the external procedure completes, the agent remains active throughout your Oracle Database session; when you log off, the agent is stopped. Consequently, you incur the cost of launching the agent only once, no matter how many calls you make. Still, call an external procedure only when the computational benefits outweigh the cost.</p>
<p>Here, you call PL/SQL function <code dir="ltr">plsCallsCdivisor_func</code>, which you published in <a href="#i1006510">Section 18.7, &#34;Publishing External C Procedures&#34;</a>, from an anonymous block. PL/SQL passes the two integer parameters to external function <code dir="ltr">Cdivisor_func</code>, which returns their greatest common divisor.</p>
<pre dir="ltr">DECLARE
   g    PLS_INTEGER;
   a    PLS_INTEGER;
   b    PLS_INTEGER;
CALL plsCallsCdivisor_func(a, b); 
IF g IN (2,4,8) THEN ... 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007710"></a>
<div id="ADFNS1411" class="sect1">
<h2 class="sect1"><span class="secnum">18.11</span> Handling Errors and Exceptions in Multilanguage Programs</h2>
<p><a id="sthref942"></a><a id="sthref943"></a>The PL/SQL compiler raises compile-time exceptions if an <code dir="ltr">AS</code> <code dir="ltr">EXTERNAL</code> call specification is found in a <code dir="ltr">TYPE</code> or <code dir="ltr">PACKAGE</code> specification.</p>
<p>C programs can raise exceptions through the <code dir="ltr">OCIExtproc</code> functions.</p>
</div>
<!-- class="sect1" -->
<a id="i1007728"></a>
<div id="ADFNS1412" class="sect1">
<h2 class="sect1"><span class="secnum">18.12</span> Using Service Routines with External C Procedures</h2>
<p><a id="sthref944"></a><a id="sthref945"></a>When called from an external procedure, a <span class="bold">service routine</span> can raise exceptions, allocate memory, and call OCI handles for callbacks to the server. To use a service routine, you must specify the <code dir="ltr">WITH</code> <code dir="ltr">CONTEXT</code> clause, which lets you pass a context structure to the external procedure. The context structure is declared in header file <code dir="ltr">ociextp</code>.<code dir="ltr">h</code> as follows:</p>
<pre dir="ltr">typedef struct OCIExtProcContext OCIExtProcContext;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">ociextp.h</code> is located in <code dir="ltr">$ORACLE_HOME/plsql/public</code> on Linux and UNIX.</div>
<p>Service procedures:</p>
<ul>
<li>
<p><a href="#g1683024">OCIExtProcAllocCallMemory</a></p>
</li>
<li>
<p><a href="#g1683108">OCIExtProcRaiseExcp</a></p>
</li>
<li>
<p><a href="#g1683120">OCIExtProcRaiseExcpWithMsg</a></p>
</li>
</ul>
<a id="g1683024"></a>
<div id="ADFNS749" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.12.1</span> OCIExtProcAllocCallMemory</h3>
<p>The <code dir="ltr">OCIExtProcAllocCallMemory</code> service routine allocates <span class="italic">n</span> bytes of memory for the duration of the external procedure call. Any memory allocated by the function is freed automatically as soon as control returns to PL/SQL.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not have the external procedure call the C function <code dir="ltr">free</code> to free memory allocated by this service routine, as this is handled automatically.</div>
<p>The C prototype for this function is as follows:</p>
<pre dir="ltr">dvoid *OCIExtProcAllocCallMemory(
   OCIExtProcContext *with_context, 
   size_t amount);
</pre>
<p>The parameters <code dir="ltr">with_context</code> and <code dir="ltr">amount</code> are the context pointer and number of bytes to allocate, respectively. The function returns an untyped pointer to the allocated memory. A return value of zero indicates failure.</p>
<p>In SQL*Plus, suppose you publish external function <code dir="ltr">plsToC_concat_func</code>, as follows:</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION plsToC_concat_func ( 
   str1 IN VARCHAR2,  
   str2 IN VARCHAR2)  
RETURN VARCHAR2 AS LANGUAGE C 
NAME &#34;concat&#34; 
LIBRARY stringlib 
WITH CONTEXT 
PARAMETERS ( 
CONTEXT,  
str1   STRING,  
str1   INDICATOR short,  
str2   STRING,  
str2   INDICATOR short,  
RETURN INDICATOR short,  
RETURN LENGTH short,  
RETURN STRING); 
</pre>
<p>When called, <code dir="ltr">C_concat</code> concatenates two strings, then returns the result:</p>
<pre dir="ltr">select plsToC_concat_func(&#39;hello &#39;, &#39;world&#39;) from DUAL; 
PLSTOC_CONCAT_FUNC(&#39;HELLO&#39;,&#39;WORLD&#39;) 
-----------------------------------------------------------------------------
hello world
</pre>
<p>If either string is <code dir="ltr">NULL</code>, the result is also <code dir="ltr">NULL</code>. As this example shows, <code dir="ltr">C_concat</code> uses <code dir="ltr">OCIExtProcAllocCallMemory</code> to allocate memory for the result string:</p>
<pre dir="ltr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;oci.h&gt;
#include &lt;ociextp.h&gt;

char *concat(ctx, str1, str1_i, str2, str2_i, ret_i, ret_l) 
OCIExtProcContext *ctx; 
char   *str1; 
short  str1_i; 
char   *str2; 
short  str2_i; 
short  *ret_i; 
short  *ret_l; 
{ 
  char *tmp; 
  short len; 
<span class="italic">  /* Check for null inputs. */ </span>
  if ((str1_i == OCI_IND_NULL) || (str2_i == OCI_IND_NULL)) 
  { 
      *ret_i = (short)OCI_IND_NULL; 
<span class="italic">      /* PL/SQL has no notion of a NULL ptr, so return a zero-byte string. */  </span>
      tmp = OCIExtProcAllocCallMemory(ctx, 1);  
      tmp[0] = &#39;\0&#39;;  
      return(tmp);  
  } 
<span class="italic">  /* Allocate memory for result string, including NULL terminator. */ </span>
  len = strlen(str1) + strlen(str2); 
  tmp = OCIExtProcAllocCallMemory(ctx, len + 1); 
 
  strcpy(tmp, str1); 
  strcat(tmp, str2); 
 
<span class="italic">  /* Set NULL indicator and length. */ </span>
  *ret_i = (short)OCI_IND_NOTNULL; 
  *ret_l = len; 
  /* Return pointer, which PL/SQL frees later. */ 
  return(tmp); 
} 

#ifdef LATER
static void checkerr (/*_ OCIError *errhp, sword status _*/);

void checkerr(errhp, status)
OCIError *errhp;
sword status;
{
  text errbuf[512];
  sb4 errcode = 0;

  switch (status)
  {
  case OCI_SUCCESS:
    break;
  case OCI_SUCCESS_WITH_INFO:
    (void) printf(&#34;Error - OCI_SUCCESS_WITH_INFO\n&#34;);
    break;
  case OCI_NEED_DATA:
    (void) printf(&#34;Error - OCI_NEED_DATA\n&#34;);
    break;
  case OCI_NO_DATA:
    (void) printf(&#34;Error - OCI_NODATA\n&#34;);
    break;
  case OCI_ERROR:
    (void) OCIErrorGet((dvoid *)errhp, (ub4) 1, (text *) NULL, &amp;errcode,
                        errbuf, (ub4) sizeof(errbuf), OCI_HTYPE_ERROR);
    (void) printf(&#34;Error - %.*s\n&#34;, 512, errbuf);
    break;
  case OCI_INVALID_HANDLE:
    (void) printf(&#34;Error - OCI_INVALID_HANDLE\n&#34;);
    break;
  case OCI_STILL_EXECUTING:
    (void) printf(&#34;Error - OCI_STILL_EXECUTE\n&#34;);
    break;
  case OCI_CONTINUE:
    (void) printf(&#34;Error - OCI_CONTINUE\n&#34;);
    break;
  default:
    break;
  }
}

char *concat(ctx, str1, str1_i, str2, str2_i, ret_i, ret_l)
OCIExtProcContext *ctx;
char   *str1;
short  str1_i;
char   *str2;
short  str2_i;
short  *ret_i;
short  *ret_l;
{
  char *tmp;
  short len;
<span class="italic">  /* Check for null inputs. */</span>
  if ((str1_i == OCI_IND_NULL) || (str2_i == OCI_IND_NULL))
  {
      *ret_i = (short)OCI_IND_NULL;
      /* PL/SQL has no notion of a NULL ptr, so return a zero-byte string. */ 
      tmp = OCIExtProcAllocCallMemory(ctx, 1); 
      tmp[0] = &#39;\0&#39;; 
      return(tmp); 
  }
<span class="italic">  /* Allocate memory for result string, including NULL terminator. */</span>
  len = strlen(str1) + strlen(str2);
  tmp = OCIExtProcAllocCallMemory(ctx, len + 1);

  strcpy(tmp, str1);
  strcat(tmp, str2);

<span class="italic">  /* Set NULL indicator and length. */</span>
  *ret_i = (short)OCI_IND_NOTNULL;
  *ret_l = len;
<span class="italic">  /* Return pointer, which PL/SQL frees later. */</span>
  return(tmp);
}

/*======================================================================*/
int main(char *argv, int argc)
{
  OCIExtProcContext *ctx;
  char           *str1;
  short          str1_i;
  char           *str2;
  short          str2_i;
  short          *ret_i;
  short          *ret_l;
<span class="italic">  /* OCI Handles */</span>
  OCIEnv        *envhp;
  OCIServer     *srvhp;
  OCISvcCtx     *svchp;
  OCIError      *errhp;
  OCISession    *authp;
  OCIStmt       *stmthp;
  OCILobLocator *clob, *blob;
  OCILobLocator *Lob_loc;

<span class="italic">  /* Initialize and Logon */</span>
  (void) OCIInitialize((ub4) OCI_DEFAULT, (dvoid *)0,
                       (dvoid * (*)(dvoid *, size_t)) 0,
                       (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                       (void (*)(dvoid *, dvoid *)) 0 );

  (void) OCIEnvInit( (OCIEnv **) &amp;envhp, 
                    OCI_DEFAULT, (size_t) 0, 
                    (dvoid **) 0 );

  (void) OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;errhp, OCI_HTYPE_ERROR, 
                   (size_t) 0, (dvoid **) 0);

<span class="italic">  /* Server contexts */</span>
  (void) OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;srvhp, OCI_HTYPE_SERVER,
                   (size_t) 0, (dvoid **) 0);

<span class="italic">  /* Service context */</span>
  (void) OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;svchp, OCI_HTYPE_SVCCTX,
                   (size_t) 0, (dvoid **) 0);

<span class="italic">  /* Attach to Oracle Database */</span>
  (void) OCIServerAttach( srvhp, errhp, (text *)&#34;&#34;, strlen(&#34;&#34;), 0);

<span class="italic">  /* Set attribute server context in the service context */</span>
  (void) OCIAttrSet ((dvoid *) svchp, OCI_HTYPE_SVCCTX, 
                     (dvoid *)srvhp, (ub4) 0,
                    OCI_ATTR_SERVER, (OCIError *) errhp);

  (void) OCIHandleAlloc((dvoid *) envhp, 
                        (dvoid **)&amp;authp, (ub4) OCI_HTYPE_SESSION,
                        (size_t) 0, (dvoid **) 0);
 
  (void) OCIAttrSet((dvoid *) authp, (ub4) OCI_HTYPE_SESSION,
                 (dvoid *) &#34;samp&#34;, (ub4)4,
                 (ub4) OCI_ATTR_USERNAME, errhp);
 
  (void) OCIAttrSet((dvoid *) authp, (ub4) OCI_HTYPE_SESSION,
                 (dvoid *) &#34;<span class="italic">password</span>&#34;, (ub4) 4,
                 (ub4) OCI_ATTR_PASSWORD, errhp);

<span class="italic">  /* Begin a User Session */</span>
  checkerr(errhp, OCISessionBegin ( svchp,  errhp, authp, OCI_CRED_RDBMS, 
                          (ub4) OCI_DEFAULT));

  (void) OCIAttrSet((dvoid *) svchp, (ub4) OCI_HTYPE_SVCCTX,
                   (dvoid *) authp, (ub4) 0,
                   (ub4) OCI_ATTR_SESSION, errhp);

<span class="italic">  /* -----------------------User Logged In------------------------------*/</span>
  printf (&#34;user logged in \n&#34;);

  /* allocate a statement handle */
  checkerr(errhp, OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;stmthp,
           OCI_HTYPE_STMT, (size_t) 0, (dvoid **) 0));

  checkerr(errhp, OCIDescriptorAlloc((dvoid *)envhp, (dvoid **) &amp;Lob_loc, 
                                     (ub4) OCI_DTYPE_LOB, 
                                     (size_t) 0, (dvoid **) 0)); 

<span class="italic">  /* ------- subprogram called  here-----------------------*/ </span>
  printf (&#34;calling concat...\n&#34;);
  concat(ctx, str1, str1_i, str2, str2_i, ret_i, ret_l);

  return 0;
}

#endif
</pre></div>
<!-- class="sect2" -->
<a id="g1683108"></a>
<div id="ADFNS750" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.12.2</span> OCIExtProcRaiseExcp</h3>
<p>The <code dir="ltr">OCIExtProcRaiseExcp</code> service routine raises a predefined exception, which must have a valid Oracle Database error number in the range 1..32,767. After doing any necessary cleanup, your external procedure must return immediately. (No values are assigned to <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameters.) The C prototype for this function follows:</p>
<pre dir="ltr">int OCIExtProcRaiseExcp(
   OCIExtProcContext *with_context, 
   size_t errnum);
</pre>
<p>The parameters <code dir="ltr">with_context</code> and <code dir="ltr">error_number</code> are the context pointer and Oracle Database error number. The return values <code dir="ltr">OCIEXTPROC_SUCCESS</code> and <code dir="ltr">OCIEXTPROC_ERROR</code> indicate success or failure.</p>
<p>In SQL*Plus, suppose you publish external procedure <code dir="ltr">plsTo_divide_proc</code>, as follows:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE plsTo_divide_proc (
   dividend IN PLS_INTEGER, 
   divisor  IN PLS_INTEGER, 
   result   OUT FLOAT) 
AS LANGUAGE C
   NAME &#34;C_divide&#34;
   LIBRARY MathLib
   WITH CONTEXT
   PARAMETERS (
      CONTEXT, 
      dividend INT, 
      divisor  INT, 
      result   FLOAT);
</pre>
<p>When called, <code dir="ltr">C_divide</code> finds the quotient of two numbers. As this example shows, if the divisor is zero, <code dir="ltr">C_divide</code> uses <code dir="ltr">OCIExtProcRaiseExcp</code> to raise the predefined exception <code dir="ltr">ZERO_DIVIDE</code>:</p>
<pre dir="ltr">void C_divide (ctx, dividend, divisor, result)
OCIExtProcContext *ctx;
int    dividend;
int    divisor;
float  *result;
{
  /* Check for zero divisor. */
  if (divisor == (int)0) 
  {
    /* Raise exception ZERO_DIVIDE, which is Oracle Database error 1476. */
    if (OCIExtProcRaiseExcp(ctx, (int)1476) == OCIEXTPROC_SUCCESS)
    {
      return;
    }
    else
    {
      /* Incorrect parameters were passed. */
      assert(0);
    }
  }
  *result = (float)dividend / (float)divisor;
}
</pre></div>
<!-- class="sect2" -->
<a id="g1683120"></a>
<div id="ADFNS751" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.12.3</span> OCIExtProcRaiseExcpWithMsg</h3>
<p>The <code dir="ltr">OCIExtProcRaiseExcpWithMsg</code> service routine raises a user-defined exception and returns a user-defined error message. The C prototype for this function follows:</p>
<pre dir="ltr">int OCIExtProcRaiseExcpWithMsg(
   OCIExtProcContext *with_context, 
   size_t  error_number,
   text   *error_message, 
   size_t  len);
</pre>
<p>The parameters <code dir="ltr">with_context</code>, <code dir="ltr">error_number</code>, and <code dir="ltr">error_message</code> are the context pointer, Oracle Database error number, and error message text. The parameter <code dir="ltr">len</code> stores the length of the error message. If the message is a null-terminated string, then <code dir="ltr">len</code> is zero. The return values <code dir="ltr">OCIEXTPROC_SUCCESS</code> and <code dir="ltr">OCIEXTPROC_ERROR</code> indicate success or failure.</p>
<p>In the previous example, you published external procedure <code dir="ltr">plsTo_divide_proc</code>. In this example, you use a different implementation. With this version, if the divisor is zero, then <code dir="ltr">C_divide</code> uses <code dir="ltr">OCIExtProcRaiseExcpWithMsg</code> to raise a user-defined exception:</p>
<pre dir="ltr">void C_divide (ctx, dividend, divisor, result)
OCIExtProcContext *ctx;
int    dividend;
int    divisor;
float  *result;
  /* Check for zero divisor. */
  if (divisor == (int)0) 
  {
<span class="italic">    /* Raise a user-defined exception, which is Oracle Database error 20100,</span>
<span class="italic">       and return a null-terminated error message. */</span>
    if (OCIExtProcRaiseExcpWithMsg(ctx, (int)20100, 
          &#34;divisor is zero&#34;, 0) == OCIEXTPROC_SUCCESS)
    {
      return;
    }
    else
    {
      /*  Incorrect parameters were passed. */
      assert(0);
    }
  }
  *result = dividend / divisor;

}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008070"></a>
<div id="ADFNS1413" class="sect1">
<h2 class="sect1"><span class="secnum">18.13</span> Doing Callbacks with External C Procedures</h2>
<p><a id="sthref946"></a>To enable callbacks, use the function OCIExtProcGetEnv.</p>
<p class="subhead2"><a id="ADFNS1096"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1685481">OCIExtProcGetEnv</a></p>
</li>
<li>
<p><a href="#g1039584">Object Support for OCI Callbacks</a></p>
</li>
<li>
<p><a href="#g1039599">Restrictions on Callbacks</a></p>
</li>
<li>
<p><a href="#g1039614">Debugging External C Procedures</a></p>
</li>
<li>
<p><a href="#i1008230">Example: Calling an External C Procedure</a></p>
</li>
<li>
<p><a href="#g1686020">Global Variables in External C Procedures</a></p>
</li>
<li>
<p><a href="#g1686035">Static Variables in External C Procedures</a></p>
</li>
<li>
<p><a href="#g1039691">Restrictions on External C Procedures</a></p>
</li>
</ul>
<a id="g1685481"></a>
<div id="ADFNS752" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.13.1</span> OCIExtProcGetEnv</h3>
<p>The <code dir="ltr">OCIExtProcGetEnv</code> service routine enables OCI callbacks to the database during an external procedure call. The environment handles obtained by using this function reuse the existing connection to go back to the database. If you must establish a new connection to the database, you cannot use these handles; instead, you must create your own.</p>
<p>The C prototype for this function follows:</p>
<pre dir="ltr">sword OCIExtProcGetEnv ( OCIExtProcContext *with_context,
   OCIEnv envh,
   OCISvcCtx svch,
   OCIError errh )
</pre>
<p>The parameter <code dir="ltr">with_context</code> is the context pointer, and the parameters <code dir="ltr">envh</code>, <code dir="ltr">svch</code>, and <code dir="ltr">errh</code> are the OCI environment, service, and error handles, respectively. The return values <code dir="ltr">OCIEXTPROC_SUCCESS</code> and <code dir="ltr">OCIEXTPROC_ERROR</code> indicate success or failure.</p>
<p>Both external C procedures and Java class methods can call-back to the database to do SQL operations. For a working example, see <a href="#i1008230">Section 18.13.5</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Callbacks are not necessarily a same-session phenomenon; you might run an SQL statement in a different session through <code dir="ltr">OCIlogon</code>.</div>
<p>An external C procedure running on Oracle Database can call a service routine to obtain OCI environment and service handles. With the OCI, you can use callbacks to run SQL statements and PL/SQL subprograms, fetch data, and manipulate LOBs. Callbacks and external procedures operate in the same user session and transaction context, and so have the same user privileges.</p>
<p>In SQL*Plus, suppose you run this script:</p>
<pre dir="ltr">CREATE TABLE Emp_tab (empno NUMBER(10))

CREATE PROCEDURE plsToC_insertIntoEmpTab_proc (
   empno PLS_INTEGER)
AS LANGUAGE C
   NAME &#34;C_insertEmpTab&#34;
   LIBRARY insert_lib
   WITH CONTEXT
   PARAMETERS (
      CONTEXT, 
      empno LONG);
</pre>
<p>Later, you might call service routine <code dir="ltr">OCIExtProcGetEnv</code> from external procedure <code dir="ltr">plsToC_insertIntoEmpTab_proc</code>, as follows:</p>
<pre dir="ltr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;oratypes.h&gt;
#include &lt;oci.h&gt;   /* includes ociextp.h */
...
void C_insertIntoEmpTab (ctx, empno) 
OCIExtProcContext *ctx; 
long empno; 
{ 
  OCIEnv    *envhp; 
  OCISvcCtx *svchp; 
  OCIError  *errhp; 
  int        err; 
  ... 
  err = OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp); 
  ... 
}
</pre>
<p>If you do not use callbacks, you need not include <code dir="ltr">oci</code>.<code dir="ltr">h</code>; instead, include <code dir="ltr">ociextp</code>.<code dir="ltr">h</code>.</p>
</div>
<!-- class="sect2" -->
<a id="g1039584"></a>
<div id="ADFNS753" class="sect2">
<h3 class="sect2"><span class="secnum">18.13.2</span> Object Support for OCI Callbacks</h3>
<p>To run object-related callbacks from your external procedures, the OCI environment in the <code dir="ltr">extproc</code> agent is fully initialized in object mode. You retrieve handles to this environment with the <code dir="ltr">OCIExtProcGetEnv</code> procedure.</p>
<p>The object runtime environment lets you use static and dynamic object support provided by OCI. To use static support, use the OTT to generate C structs for the appropriate object types, and then use conventional C code to access the object attributes.</p>
<p>For those objects whose types are unknown at external procedure creation time, an alternative, dynamic, way of accessing objects is first to call <code dir="ltr">OCIDescribeAny</code> to obtain attribute and method information about the type. Then, <code dir="ltr">OCIObjectGetAttr</code> and <code dir="ltr">OCIObjectSetAttr</code> can be called to retrieve and set attribute values.</p>
<p>Because the current external procedure model is stateless, <code dir="ltr">OCIExtProcGetEnv</code> must be called in every external procedure that wants to run callbacks, or call <code dir="ltr">OCIExtProc</code>. service routines. After every external procedure call, the callback mechanism is cleaned up and all OCI handles are freed.</p>
</div>
<!-- class="sect2" -->
<a id="g1039599"></a>
<div id="ADFNS754" class="sect2">
<h3 class="sect2"><span class="secnum">18.13.3</span> Restrictions on Callbacks</h3>
<p>With callbacks, this SQL statements and OCI subprograms are not supported:</p>
<ul>
<li>
<p>Transaction control statements such as <code dir="ltr">COMMIT</code></p>
</li>
<li>
<p>Data definition statements such as <code dir="ltr">CREATE</code></p>
</li>
<li>
<p>These object-oriented OCI subprograms:</p>
<pre dir="ltr">OCIObjectNew 
OCIObjectPin 
OCIObjectUnpin 
OCIObjectPinCountReset 
OCIObjectLock 
OCIObjectMarkUpdate 
OCIObjectUnmark 
OCIObjectUnmarkByRef 
OCIObjectAlwaysLatest 
OCIObjectNotAlwaysLatest 
OCIObjectMarkDeleteByRef 
OCIObjectMarkDelete 
OCIObjectFlush 
OCIObjectFlushRefresh 
OCIObjectGetTypeRef 
OCIObjectGetObjectRef 
OCIObjectExists 
OCIObjectIsLocked 
OCIObjectIsDirtied 
OCIObjectIsLoaded 
OCIObjectRefresh 
OCIObjectPinTable 
OCIObjectArrayPin 
OCICacheFlush, 
OCICacheFlushRefresh, 
OCICacheRefresh 
OCICacheUnpin 
OCICacheFree 
OCICacheUnmark 
OCICacheGetObjects 
OCICacheRegister 
</pre></li>
</ul>
<ul>
<li>
<p>Polling-mode OCI subprograms such as <code dir="ltr">OCIGetPieceInfo</code></p>
</li>
<li>
<p>These OCI subprograms:</p>
<pre dir="ltr">OCIEnvInit
OCIInitialize
OCIPasswordChange
OCIServerAttach
OCIServerDetach
OCISessionBegin
OCISessionEnd
OCISvcCtxToLda
OCITransCommit
OCITransDetach
OCITransRollback
OCITransStart
</pre></li>
</ul>
<pre dir="ltr"></pre>
<p>Also, with OCI subprogram <code dir="ltr">OCIHandleAlloc</code>, these handle types are not supported:</p>
<pre dir="ltr">OCI_HTYPE_SERVER 
OCI_HTYPE_SESSION 
OCI_HTYPE_SVCCTX 
OCI_HTYPE_TRANS
</pre></div>
<!-- class="sect2" -->
<a id="g1039614"></a>
<div id="ADFNS755" class="sect2">
<h3 class="sect2"><span class="secnum">18.13.4</span> Debugging External C Procedures</h3>
<p><a id="sthref947"></a><a id="sthref948"></a>Usually, when an external procedure fails, its prototype is faulty. In other words, the prototype does not match the one generated internally by PL/SQL. This can happen if you specify an incompatible C data type. For example, to pass an <code dir="ltr">OUT</code> parameter of type <code dir="ltr">REAL</code>, you must specify <code dir="ltr">float *</code>. Specifying <code dir="ltr">float</code>, <code dir="ltr">double</code> <code dir="ltr">*</code>, or any other C data type results in a mismatch.</p>
<p>In such cases, you might get:</p>
<pre dir="ltr">lost RPC connection to external routine agent 
</pre>
<p>This error, which means that <code dir="ltr">extproc</code> terminated abnormally because the external procedure caused a core dump. To avoid errors when declaring C prototype parameters, see the preceding tables.</p>
<p>To help you debug external procedures, PL/SQL provides the utility package <code dir="ltr">DEBUG_EXTPROC</code>. To install the package, run the script <code dir="ltr">dbgextp</code>.<code dir="ltr">sql</code>, which you can find in the PL/SQL demo directory. (For the location of the directory, see your Oracle Database Installation or User&#39;s Guide.)</p>
<p>To use the package, follow the instructions in <code dir="ltr">dbgextp</code>.<code dir="ltr">sql</code>. Your Oracle Database account must have <code dir="ltr">EXECUTE</code> privileges on the package and <code dir="ltr">CREATE</code> <code dir="ltr">LIBRARY</code> privileges.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">DEBUG_EXTPROC</code> works only on platforms with debuggers that can attach to a running process.</div>
</div>
<!-- class="sect2" -->
<a id="i1008230"></a>
<div id="ADFNS756" class="sect2">
<h3 class="sect2"><span class="secnum">18.13.5</span> Example: Calling an External C Procedure</h3>
<p>Also in the PL/SQL demo directory is the script <code dir="ltr">extproc</code>.<code dir="ltr">sql</code>, which demonstrates the calling of an external procedure. The companion file <code dir="ltr">extproc</code>.<code dir="ltr">c</code> contains the C source code for the external procedure.</p>
<p>To run the demo, follow the instructions in <code dir="ltr">extproc</code>.<code dir="ltr">sql</code>. You must use the <code dir="ltr">SCOTT</code> account, which must have <code dir="ltr">CREATE</code> <code dir="ltr">LIBRARY</code> privileges.</p>
</div>
<!-- class="sect2" -->
<a id="g1686020"></a>
<div id="ADFNS757" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.13.6</span> Global Variables in External C Procedures</h3>
<p><a id="sthref949"></a><a id="sthref950"></a><a id="sthref951"></a>A global variable is declared outside of a function, and its value is shared by all functions of a program. Therefore, in external procedures, all functions in a DLL share the value of the global variable. Global variables are also used to store data that is intended to persist beyond the lifetime of a function. However, Oracle discourages the use of global variables for two reasons:</p>
<ul>
<li>
<p>Threading</p>
<p>In the nonthreaded configuration of the agent process, one function is active at a time. For the multithreaded <code dir="ltr">extproc</code> agent, multiple functions can be active at the same time, and they might try to access the global variable concurrently, with unsuccessful results.</p>
</li>
<li>
<p>DLL caching</p>
<p>Suppose that function <code dir="ltr">func1</code> tries to pass data to function <code dir="ltr">func2</code> by storing the data in a global variable. After <code dir="ltr">func1</code> completes, the DLL cache might be unloaded, causing all global variables to lose their values. Then, when <code dir="ltr">func2</code> runs, the DLL is reloaded, and all global variables are initialized to 0.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="g1686035"></a>
<div id="ADFNS758" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">18.13.7</span> Static Variables in External C Procedures</h3>
<p><a id="sthref952"></a><a id="sthref953"></a>There are two types of static variables: external and internal. An external static variable is a special case of a global variable, so its usage is discouraged. Internal static variables are local to a particular function, but remain in existence rather than coming and going each time the function is activated. Therefore, they provide private, permanent storage within a single function. These variables are used to pass on data to subsequent calls to the same function. But, because of the DLL caching feature mentioned in <a href="#g1686020">Section 18.13.6, &#34;Global Variables in External C Procedures,&#34;</a> the DLL might be unloaded and reloaded between calls, which means that the internal static variable loses its value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Template <code dir="ltr">makefile</code> in the RDBMS subdirectory <code dir="ltr">/public</code> for help creating a dynamic link library</div>
<p>When calling external procedures:</p>
<ul>
<li>
<p>Never write to <code dir="ltr">IN</code> parameters or overflow the capacity of <code dir="ltr">OUT</code> parameters. (PL/SQL does no runtime checks for these error conditions.)</p>
</li>
<li>
<p>Never read an <code dir="ltr">OUT</code> parameter or a function result.</p>
</li>
<li>
<p>Always assign a value to <code dir="ltr">IN</code> <code dir="ltr">OUT</code> and <code dir="ltr">OUT</code> parameters and to function results. Otherwise, your external procedure will not return successfully.</p>
</li>
<li>
<p>If you include the <code dir="ltr">WITH</code> <code dir="ltr">CONTEXT</code> and <code dir="ltr">PARAMETERS</code> clauses, then you must specify the parameter <code dir="ltr">CONTEXT</code>, which shows the position of the context pointer in the parameter list.</p>
</li>
<li>
<p>If you include the <code dir="ltr">PARAMETERS</code> clause, and if the external procedure is a function, then you must specify the parameter <code dir="ltr">RETURN</code> in the last position.</p>
</li>
<li>
<p>For every formal parameter, there must be a corresponding parameter in the <code dir="ltr">PARAMETERS</code> clause. Also, ensure that the data types of parameters in the <code dir="ltr">PARAMETERS</code> clause are compatible with those in the C prototype, because no implicit conversions are done.</p>
</li>
<li>
<p>With a parameter of type <code dir="ltr">RAW</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, you must use the property <code dir="ltr">LENGTH</code>. Also, if that parameter is <code dir="ltr">IN</code> <code dir="ltr">OUT</code> or <code dir="ltr">OUT</code> and null, then you must set the length of the corresponding C parameter to zero.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="g1039691"></a>
<div id="ADFNS759" class="sect2">
<h3 class="sect2"><span class="secnum">18.13.8</span> Restrictions on External C Procedures</h3>
<p>These restrictions apply to external procedures:</p>
<ul>
<li>
<p>This feature is available only on platforms that support DLLs.</p>
</li>
<li>
<p>Only C procedures and procedures callable from C code are supported.</p>
</li>
<li>
<p>External procedure callouts combined with distributed transactions is not supported.</p>
</li>
<li>
<p>You cannot pass PL/SQL cursor variables or records to an external procedure. For records, use instances of object types instead.</p>
</li>
<li>
<p>In the <code dir="ltr">LIBRARY</code> subclause, you cannot use a database link to specify a remote library.</p>
</li>
<li>
<p>The maximum number of parameters that you can pass to a external procedure is 128. However, if you pass float or double parameters by value, then the maximum is less than 128. How much less depends on the number of such parameters and your operating system. To get a rough estimate, count each float or double passed by value as two parameters.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment286">
<tr>
<td class="cellalignment295">
<table class="cellalignment291">
<tr>
<td class="cellalignment290"><a href="adfns_environments.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment290"><a href="adfns_xa.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment298">
<table class="cellalignment289">
<tr>
<td class="cellalignment290"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment290"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment290"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment290"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment290"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment290"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>


</body></html>