<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-74"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Coding%20PL%2FSQL%20Subprograms%20and%20Packages"></a><title>Coding PL/SQL Subprograms and Packages</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1080"/>
<meta name="dcterms.created" content="2016-05-05T16:23:34Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Development Guide"/>
<meta name="dcterms.identifier" content="E41452-07"/>
<meta name="dcterms.isVersionOf" content="ADFNS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="adfns_part_plsql.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adfns_plscope.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41452-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">21/38</span> <!-- End Header -->
<div id="ADFNS009" class="chapter"><a id="g1044585"></a>
<h1 class="chapter"><span class="secnum">11</span> Coding PL/SQL Subprograms and Packages</h1>
<p>PL/SQL subprograms and packages are the building blocks of Oracle Database applications. Oracle recommends that you implement your application as a package, for the reasons given in <a class="olink LNPLS00902" href="../LNPLS/packages.htm#LNPLS00902"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p class="subhead2"><a id="ADFNS1029"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABBCIDH">Overview of PL/SQL Subprograms</a></p>
</li>
<li>
<p><a href="#BABJFHFI">Overview of PL/SQL Packages</a></p>
</li>
<li>
<p><a href="#i1006224">Overview of PL/SQL Units</a></p>
</li>
<li>
<p><a href="#BABDHHGB">Creating PL/SQL Subprograms and Packages</a></p>
</li>
<li>
<p><a href="#g1041906">Altering PL/SQL Subprograms and Packages</a></p>
</li>
<li>
<p><a href="#g1041928">Dropping PL/SQL Subprograms and Packages</a></p>
</li>
<li>
<p><a href="#i1007058">Compiling PL/SQL Units for Native Execution</a></p>
</li>
<li>
<p><a href="#i1007682">Invoking Stored PL/SQL Subprograms</a></p>
</li>
<li>
<p><a href="#i1007943">Invoking Stored PL/SQL Functions from SQL Statements</a></p>
</li>
<li>
<p><a href="#i1007648">Debugging Stored Subprograms</a></p>
</li>
<li>
<p><a href="#g1042030">Package Invalidations and Session State</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS007" href="../LNPLS/errors.htm#LNPLS007"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about handling errors in PL/SQL subprograms and packages</p>
</li>
<li>
<p><a class="olink ADDCI2120" href="../ADDCI/aggr_functions.htm#ADDCI2120"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for information about creating <a id="sthref587"></a><a id="sthref588"></a>aggregate functions for complex data types such as multimedia data stored using object types, opaque types, and LOBs</p>
</li>
<li>
<p><a class="olink TGSQL791" href="../TGSQL/tgsql_trace.htm#TGSQL791"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for information about application <a id="sthref589"></a>tracing tools, which can help you find problems in PL/SQL code</p>
</li>
</ul>
</div>
<a id="BABBCIDH"></a>
<div id="ADFNS1397" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">11.1</span> Overview of PL/SQL Subprograms</h2>
<p>The basic unit of a PL/SQL source program is the <a id="sthref590"></a><a id="sthref591"></a><span class="bold">block</span>, which groups related declarations and statements. A block has an optional declarative part, a required executable part, and an optional exception-handling part. A block can be either anonymous or named. (For more information about PL/SQL blocks, see <a class="olink LNPLS141" href="../LNPLS/overview.htm#LNPLS141"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.)</p>
<p>A PL/SQL <a id="sthref592"></a><span class="bold">subprogram</span> is a named block that can be invoked repeatedly. If the subprogram has parameters, then their values can differ for each invocation. For the reasons to use subprograms, see <a class="olink LNPLS99900" href="../LNPLS/subprograms.htm#LNPLS99900"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>A subprogram is either a procedure or a function. Typically, you use a <span class="bold">procedure</span> to perform an action and a <span class="bold">function</span> to compute and return a value.</p>
<p>A subprogram is also either a <a id="sthref593"></a><span class="bold">nested subprogram</span> (created inside a PL/SQL block, which can be another subprogram), a <a id="sthref594"></a><span class="bold">package subprogram</span> (declared in a package specification and defined in the package body), or a <a id="sthref595"></a><span class="bold">standalone subprogram</span> (created at schema level). Package subprograms and standalone programs are <a id="sthref596"></a><span class="bold">stored subprograms</span>. A stored subprogram is compiled and stored in the database, where many applications can invoke it.</p>
<p>Stored subprograms are affected by the <a id="sthref597"></a><code dir="ltr">AUTHID</code> and <a id="sthref598"></a><code dir="ltr">ACCESSIBLE</code> <code dir="ltr">BY</code> clauses. The <code dir="ltr"><span class="codeinlinebold">AUTHID</span></code> <span class="bold">clause</span> affects the name resolution and privilege checking of SQL statements that the subprogram issues at runtime. The <code dir="ltr"><span class="codeinlinebold">ACCESSIBLE</span></code> <code dir="ltr"><span class="codeinlinebold">BY</span></code> <span class="bold">clause</span> specifies a white list of PL/SQL units that can access the subprogram. For information about PL/SQL units, see <a href="#i1006224">Section 11.3</a>.</p>
<p>A PL/SQL subprogram running on an Oracle Database instance can invoke an <span class="bold">external subprogram</span> written in a third-generation language (3GL). The 3GL subprogram runs in a separate address space from that of the database. For information about external subprograms, see <a href="adfns_externproc.htm#g1040439">Chapter 18, &#34;Developing Applications with Multiple Programming Languages.&#34;</a></p>
<p>PL/SQL lets you overload nested subprograms, package subprograms, and type methods. <a id="sthref599"></a><a id="sthref600"></a><span class="bold">Overloaded subprograms</span> have the same name but their formal parameters differ in either name, number, order, or data type family. For more information about overloaded subprograms, see <a class="olink LNPLS00807" href="../LNPLS/subprograms.htm#LNPLS00807"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>Like a stored procedure, a <a id="sthref601"></a><span class="bold">trigger</span> is a named PL/SQL unit that is stored in the database and can be invoked repeatedly. Unlike a stored procedure, you can enable and disable a trigger, but you cannot explicitly invoke it. While a trigger is enabled, the database automatically invokes it&mdash;that is, the trigger fires&mdash;whenever its triggering event occurs. While a trigger is disabled, it does not fire. For more information about triggers, see <a class="olink LNPLS020" href="../LNPLS/overview.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS008" href="../LNPLS/overview.htm#LNPLS008"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for complete information about PL/SQL subprograms</div>
</div>
<!-- class="sect1" -->
<a id="BABJFHFI"></a>
<div id="ADFNS1398" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">11.2</span> Overview of PL/SQL Packages</h2>
<p>A PL/SQL <span class="bold">package</span> is a schema object that groups logically related PL/SQL types, variables, constants, subprograms, cursors, and exceptions. A package is compiled and stored in the database, where many applications can share its contents. For the reasons to use packages, see <a class="olink LNPLS00902" href="../LNPLS/packages.htm#LNPLS00902"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>A package always has a <a id="sthref602"></a><span class="bold">specification</span>, which declares the <span class="bold">public items</span> that can be referenced from outside the package. Public items can be used or invoked by external users who have the <code dir="ltr">EXECUTE</code> privilege for the package or the <code dir="ltr">EXECUTE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> privilege.</p>
<p>If the public items include cursors or subprograms, then the package must also have a <a id="sthref603"></a><span class="bold">body</span>. The body must define queries for public cursors and code for public subprograms. The body can also declare and define <span class="bold">private items</span> that cannot be referenced from outside the package, but are necessary for the internal workings of the package. Finally, the body can have an <span class="bold">initialization part</span>, whose statements initialize variables and do other one-time setup steps, and an exception-handling part. You can change the body without changing the specification or the references to the public items; therefore, you can think of the package body as a black box.</p>
<p>In either the package specification or package body, you can map a package subprogram to an external Java or C subprogram by using a <a id="sthref604"></a><span class="bold">call specification</span>, which maps the external subprogram name, parameter types, and return type to their SQL counterparts.</p>
<p>The <a id="sthref605"></a><code dir="ltr"><span class="codeinlinebold">AUTHID</span></code> <span class="bold">clause</span> of the package specification determines whether the subprograms and cursors in the package run with the privileges of their definer (the default) or invoker, and whether their unqualified references to schema objects are resolved in the schema of the definer or invoker.</p>
<p>The <a id="sthref606"></a><code dir="ltr"><span class="codeinlinebold">ACCESSIBLE</span></code> <code dir="ltr"><span class="codeinlinebold">BY</span></code> <span class="bold">clause</span> of the package specification lets you specify a white list&#34; of PL/SQL units that can access the package. You use this clause in situations like these:</p>
<ul>
<li>
<p>You implement a PL/SQL application as several packages&mdash;one package that provides the application programming interface (API) and helper packages to do the work. You want clients to have access to the API, but not to the helper packages. Therefore, you omit the <code dir="ltr">ACCESSIBLE</code> <code dir="ltr">BY</code> clause from the API package specification and include it in each helper package specification, where you specify that only the API package can access the helper package.</p>
</li>
<li>
<p>You create a utility package to provide services to some, but not all, PL/SQL units in the same schema. To restrict use of the package to the intended units, you list them in the <code dir="ltr">ACCESSIBLE</code> <code dir="ltr">BY</code> clause in the package specification.</p>
</li>
</ul>
<p>For information about PL/SQL units, see <a href="#i1006224">Section 11.3</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before you create your own package, check <a class="olink ARPLS" href="../ARPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to see if Oracle supplies a package with the functionality that you need.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS009" href="../LNPLS/overview.htm#LNPLS009"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for complete information about PL/SQL packages</div>
</div>
<!-- class="sect1" -->
<a id="i1006224"></a>
<div id="ADFNS00901" class="sect1">
<h2 class="sect1"><span class="secnum">11.3</span> Overview of PL/SQL Units</h2>
<p>A <a id="sthref607"></a>PL/SQL unit is one of these:</p>
<ul>
<li>
<p>PL/SQL anonymous block</p>
</li>
<li>
<p><code dir="ltr">FUNCTION</code></p>
</li>
<li>
<p><code dir="ltr">LIBRARY</code></p>
</li>
<li>
<p><code dir="ltr">PACKAGE</code></p>
</li>
<li>
<p><code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code></p>
</li>
<li>
<p><code dir="ltr">PROCEDURE</code></p>
</li>
<li>
<p><code dir="ltr">TRIGGER</code></p>
</li>
<li>
<p><code dir="ltr">TYPE</code></p>
</li>
<li>
<p><code dir="ltr">TYPE</code> <code dir="ltr">BODY</code></p>
</li>
</ul>
<p>PL/SQL units are affected by <a id="sthref608"></a>PL/SQL compilation parameters (a category of database <a id="sthref609"></a><a id="sthref610"></a>initialization parameters). Different PL/SQL units&mdash;for example, a package specification and its body&mdash;can have different compilation parameter settings. For more information about PL/SQL units and compilation parameters, see <a class="olink LNPLS0121" href="../LNPLS/overview.htm#LNPLS0121"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>The <a id="sthref611"></a><code dir="ltr">AUTHID</code> property of a PL/SQL unit affects the name resolution and privilege checking of SQL statements that the unit issues at runtime. For details, see <a class="olink LNPLS00809" href="../LNPLS/subprograms.htm#LNPLS00809"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<a id="BABBBAJJ"></a>
<div id="ADFNS1422" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.3.1</span> PLSQL_OPTIMIZE_LEVEL Compilation Parameter</h3>
<p>The <a id="sthref612"></a>PL/SQL optimize level determines how much the PL/SQL optimizer can rearrange code for better performance. This level is set with the compilation parameter <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code> (whose default value is 2).</p>
<p>To change the PL/SQL optimize level for your session, use the SQL command <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code>. Changing the level for your session affects only subsequently created PL/SQL units. To change the level for an existing PL/SQL unit, use an <code dir="ltr">ALTER</code> command with the <code dir="ltr">COMPILE</code> clause.</p>
<p>To display the current value of <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code> for one or more PL/SQL units, use the static data dictionary view <code dir="ltr">ALL_PLSQL_OBJECT_SETTINGS</code>.</p>
<p><a href="#BABJGEAA">Example 11-1</a> creates two procedures, displays their optimize levels, changes the optimize level for the session, creates a third procedure, and displays the optimize levels of all three procedures. Only the third procedure has the new optimize level. Then the example changes the optimize level for only one procedure and displays the optimize levels of all three procedures again.</p>
<div id="ADFNS1423" class="example">
<p class="titleinexample"><a id="BABJGEAA"></a>Example 11-1 Changing PLSQL_OPTIMIZE_LEVEL</p>
<p>Create two procedures:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE p1 AUTHID DEFINER AS
BEGIN
  NULL;
END;
/
CREATE OR REPLACE PROCEDURE p2 AUTHID DEFINER AS
BEGIN
  NULL;
END;
/
</pre>
<p>Display the optimization levels of the two procedures:</p>
<pre dir="ltr">SELECT NAME, PLSQL_OPTIMIZE_LEVEL
FROM USER_PLSQL_OBJECT_SETTINGS
WHERE NAME LIKE &#39;P%&#39; AND TYPE=&#39;PROCEDURE&#39;
ORDER BY NAME;
 
</pre>
<p>Result:</p>
<pre dir="ltr">NAME                           PLSQL_OPTIMIZE_LEVEL
------------------------------ --------------------
P1                                                2
P2                                                2
 
2 rows selected.
</pre>
<p>Change the optimization level for the session and create a third procedure:</p>
<pre dir="ltr"><span class="bold">ALTER SESSION SET PLSQL_OPTIMIZE_LEVEL=1;</span>
 
CREATE OR REPLACE PROCEDURE p3 AUTHID DEFINER AS
BEGIN
  NULL;
END;
/
 
</pre>
<p>Display the optimization levels of the three procedures:</p>
<pre dir="ltr">SELECT NAME, PLSQL_OPTIMIZE_LEVEL
FROM USER_PLSQL_OBJECT_SETTINGS
WHERE NAME LIKE &#39;P%&#39; AND TYPE=&#39;PROCEDURE&#39;
ORDER BY NAME;
 
</pre>
<p>Result:</p>
<pre dir="ltr">NAME                           PLSQL_OPTIMIZE_LEVEL
------------------------------ --------------------
P1                                                2
P2                                                2
P3                                                1
 
3 rows selected.
</pre>
<p>Change the optimization level of procedure <code dir="ltr">p1</code> to 3:</p>
<pre dir="ltr"><span class="bold">ALTER PROCEDURE p1 COMPILE PLSQL_OPTIMIZE_LEVEL=3;</span>
 
</pre>
<p>Display the optimization levels of the three procedures:</p>
<pre dir="ltr">SELECT NAME, PLSQL_OPTIMIZE_LEVEL
FROM USER_PLSQL_OBJECT_SETTINGS
WHERE NAME LIKE &#39;P%&#39; AND TYPE=&#39;PROCEDURE&#39;
ORDER BY NAME;
</pre>
<p>Result:</p>
<pre dir="ltr">NAME                           PLSQL_OPTIMIZE_LEVEL
------------------------------ --------------------
P1                                                3
P2                                                2
P3                                                1
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS01201" href="../LNPLS/tuning.htm#LNPLS01201"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the PL/SQL optimizer</p>
</li>
<li>
<p><a class="olink REFRN10255" href="../REFRN/GUID-364B752A-4335-468C-B4BA-AAC32D75385A.htm#REFRN10255"><span class="italic">Oracle Database Reference</span></a> for more information about <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code></p>
</li>
<li>
<p><a class="olink SQLRF00901" href="../SQLRF/statements_2015.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code></p>
</li>
<li>
<p><a class="olink LNPLS99974" href="../LNPLS/sqlstatements.htm#LNPLS99974"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> commands for PL/SQL units</p>
</li>
<li>
<p><a class="olink REFRN20385" href="../REFRN/GUID-7EF7B6E3-50B1-43C3-A56E-40955B47C65D.htm#REFRN20385"><span class="italic">Oracle Database Reference</span></a> for more information about <code dir="ltr">ALL_PLSQL_OBJECT_SETTINGS</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDHHGB"></a>
<div id="ADFNS311" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">11.4</span> Creating PL/SQL Subprograms and Packages</h2>
<p class="subhead2"><a id="ADFNS312"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABFHIFD">Privileges Needed to Create Subprograms and Packages</a></p>
</li>
<li>
<p><a href="#g1041863">Creating Subprograms and Packages</a></p>
</li>
<li>
<p><a href="#g1041980">PL/SQL Object Size Limits</a></p>
</li>
<li>
<p><a href="#BABJEAEG">PL/SQL Data Types</a></p>
</li>
<li>
<p><a href="#i1007323">Returning Result Sets to Clients</a></p>
</li>
<li>
<p><a href="#i1008519">Returning Large Amounts of Data from a Function</a></p>
</li>
<li>
<p><a href="#CIHBDCEF">PL/SQL Function Result Cache</a></p>
</li>
<li>
<p><a href="#i1006920">Overview of Bulk Binding</a></p>
</li>
<li>
<p><a href="#BABFJFCC">PL/SQL Dynamic SQL</a></p>
</li>
</ul>
<a id="BABFHIFD"></a>
<div id="ADFNS328" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.4.1</span> Privileges Needed to Create Subprograms and Packages</h3>
<p>To create a standalone subprogram or package in your own schema, you must have the <code dir="ltr">CREATE</code> <code dir="ltr">PROCEDURE</code> system privilege. To create a standalone subprogram or package in another schema, you must have the <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege.</p>
<p>If the subprogram or package that you create references schema objects, then you must have the necessary object privileges for those objects. These privileges must be granted to you explicitly, not through roles.</p>
<p>If the privileges of the owner of a subprogram or package change, then the subprogram or package must be reauthenticated before it is run. If a necessary object privilege for a referenced object is revoked from the owner of the subprogram or package, then the subprogram cannot run.</p>
<p>Granting the <a id="sthref613"></a><code dir="ltr">EXECUTE</code> privilege on a subprogram lets users run that subprogram under the security domain of the subprogram owner, so that the user need not be granted privileges to the objects that the subprogram references. The <code dir="ltr">EXECUTE</code> privilege allows more disciplined and efficient security strategies for database applications and their users. Furthermore, it allows subprograms and packages to be stored in the data dictionary (in the <code dir="ltr">SYSTEM</code> tablespace), where no quota controls the amount of space available to a user who creates subprograms and packages.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01603" href="../SQLRF/statements_9014.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about system and object privileges</p>
</li>
<li>
<p><a href="#i1007682">Section 11.8, &#34;Invoking Stored PL/SQL Subprograms&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="g1041863"></a>
<div id="ADFNS327" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.2</span> Creating Subprograms and Packages</h3>
<p>This topic explains how to create standalone subprograms and packages, using SQL Data Definition Language (DDL) statements.</p>
<p>The DDL statements for creating standalone <a id="sthref614"></a>subprograms and <a id="sthref615"></a>packages are:</p>
<ul>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code>, described in <a class="olink LNPLS01370" href="../LNPLS/create_function.htm#LNPLS01370"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">PROCEDURE</code>, described in <a class="olink LNPLS01373" href="../LNPLS/create_procedure.htm#LNPLS01373"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code>, described in <a class="olink LNPLS01371" href="../LNPLS/create_package.htm#LNPLS01371"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code>, described in <a class="olink LNPLS01372" href="../LNPLS/create_package_body.htm#LNPLS01372"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
<p>The name of a package and the names of its public objects must be unique within the package schema. The package specification and body must have the same name. Package constructs must have unique names within the scope of the package, except for overloaded subprograms.</p>
</li>
</ul>
<p>Each of the preceding <code dir="ltr">CREATE</code> statements has an optional <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> clause. Specify <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> to re-create an existing PL/SQL unit&mdash;that is, to change its declaration or definition without dropping it, re-creating it, and regranting object privileges previously granted on it. If you redefine a PL/SQL unit, the database recompiles it.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
A <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> statement does not issue a warning before replacing the existing PL/SQL unit.</div>
<p>Using any text editor, create a text file that contains DDL statements for creating any number of <a id="sthref616"></a>subprograms and <a id="sthref617"></a>packages.</p>
<p>To run the DDL statements, use an interactive tool such as SQL*Plus. The SQL*Plus command <code dir="ltr">START</code> or @ runs a script. For example, this SQL*Plus command runs the script <code dir="ltr">my_app.sql</code>:</p>
<pre dir="ltr">@my_app
</pre>
<p>(For information about runnings scripts in SQL*Plus, see <a class="olink SQPUG015" href="../SQPUG/ch_five.htm#SQPUG015"><span class="italic">SQL*Plus User&#39;s Guide and Reference</span></a>.)</p>
<p>Alternatively, you can create and run the DDL statements using SQL Developer. For information about SQL Developer, see <a class="olink RPTUG" href="../RPTUG/toc.htm"><span class="italic">Oracle SQL Developer User&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="g1041980"></a>
<div id="ADFNS336" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.3</span> PL/SQL Object Size Limits</h3>
<p><a id="sthref618"></a>The size limit for PL/SQL stored database objects such as <a id="sthref619"></a><a id="sthref620"></a><a id="sthref621"></a>subprograms, triggers, and packages is the size of the Descriptive Intermediate Attributed Notation for Ada (DIANA) code in the shared pool in bytes. The Linux and UNIX limit on the size of the flattened DIANA/code size is 64K but the limit might be 32K on desktop platforms.</p>
<p>The most closely related number that a user can access is <code dir="ltr">PARSED_SIZE</code>, a column in the static data dictionary view <code dir="ltr">*_OBJECT_SIZE</code>. The column <code dir="ltr">PARSED_SIZE</code> gives the size of the DIANA in bytes as stored in the <code dir="ltr">SYS.IDL_xxx$</code> tables. This is not the size in the shared pool. The size of the DIANA part of PL/SQL code (used during compilation) is significantly larger in the shared pool than it is in the system table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS018" href="../LNPLS/limits.htm#LNPLS018"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about PL/SQL program limits and <code dir="ltr">PARSED_SIZE</code></p>
</li>
<li>
<p><a class="olink REFRN23143" href="../REFRN/GUID-0A990179-83B9-41A5-9F1C-698C8504EF10.htm#REFRN23143"><span class="italic">Oracle Database Reference</span></a> for information about <code dir="ltr">*_OBJECT_SIZE</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABJEAEG"></a>
<div id="ADFNS975" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.4</span> PL/SQL Data Types</h3>
<p>This topic introduces the <a id="sthref622"></a><a id="sthref623"></a>PL/SQL data types and refers to other chapters or documents for more information.</p>
<p>Use the correct and most specific PL/SQL data type for each PL/SQL variable in your database application. For the reasons, see <a href="adfns_sqltypes.htm#BABCDHAH">Section 7.1, &#34;Using the Correct and Most Specific Data Type.&#34;</a></p>
<p class="subhead2"><a id="ADFNS1345"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABHBGFE">PL/SQL Scalar Data Types</a></p>
</li>
<li>
<p><a href="#BABDFHCJ">PL/SQL Composite Data Types</a></p>
</li>
<li>
<p><a href="#BABFHDGA">Abstract Data Types</a></p>
</li>
</ul>
<a id="BABHBGFE"></a>
<div id="ADFNS1104" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.4.1</span> PL/SQL Scalar Data Types</h4>
<p><a id="sthref624"></a><span class="bold">Scalar data types</span> store values that have no internal components.</p>
<p>A scalar data type can have subtypes. A <a id="sthref625"></a><span class="bold">subtype</span> is a data type that is a subset of another data type, which is its <span class="bold">base type</span>. A subtype has the same valid operations as its base type. A data type and its subtypes comprise a <a id="sthref626"></a><a id="sthref627"></a><span class="bold">data type family</span>.</p>
<p>PL/SQL predefines many types and subtypes in the package <code dir="ltr">STANDARD</code> and lets you define your own subtypes.</p>
<p class="subhead2"><a id="ADFNS1208"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABDCJJE">SQL Data Types</a></p>
</li>
<li>
<p><a href="#BABHHCIG">BOOLEAN Data Type</a></p>
</li>
<li>
<p><a href="#BABEHHAD">PLS_INTEGER and BINARY_INTEGER Data Types</a></p>
</li>
<li>
<p><a href="#BABEBCEH">REF CURSOR Data Type</a></p>
</li>
<li>
<p><a href="#BABFDCDH">User-Defined PL/SQL Subtypes</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS003" href="../LNPLS/datatypes.htm#LNPLS003"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for a complete description of scalar PL/SQL data types</p>
</li>
<li>
<p><a class="olink LNPLS2163" href="../LNPLS/predefined.htm#LNPLS2163"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for the predefined PL/SQL data types and subtypes, grouped by data type family</p>
</li>
</ul>
</div>
<a id="BABDCJJE"></a>
<div id="ADFNS1209" class="sect4">
<h5 class="sect4"><span class="secnum">11.4.4.1.1</span> SQL Data Types</h5>
<p>The PL/SQL data types include the SQL data types. For general information about the SQL data types, see <a class="olink SQLRF002" href="../SQLRF/sql_elements.htm#SQLRF002"><span class="italic">Oracle Database SQL Language Reference</span></a>&mdash;all information there about data types and subtypes, data type comparison rules, data conversion, literals, and format models applies to both SQL and PL/SQL, except as noted in <a class="olink LNPLS286" href="../LNPLS/datatypes.htm#LNPLS286"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>For information about how to use the SQL data types in database applications, see <a href="adfns_sqltypes.htm#i1006173">Chapter 7, &#34;Using SQL Data Types in Database Applications.&#34;</a></p>
</div>
<!-- class="sect4" -->
<a id="BABHHCIG"></a>
<div id="ADFNS1210" class="sect4">
<h5 class="sect4"><span class="secnum">11.4.4.1.2</span> BOOLEAN Data Type</h5>
<p>The <a id="sthref628"></a><a id="sthref629"></a><code dir="ltr">BOOLEAN</code> data type stores <a id="sthref630"></a><span class="bold">logical values</span>, which are the Boolean values <code dir="ltr">TRUE</code> and <code dir="ltr">FALSE</code> and the value <code dir="ltr">NULL</code>. <code dir="ltr">NULL</code> represents an unknown value. For more information about the <code dir="ltr">BOOLEAN</code> data type, see <a class="olink LNPLS348" href="../LNPLS/datatypes.htm#LNPLS348"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect4" -->
<a id="BABEHHAD"></a>
<div id="ADFNS1211" class="sect4">
<h5 class="sect4"><span class="secnum">11.4.4.1.3</span> PLS_INTEGER and BINARY_INTEGER Data Types</h5>
<p>The PL/SQL data types <a id="sthref631"></a><a id="sthref632"></a><code dir="ltr">PLS_INTEGER</code> and <code dir="ltr">BINARY_INTEGER</code> are identical. For simplicity, this guide uses <code dir="ltr">PLS_INTEGER</code> to mean both <code dir="ltr">PLS_INTEGER</code> and <code dir="ltr">BINARY_INTEGER</code>.</p>
<p>The <code dir="ltr">PLS_INTEGER</code> data type stores signed integers in the range -2,147,483,648 through 2,147,483,647, represented in 32 bits.</p>
<p>The <code dir="ltr">PLS_INTEGER</code> data type has these advantages over the <code dir="ltr">NUMBER</code> data type and <code dir="ltr">NUMBER</code> subtypes:</p>
<ul>
<li>
<p><code dir="ltr">PLS_INTEGER</code> values require less storage.</p>
</li>
<li>
<p><code dir="ltr">PLS_INTEGER</code> operations use hardware arithmetic, so they are faster than <code dir="ltr">NUMBER</code> operations, which use library arithmetic.</p>
</li>
</ul>
<p>For efficiency, use <code dir="ltr">PLS_INTEGER</code> values for all calculations in its range.</p>
<p>For more information about the <code dir="ltr">PLS_INTEGER</code> data type, see <a class="olink LNPLS319" href="../LNPLS/datatypes.htm#LNPLS319"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect4" -->
<a id="BABEBCEH"></a>
<div id="ADFNS1316" class="sect4">
<h5 class="sect4"><span class="secnum">11.4.4.1.4</span> REF CURSOR Data Type</h5>
<p><a id="sthref633"></a><a id="sthref634"></a><code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> is the data type of a cursor variable.</p>
<p>A <a id="sthref635"></a><span class="bold">cursor variable</span> is like an explicit cursor, except that:</p>
<ul>
<li>
<p>It is not limited to one query.</p>
<p>You can open a cursor variable for a query, process the result set, and then use the cursor variable for another query.</p>
</li>
<li>
<p>You can assign a value to it.</p>
</li>
<li>
<p>You can use it in an expression.</p>
</li>
<li>
<p>It can be a subprogram parameter.</p>
<p>You can use cursor variables to pass query result sets between subprograms.</p>
</li>
<li>
<p>It can be a host variable.</p>
<p>You can use cursor variables to pass query result sets between PL/SQL stored subprograms and their clients.</p>
</li>
<li>
<p>It cannot accept parameters.</p>
<p>You cannot pass parameters to a cursor variable, but you can pass whole queries to it.</p>
</li>
</ul>
<p>A cursor variable has this flexibility because it is a pointer; that is, its value is the address of an item, not the item itself.</p>
<p>For more information about the <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> data type and cursor variables, see <a class="olink LNPLS00605" href="../LNPLS/static.htm#LNPLS00605"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect4" -->
<a id="BABFDCDH"></a>
<div id="ADFNS1317" class="sect4">
<h5 class="sect4"><span class="secnum">11.4.4.1.5</span> User-Defined PL/SQL Subtypes</h5>
<p><a id="sthref636"></a><a id="sthref637"></a>PL/SQL lets you define your own subtypes. The base type can be any scalar PL/SQL type, including a previously defined user-defined subtype.</p>
<p>Subtypes can:</p>
<ul>
<li>
<p>Provide compatibility with ANSI/ISO data types</p>
</li>
<li>
<p>Show the intended use of data items of that type</p>
</li>
<li>
<p>Detect out-of-range values</p>
</li>
</ul>
<p>For more information about user-defined PL/SQL subtypes, see <a class="olink LNPLS99935" href="../LNPLS/datatypes.htm#LNPLS99935"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABDFHCJ"></a>
<div id="ADFNS1318" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.4.2</span> PL/SQL Composite Data Types</h4>
<p><a id="sthref638"></a><span class="bold">Composite data types</span> have internal components. The PL/SQL composite data types are collections and records.</p>
<p>In a <a id="sthref639"></a><span class="bold">collection</span>, the internal components always have the same data type, and are called <span class="bold">elements</span>. You can access each element of a collection variable by its unique index. PL/SQL has three collection types&mdash;associative array, <code dir="ltr">VARRAY</code> (variable-size array), and nested table.</p>
<p>In a <a id="sthref640"></a><span class="bold">record</span>, the internal components can have different data types, and are called <span class="bold">fields</span>. You can access each field of a record variable by its name.</p>
<p>You can create a collection of records, and a record that contains collections.</p>
<p>For more information about PL/SQL composite data types, see <a class="olink LNPLS005" href="../LNPLS/composites.htm#LNPLS005"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect3" -->
<a id="BABFHDGA"></a>
<div id="ADFNS1323" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.4.3</span> Abstract Data Types</h4>
<p>An <a id="sthref641"></a>Abstract Data Type (ADT) consists of a data structure and subprograms that manipulate the data. In the static data dictionary view <code dir="ltr">*_OBJECTS</code>, the <code dir="ltr">OBJECT_TYPE</code> of an ADT is <code dir="ltr">TYPE</code>. In the static data dictionary view <code dir="ltr">*_TYPES</code>, the <code dir="ltr">TYPECODE</code> of an ADT is <code dir="ltr">OBJECT</code>.</p>
<p>For more information about ADTs, see <a class="olink LNPLS163" href="../LNPLS/overview.htm#LNPLS163"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007323"></a>
<div id="ADFNS00903" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.5</span> Returning Result Sets to Clients</h3>
<p>In PL/SQL, as in traditional database programming, you use cursors to process <a id="sthref642"></a>query result sets. A <a id="sthref643"></a><span class="bold">cursor</span> is a pointer to a private SQL area that stores information about processing a specific <code dir="ltr">SELECT</code> or DML statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The cursors that this section discusses are session cursors. A <a id="sthref644"></a><a id="sthref645"></a><span class="bold">session cursor</span> lives in session memory until the session ends, when it ceases to exist. Session cursors are different from the cursors in the private SQL area of the program global area (PGA), which are explained in <a class="olink CNCPT1239" href="../CNCPT/memory.htm#CNCPT1239"><span class="italic">Oracle Database Concepts</span></a>.</div>
<p>A cursor that is constructed and managed by PL/SQL is an <a id="sthref646"></a><a id="sthref647"></a><span class="bold">implicit cursor</span>. A cursor that you construct and manage is an <a id="sthref648"></a><a id="sthref649"></a><span class="bold">explicit cursor</span>. The only advantage of an explicit cursor over an implicit cursor is that with an explicit cursor, you can limit the number of fetched rows (for details, see <a class="olink LNPLS897" href="../LNPLS/tuning.htm#LNPLS897"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>). For general information about cursors, see <a class="olink LNPLS00602" href="../LNPLS/static.htm#LNPLS00602"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>. For information about query set result processing with implicit and explicit cursors, see <a class="olink LNPLS00603" href="../LNPLS/static.htm#LNPLS00603"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>A <span class="bold">cursor variable</span> is a pointer to a cursor. That is, its value is the address of a cursor, not the cursor itself. Therefore, a cursor variable has more flexibility than an explicit cursor. However, a cursor variable also has costs that an explicit cursor does not.</p>
<p class="subhead2"><a id="ADFNS1034"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABBHIEA">Advantages of Cursor Variables</a></p>
</li>
<li>
<p><a href="#BABHHJEJ">Disadvantages of Cursor Variables</a></p>
</li>
<li>
<p><a href="#BABEHHJH">Returning Query Results Implicitly</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS00605" href="../LNPLS/static.htm#LNPLS00605"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for general information about cursor variables</p>
</li>
<li>
<p><a class="olink LNOCI16367" href="../LNOCI/oci05bnd.htm#LNOCI16367"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for information about using cursor variables in OCI</p>
</li>
<li>
<p><a class="olink LNPCC3218" href="../LNPCC/pc_04dat.htm#LNPCC3218"><span class="italic">Pro*C/C++ Programmer&#39;s Guide</span></a> for information about using cursor variables in Pro*C/C++</p>
</li>
<li>
<p><a class="olink LNPCB371" href="../LNPCB/pco05sql.htm#LNPCB371"><span class="italic">Pro*COBOL Programmer&#39;s Guide</span></a> for information about using cursor variables in Pro*COBOL</p>
</li>
<li>
<p><a class="olink JJDBC28151" href="../JJDBC/oraint.htm#JJDBC28151"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for information about using cursor variables in JDBC</p>
</li>
<li>
<p><a href="#i1008519">Section 11.4.6, &#34;Returning Large Amounts of Data from a Function&#34;</a></p>
</li>
</ul>
</div>
<a id="BABBHIEA"></a>
<div id="ADFNS159" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.5.1</span> Advantages of Cursor Variables</h4>
<p>A <a id="sthref650"></a>cursor variable is like an explicit cursor except that:</p>
<ul>
<li>
<p>It is not limited to one query.</p>
<p>You can open a cursor variable for a query, process the result set, and then use the cursor variable for another query.</p>
</li>
<li>
<p>You can assign a value to it.</p>
</li>
<li>
<p>You can use it in an expression.</p>
</li>
<li>
<p>It can be a subprogram parameter.</p>
<p>You can use cursor variables to pass query result sets between subprograms.</p>
</li>
<li>
<p>It can be a host variable.</p>
<p>You can use cursor variables to pass query result sets between PL/SQL stored subprograms and their clients.</p>
</li>
<li>
<p>It cannot accept parameters.</p>
<p>You cannot pass parameters to a cursor variable, but you can pass whole queries to it. The queries can include variables.</p>
</li>
</ul>
<p>The preceding characteristics give cursor variables these advantages:</p>
<ul>
<li>
<p>Encapsulation</p>
<p>Queries are centralized in the stored subprogram that opens the cursor variable.</p>
</li>
<li>
<p>Easy maintenance</p>
<p>If you must change the cursor, then you must change only the stored subprogram, not every application that invokes the stored subprogram.</p>
</li>
<li>
<p>Convenient security</p>
<p>The application connects to the server with the user name of the application user. The application user must have <code dir="ltr">EXECUTE</code> permission on the stored subprogram that opens the cursor, but need not have <code dir="ltr">READ</code> permission on the queried tables.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABHHJEJ"></a>
<div id="ADFNS160" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.5.2</span> Disadvantages of Cursor Variables</h4>
<p>If you need not use a <a id="sthref651"></a>cursor variable, then use an implicit or explicit cursor, for both better performance and ease of programming.</p>
<p class="subhead2"><a id="ADFNS176"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABBDCHA">Parsing Penalty for Cursor Variable</a></p>
</li>
<li>
<p><a href="#BABGFHIG">Multiple-Row-Fetching Penalty for Cursor Variable</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The examples in these topics include <code dir="ltr">TKPROF</code> reports. For instructions for producing <code dir="ltr">TKPROF</code> reports, see <a class="olink TGSQL809" href="../TGSQL/tgsql_trace.htm#TGSQL809"><span class="italic">Oracle Database SQL Tuning Guide</span></a>.</div>
<a id="BABBDCHA"></a>
<div id="ADFNS177" class="sect4">
<h5 class="sect4"><span class="secnum">11.4.5.2.1</span> Parsing Penalty for Cursor Variable</h5>
<p>When you close an explicit cursor, the cursor closes from your perspective&mdash;that is, you cannot use it where an open cursor is required&mdash;but PL/SQL caches the explicit cursor in an open state. If you reexecute the statement associated with the cursor, then PL/SQL uses the cached cursor, thereby avoiding a parse.</p>
<p>Avoiding a parse can significantly reduce CPU use, and the caching of explicit cursors is transparent to you; it does not affect your programming. PL/SQL does not reduce your supply of available open cursors. If your program must open another cursor but doing so would exceed the init.ora setting of <code dir="ltr">OPEN_CURSORS</code>, then PL/SQL closes cached cursors.</p>
<p>PL/SQL cannot cache a cursor variable in an open state. Therefore, a cursor variable has a parsing penalty.</p>
<p>In <a href="#BABJIJBE">Example 11-2</a>, the procedure opens, fetches from, and closes an explicit cursor and then does the same with a cursor variable. The anonymous block calls the procedure 10 times. The <code dir="ltr">TKPROF</code> report shows that both queries were run 10 times, but the query associated with the explicit cursor was parsed only once, while the query associated with the cursor variable was parsed 10 times.</p>
<div id="ADFNS178" class="example">
<p class="titleinexample"><a id="BABJIJBE"></a>Example 11-2 Parsing Penalty for Cursor Variable</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE p AUTHID DEFINER IS
  CURSOR e_c IS <span class="bold">SELECT * FROM DUAL d1</span>;  -- <span class="bold">explicit cursor</span>
  c_v SYS_REFCURSOR;                    -- <span class="bold">cursor variable</span>
  rec DUAL%ROWTYPE;
BEGIN
  OPEN e_c;                             -- <span class="bold">explicit cursor</span>
  FETCH e_c INTO rec;
  CLOSE e_c;

  OPEN c_v FOR <span class="bold">SELECT * FROM DUAL d2</span>;   -- <span class="bold">cursor variable</span>
  FETCH c_v INTO rec;
  CLOSE c_v;
END;
/
BEGIN
  FOR i IN 1..10 LOOP                   -- execute p 10 times
     p;
  END LOOP;
</pre>
<p><code dir="ltr">TKPROF</code> report is similar to:</p>
<pre dir="ltr"><span class="bold">SELECT * FROM DUAL D1;</span>
 
call     count
------- ------
<span class="bold">Parse</span>        <span class="bold">1</span>
Execute     10
Fetch       10
------- ------
total       <span class="bold">21</span>
****************
<span class="bold">SELECT * FROM DUAL D2;</span>
 
 
call     count
------- ------
<span class="bold">Parse</span>       <span class="bold">10</span>
Execute     10
Fetch       10
------- ------
total       <span class="bold">30</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="BABGFHIG"></a>
<div id="ADFNS215" class="sect4">
<h5 class="sect4"><span class="secnum">11.4.5.2.2</span> Multiple-Row-Fetching Penalty for Cursor Variable</h5>
<p><a href="#BABEBAJF">Example 11-3</a> creates a table that has more than 7,000 rows and fetches all of those rows twice, first with an implicit cursor (fetching arrays) and then with a cursor variable (fetching individual rows). The code for the implicit cursor is simpler than the code for the cursor variable, and the <code dir="ltr">TKPROF</code> report shows that it also performs better.</p>
<p>Although you could use the cursor variable to fetch arrays, you would need much more code. Specifically, you would need code to do the following:</p>
<ul>
<li>
<p>Define the types of the collections into which you will fetch the arrays</p>
</li>
<li>
<p>Explicitly bulk collect into the collections</p>
</li>
<li>
<p>Loop through the collections to process the fetched data</p>
</li>
<li>
<p>Close the explicitly opened cursor variable</p>
</li>
</ul>
<div id="ADFNS217" class="example">
<p class="titleinexample"><a id="BABEBAJF"></a>Example 11-3 Array Fetching Penalty for Cursor Variable</p>
<p>Create table to query and display its number of rows:</p>
<pre dir="ltr">CREATE TABLE t AS
  SELECT * FROM ALL_OBJECTS;
 
SELECT COUNT(*) FROM t;
 
</pre>
<p>Result is similar to:</p>
<pre dir="ltr">  COUNT(*)
----------
     70788
</pre>
<p>Perform equivalent operations with an implicit cursor and a cursor variable:</p>
<pre dir="ltr">DECLARE
  c_v SYS_REFCURSOR;
  rec t%ROWTYPE;
BEGIN
  FOR x IN (<span class="bold">SELECT * FROM t exp_cur</span>) LOOP  -- <span class="bold">implicit cursor</span>
    NULL;
  END LOOP;
 
  OPEN c_v FOR <span class="bold">SELECT * FROM t cur_var</span>;    -- <span class="bold">cursor variable</span>
 
  LOOP
    FETCH c_v INTO rec;
    EXIT WHEN c_v%NOTFOUND;
  END LOOP;
 
  CLOSE c_v;
END;
/
</pre>
<p><code dir="ltr">TKPROF</code> report is similar to:</p>
<pre dir="ltr"><span class="bold">SELECT * FROM T EXP_CUR</span>

call     count       cpu    elapsed       disk      query    current        rows
------- ------  -------- ---------- ---------- ---------- ----------  ----------
Parse        1      0.00       0.00          0          0          0           0
Execute      1      0.00       0.00          0          0          0           0
<span class="bold">Fetch      722</span>      0.23       0.23          0       <span class="bold">1748</span>          0       <span class="bold">72198</span>
------- ------  -------- ---------- ---------- ---------- ----------  ----------
total      724      0.23       0.23          0       1748          0       72198
********************************************************************************
<span class="bold">SELECT * FROM T CUR_VAR</span>

call     count       cpu    elapsed       disk      query    current        rows
------- ------  -------- ---------- ---------- ---------- ----------  ----------
Parse        1      0.00       0.00          0          0          0           0
Execute      1      0.00       0.00          0          0          0           0
<span class="bold">Fetch    72199</span>      0.40       0.42          0      <span class="bold">72203</span>          0       <span class="bold">72198</span>
------- ------  -------- ---------- ---------- ---------- ----------  ----------
total    72201      0.40       0.42          0      72203          0       72198
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABEHHJH"></a>
<div id="ADFNS1035" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.5.3</span> Returning Query Results Implicitly</h4>
<p>A stored subprogram can return a <a id="sthref652"></a>query result implicitly to either the client program or the subprogram&#39;s immediate caller by invoking the <a id="sthref653"></a><a id="sthref654"></a><code dir="ltr">DBMS_SQL</code>.<code dir="ltr">RETURN_RESULT</code> procedure. After <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">RETURN_RESULT</code> returns the result, only the recipient can access it. For details, see <a class="olink LNPLS2174" href="../LNPLS/dynamic.htm#LNPLS2174"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To return implicitly the result of a query executed with <a id="sthref655"></a>dynamic SQL, the subprogram must execute the query with <code dir="ltr">DBMS_SQL</code> procedures, not the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement. The reason is that the cursors that the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement returns to the subprogram are closed when the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement completes. For information about using <code dir="ltr">DBMS_SQL</code> procedures for dynamic SQL, see <a class="olink LNPLS01108" href="../LNPLS/dynamic.htm#LNPLS01108"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008519"></a>
<div id="ADFNS00909" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.6</span> Returning Large Amounts of Data from a Function</h3>
<p><a id="sthref656"></a>In a data warehousing environment, you might use PL/SQL functions to transform large amounts of data. You might pass the data through a series of transformations, each performed by a different function. PL/SQL table functions let you perform such transformations without significant memory overhead or the need to store the data in tables between each transformation stage. These functions can accept and return multiple rows, can return rows as they are ready rather than all at once, and can be parallelized.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01210" href="../LNPLS/tuning.htm#LNPLS01210"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about performing multiple transformations with pipelined table functions</div>
</div>
<!-- class="sect2" -->
<a id="CIHBDCEF"></a>
<div id="ADFNS333" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.7</span> PL/SQL Function Result Cache</h3>
<p><a id="sthref657"></a><a id="sthref658"></a><a id="sthref659"></a><a id="sthref660"></a><a id="sthref661"></a>Using the PL/SQL function result cache can save significant space and time. Each time a result-cached PL/SQL function is invoked with different parameter values, those parameters and their result are stored in the cache. Subsequently, when the same function is invoked with the same parameter values, the result is retrieved from the cache, instead of being recomputed. Because the cache is stored in a shared global area (SGA), it is available to any session that runs your application.</p>
<p>If a database object that was used to compute a cached result is updated, the cached result becomes invalid and must be recomputed.</p>
<p>The best candidates for result-caching are functions that are invoked frequently but depend on information that changes infrequently or never.</p>
<p>For more information about the PL/SQL function result cache, see <a class="olink LNPLS00817" href="../LNPLS/subprograms.htm#LNPLS00817"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1006920"></a>
<div id="ADFNS343" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.8</span> Overview of Bulk Binding</h3>
<p><a id="sthref662"></a>Oracle Database uses two engines to run PL/SQL units. The PL/SQL engine runs the procedural statements and the SQL engine runs the SQL statements. Every SQL statement causes a context switch between the two engines. You can greatly improve the performance of your database application by minimizing the number of context switches for each PL/SQL unit.</p>
<p>When a SQL statement runs inside a loop that uses collection elements as bind variables, the large number of context switches required can cause poor performance. Collections include:</p>
<ul>
<li>
<p>Associative arrays</p>
</li>
<li>
<p>Variable-size arrays</p>
</li>
<li>
<p>Nested tables</p>
</li>
<li>
<p>Host arrays</p>
</li>
</ul>
<p><span class="glossaryterm">Binding</span> is the assignment of values to PL/SQL variables in SQL statements. <span class="glossaryterm">Bulk binding</span> is binding an entire collection at once. Bulk binds pass the entire collection between the two engines in a single operation.</p>
<p>Typically, bulk binding improves performance for SQL statements that affect four or more database rows. The more rows affected by a SQL statement, the greater the performance gain from bulk binding. Consider using bulk binding to improve the performance of DML and <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statements that reference collections and <code dir="ltr">FOR</code> loops that reference collections and return DML.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Parallel DML statements are disabled with bulk binding. For information about parallel DML statements, see <a class="olink LNPLS930" href="../LNPLS/tuning.htm#LNPLS930"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</div>
<p class="subhead2"><a id="ADFNS1055"></a>Topics:</p>
<ul>
<li>
<p><a href="#CIHCHADH">DML Statements that Reference Collections</a></p>
</li>
<li>
<p><a href="#CIHCHIBG">SELECT Statements that Reference Collections</a></p>
</li>
<li>
<p><a href="#CIHCAGJE">FOR Loops that Reference Collections and Return DML</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01205" href="../LNPLS/tuning.htm#LNPLS01205"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about bulk binding, including how to handle exceptions that occur during bulk binding operations</div>
<a id="CIHCHADH"></a>
<div id="ADFNS345" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.8.1</span> DML Statements that Reference Collections</h4>
<p><a id="sthref663"></a><a id="sthref664"></a><a id="sthref665"></a>A bulk bind, which uses the <code dir="ltr">FORALL</code> keyword, can improve the performance of <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statements that reference collection elements.</p>
<p>The PL/SQL block in <a href="#BABDJIJG">Example 11-4</a> increases the salary for employees whose manager&#39;s ID number is 7902, 7698, or 7839, with and without bulk binds. Without bulk bind, PL/SQL sends a SQL statement to the SQL engine for each updated employee, leading to context switches that slow performance.</p>
<div id="ADFNS346" class="example">
<p class="titleinexample"><a id="BABDJIJG"></a>Example 11-4 DML Statements that Reference Collections</p>
<pre dir="ltr">DECLARE
  TYPE numlist IS VARRAY (100) OF NUMBER;
  id NUMLIST := NUMLIST(7902, 7698, 7839);
BEGIN
  <span class="bold">-- Efficient method, using bulk bind:</span>
  
  <span class="bold">FORALL</span> i IN id.FIRST..id.LAST
  UPDATE EMPLOYEES
  SET SALARY = 1.1 * SALARY
  WHERE MANAGER_ID = id(i);
 
 <span class="bold">-- Slower method:</span>
 
 <span class="bold">FOR</span> i IN id.FIRST..id.LAST <span class="bold">LOOP</span>
    UPDATE EMPLOYEES
    SET SALARY = 1.1 * SALARY
    WHERE MANAGER_ID = id(i);
 <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS879" href="../LNPLS/tuning.htm#LNPLS879"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about the <code dir="ltr">FORALL</code> statement</div>
</div>
<!-- class="sect3" -->
<a id="CIHCHIBG"></a>
<div id="ADFNS347" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.8.2</span> SELECT Statements that Reference Collections</h4>
<p><a id="sthref666"></a><a id="sthref667"></a><a id="sthref668"></a>The <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause can improve the performance of queries that reference collections. You can use <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> with tables of scalar values, or tables of <code dir="ltr">%TYPE</code> values.</p>
<p>The PL/SQL block in <a href="#BABGEDJB">Example 11-5</a> queries multiple values into PL/SQL tables, with and without bulk binds. Without bulk bind, PL/SQL sends a SQL statement to the SQL engine for each selected employee, leading to context switches that slow performance.</p>
<div id="ADFNS348" class="example">
<p class="titleinexample"><a id="BABGEDJB"></a>Example 11-5 SELECT Statements that Reference Collections</p>
<pre dir="ltr">DECLARE
  TYPE var_tab IS TABLE OF VARCHAR2(20)
  INDEX BY PLS_INTEGER;
  
  empno    VAR_TAB;
  ename    VAR_TAB;
  counter  NUMBER;
  
  CURSOR c IS
    SELECT EMPLOYEE_ID, LAST_NAME
    FROM EMPLOYEES
    WHERE MANAGER_ID = 7698;
BEGIN
 <span class="bold">-- Efficient method, using bulk bind:</span>
 
 SELECT EMPLOYEE_ID, LAST_NAME <span class="bold">BULK COLLECT</span>
 INTO empno, ename
 FROM EMPLOYEES
 WHERE MANAGER_ID = 7698;
 
 <span class="bold">-- Slower method:</span>
 
 counter := 1;
 
 <span class="bold">FOR</span> rec IN c <span class="bold">LOOP</span>
    empno(counter) := rec.EMPLOYEE_ID;
    ename(counter) := rec.LAST_NAME;
    counter := counter + 1;
 <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS891" href="../LNPLS/tuning.htm#LNPLS891"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause</div>
</div>
<!-- class="sect3" -->
<a id="CIHCAGJE"></a>
<div id="ADFNS99880" class="sect3">
<h4 class="sect3"><span class="secnum">11.4.8.3</span> FOR Loops that Reference Collections and Return DML</h4>
<p><a id="sthref669"></a><a id="sthref670"></a><a id="sthref671"></a>You can use the <code dir="ltr">FORALL</code> keyword with the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> keywords to improve the performance of <code dir="ltr">FOR</code> loops that reference collections and return DML.</p>
<p>The PL/SQL block in <a href="#BABIBDGI">Example 11-6</a> updates the <code dir="ltr">EMPLOYEES</code> table by computing bonuses for a collection of employees. Then it returns the bonuses in a column called <code dir="ltr">bonus_list_inst</code>. The actions are performed with and without bulk binds. Without bulk bind, PL/SQL sends a SQL statement to the SQL engine for each updated employee, leading to context switches that slow performance.</p>
<div id="ADFNS350" class="example">
<p class="titleinexample"><a id="BABIBDGI"></a>Example 11-6 FOR Loops that Reference Collections and Return DML</p>
<pre dir="ltr">DECLARE
  TYPE emp_list IS VARRAY(100) OF EMPLOYEES.EMPLOYEE_ID%TYPE;
  empids emp_list := emp_list(182, 187, 193, 200, 204, 206);
  
  TYPE bonus_list IS TABLE OF EMPLOYEES.SALARY%TYPE;
  bonus_list_inst  bonus_list;
  
BEGIN
  <span class="bold">-- Efficient method, using bulk bind:</span>
 
 <span class="bold">FORALL</span> i IN empids.FIRST..empids.LAST
 UPDATE EMPLOYEES
 SET SALARY = 0.1 * SALARY
 WHERE EMPLOYEE_ID = empids(i)
 <span class="bold">RETURNING SALARY BULK COLLECT INTO bonus_list_inst;</span>
 
 -- Slower method:
 
 <span class="bold">FOR</span> i IN empids.FIRST..empids.LAST <span class="bold">LOOP</span>
   UPDATE EMPLOYEES
   SET SALARY = 0.1 * SALARY
   WHERE EMPLOYEE_ID = empids(i)
   <span class="bold">RETURNING SALARY INTO bonus_list_inst(i);</span>
 <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS899" href="../LNPLS/tuning.htm#LNPLS899"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about use the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause with the <code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABFJFCC"></a>
<div id="ADFNS1320" class="sect2">
<h3 class="sect2"><span class="secnum">11.4.9</span> PL/SQL Dynamic SQL</h3>
<p><a id="sthref672"></a><span class="bold">Dynamic SQL</span> is a programming methodology for generating and running SQL statements at runtime. It is useful when writing general-purpose and flexible programs like dynamic query systems, when writing programs that must run database definition language (DDL) statements, or when you do not know at compile time the full text of a SQL statement or the number or data types of its input and output variables.</p>
<p>If you do not need dynamic SQL, then use static SQL, which has these advantages:</p>
<ul>
<li>
<p>Successful compilation verifies that static SQL statements reference valid database objects and that the necessary privileges are in place to access those objects.</p>
</li>
<li>
<p>Successful compilation creates schema object dependencies.</p>
<p>For information about schema object dependency, see <a href="adfns_dependencies.htm#CHDFADFI">Chapter 23, &#34;Understanding Schema Object Dependency.&#34;</a></p>
</li>
</ul>
<p>For information about dynamic SQL, see <a class="olink LNPLS011" href="../LNPLS/dynamic.htm#LNPLS011"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>For information about static SQL, see <a class="olink LNPLS006" href="../LNPLS/static.htm#LNPLS006"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="g1041906"></a>
<div id="ADFNS329" class="sect1">
<h2 class="sect1"><span class="secnum">11.5</span> Altering PL/SQL Subprograms and Packages</h2>
<p>To alter the name of a stored standalone subprogram or package, you must drop it (as instructed in <a href="#g1041928">Section 11.6</a>) and then create it with the new name. For example:</p>
<pre dir="ltr">CREATE PROCEDURE <span class="bold">p</span> IS BEGIN NULL; END;
/
DROP PROCEDURE p
/
CREATE PROCEDURE <span class="bold">p1</span> IS BEGIN NULL; END;
/
</pre>
<p>To alter a stored standalone subprogram or package without changing its name, you can replace it with a new version with the same name by including <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> in the <code dir="ltr">CREATE</code> statement. For example:</p>
<pre dir="ltr">CREATE <span class="bold">OR REPLACE</span> PROCEDURE <span class="bold">p1</span> IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;Hello, world!&#39;);
END;
/
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">ALTER</code> statements (such as <code dir="ltr">ALTER</code> <code dir="ltr">FUNCTION</code>, <code dir="ltr">ALTER</code> <code dir="ltr">PROCEDURE</code>, and <code dir="ltr">ALTER</code> <code dir="ltr">PACKAGE</code>) do not alter the declarations or definitions of existing PL/SQL units, they recompile only the units. For information about <code dir="ltr">ALTER</code> statements, see <a class="olink LNPLS99974" href="../LNPLS/sqlstatements.htm#LNPLS99974"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</div>
</div>
<!-- class="sect1" -->
<a id="g1041928"></a>
<div id="ADFNS330" class="sect1">
<h2 class="sect1"><span class="secnum">11.6</span> Dropping PL/SQL Subprograms and Packages</h2>
<p>To drop <a id="sthref673"></a>stored standalone subprograms, use these statements:</p>
<ul>
<li>
<p><code dir="ltr">DROP</code> <code dir="ltr">FUNCTION</code>, described in <a class="olink LNPLS99993" href="../LNPLS/drop_function.htm#LNPLS99993"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
<li>
<p><code dir="ltr">DROP</code> <code dir="ltr">PROCEDURE</code>, described in <a class="olink LNPLS99991" href="../LNPLS/drop_procedure.htm#LNPLS99991"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
</ul>
<p>To drop a <a id="sthref674"></a>package (specification and body) or only its body, use the statement <code dir="ltr">DROP</code> <code dir="ltr">PACKAGE</code>, described in <a class="olink LNPLS99992" href="../LNPLS/drop_package.htm#LNPLS99992"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1007058"></a>
<div id="ADFNS00902" class="sect1">
<h2 class="sect1"><span class="secnum">11.7</span> Compiling PL/SQL Units for Native Execution</h2>
<p><a id="sthref675"></a>You can usually speed up PL/SQL units&mdash;your own and those that Oracle supplies&mdash;by compiling them into native code (processor-dependent system code), which is stored in the SYSTEM tablespace.</p>
<p>PL/SQL units compiled into native code run in all server environments, including the shared server configuration (formerly called &#34;multithreaded server&#34;) and Oracle Real Application Clusters (Oracle RAC).</p>
<p>Whether to compile a PL/SQL unit into native code depends on where you are in the development cycle and what the PL/SQL unit does.</p>
<p>For more information about compiling PL/SQL units for native execution, see <a class="olink LNPLS01209" href="../LNPLS/tuning.htm#LNPLS01209"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To compile Java packages and classes for native execution, use the <code dir="ltr">ncomp</code> tool. For more information, see <a class="olink JJDEV01200" href="../JJDEV/chone.htm#JJDEV01200"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a>.</div>
</div>
<!-- class="sect1" -->
<a id="i1007682"></a>
<div id="ADFNS00906" class="sect1">
<h2 class="sect1"><span class="secnum">11.8</span> Invoking Stored PL/SQL Subprograms</h2>
<p><a id="sthref676"></a>Stored PL/SQL subprograms can be invoked from many different environments. For example:</p>
<ul>
<li>
<p>Interactively, using an Oracle Database tool</p>
</li>
<li>
<p>From the body of another subprogram</p>
</li>
<li>
<p>From the body of a trigger</p>
</li>
<li>
<p>From within an application (such as a SQL*Forms or a precompiler)</p>
</li>
</ul>
<p>Stored PL/SQL functions (but not procedures) can also be invoked from within SQL statements. For details, see <a href="#i1007943">Section 11.9</a>.</p>
<p>When you invoke a subprogram owned by another user:</p>
<ul>
<li>
<p>You must include the name of the owner in the invocation. For example:</p>
<pre dir="ltr">EXECUTE <span class="bold">jdoe</span>.Fire_emp (1043);
EXECUTE <span class="bold">jdoe</span>.Hire_fire.Fire_emp (1043);
</pre></li>
<li>
<p>The <a id="sthref677"></a><code dir="ltr">AUTHID</code> property of the subprogram affects the name resolution and privilege checking of SQL statements that the subprogram issues at runtime. For details, see <a class="olink LNPLS00809" href="../LNPLS/subprograms.htm#LNPLS00809"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS1038"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1879512">Privileges Required to Invoke a Stored Subprogram</a></p>
</li>
<li>
<p><a href="#g1043032">Invoking a Subprogram Interactively from Oracle Tools</a></p>
</li>
<li>
<p><a href="#g1043025">Invoking a Subprogram from Another Subprogram</a></p>
</li>
<li>
<p><a href="#i1007858">Invoking a Remote Subprogram</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS008" href="../LNPLS/overview.htm#LNPLS008"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about subprogram invocation, parameters, and definer&#39;s and invoker&#39;s rights</p>
</li>
<li>
<p><a class="olink LNPLS2006" href="../LNPLS/create_trigger.htm#LNPLS2006"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about coding the body of a trigger</p>
</li>
<li>
<p><a href="#i1007943">Section 11.9, &#34;Invoking Stored PL/SQL Functions from SQL Statements&#34;</a></p>
</li>
<li>
<p><a class="olink LNOCI16365" href="../LNOCI/oci05bnd.htm#LNOCI16365"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for information about invoking PL/SQL subprograms from OCI applications</p>
</li>
<li>
<p><a class="olink LNPCC3422" href="../LNPCC/pc_07pls.htm#LNPCC3422"><span class="italic">Pro*C/C++ Programmer&#39;s Guide</span></a> for information about invoking PL/SQL subprograms from Pro*C/C++</p>
</li>
<li>
<p><a class="olink LNPCB006" href="../LNPCB/pco06pls.htm#LNPCB006"><span class="italic">Pro*COBOL Programmer&#39;s Guide</span></a> for information about invoking PL/SQL subprograms from Pro*COBOL</p>
</li>
<li>
<p><a class="olink JJDBC28076" href="../JJDBC/getsta.htm#JJDBC28076"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for information about invoking PL/SQL subprograms from JDBC applications</p>
</li>
</ul>
</div>
<a id="g1879512"></a>
<div id="ADFNS370" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.8.1</span> Privileges Required to Invoke a Stored Subprogram</h3>
<p><a id="sthref678"></a><a id="sthref679"></a>You do not need privileges to invoke:</p>
<ul>
<li>
<p>Standalone subprograms that you own</p>
</li>
<li>
<p>Subprograms in packages that you own</p>
</li>
<li>
<p>Public standalone subprograms</p>
</li>
<li>
<p>Subprograms in public packages</p>
</li>
</ul>
<p>To invoke a stored subprogram owned by another user, you must have the <code dir="ltr">EXECUTE</code> privilege for the standalone subprogram or for the package containing the package subprogram, or you must have the <code dir="ltr">EXECUTE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege. If the subprogram is remote, then you must be granted the <code dir="ltr">EXECUTE</code> privilege or <code dir="ltr">EXECUTE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege directly, not through a role.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01603" href="../SQLRF/statements_9014.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about system and object privileges</div>
</div>
<!-- class="sect2" -->
<a id="g1043032"></a>
<div id="ADFNS371" class="sect2">
<h3 class="sect2"><span class="secnum">11.8.2</span> Invoking a Subprogram Interactively from Oracle Tools</h3>
<p><a id="sthref680"></a>You can invoke a subprogram interactively from an Oracle Database tool, such as SQL*Plus. <a href="#BABFDDBJ">Example 11-7</a> uses SQL*Plus to create a procedure and then invokes it in two different ways.</p>
<div id="ADFNS372" class="example">
<p class="titleinexample"><a id="BABFDDBJ"></a>Example 11-7 Invoking a Subprogram Interactively with SQL*Plus</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE salary_raise (
  employee  EMPLOYEES.EMPLOYEE_ID%TYPE,
  increase  EMPLOYEES.SALARY%TYPE
)
IS
BEGIN
  UPDATE EMPLOYEES
  SET SALARY = SALARY + increase
  WHERE EMPLOYEE_ID = employee;
END;
/
 
</pre>
<p>Invoke procedure from within anonymous block:</p>
<pre dir="ltr">BEGIN
  <span class="bold">salary_raise(205, 200);</span>
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">PL/SQL procedure successfully completed.
 
</pre>
<p>Invoke procedure with <code dir="ltr">EXECUTE</code> statement:</p>
<pre dir="ltr"><span class="bold">EXECUTE salary_raise(205, 200);</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr">PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p>Some interactive tools allow you to create <a id="sthref681"></a>session variables, which you can use for the duration of the session. Using SQL*Plus, <a href="#BABFJFJC">Example 11-8</a> creates, uses, and prints a session variable.</p>
<div id="ADFNS373" class="example">
<p class="titleinexample"><a id="BABFJFJC"></a>Example 11-8 Creating and Using a Session Variable with SQL*Plus</p>
<pre dir="ltr">-- Create function for later use:

CREATE OR REPLACE FUNCTION get_job_id (
  emp_id  EMPLOYEES.EMPLOYEE_ID%TYPE
) RETURN EMPLOYEES.JOB_ID%TYPE
IS
  job_id  EMPLOYEES.JOB_ID%TYPE;
BEGIN
  SELECT JOB_ID INTO job_id
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = emp_id;
 
  RETURN job_id;
END;
/
<span class="bold">-- Create session variable:</span>
 
<span class="bold">VARIABLE job VARCHAR2(10);</span>
 
<span class="bold">-- Run function and store returned value in session variable:</span>
 
<span class="bold">EXECUTE :job := get_job_id(204);</span>
 
PL/SQL procedure successfully completed.
 
</pre>
<p>SQL*Plus command:</p>
<pre dir="ltr"><span class="bold">PRINT job;</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">JOB</span>
<span class="bold">--------------------------------</span>
<span class="bold">PR_REP</span>
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQPUG043" href="../SQPUG/ch_twelve022.htm#SQPUG043"><span class="italic">SQL*Plus User&#39;s Guide and Reference</span></a> for information about the <code dir="ltr">EXECUTE</code> command</p>
</li>
<li>
<p>Your tools documentation for information about performing similar operations using your development tool</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="g1043025"></a>
<div id="ADFNS374" class="sect2">
<h3 class="sect2"><span class="secnum">11.8.3</span> Invoking a Subprogram from Another Subprogram</h3>
<p><a id="sthref682"></a><a id="sthref683"></a><a id="sthref684"></a>A subprogram or a trigger can invoke another stored subprogram. In <a href="#BABGJHII">Example 11-9</a>, the procedure <code dir="ltr">print_mgr_name</code> invokes the procedure <code dir="ltr">print_emp_name</code>.</p>
<p>Recursive subprogram invocations are allowed (that is, a subprogram can invoke itself).</p>
<div id="ADFNS375" class="example">
<p class="titleinexample"><a id="BABGJHII"></a>Example 11-9 Invoking a Subprogram from Within Another Subprogram</p>
<pre dir="ltr">-- Create procedure that takes employee&#39;s ID and prints employee&#39;s name:
 
CREATE OR REPLACE <span class="bold">PROCEDURE print_emp_name</span> (
  emp_id  EMPLOYEES.EMPLOYEE_ID%TYPE
)
IS
  fname  EMPLOYEES.FIRST_NAME%TYPE;
  lname  EMPLOYEES.LAST_NAME%TYPE;
BEGIN
  SELECT FIRST_NAME, LAST_NAME
  INTO fname, lname
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = emp_id;
 
  DBMS_OUTPUT.PUT_LINE (
    &#39;Employee #&#39; || emp_id || &#39;:  &#39; || fname || &#39; &#39; || lname
  );
END;
/
 
-- Create procedure that takes employee&#39;s ID and prints manager&#39;s name:
 
CREATE OR REPLACE <span class="bold">PROCEDURE print_mgr_name</span> (
  emp_id  EMPLOYEES.EMPLOYEE_ID%TYPE
)
IS
  mgr_id  EMPLOYEES.MANAGER_ID%TYPE;
BEGIN
  SELECT MANAGER_ID
  INTO mgr_id
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = emp_id;
 
 DBMS_OUTPUT.PUT_LINE (
   &#39;Manager of employee #&#39; || emp_id || &#39; is:  &#39;
 );
 
 <span class="bold">print_emp_name(mgr_id);</span>
END;
/
 
</pre>
<p>Invoke procedures:</p>
<pre dir="ltr">BEGIN
  print_emp_name(200);
  print_mgr_name(200);
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">Employee #200:  Jennifer Whalen
Manager of employee #200 is:
Employee #101:  Neena Kochhar
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1007858"></a>
<div id="ADFNS00907" class="sect2">
<h3 class="sect2"><span class="secnum">11.8.4</span> Invoking a Remote Subprogram</h3>
<p>A <a id="sthref685"></a><a id="sthref686"></a><span class="bold">remote subprogram</span> is stored on a different database from its invoker. A remote subprogram invocation must include the subprogram name, a database link to the database on which the subprogram is stored, and an actual parameter for every formal parameter (even if the formal parameter has a default value).</p>
<p>For example, this SQL*Plus statement invokes the stored standalone procedure <code dir="ltr">fire_emp1</code>, which is referenced by the local database link named <code dir="ltr">boston_server</code>:</p>
<pre dir="ltr">EXECUTE fire_emp1@boston_server(1043);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although you can invoke remote package subprograms, you cannot directly access remote package variables and constants.</div>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<ul>
<li>
<p>Remote subprogram invocations use runtime binding. The user account to which you connect depends on the database link. (Stored subprograms use compile-time binding.)</p>
</li>
<li>
<p>If a local subprogram invokes a remote subprogram, and a time-stamp mismatch is found during execution of the local subprogram, then the remote subprogram is not run, and the local subprogram is invalidated. For more information, see <a href="adfns_dependencies.htm#CHDIBBDE">Section 23.9.1, &#34;Dependencies Among Local and Remote Database Procedures.&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="ADFNS1039"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABGHIBF">Synonyms for Remote Subprograms</a></p>
</li>
<li>
<p><a href="#BABCDDHJ">Transactions That Invoke Remote Subprograms</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adfns_dependencies.htm#CHDIBBDE">Section 23.9.1, &#34;Dependencies Among Local and Remote Database Procedures&#34;</a></p>
</li>
<li>
<p><a class="olink LNPLS007" href="../LNPLS/errors.htm#LNPLS007"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about handling errors in subprograms</p>
</li>
</ul>
</div>
<a id="BABGHIBF"></a>
<div id="ADFNS377" class="sect3">
<h4 class="sect3"><span class="secnum">11.8.4.1</span> Synonyms for Remote Subprograms</h4>
<p>A <a id="sthref687"></a><a id="sthref688"></a><a id="sthref689"></a><a id="sthref690"></a><span class="bold">synonym</span> is an alias for a schema object. You can create a synonym for a remote subprogram name and database link, and then use the synonym to invoke the subprogram. For example:</p>
<pre dir="ltr"><span class="bold">CREATE SYNONYM synonym1 for fire_emp1@boston_server;</span>
EXECUTE <span class="bold">synonym1</span>(1043);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot create a synonym for a package subprogram, because it is not a schema object (its package is a schema object).</div>
<p>Synonyms provide both data independence and location transparency. Using the synonym, a user can invoke the subprogram without knowing who owns it or where it is. However, a synonym is not a substitute for privileges&mdash;to use the synonym to invoke the subprogram, the user still needs the necessary privileges for the subprogram.</p>
<p>Granting a privilege on a synonym is equivalent to granting the privilege on the base object. Similarly, granting a privilege on a base object is equivalent to granting the privilege on all synonyms for the object.</p>
<p>You can create both private and public synonyms. A private synonym is in your schema and you control its availability to others. A public synonym belongs to the user group <code dir="ltr">PUBLIC</code> and is available to every database user.</p>
<p>Use public synonyms sparingly because they make database consolidation more difficult (for an example, see <a class="olink CNCPT88883" href="../CNCPT/schemaob.htm#CNCPT88883"><span class="italic">Oracle Database Concepts</span></a>).</p>
<p>If you do not want to use a synonym, you can create a local subprogram to invoke the remote subprogram. For example:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE local_procedure
  (arg IN NUMBER)
AS
BEGIN
  <span class="bold">fire_emp1@boston_server(arg);</span>
END;
/
DECLARE
  arg NUMBER;
BEGIN
  <span class="bold">local_procedure(arg);</span>
END;
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT711" href="../CNCPT/schemaob.htm#CNCPT711"><span class="italic">Oracle Database Concepts</span></a> for general information about synonyms</p>
</li>
<li>
<p><a class="olink SQLRF01401" href="../SQLRF/statements_7001.htm#SQLRF01401"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">CREATE</code> <code dir="ltr">SYNONYM</code> statement</p>
</li>
<li>
<p><a class="olink SQLRF01603" href="../SQLRF/statements_9014.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">GRANT</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABCDDHJ"></a>
<div id="ADFNS378" class="sect3">
<h4 class="sect3"><span class="secnum">11.8.4.2</span> Transactions That Invoke Remote Subprograms</h4>
<p><a id="sthref691"></a>A remote subprogram invocation is assumed to update a database. Therefore, a transaction that invokes a remote subprogram requires a two-phase commit (even if the remote subprogram does not update a database). If the transaction is rolled back, then the work done by the remote subprogram is also rolled back.</p>
<p>With respect to the statements <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, and <code dir="ltr">SAVEPOINT</code>, a remote subprogram differs from a local subprogram in these ways:</p>
<ul>
<li>
<p>If the transaction starts on a database that is not an Oracle database, then the remote subprogram cannot run these statements.</p>
<p>This situation can occur in Oracle XA applications, which are not recommended. For details, see <a href="adfns_xa.htm#g1027587">Chapter 19, &#34;Developing Applications with Oracle XA.&#34;</a></p>
</li>
<li>
<p>After running one of these statements, the remote subprogram cannot start its own distributed transactions.</p>
<p>A <a id="sthref692"></a><a id="sthref693"></a><span class="glossaryterm">distributed transaction</span> updates two or more databases. Statements in the transaction are sent to the different databases, and the transaction succeeds or fails as a unit. If the transaction fails on any database, then it must be rolled back (either to a savepoint or completely) on all databases. Consider this when creating subprograms that perform distributed updates.</p>
</li>
<li>
<p>If the remote subprogram does not commit or roll back its work, then the work is implicitly committed when the database link is closed. Until then, the remote subprogram is considered to be performing a transaction. Therefore, further invocations to the remote subprogram are not allowed.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007943"></a>
<div id="ADFNS00908" class="sect1">
<h2 class="sect1"><span class="secnum">11.9</span> Invoking Stored PL/SQL Functions from SQL Statements</h2>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Because SQL is a declarative language, rather than an imperative (or procedural) one, you cannot know how many times a <a id="sthref694"></a>function invoked by a SQL statement will run&mdash;even if the function is written in PL/SQL, an imperative language.
<p>If your application requires that a function be executed a certain number of times, do not invoke that function from a SQL statement. Use a cursor instead.</p>
<p>For example, if your application requires that a function be called for each selected row, then open a cursor, select rows from the cursor, and call the function for each row. This technique guarantees that the number of calls to the function is the number of rows fetched from the cursor.</p>
<p>For general information about cursors, see <a class="olink LNPLS00602" href="../LNPLS/static.htm#LNPLS00602"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<p><a id="sthref695"></a><a id="sthref696"></a>These SQL statements can invoke PL/SQL stored functions:</p>
<ul>
<li>
<p><code dir="ltr">INSERT</code></p>
</li>
<li>
<p><code dir="ltr">UPDATE</code></p>
</li>
<li>
<p><code dir="ltr">DELETE</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code></p>
<p>(<code dir="ltr">SELECT</code> can also invoke a PL/SQL function declared and defined in its <code dir="ltr">WITH</code> clause. For more information, see <a class="olink SQLRF55665" href="../SQLRF/statements_10002.htm#SQLRF55665"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
</li>
<li>
<p><code dir="ltr">CALL</code></p>
<p>(<code dir="ltr">CALL</code> can also invoke a PL/SQL stored procedure.)</p>
</li>
</ul>
<p>To invoke a PL/SQL function from a SQL statement, you must either own or have the <code dir="ltr">EXECUTE</code> privilege on the function. To select from a view defined with a PL/SQL function, you must have <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> privilege on the view. No separate <code dir="ltr">EXECUTE</code> privileges are needed to select from the view.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <a id="sthref697"></a><code dir="ltr">AUTHID</code> property of the PL/SQL function can also affect the privileges that you need to invoke the function from a SQL statement, because <code dir="ltr">AUTHID</code> affects the name resolution and privilege checking of SQL statements that the unit issues at runtime. For details, see <a class="olink LNPLS00809" href="../LNPLS/subprograms.htm#LNPLS00809"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</div>
<p>For general information about invoking subprograms, including passing parameters, see <a class="olink LNPLS008" href="../LNPLS/overview.htm#LNPLS008"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p class="subhead2"><a id="ADFNS1040"></a>Topics:</p>
<ul>
<li>
<p><a href="#CIHGEHJA">Why Invoke PL/SQL Functions from SQL Statements?</a></p>
</li>
<li>
<p><a href="#CIHHBAJB">Where PL/SQL Functions Can Appear in SQL Statements</a></p>
</li>
<li>
<p><a href="#g1043220">When PL/SQL Functions Can Appear in SQL Expressions</a></p>
</li>
<li>
<p><a href="#g1043241">Controlling Side Effects of PL/SQL Functions Invoked from SQL Statements</a></p>
</li>
</ul>
<a id="CIHGEHJA"></a>
<div id="ADFNS379" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.9.1</span> Why Invoke PL/SQL Functions from SQL Statements?</h3>
<p>Invoking PL/SQL functions in SQL statements can:</p>
<ul>
<li>
<p>Increase user productivity by extending SQL</p>
<p>Expressiveness of the SQL statement increases where activities are too complex, too awkward, or unavailable with SQL.</p>
</li>
<li>
<p>Increase query efficiency</p>
<p>Functions in the <code dir="ltr">WHERE</code> clause of a query can filter data using criteria that must otherwise be evaluated by the application.</p>
</li>
<li>
<p>Manipulate character strings to represent special data types (for example, latitude, longitude, or temperature)</p>
</li>
<li>
<p>Provide parallel query execution</p>
<p>If the query is parallelized, then SQL statements in your PL/SQL subprogram might also run in parallel (using the parallel query option).</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHHBAJB"></a>
<div id="ADFNS380" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.9.2</span> Where PL/SQL Functions Can Appear in SQL Statements</h3>
<p>A PL/SQL function can appear in a SQL statement wherever a SQL function or an expression can appear in a SQL statement. For example:</p>
<ul>
<li>
<p>Select list of the <code dir="ltr">SELECT</code> statement</p>
</li>
<li>
<p>Condition of the <code dir="ltr">WHERE</code> or <code dir="ltr">HAVING</code> clause</p>
</li>
<li>
<p><code dir="ltr">CONNECT</code> <code dir="ltr">BY</code>, <code dir="ltr">START</code> <code dir="ltr">WITH</code>, <code dir="ltr">ORDER</code> <code dir="ltr">BY</code>, or <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause</p>
</li>
<li>
<p><code dir="ltr">VALUES</code> clause of the <code dir="ltr">INSERT</code> statement</p>
</li>
<li>
<p><code dir="ltr">SET</code> clause of the <code dir="ltr">UPDATE</code> statement</p>
</li>
</ul>
<p>A PL/SQL table function (which returns a collection of rows) can appear in a <code dir="ltr">SELECT</code> statement instead of:</p>
<ul>
<li>
<p>Column name in the <code dir="ltr">SELECT</code> list</p>
</li>
<li>
<p>Table name in the <code dir="ltr">FROM</code> clause</p>
</li>
</ul>
<p>A PL/SQL function cannot appear in these contexts, which require unchanging definitions:</p>
<ul>
<li>
<p><code dir="ltr">CHECK</code> constraint clause of a <code dir="ltr">CREATE</code> or <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement</p>
</li>
<li>
<p>Default value specification for a column</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="g1043220"></a>
<div id="ADFNS381" class="sect2">
<h3 class="sect2"><span class="secnum">11.9.3</span> When PL/SQL Functions Can Appear in SQL Expressions</h3>
<p>To be invoked from a SQL expression, a PL/SQL function must satisfy these requirements:</p>
<ul>
<li>
<p>It must be either a user-defined aggregate function or a row function.</p>
</li>
<li>
<p>Its formal parameters must be <code dir="ltr">IN</code> parameters, not <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameters.</p>
</li>
</ul>
<p>The function in <a href="#CIHGHHCE">Example 11-10</a> satisfies the preceding requirements.</p>
<div id="ADFNS382" class="example">
<p class="titleinexample"><a id="CIHGHHCE"></a>Example 11-10 PL/SQL Function in SQL Expression (Follows Rules)</p>
<pre dir="ltr">DROP TABLE payroll;  -- in case it exists
CREATE TABLE payroll (
  srate  NUMBER,
  orate  NUMBER,
  acctno NUMBER
);
 
CREATE OR REPLACE <span class="bold">FUNCTION gross_pay</span> (
  emp_id  <span class="bold">IN NUMBER</span>,
  st_hrs  <span class="bold">IN NUMBER</span> := 40,
  ot_hrs  <span class="bold">IN NUMBER</span> := 0
) <span class="bold">RETURN NUMBER</span>
IS
  st_rate  NUMBER;
  ot_rate  NUMBER;
BEGIN
  SELECT srate, orate
  INTO st_rate, ot_rate
  FROM payroll
  WHERE acctno = emp_id;
 
 RETURN st_hrs * st_rate + ot_hrs * ot_rate;
END gross_pay;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="g1043241"></a>
<div id="ADFNS384" class="sect2">
<h3 class="sect2"><span class="secnum">11.9.4</span> Controlling Side Effects of PL/SQL Functions Invoked from SQL Statements</h3>
<p>A subprogram has <a id="sthref698"></a><span class="bold">side effects</span> if it changes anything except the values of its own local variables. For example, a subprogram that changes any of the following has side effects:</p>
<ul>
<li>
<p>Its own <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameter</p>
</li>
<li>
<p>A global variable</p>
</li>
<li>
<p>A public variable in a package</p>
</li>
<li>
<p>A database table</p>
</li>
<li>
<p>The database</p>
</li>
<li>
<p>The external state (by invoking <code dir="ltr">DBMS_OUTPUT</code> or sending e-mail, for example)</p>
</li>
</ul>
<p>Side effects can prevent the parallelization of a query, yield order-dependent (and therefore, indeterminate) results, or require that package state be maintained across user sessions.</p>
<p>Some side effects are not allowed in a function invoked from a SQL query or DML statement.</p>
<p>Before Oracle Database 8<span class="italic">g</span> Release 1 (8.1), application developers used <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> to assert the <a id="sthref699"></a><a id="sthref700"></a><span class="bold">purity</span> (freedom from side effects) of a function. This pragma remains available for backward compatibility, but do not use it in new applications. Instead, specify the optimizer hints <code dir="ltr">DETERMINISTIC</code> and <code dir="ltr">PARALLEL_ENABLE</code> when you create the function. For information about <code dir="ltr">DETERMINISTIC</code> and <code dir="ltr">PARALLEL_ENABLE</code>, see <a class="olink LNPLS01370" href="../LNPLS/create_function.htm#LNPLS01370"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p class="subhead2"><a id="ADFNS1041"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1008107">Restrictions on Functions Invoked from SQL Statements</a></p>
</li>
<li>
<p><a href="#g1042309">PL/SQL Functions Invoked from Parallelized SQL Statements</a></p>
</li>
<li>
<p><a href="#i1008174">PRAGMA RESTRICT_REFERENCES</a> (deprecated)</p>
</li>
</ul>
<a id="i1008107"></a>
<div id="ADFNS385" class="sect3">
<h4 class="sect3"><span class="secnum">11.9.4.1</span> Restrictions on Functions Invoked from SQL Statements</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
The restrictions on functions invoked from SQL statements also apply to triggers fired by SQL statements.</div>
<p>If a SQL statement invokes a function, and the function runs a new SQL statement, then the execution of the new statement is logically embedded in the context of the statement that invoked the function. To ensure that the new statement is safe in this context, Oracle Database enforces these restrictions on the function:</p>
<ul>
<li>
<p>If the SQL statement that invokes the function is a query or DML statement, then the function cannot end the current transaction, create or rollback to a savepoint, or <code dir="ltr">ALTER</code> the system or session.</p>
</li>
<li>
<p>If the SQL statement that invokes the function is a query or parallelized DML statement, then the function cannot run a DML statement or otherwise modify the database.</p>
</li>
<li>
<p>If the SQL statement that invokes the function is a DML statement, then the function can neither read nor modify the table being modified by the SQL statement that invoked the function.</p>
</li>
</ul>
<p>The restrictions apply regardless of how the function runs the new SQL statement. For example, they apply to new SQL statements that the function:</p>
<ul>
<li>
<p>Invokes from PL/SQL, whether embedded directly in the function body, run using the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement, or run using the <code dir="ltr">DBMS_SQL</code> package</p>
</li>
<li>
<p>Embeds in Java with SQLJ syntax or runs using JDBC</p>
</li>
<li>
<p>Runs with OCI using the callback context from within an external C function</p>
</li>
</ul>
<p>To avoid these restrictions, ensure that the execution of the new SQL statement is not logically embedded in the context of the SQL statement that invokes the function. For example, put the new SQL statement in an autonomous transaction or, in OCI, create a new connection for the external C function rather than using the handle provided by the <code dir="ltr">OCIExtProcContext</code> argument. For information about autonomous transactions, see <a href="adfns_sqlproc.htm#i1007356">Section 6.8</a>.</p>
</div>
<!-- class="sect3" -->
<a id="g1042309"></a>
<div id="ADFNS387" class="sect3">
<h4 class="sect3"><span class="secnum">11.9.4.2</span> PL/SQL Functions Invoked from Parallelized SQL Statements</h4>
<p>When Oracle Database runs a <a id="sthref701"></a><a id="sthref702"></a><span class="bold">parallelized</span> SQL statement, multiple processes work simultaneously to run the single SQL statement. When a parallelized SQL statement invokes a function, each process might invoke its own copy of the function, for only the subset of rows that the process handles.</p>
<p>Each process has its own copy of package variables. When parallel execution begins, the package variables are initialized for each process as if a user were logging into the system; the package variable values are not copied from the original login session. Changes that one process makes to package variables do not automatically propagate to the other processes or to the original login session. Java <code dir="ltr">STATIC</code> class attributes are similarly initialized and modified independently in each process. A function can use package and Java <code dir="ltr">STATIC</code> variables to accumulate a value across the various rows that it encounters. Therefore, Oracle Database does not parallelize the execution of user-defined functions by default.</p>
<p>Before Oracle Database 8<span class="italic">g</span> Release 1 (8.1):</p>
<ul>
<li>
<p>If a parallelized query invoked a user-defined function, then the execution of the function could be parallelized if <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> asserted both <code dir="ltr">RNPS</code> and <code dir="ltr">WNPS</code> for the function&mdash;that is, that the function neither referenced package variables nor changed their values.</p>
<p>Without this assertion, the execution of a standalone PL/SQL function (but not a C or Java function) could be parallelized if Oracle Database determined that the function neither referenced package variables nor changed their values.</p>
</li>
<li>
<p>If a parallelized DML statement invoked a user-defined function, then the execution of the function could be parallelized if <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> asserted <code dir="ltr">RNDS</code>, <code dir="ltr">WNDS</code>, <code dir="ltr">RNPS</code> and <code dir="ltr">WNPS</code> for the function&mdash;that is, that the function neither referenced nor changed the values of either package variables or database tables.</p>
<p>Without this assertion, the execution of a standalone PL/SQL function (but not a C or Java function) could be parallelized if Oracle Database determined that the function neither referenced nor changed the values of either package variables or database tables.</p>
</li>
</ul>
<p>As of Oracle Database 8<span class="italic">g</span> Release 1 (8.1), if a parallelized SQL statement invokes a user-defined function, then the execution of a function can be parallelized in these situations:</p>
<ul>
<li>
<p>The function was created with <code dir="ltr">PARALLEL_ENABLE</code>.</p>
</li>
<li>
<p>Before Oracle Database 8<span class="italic">g</span> Release 1 (8.1), the database recognized the function as parallelizable.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1008174"></a>
<div id="ADFNS388" class="sect3">
<h4 class="sect3"><span class="secnum">11.9.4.3</span> PRAGMA RESTRICT_REFERENCES</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref703"></a><a id="sthref704"></a><code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> is deprecated. In new applications, Oracle recommends using <code dir="ltr">DETERMINISTIC</code> and <code dir="ltr">PARALLEL_ENABLE</code> (explained in <a class="olink LNPLS01370" href="../LNPLS/create_function.htm#LNPLS01370"><span class="italic">Oracle Database SQL Language Reference</span></a>) instead of <code dir="ltr">RESTRICT_REFERENCES</code>.</div>
<p>In existing PL/SQL applications, you can either remove <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> or continue to use it, even with new functionality, to ease integration with the existing code. For example:</p>
<ul>
<li>
<p>When it is impossible or impractical to completely remove <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> from existing code.</p>
<p>For example, if subprogram S1 depends on subprogram S2, and you do not remove the pragma from S1, then you might need the pragma in S2 to compile S1.</p>
</li>
<li>
<p>When replacing <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> with <code dir="ltr">PARALLEL_ENABLE</code> and <code dir="ltr">DETERMINISTIC</code> in existing code would negatively affect the action of new, dependent code.</p>
</li>
</ul>
<p>To used <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> to assert the purity of a function: In the package specification (not the package body), anywhere after the function declaration, use this syntax:</p>
<pre dir="ltr">PRAGMA RESTRICT_REFERENCES (<span class="italic">function_name</span>, <span class="italic">assertion</span> [, <span class="italic">assertion</span>]... );
</pre>
<p>Where <code dir="ltr"><span class="codeinlineitalic">assertion</span></code> is one of the following:</p>
<div class="inftblinformal">
<table class="cellalignment296" title="RESTRICT_REFERENCES keywords" summary="This table summarizes the assertions of the RESTRICT_REFERENCES pragma." dir="ltr">
<thead>
<tr class="cellalignment287">
<th class="cellalignment294" id="r1c1-t35">Assertion</th>
<th class="cellalignment294" id="r1c2-t35">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment287">
<td class="cellalignment295" id="r2c1-t35" headers="r1c1-t35"><code dir="ltr">RNPS</code></td>
<td class="cellalignment295" headers="r2c1-t35 r1c2-t35">The function reads no package state (does not reference the values of package variables)</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r3c1-t35" headers="r1c1-t35"><code dir="ltr">WNPS</code></td>
<td class="cellalignment295" headers="r3c1-t35 r1c2-t35">The function writes no package state (does not change the values of package variables).</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r4c1-t35" headers="r1c1-t35"><code dir="ltr">RNDS</code></td>
<td class="cellalignment295" headers="r4c1-t35 r1c2-t35">The function reads no database state (does not query database tables).</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r5c1-t35" headers="r1c1-t35"><code dir="ltr">WNDS</code></td>
<td class="cellalignment295" headers="r5c1-t35 r1c2-t35">The function writes no database state (does not modify database tables).</td>
</tr>
<tr class="cellalignment287">
<td class="cellalignment295" id="r6c1-t35" headers="r1c1-t35"><code dir="ltr">TRUST</code></td>
<td class="cellalignment295" headers="r6c1-t35 r1c2-t35">Trust that no SQL statement in the function body violates any assertion made for the function. For more information, see <a href="#g1041703">Section 11.9.4.3.1</a>.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>If you do not specify <code dir="ltr">TRUST</code>, and a SQL statement in the function body violates an assertion that you do specify, then the PL/SQL compiler issues an error message when it parses a violating statement.</p>
<p>Assert the highest purity level (the most assertions) that the function allows, so that the PL/SQL compiler never rejects the function unnecessarily.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the function invokes subprograms, then either specify <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> for those subprograms also or specify <code dir="ltr">TRUST</code> in either the invoking function or the invoked subprograms.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01339" href="../LNPLS/restrictreferences_pragma.htm#LNPLS01339"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code></div>
<p><a href="#CIHEIHCD">Example 11-11</a> creates a function that neither reads nor writes database or package state, and asserts that is has the maximum purity level.</p>
<div id="ADFNS389" class="example">
<p class="titleinexample"><a id="CIHEIHCD"></a>Example 11-11 PRAGMA RESTRICT_REFERENCES</p>
<pre dir="ltr">DROP TABLE accounts; -- in case it exists
CREATE TABLE accounts (
  acctno   INTEGER,
  balance  NUMBER
);
 
INSERT INTO accounts (acctno, balance)
VALUES (12345, 1000.00);
 
CREATE OR REPLACE PACKAGE finance AS
  <span class="bold">FUNCTION compound_</span> (
    years  IN NUMBER,
    amount IN NUMBER,
    rate   IN NUMBER
   ) RETURN NUMBER;
  <span class="bold">PRAGMA RESTRICT_REFERENCES (compound_, WNDS, WNPS, RNDS, RNPS)</span>;
END finance;
/
CREATE PACKAGE BODY finance AS
  <span class="bold">FUNCTION compound_</span> (
    years  IN NUMBER,
    amount IN NUMBER,
    rate   IN NUMBER
   ) RETURN NUMBER
   IS
   BEGIN
     RETURN amount * POWER((rate / 100) + 1, years);
   END compound_;
  <span class="bold">-- No pragma in package body</span>
END finance;
/
DECLARE
  interest NUMBER;
BEGIN
  SELECT finance.compound_(5, 1000, 6)
  INTO interest
  FROM accounts
  WHERE acctno = 12345;
END;
/
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="ADFNS1042"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1041703">Specifying the Assertion TRUST</a></p>
</li>
<li>
<p><a href="#g1041730">Differences between Static and Dynamic SQL Statements</a></p>
</li>
</ul>
<a id="g1041703"></a>
<div id="ADFNS390" class="sect4">
<h5 class="sect4"><span class="secnum">11.9.4.3.1</span> Specifying the Assertion TRUST</h5>
<p><a id="sthref705"></a>When <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT</code> <code dir="ltr">REFERENCES</code> specifies <a id="sthref706"></a><code dir="ltr">TRUST</code>, the PL/SQL compiler does not check the subprogram body for violations.</p>
<p><code dir="ltr">TRUST</code> makes it easier for a subprogram that uses <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT</code> <code dir="ltr">REFERENCES</code> to invoke subprograms that do not use it.</p>
<p>If your PL/SQL subprogram invokes a C or Java subprogram, then you must specify <code dir="ltr">TRUST</code> for either the PL/SQL subprogram (as in <a href="#BABBAGBC">Example 11-12</a>) or the C or Java subprogram (as in <a href="#BABDCDFI">Example 11-13</a>), because the PL/SQL compiler cannot check a C or Java subprogram for violations at runtime.</p>
<div id="ADFNS392" class="example">
<p class="titleinexample"><a id="BABBAGBC"></a>Example 11-12 PRAGMA RESTRICT REFERENCES with TRUST on Invoker</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE p IS
  PROCEDURE java_sleep (milli_seconds IN NUMBER)
  AS LANGUAGE JAVA NAME &#39;java.lang.Thread.sleep(long)&#39;;
  
  <span class="bold">FUNCTION f</span> (n NUMBER) RETURN NUMBER;
  <span class="bold">PRAGMA RESTRICT_REFERENCES(f,WNDS,TRUST);</span>
END p;
/
CREATE OR REPLACE PACKAGE BODY p IS
  <span class="bold">FUNCTION f</span> (
    n NUMBER
  ) RETURN NUMBER
  IS
  BEGIN
    <span class="bold">java_sleep(n);</span>
     RETURN n;
  END f;
END p;
/
</pre></div>
<!-- class="example" -->
<div id="ADFNS391" class="example">
<p class="titleinexample"><a id="BABDCDFI"></a>Example 11-13 PRAGMA RESTRICT REFERENCES with TRUST on Invokee</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE p IS
  <span class="bold">PROCEDURE java_sleep</span> (milli_seconds IN NUMBER)
  AS LANGUAGE JAVA NAME &#39;java.lang.Thread.sleep(long)&#39;;
  <span class="bold">PRAGMA RESTRICT_REFERENCES(java_sleep,WNDS,TRUST)</span>;
  
  FUNCTION f (n NUMBER) RETURN NUMBER;
END p;
/
CREATE OR REPLACE PACKAGE BODY p IS
  <span class="bold">FUNCTION f</span> (
    n NUMBER
   ) RETURN NUMBER
   IS
   BEGIN
     <span class="bold">java_sleep(n);</span>
     RETURN n;
   END f;
END p;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="g1041730"></a>
<div id="ADFNS393" class="sect4">
<h5 class="sect4"><span class="secnum">11.9.4.3.2</span> Differences between Static and Dynamic SQL Statements</h5>
<p><a id="sthref707"></a><a id="sthref708"></a><a id="sthref709"></a>A static <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statement does not violate <code dir="ltr">RNDS</code> if it does not explicitly read a database state (such as a table column). A dynamic <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statement always violate <code dir="ltr">RNDS</code>, regardless of whether it explicitly reads a database state.</p>
<p>The following <code dir="ltr">INSERT</code> statement violates <code dir="ltr">RNDS</code> if it is executed dynamically, but not if it is executed statically:</p>
<pre dir="ltr">INSERT INTO my_table values(3, &#39;BOB&#39;);
</pre>
<p>The following <code dir="ltr">UPDATE</code> statement always violates <code dir="ltr">RNDS</code>, whether it is executed statically or dynamically, because it explicitly reads the column <code dir="ltr">name</code> of <code dir="ltr">my_table</code>:</p>
<pre dir="ltr">UPDATE my_table SET id=777 WHERE name=&#39;BOB&#39;;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007648"></a>
<div id="ADFNS99873" class="sect1">
<h2 class="sect1"><span class="secnum">11.10</span> Debugging Stored Subprograms</h2>
<p><a id="sthref710"></a>To compile a stored subprogram, you must fix any syntax errors in the code. To ensure that the subprogram works correctly, performs well, and recovers from errors, you might need to do additional debugging. Such debugging might involve:</p>
<ul>
<li>
<p>Adding extra output statements to verify execution progress and check data values at certain points within the subprogram.</p>
<p>To output the value of variables and expressions, use the <code dir="ltr">PUT</code> and <code dir="ltr">PUT_LINE</code> subprograms in the Oracle package <a id="sthref711"></a><code dir="ltr">DBMS_OUTPUT</code>, described in <a class="olink ARPLS036" href="../ARPLS/d_output.htm#ARPLS036"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li>
<p>Analyzing execution in greater detail by running PL/Scope, the PL/SQL hierarchical profiler, or a debugger</p>
</li>
</ul>
<p class="subhead2"><a id="ADFNS1037"></a>Topics:</p>
<ul>
<li>
<p><a href="#CIHHJJIF">PL/Scope</a></p>
</li>
<li>
<p><a href="#CIHCCIAC">PL/SQL Hierarchical Profiler</a></p>
</li>
<li>
<p><a href="#BABIHIHB">Compiling Code for Debugging</a></p>
</li>
<li>
<p><a href="#g1878754">Privileges for Debugging PL/SQL and Java Stored Subprograms</a></p>
</li>
<li>
<p><a href="#g1879122">DBMS_DEBUG Package</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS007" href="../LNPLS/errors.htm#LNPLS007"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about handling errors in PL/SQL subprograms and packages</p>
</li>
<li>
<p><a class="olink JJDEV13192" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=JJDEV13192"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a> for information about debugging Java applications</p>
</li>
</ul>
</div>
<a id="CIHHJJIF"></a>
<div id="ADFNS362" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.10.1</span> PL/Scope</h3>
<p>PL/Scope is a compiler-driven tool that collects and organizes data about user-defined identifiers from PL/SQL source code. Because PL/Scope is a compiler-driven tool, you use it through interactive development environments (such as SQL Developer and JDeveloper), rather than directly.</p>
<p>PL/Scope lets you develop powerful and effective PL/Scope source code browsers that increase PL/SQL developer productivity by minimizing time spent browsing and understanding source code.</p>
<p>For more information about PL/Scope, see <a href="adfns_plscope.htm#g1010526">Chapter 12, &#34;Using PL/Scope.&#34;</a></p>
</div>
<!-- class="sect2" -->
<a id="CIHCCIAC"></a>
<div id="ADFNS363" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.10.2</span> PL/SQL Hierarchical Profiler</h3>
<p>The PL/SQL hierarchical profiler reports the dynamic execution profile of your PL/SQL program, organized by subprogram calls. It accounts for SQL and PL/SQL execution times separately. Each subprogram-level summary in the dynamic execution profile includes information such as number of calls to the subprogram, time spent in the subprogram itself, time spent in the subprogram subtree (that is, in its descendent subprograms), and detailed parent-children information.</p>
<p>You can browse the generated HTML reports in any browser. The browser&#39;s navigational capabilities, combined with well chosen links, provide a powerful way to analyze performance of large applications, improve application performance, and lower development costs.</p>
<p>For a detailed description of PL/SQL hierarchical profiler, see <a href="adfns_profiler.htm#CHDBHDFE">Chapter 13, &#34;Using the PL/SQL Hierarchical Profiler.&#34;</a></p>
</div>
<!-- class="sect2" -->
<a id="BABIHIHB"></a>
<div id="ADFNS313" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.10.3</span> Compiling Code for Debugging</h3>
<p>A debugger can stop on individual code lines and access variables only in code compiled with debug information generated.</p>
<p>To compile a <a id="sthref712"></a><a id="sthref713"></a>PL/SQL unit with debug information generated, set the compilation parameter <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code> to 1 (the default value is 2). For more information about <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code>, see <a class="olink REFRN10255" href="../REFRN/GUID-364B752A-4335-468C-B4BA-AAC32D75385A.htm#REFRN10255"><span class="italic">Oracle Database Reference</span></a>. For information about PL/SQL units, see <a href="#i1006224">Section 11.3</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The PL/SQL compiler never generates debug information for code hidden with the PL/SQL <a id="sthref714"></a><a id="sthref715"></a><code dir="ltr">wrap</code> utility. For information about the <code dir="ltr">wrap</code> utility, see <a class="olink LNPLS016" href="../LNPLS/wrap.htm#LNPLS016"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</div>
</div>
<!-- class="sect2" -->
<a id="g1878754"></a>
<div id="ADFNS366" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.10.4</span> Privileges for Debugging PL/SQL and Java Stored Subprograms</h3>
<p><a id="sthref716"></a><a id="sthref717"></a>As of Oracle Database&nbsp;10<span class="italic">g</span>, a new privilege model applies to debugging PL/SQL and Java code running in the database. This model applies to all development environments.</p>
<p>For a session to connect to a debugger, the effective user at the time of the connect operation must have the <code dir="ltr">DEBUG</code> <code dir="ltr">CONNECT</code> <code dir="ltr">SESSION</code> system privilege. The effective user might be the owner of a DR subprogram involved in making the connect call.</p>
<p>When a session connects to a debugger, the session login user and the enabled session-level roles are fixed as the privilege environment for that debugging connection. The privileges needed for debugging must be granted to that combination of user and roles on the relevant code. The privileges are:</p>
<ul>
<li>
<p>To display and change variables declared in a PL/SQL package specification or Java public variables: either <code dir="ltr">EXECUTE</code> or <code dir="ltr">DEBUG</code>.</p>
</li>
<li>
<p>To display and change private variables, or to breakpoint and run code lines step by step: <code dir="ltr">DEBUG</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Caution:</p>
The <code dir="ltr">DEBUG</code> privilege allows a debugging session to do anything that the subprogram being debugged could have done if that action had been included in its code.</div>
<p>Granting the <code dir="ltr">DEBUG</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege is equivalent to granting the <code dir="ltr">DEBUG</code> privilege on all objects in the database. Objects owned by <code dir="ltr">SYS</code> are included if the value of the <code dir="ltr">O7_DICTIONARY_ACCESSIBILITY</code> parameter is <code dir="ltr">TRUE</code>.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Granting the <code dir="ltr">DEBUG</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> privilege, or granting the <code dir="ltr">DEBUG</code> privilege on any object owned by <code dir="ltr">SYS</code>, grants complete rights to the database.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01603" href="../SQLRF/statements_9014.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about system and object privileges</p>
</li>
<li>
<p><a class="olink JJDEV13344" href="../JJDEV/chten.htm#JJDEV13344"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a> for information about privileges for debugging Java subprograms</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="g1879122"></a>
<div id="ADFNS369" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">11.10.5</span> DBMS_DEBUG Package</h3>
<p>The <a id="sthref718"></a><code dir="ltr">DBMS_DEBUG</code> package is a PL/SQL interface to the PL/SQL debugger layer, Probe, in the Oracle server. This API is primarily intended to implement server-side debuggers and it provides a way to debug server-side PL/SQL program units.</p>
<p>Several debuggers, such as Oracle Procedure Builder and various third-party vendor solutions, use this API.</p>
<p>If you are writing <a id="sthref719"></a><a id="sthref720"></a>low-level debugging code (for example, code for part of a debugger), you might need to use <code dir="ltr">DBMS_DEBUG</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS009" href="../ARPLS/d_debug.htm#ARPLS009"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code dir="ltr">DBMS_DEBUG</code></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="g1042030"></a>
<div id="ADFNS341" class="sect1">
<h2 class="sect1"><span class="secnum">11.11</span> Package Invalidations and Session State</h2>
<p><a id="sthref721"></a><a id="sthref722"></a><a id="sthref723"></a>Each session that references a package object has its own instance of the corresponding package, including persistent state for any public and private variables, cursors, and constants. If any of the session&#39;s instantiated packages (specification or body) are invalidated, then all package instances in the session are invalidated and recompiled. Therefore, the session state is lost for all package instances in the session.</p>
<p>When a package in a given session is invalidated, the session receives ORA-04068 the first time it tries to use any object of the invalid package instance. The second time a session makes such a package call, the package is reinstantiated for the session without error. However, if you handle this error in your application, be aware of the following:</p>
<ul>
<li>
<p>For optimal performance, Oracle Database returns this error message only when the package state is discarded. When a subprogram in one package invokes a subprogram in another package, the session state is lost for both packages.</p>
</li>
<li>
<p>If a server session traps ORA-04068, then ORA-04068 is not raised for the client session. Therefore, when the client session tries to use an object in the package, the package is not reinstantiated. To reinstantiate the package, the client session must either reconnect to the database or recompile the package.</p>
</li>
</ul>
<p>In <a href="#BABCFFEC">Example 11-14</a>, the <code dir="ltr">RAISE</code> statement raises the current exception, ORA-04068, which is the cause of the exception being handled, ORA-06508. ORA-04068 is not trapped.</p>
<div id="ADFNS1032" class="example">
<p class="titleinexample"><a id="BABCFFEC"></a>Example 11-14 Raising ORA-04068</p>
<pre dir="ltr">PROCEDURE p IS
  package_exception EXCEPTION;
  PRAGMA EXCEPTION_INIT (package_exception, -6508);
BEGIN
 ...
EXCEPTION
  WHEN package_exception THEN
    <span class="bold">RAISE;</span>
END;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABIFBBB">Example 11-15</a>, the <code dir="ltr">RAISE</code> statement raises the exception ORA-20001 in response to ORA-06508, instead of the current exception, ORA-04068. ORA-04068 is trapped. When this happens, the ORA-04068 error is masked, which stops the package from being reinstantiated.</p>
<div id="ADFNS1033" class="example">
<p class="titleinexample"><a id="BABIFBBB"></a>Example 11-15 Trapping ORA-04068</p>
<pre dir="ltr">PROCEDURE p IS
  package_exception EXCEPTION;
  other_exception   EXCEPTION;
  PRAGMA EXCEPTION_INIT (package_exception, -6508);
  PRAGMA EXCEPTION_INIT (other_exception, -20001);
BEGIN
 ...
EXCEPTION
  WHEN package_exception THEN
    ...
    <span class="bold">RAISE other_exception;</span>
END;
/
</pre></div>
<!-- class="example" -->
<p>In most production environments, DDL operations that can cause invalidations are usually performed during inactive working hours; therefore, this situation might not be a problem for end-user applications. However, if package invalidations are common in your system during working hours, then you might want to code your applications to handle this error when package calls are made.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment286">
<tr>
<td class="cellalignment295">
<table class="cellalignment291">
<tr>
<td class="cellalignment290"><a href="adfns_part_plsql.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment290"><a href="adfns_plscope.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment298">
<table class="cellalignment289">
<tr>
<td class="cellalignment290"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment290"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment290"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment290"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment290"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment290"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>