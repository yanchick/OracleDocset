<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-70994"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/JDBC%20RowSets"></a><title>JDBC RowSets</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="description" content="This book describes how to use Oracle JDBC drivers to develop powerful Java database applications."/>
<meta name="dcterms.created" content="2014-06-30T1:22:37Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database JDBC Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49300-05"/>
<meta name="dcterms.isVersionOf" content="JJDBC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="resltset.htm" title="Previous" type="text/html"/>
<link rel="Next" href="global.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49300-05.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">29/55</span> <!-- End Header -->
<div id="JJDBC28630" class="chapter"><a id="g634339"></a>
<h1 class="chapter"><span class="secnum">18</span> JDBC RowSets</h1>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#CHDGIFEI">Overview of JDBC RowSets</a></p>
</li>
<li>
<p><a href="#i630230">CachedRowSet</a></p>
</li>
<li>
<p><a href="#i630234">JdbcRowSet</a></p>
</li>
<li>
<p><a href="#BABCFJBE">WebRowSet</a></p>
</li>
<li>
<p><a href="#BABGFHJI">FilteredRowSet</a></p>
</li>
<li>
<p><a href="#BABDHJBJ">JoinRowSet</a></p>
</li>
</ul>
<a id="CHDGIFEI"></a>
<div id="JJDBC28631" class="sect1">
<h2 class="sect1">Overview of JDBC RowSets</h2>
<p>A <a id="sthref670"></a>RowSet is an object that encapsulates a set of rows from either java Database Connectivity (JDBC) result sets or tabular data sources. RowSets support component-based development models like JavaBeans, with a standard set of properties and an event notification mechanism.</p>
<p>RowSets were introduced in JDBC 2.0 through the optional packages. However, the implementation of RowSets was standardized in the JDBC RowSet Implementations Specification (JSR-114), which is available as non-optional package since Java Platform, Standard Edition (Java SE) 5.0. Java SE 6.0 RowSets contain more APIs supporting features like RowId, National Language Charactersets, and so on. The Java SE Javadocs provide information about the standard interfaces and base classes for JDBC RowSet implementations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>Java SE 6 Javadoc at: <code><a href="http://docs.oracle.com/javase/6/docs/api/">http://docs.oracle.com/javase/6/docs/api/</a></code></p>
</li>
<li>
<p>Java SE 7 Javadoc at: <code><a href="http://docs.oracle.com/javase/7/docs/api/">http://docs.oracle.com/javase/7/docs/api/</a></code></p>
</li>
</ul>
</div>
<p>The JSR-114 specification includes implementation details for five types of RowSet:</p>
<ul>
<li>
<p><code>CachedRowSet</code></p>
</li>
<li>
<p><code>JdbcRowSet</code></p>
</li>
<li>
<p><code>WebRowSet</code></p>
</li>
<li>
<p><code>FilteredRowSet</code></p>
</li>
<li>
<p><code>JoinRowSet</code></p>
</li>
</ul>
<p>Oracle JDBC supports all five types of RowSets through the interfaces and classes present in the <code>oracle.jdbc.rowset</code> package. Since Oracle Database 11<span class="italic">g</span> Release 1, RowSets support has been added in the server-side drivers. Therefore, starting from Oracle Database 11<span class="italic">g</span> Release 1, RowSets support is uniform across all Oracle JDBC driver types. The standard Oracle JDBC Java Archive (JAR) files, for example, <code>ojdbc6.jar</code> and <code>ojdbc7.jar</code> contain the <code>oracle.jdbc.rowset</code> package.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The other JAR files with different file suffix names, for example, <code>ojdbc6_g.jar</code>, <code>ojdbc6dms.jar</code>, and so on also contain the <code>oracle.jdbc.rowset</code> package.</p>
</li>
<li>
<p>In Oracle Database 10<span class="italic">g</span> release 2, the implementation classes were packaged in the <code>ojdbc14.jar</code> file.</p>
</li>
<li>
<p>Prior to Oracle Database 10<span class="italic">g</span> release 2, the implementation classes were packaged in the <code>ocrs12.jar</code> file.</p>
</li>
<li>
<p>Prior to Oracle Database 11<span class="italic">g</span> Release 1, RowSets support was not available in the server-side drivers.</p>
</li>
</ul>
</div>
<p>To use the Oracle RowSet implementations, you need to import either the entire <code>oracle.jdbc.rowset</code> package or specific classes and interfaces from the package for the required RowSet type. For client-side usage, you also need to include the standard Oracle JAR files like <code>ojdbc6.jar</code> or <code>ojdbc7.jar</code> in the <code>CLASSPATH</code> environment variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="getsta.htm#i1005378">&#34;Check the Environment Variables&#34;</a> for information about setting the <code>CLASSPATH</code> environment variable.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CIHBJFJI">RowSet Properties</a></p>
</li>
<li>
<p><a href="#CIHDBICJ">Events and Event Listeners</a></p>
</li>
<li>
<p><a href="#CIHGEEHD">Command Parameters and Command Execution</a></p>
</li>
<li>
<p><a href="#CIHBFAAE">Traversing RowSets</a></p>
</li>
</ul>
<a id="CIHBJFJI"></a>
<div id="JJDBC28632" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref671"></a>RowSet Properties</h3>
<p>The <code>javax.sql.RowSet</code> interface provides a set of JavaBeans properties that can be altered to access the data in the data source through a single interface. Example of properties are connection string, user name, password, type of connection, and the query string.</p>
<p>For a complete list of properties and property descriptions, refer to the Java2 Platform, Standard Edition (J2SE) Javadoc for <code>javax.sql.RowSet</code> at <code><a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/sql/RowSet.html">http://docs.oracle.com/javase/1.5.0/docs/api/javax/sql/RowSet.html</a></code></p>
<p>The interface provides standard accessor methods for setting and retrieving the property values. The following code illustrates setting some of the <code>RowSet</code> properties:</p>
<pre>...
rowset.setUrl(&#34;jdbc:oracle:oci:@&#34;);
rowset.setUsername(&#34;HR&#34;);
rowset.setPassword(&#34;hr&#34;);
rowset.setCommand(&#34;SELECT employee_id, first_name, last_name, salary FROM employees&#34;);
...
</pre>
<p>In this example, the URL, user name, password, and SQL query are set as the <code>RowSet</code> properties to retrieve the employee number, employee name, and salary of all the employees into the <code>RowSet</code> object.</p>
</div>
<!-- class="sect2" -->
<a id="CIHDBICJ"></a>
<div id="JJDBC28633" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref672"></a>Events and Event Listeners</h3>
<p>RowSets support JavaBeans events. The following types of events are supported by the <code>RowSet</code> interface:</p>
<ul>
<li>
<p><code>cursorMoved</code></p>
<p>This event is generated whenever there is a cursor movement. For example, when the <code>next</code> or <code>previous</code> method is called.</p>
</li>
<li>
<p><code>rowChanged</code></p>
<p>This event is generated when a row is inserted, updated, or deleted from the RowSet.</p>
</li>
<li>
<p><code>rowSetChanged</code></p>
<p>This event is generated when the whole RowSet is created or changed. For example, when the <code>execute</code> method is called.</p>
</li>
</ul>
<p>An application component can implement a RowSet listener to listen to these RowSet events and perform desired operations when the event occurs. Application components, which are interested in these events, must implement the standard <code>javax.sql.RowSetListener</code> interface and register such listener objects with a <code>RowSet</code> object. A listener can be registered using the <code>RowSet.addRowSetListener</code> method and unregistered using the <code>RowSet.removeRowSetListener</code> method. Multiple listeners can be registered with the same <code>RowSet</code> object.</p>
<p>The following code illustrates the registration of a RowSet listener:</p>
<pre> ...
 MyRowSetListener rowsetListener = new MyRowSetListener ();
 // adding a rowset listener
 rowset.addRowSetListener (rowsetListener);
 ...
</pre>
<p>The following code illustrates a listener implementation:</p>
<pre> public class MyRowSetListener implements RowSetListener
  {
    public void cursorMoved(RowSetEvent event)
    {
      // action on cursor movement
    }
 
    public void rowChanged(RowSetEvent event)
    {
      // action on change of row
    }
 
    public void rowSetChanged(RowSetEvent event)
    {
      // action on changing of rowset
    }
  }// end of class MyRowSetListener
</pre>
<p>Applications that need to handle only selected events can implement only the required event handling methods by using the <code>oracle.jdbc.rowset.OracleRowSetListenerAdapter</code> class, which is an abstract class with empty implementation for all the event handling methods. In the following code, only the <code>rowSetChanged</code> event is handled, while the remaining events are not handled by the application:</p>
<pre> ...
 rowset.addRowSetListener(new oracle.jdbc.rowset.OracleRowSetListenerAdapter ()
    {
      public void rowSetChanged(RowSetEvent event)
      {
        // your action for rowSetChanged
      }
    }
  );
 ...
</pre></div>
<!-- class="sect2" -->
<a id="CIHGEEHD"></a>
<div id="JJDBC28634" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Command Parameters and Command Execution</h3>
<p>The <code>command</code> property of a <code>RowSet</code> object typically represents a SQL query string, which when processed would populate the <code>RowSet</code> object with actual data. Like in regular JDBC processing, this query string can take input or bind parameters. The <code>javax.sql.RowSet</code> interface also provides methods for setting input parameters to this SQL query. After the required input parameters are set, the SQL query can be processed to populate the <code>RowSet</code> object with data from the underlying data source. The following code illustrates this simple sequence:</p>
<pre> ...
  rowset.setCommand(&#34;SELECT first_name, last_name, salary FROM employees WHERE employee_id = ?&#34;);
  // setting the employee number input parameter for employee named &#34;Douglas&#34;
  rowset.setInt(1, 199);
  rowset.execute();
  ...
</pre>
<p>In the preceding example, the employee number 199 is set as the input or bind parameter for the SQL query specified in the <code>command</code> property of the <code>RowSet</code> object. When the SQL query is processed, the <code>RowSet</code> object is filled with the employee name and salary information of the employee whose employee number is 199.</p>
</div>
<!-- class="sect2" -->
<a id="CIHBFAAE"></a>
<div id="JJDBC28635" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Traversing <a id="sthref673"></a>RowSets</h3>
<p>The <code>javax.sql.RowSet</code> interface extends the <code>java.sql.ResultSet</code> interface. The <code>RowSet</code> interface, therefore, provides cursor movement and positioning methods, which are inherited from the <code>ResultSet</code> interface, for traversing through data in a <code>RowSet</code> object. Some of the inherited methods are <code>absolute</code>, <code>beforeFirst</code>, <code>afterLast</code>, <code>next</code>, and <code>previous</code>.</p>
<p>The <code>RowSet</code> interface can be used just like a <code>ResultSet</code> interface for retrieving and updating data. The <code>RowSet</code> interface provides an optional way to implement a scrollable and updatable result set. All the fields and methods provided by the <code>ResultSet</code> interface are implemented in <code>RowSet</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle implementation of <code>ResultSet</code> provides the scrollable and updatable properties of the <code>java.sql.ResultSet</code> interface.</div>
<p>The following code illustrates how to scroll through a RowSet:</p>
<pre>/**
 *  Scrolling forward, and printing the empno in 
 *  the order in which it was fetched.
 */
...
rowset.setCommand(&#34;SELECT empno, ename, sal FROM emp&#34;);
rowset.execute();
...
// going to the first row of the rowset
rowset.beforeFirst ();
while (rowset.next ())
  System.out.println (&#34;empno: &#34; +rowset.getInt (1));
</pre>
<p>In the preceding code, the cursor position is initialized to the position before the first row of the RowSet by the <code><a id="sthref674"></a>beforeFirst</code> method. The rows are retrieved in forward direction using the <code><a id="sthref675"></a>next</code> method.</p>
<p>The following code illustrates how to scroll through a RowSet in the reverse direction:</p>
<pre>/**
 *  Scrolling backward, and printing the empno in 
 *  the reverse order as it was fetched.
 */
//going to the last row of the rowset
rowset.afterLast ();
while (rowset.previous ())
  System.out.println (&#34;empno: &#34; +rowset.getInt (1));
</pre>
<p>In the preceding code, the cursor position is initialized to the position after the last row of the <code>RowSet</code>. The rows are retrieved in reverse direction using the <code>previous</code> method of <code>RowSet</code>.</p>
<p>Inserting, updating, and deleting rows are supported by the Row Set feature as they are in the Result Set feature. In order to make the Row Set updatable, you must call the <code>setReadOnly(false)</code> and <code>acceptChanges</code> methods.</p>
<p>The following code illustrates the insertion of a row at the fifth position of a Row Set:</p>
<pre>...
/**
  * Make rowset updatable
  */
rowset.setReadOnly (false); 
/**
 * Inserting a row in the 5th position of the rowset.
 */
// moving the cursor to the 5th position in the rowset
if (rowset.absolute(5))
{
  rowset.moveToInsertRow ();
  rowset.updateInt (1, 193);
  rowset.updateString (2, &#34;Smith&#34;);
  rowset.updateInt (3, 7200);

  // inserting a row in the rowset
  rowset.insertRow ();

  // Synchronizing the data in RowSet with that in the database.
  rowset.acceptChanges ();
}
...
</pre>
<p>In the preceding code, a call to the <code>absolute</code> method with a parameter <code>5</code> takes the cursor to the fifth position of the RowSet and a call to the <code>moveToInsertRow</code> method creates a place for the insertion of a new row into the RowSet. The <code>update</code><code><span class="codeinlineitalic">XXX</span></code> methods are used to update the newly created row. When all the columns of the row are updated, the <code>insertRow</code> is called to update the RowSet. The changes are committed through <code>acceptChanges</code> method.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i630230"></a>
<div id="JJDBC28636" class="sect1">
<h2 class="sect1"><a id="sthref676"></a>CachedRowSet</h2>
<p>A CachedRowSet is a RowSet in which the rows are cached and the RowSet is disconnected, that is, it does not maintain an active connection to the database. The <code>oracle.jdbc.rowset.OracleCachedRowSet</code> class is the Oracle implementation of CachedRowSet. It can interoperate with the standard reference implementation. The <code>OracleCachedRowSet</code> class in the <code>ojdbc6.jar</code> and <code>ojdbc7.jar</code> files implements the standard JSR-114 interface <code>javax.sql.rowset.CachedRowSet</code>.</p>
<p>In the following code, an <code>OracleCachedRowSet</code> object is created and the connection URL, user name, password, and the SQL query for the <code>RowSet</code> object is set as properties. The <code>RowSet</code> object is populated using the <code>execute</code> method. After the <code>execute</code> method has been processed, the <code>RowSet</code> object can be used as a <code>java.sql.ResultSet</code> object to retrieve, scroll, insert, delete, or update data.</p>
<pre>...
RowSet rowset = new OracleCachedRowSet();
rowset.setUrl(&#34;jdbc:oracle:oci:@&#34;);
rowset.setUsername(&#34;HR&#34;);
rowset.setPassword(&#34;hr&#34;);
rowset.setCommand(&#34;SELECT employee_id, first_name, last_name, salary FROM employees&#34;);
rowset.execute();
while (rowset.next ())
{
  System.out.println(&#34;employee_id: &#34; +rowset.getInt (1));
  System.out.println(&#34;first_name: &#34; +rowset.getString (2));
  System.out.println(&#34;last_name: &#34; +rowset.getString (3));
  System.out.println(&#34;sal: &#34;   +rowset.getInt (4));
}
...
</pre>
<p>To populate a <code>CachedRowSet</code> object with a query, complete the following steps:</p>
<ol>
<li>
<p>Instantiate <code>OracleCachedRowSet</code>.</p>
</li>
<li>
<p>Set the <code>Url</code>, which is the connection URL, <code>Username</code>, <code>Password</code>, and <code>Command</code>, which is the query string, properties for the <code>RowSet</code> object. You can also set the connection type, but it is optional.</p>
</li>
<li>
<p>Call the <code>execute</code> method to populate the <code>CachedRowSet</code> object. Calling <code>execute</code> runs the query set as a property on this RowSet.</p>
</li>
</ol>
<pre>    OracleCachedRowSet rowset = new OracleCachedRowSet ();
    rowset.setUrl (&#34;jdbc:oracle:oci:@&#34;);
    rowset.setUsername (&#34;HR&#34;);
    rowset.setPassword (&#34;hr&#34;);
    rowset.setCommand (&#34;SELECT employee_id, first_name, last_name, salary FROM employees&#34;);
    rowset.execute ();
    
</pre>
<p>A <code>CachedRowSet</code> object can be populated with an existing <code>ResultSet</code> object, using the <code>populate</code> method. To do so, complete the following steps:</p>
<ol>
<li>
<p>Instantiate <code>OracleCachedRowSet</code>.</p>
</li>
<li>
<p>Pass the already available <code>ResultSet</code> object to the <code>populate</code> method to populate the <code>RowSet</code> object.</p>
</li>
</ol>
<pre>    // Executing a query to get the ResultSet object.
    ResultSet rset = pstmt.executeQuery ();
    
    OracleCachedRowSet rowset = new OracleCachedRowSet ();
    // the obtained ResultSet object is passed to the populate method
    // to populate the data in the rowset object.
    rowset.populate (rset);
    
</pre>
<p>In the preceding example, a <code>ResultSet</code> object is obtained by running a query and the retrieved <code>ResultSet</code> object is passed to the <code><a id="sthref677"></a>populate</code> method of the <code>CachedRowSet</code> object to populate the contents of the result set into the CachedRowSet.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Connection properties, like transaction isolation or the concurrency mode of the result set, and the bind properties cannot be set in the case where a pre-existent <code>ResultSet</code> object is used to populate the <code>CachedRowSet</code> object, because the connection or result set on which the property applies would have already been created.</div>
<p>The following code illustrates how an <code>OracleCachedRowSet</code> object is serialized to a file and then retrieved:</p>
<pre>// writing the serialized OracleCachedRowSet object
{
  FileOutputStream fileOutputStream = new FileOutputStream(&#34;emp_tab.dmp&#34;);
  ObjectOutputStream ostream = new ObjectOutputStream(fileOutputStream);
  ostream.writeObject(rowset);
  ostream.close();
  fileOutputStream.close();
}

// reading the serialized OracleCachedRowSet object
{
  FileInputStream fileInputStream = new FileInputStream(&#34;emp_tab.dmp&#34;);
  ObjectInputStream istream = new ObjectInputStream(fileInputStream);
  RowSet rowset1 = (RowSet) istream.readObject();
  istream.close();
  fileInputStream.close();
}
</pre>
<p>In the preceding code, a <code>FileOutputStream</code> object is opened for an <code>emp_tab.dmp</code> file, and the populated <code>OracleCachedRowSet</code> object is written to the file using <code>ObjectOutputStream</code>. The serialized <code>OracleCachedRowSet</code> object is retrieved using the <code>FileInputStream</code> and <code>ObjectInputStream</code> objects.</p>
<p><code>OracleCachedRowSet</code> takes care of the serialization of non-serializable form of data like <code>InputStream</code>, <code>OutputStream</code>, binary large objects (BLOBs), and character large objects (CLOBs). <code>OracleCachedRowSets</code> also implements metadata of its own, which could be obtained without any extra server round-trip. The following code illustrates how you can obtain metadata for the RowSet:</p>
<pre>...
ResultSetMetaData metaData = rowset.getMetaData();
int maxCol = metaData.getColumnCount();
for (int i = 1; i &lt;= maxCol; ++i)
   System.out.println(&#34;Column (&#34; + i +&#34;) &#34; + metaData.getColumnName(i));
...
</pre>
<p>Because the <code>OracleCachedRowSet</code> class is serializable, it can be passed across a network or between Java Virtual Machines (JVMs), as done in <a id="sthref678"></a>Remote Method Invocation (<a id="sthref679"></a>RMI). Once the <code>OracleCachedRowSet</code> class is populated, it can move around any JVM, or any environment that does not have JDBC drivers. Committing the data in the RowSet requires the presence of JDBC drivers.</p>
<p>The complete process of retrieving the data and populating it in the <code>OracleCachedRowSet</code> class is performed on the server and the populated RowSet is passed on to the client using suitable architectures like RMI or <a id="sthref680"></a>Enterprise Java Beans (EJB). The client would be able to perform all the operations like retrieving, scrolling, inserting, updating, and deleting on the RowSet without any connection to the database. Whenever data is committed to the database, the <code><a id="sthref681"></a>acceptChanges</code> method is called, which synchronizes the data in the RowSet to that in the database. This method makes use of JDBC drivers, which require the JVM environment to contain JDBC implementation. This architecture would be suitable for systems involving a Thin client like a <a id="sthref682"></a>Personal Digital Assistant (<a id="sthref683"></a>PDA).</p>
<p>After populating the <code>CachedRowSet</code> object, it can be used as a <code>ResultSet</code> object or any other object, which can be passed over the network using RMI or any other suitable architecture.</p>
<p>Some of the other key-features of CachedRowSet are the following:</p>
<ul>
<li>
<p>Cloning a RowSet</p>
</li>
<li>
<p>Creating a copy of a RowSet</p>
</li>
<li>
<p>Creating a shared copy of a RowSet</p>
</li>
</ul>
<p class="subhead2"><a id="JJDBC28637"></a>CachedRowSet Constraints</p>
<p>All the constraints that apply to an updatable result set are applicable here, except serialization, because <code>OracleCachedRowSet</code> is serializable. The SQL query has the following constraints:</p>
<ul>
<li>
<p>References only a single table in the database</p>
</li>
<li>
<p>Contains no join operations</p>
</li>
<li>
<p>Selects the primary key of the table it references</p>
</li>
</ul>
<p>In addition, a SQL query should also satisfy the following conditions, if new rows are to be inserted:</p>
<ul>
<li>
<p>Selects all non-nullable columns in the underlying table</p>
</li>
<li>
<p>Selects all columns that do not have a default value</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>CachedRowSet</code> cannot hold a large quantity of data, because all the data is cached in memory. Oracle, therefore, recommends against using <code>OracleCachedRowSet</code> with queries that could potentially return a large volume of data.</div>
</li>
</ul>
<p>Connection properties like, transaction isolation and concurrency mode of the result set, cannot be set after populating the RowSet, because the properties cannot be applied to the connection after retrieving the data from the same.</p>
</div>
<!-- class="sect1" -->
<a id="i630234"></a>
<div id="JJDBC28638" class="sect1">
<h2 class="sect1"><a id="sthref684"></a>JdbcRowSet</h2>
<p>A JdbcRowSet is a RowSet that wraps around a <code>ResultSet</code> object. It is a connected RowSet that provides JDBC interfaces in the form of a JavaBean interface. The Oracle implementation of JdbcRowSet is <code>oracle.jdbc.rowset.OracleJDBCRowSet</code>. The <code>OracleJDBCRowSet</code> class in <code>ojdbc6.jar</code> and <code>ojdbc7.jar</code> implements the standard JSR-114 interface <code>javax.sql.rowset.JdbcRowSet</code>.</p>
<p><a href="#g631556">Table 18-1</a> shows how the <code>JdbcRowSet</code> interface differs from <code>CachedRowSet</code> interface.</p>
<div id="JJDBC28639" class="tblformal">
<p class="titleintable"><a id="sthref685"></a><a id="g631556"></a>Table 18-1 The JDBC and Cached Row Sets Compared</p>
<table class="cellalignment2244" title="The JDBC and Cached Row Sets Compared " summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t8">RowSet Type</th>
<th class="cellalignment2245" id="r1c2-t8">Serializable</th>
<th class="cellalignment2245" id="r1c3-t8">Connected to Database</th>
<th class="cellalignment2245" id="r1c4-t8">Movable Across JVMs</th>
<th class="cellalignment2245" id="r1c5-t8">Synchronization of data to database</th>
<th class="cellalignment2245" id="r1c6-t8">Presence of JDBC Drivers</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t8" headers="r1c1-t8">
<p>JDBC</p>
</td>
<td class="cellalignment2246" headers="r2c1-t8 r1c2-t8">
<p>Yes</p>
</td>
<td class="cellalignment2246" headers="r2c1-t8 r1c3-t8">
<p>Yes</p>
</td>
<td class="cellalignment2246" headers="r2c1-t8 r1c4-t8">
<p>No</p>
</td>
<td class="cellalignment2246" headers="r2c1-t8 r1c5-t8">
<p>No</p>
</td>
<td class="cellalignment2246" headers="r2c1-t8 r1c6-t8">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r3c1-t8" headers="r1c1-t8">
<p>Cached</p>
</td>
<td class="cellalignment2246" headers="r3c1-t8 r1c2-t8">
<p>Yes</p>
</td>
<td class="cellalignment2246" headers="r3c1-t8 r1c3-t8">
<p>No</p>
</td>
<td class="cellalignment2246" headers="r3c1-t8 r1c4-t8">
<p>Yes</p>
</td>
<td class="cellalignment2246" headers="r3c1-t8 r1c5-t8">
<p>Yes</p>
</td>
<td class="cellalignment2246" headers="r3c1-t8 r1c6-t8">
<p>No</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>JdbcRowSet is a connected RowSet, which has a live connection to the database and all the calls on the JdbcRowSet are percolated to the mapping call in the JDBC connection, statement, or result set. A CachedRowSet does not have any connection to the database open.</p>
<p>JdbcRowSet requires the presence of JDBC drivers unlike a CachedRowSet, which does not require JDBC drivers during manipulation. However, both JdbcRowSet and CachedRowSet require JDBC drivers during population of the RowSet and while committing the changes of the RowSet.</p>
<p>The following code illustrates how a JdbcRowSet is used:</p>
<pre>...
RowSet rowset = new OracleJDBCRowSet();
rowset.setUrl(&#34;java:oracle:oci:@&#34;);
rowset.setUsername(&#34;HR&#34;);
rowset.setPassword(&#34;hr&#34;);
rowset.setCommand(&#34;SELECT empno, ename, sal FROM emp&#34;);
rowset.execute();
while (rowset.next())
{
  System.out.println(&#34;empno: &#34; + rowset.getInt(1));
  System.out.println(&#34;ename: &#34; + rowset.getString(2));
  System.out.println(&#34;sal: &#34; + rowset.getInt(3));
}
...
</pre>
<p>In the preceding example, the connection URL, user name, password, and SQL query are set as properties of the <code>RowSet</code> object, the SQL query is processed using the <code><a id="sthref686"></a>execute</code> method, and the rows are retrieved and printed by traversing through the data populated in the <code>RowSet</code> object.</p>
</div>
<!-- class="sect1" -->
<a id="BABCFJBE"></a>
<div id="JJDBC28640" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref687"></a>WebRowSet</h2>
<p>A WebRowSet is an extension to CachedRowSet. It represents a set of fetched rows or tabular data that can be passed between tiers and components in a way such that no active connections with the data source need to be maintained. The <code>WebRowSet</code> interface provides support for the production and consumption of result sets and their synchronization with the data source, both in Extensible Markup Language (XML) format and in disconnected fashion. This allows result sets to be shipped across tiers and over Internet protocols.</p>
<p>The Oracle implementation of WebRowSet is <code>oracle.jdbc.rowset.OracleWebRowSet</code>. This class, which is in the <code>ojdbc6.jar</code> and <code>ojdbc7.jar</code> files, implements the standard JSR-114 interface <code>javax.sql.rowset.WebRowSet</code>. This class also extends the <code>oracle.jdbc.rowset.OracleCachedRowSet</code> class. Besides the methods available in <code>OracleCachedRowSet</code>, the <code>OracleWebRowSet</code> class provides the following methods:</p>
<ul>
<li>
<pre>public OracleWebRowSet() throws SQLException
</pre>
<p>This is the constructor for creating an <code>OracleWebRowSet</code> object, which is initialized with the default values for an <code>OracleCachedRowSet</code> object, a default <code>OracleWebRowSetXmlReader</code>, and a default <code>OracleWebRowSetXmlWriter</code>.</p>
</li>
<li>
<pre>public void writeXml(java.io.Writer writer) throws SQLException
public void writeXml(java.io.OutputStream ostream) throws SQLException
</pre>
<p>These methods write the <code>OracleWebRowSet</code> object to the supplied <code>Writer</code> or <code>OutputStream</code> object in the XML format that conforms to the JSR-114 XML schema. In addition to the RowSet data, the properties and metadata of the RowSet are written.</p>
</li>
<li>
<pre>public void writeXml(ResultSet rset, java.io.Writer writer) throws SQLException
public void writeXml(ResultSet rset, java.io.OutputStream ostream) throws SQLException
</pre>
<p>These methods create an <code>OracleWebRowSet</code> object, populate it with the data in the given <code>ResultSet</code> object, and write it to the supplied <code>Writer</code> or <code>OutputStream</code> object in the XML format that conforms to the JSR-114 XML schema.</p>
</li>
<li>
<pre>public void readXml(java.io.Reader reader) throws SQLException
public void readXml(java.io.InputStream istream) throws SQLException
</pre>
<p>These methods read the <code>OracleWebRowSet</code> object in the XML format according to its JSR-114 XML schema, using the supplied <code>Reader</code> or <code>InsputStream</code> object.</p>
</li>
</ul>
<p>The Oracle WebRowSet implementation supports Java API for XML Processing (JAXP) 1.2. Both Simple API for XML (SAX) 2.0 and Document Object Model (DOM) JAXP-conforming XML parsers are supported. It follows the current JSR-114 W3C XML schema for WebRowSet at: <code><a href="http://java.sun.com/xml/ns/jdbc/webrowset.xsd">http://java.sun.com/xml/ns/jdbc/webrowset.xsd</a></code></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>Java SE 6 Javadoc at: <code><a href="http://docs.oracle.com/javase/6/docs/api/">http://docs.oracle.com/javase/6/docs/api/</a></code></p>
</li>
<li>
<p>Java SE 7 Javadoc at: <code><a href="http://docs.oracle.com/javase/7/docs/api/">http://docs.oracle.com/javase/7/docs/api/</a></code></p>
</li>
</ul>
</div>
<p>Applications that use the <code>readXml(...)</code> methods should set one of the following two standard JAXP system properties before calling the methods:</p>
<ul>
<li>
<p><code>javax.xml.parsers.SAXParserFactory</code></p>
<p>This property is for a SAX parser.</p>
</li>
<li>
<p><code>javax.xml.parsers.DocumentBuilderFactory</code></p>
<p>This property is for a DOM parser.</p>
</li>
</ul>
<p>The following code illustrates the use of <code>OracleWebRowSet</code> for both writing and reading in XML format:</p>
<pre>import java.sql.*;
import java.io.*;
import oracle.jdbc.rowset.*;

...
String url = &#34;jdbc:oracle:oci8:@&#34;;

Connection conn = DriverManager.getConnection(url,&#34;HR&#34;,&#34;hr&#34;);
Statement stmt = conn.createStatement();
ResultSet rset = stmt.executeQuery(&#34;select * from employees&#34;);

// Create an OracleWebRowSet object and populate it with the ResultSet object
OracleWebRowSet wset = new OracleWebRowSet();
wset.populate(rset);

try
{
  // Create a java.io.Writer object
  FileWriter out = new FileWriter(&#34;xml.out&#34;);
  
  // Now generate the XML and write it out
  wset.writeXml(out);
}
catch (IOException exc)
{
  System.out.println(&#34;Couldn&#39;t construct a FileWriter&#34;);
}
System.out.println(&#34;XML output file generated.&#34;);

// Create a new OracleWebRowSet for reading from XML input
OracleWebRowSet wset2 = new OracleWebRowSet();

// Use Oracle JAXP SAX parser
System.setProperty(&#34;javax.xml.parsers.SAXParserFactory&#34;,&#34;oracle.xml.jaxp.JXSAXParserFactory&#34;);

try
{
  // Use the preceding output file as input
  FileReader fr = new FileReader(&#34;xml.out&#34;);
  
  // Now read XML stream from the FileReader
  wset2.readXml(fr);
}
catch (IOException exc)
{
  System.out.println(&#34;Couldn&#39;t construct a FileReader&#34;);
}
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The preceding code uses the Oracle SAX XML parser, which supports schema validation.</div>
</div>
<!-- class="sect1" -->
<a id="BABGFHJI"></a>
<div id="JJDBC28641" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref688"></a>FilteredRowSet</h2>
<p>A FilteredRowSet is an extension to WebRowSet that provides programmatic support for filtering its content. This enables you to avoid the overhead of supplying a query and the processing involved. The Oracle implementation of FilteredRowSet is <code>oracle.jdbc.rowset.OracleFilteredRowSet</code>. The <code>OracleFilteredRowSet</code> class in the <code>ojdbc7.jar</code> files implements the standard JSR-114 interface <code>javax.sql.rowset.FilteredRowSet</code>.</p>
<p>The <code>OracleFilteredRowSet</code> class defines the following new methods:</p>
<ul>
<li>
<pre>public Predicate getFilter();
</pre>
<p>This method returns a <code>Predicate</code> object that defines the filtering criteria active on the <code>OracleFilteredRowSet</code> object.</p>
</li>
<li>
<pre>public void setFilter(Predicate p) throws SQLException;
</pre>
<p>This method takes a <code>Predicate</code> object as a parameter. The <code>Predicate</code> object defines the filtering criteria to be applied on the <code>OracleFilteredRowSet</code> object. The methods throws a <code>SQLException</code> exception.</p>
</li>
</ul>
<p>The predicate set on an <code>OracleFilteredRowSet</code> object defines a filtering criteria that is applied to all the rows in the object to obtain the set of visible rows. The predicate also defines the criteria for inserting, deleting, and modifying rows. The set filtering criteria acts as a gating mechanism for all views and updates to the <code>OracleFilteredRowSet</code> object. Any attempt to update the <code>OracleFilteredRowSet</code> object, which violates the filtering criteria, throws a <code>SQLException</code> exception.</p>
<p>The filtering criteria set on an <code>OracleFilteredRowSet</code> object can be modified by applying a new <code>Predicate</code> object. The new criteria is immediately applied on the object, and all further views and updates must adhere to this new criteria. A new filtering criteria can be applied only if there are no reference to the <code>OracleFilteredRowSet</code> object.</p>
<p>Rows that fall outside of the filtering criteria set on the object cannot be modified until the filtering criteria is removed or a new filtering criteria is applied. Also, only the rows that fall within the bounds of the filtering criteria will be synchronized with the data source, if an attempt is made to persist the object.</p>
<p>The following code example illustrates the use of OracleFilteredRowSet. Assume a table, <code>test_table</code>, with two <code>NUMBER</code> columns, <code>col1</code> and <code>col2</code>. The code retrieves those rows from the table that have value of <code>col1</code> between <code>50</code> and <code>100</code> and value of <code>col2</code> between <code>100</code> and <code>200</code>.</p>
<p>The predicate defining the filtering criteria is as follows:</p>
<pre>public class PredicateImpl implements Predicate
{
  private int low[];
  private int high[];
  private int columnIndexes[];
  
  public PredicateImpl(int[] lo, int[] hi, int[] indexes)
  {
    low = lo;
    high = hi;
    columnIndexes = indexes;
  }
  
  public boolean evaluate(RowSet rs)
  {
    boolean result = true;
    for (int i = 0; i &lt; columnIndexes.length; i++)
    {
      int columnValue = rs.getInt(columnIndexes[i]);
      if (columnValue &lt; low[i] || columnValue &gt; high[i])
        result = false;
    }
    return result;
  }

// the other two evaluate(...) methods simply return true

}
</pre>
<p>The predicate defined in the preceding code is used for filtering content in an <code>OracleFilteredRowSet</code> object, as follows:</p>
<pre>...
OracleFilteredRowSet ofrs = new OracleFilteredRowSet();
int low[] = {50, 100};
int high[] = {100, 200};
int indexes[] = {1, 2};
ofrs.setCommand(&#34;select col1, col2 from test_table&#34;);

// set other properties on ofrs like usr/pwd ...
...
ofrs.execute();
ofrs.setPredicate(new PredicateImpl(low, high, indexes));

// this will only get rows with col1 in (50,100) and col2 in (100,200)
while (ofrs.next()) {...}
...
</pre></div>
<!-- class="sect1" -->
<a id="BABDHJBJ"></a>
<div id="JJDBC28642" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref689"></a>JoinRowSet</h2>
<p>A JoinRowSet is an extension to WebRowSet that consists of related data from different RowSets. There is no standard way to establish a SQL <code>JOIN</code> between disconnected RowSets without connecting to the data source. A JoinRowSet addresses this issue. The Oracle implementation of JoinRowSet is the <code>oracle.jdbc.rowset.OracleJoinRowSet</code> class. This class, which is in the <code>ojdbc7.jar</code> files, implements the standard JSR-114 interface <code>javax.sql.rowset.JoinRowSet</code>.</p>
<p>Any number of <code>RowSet</code> objects, which implement the <code>Joinable</code> interface, can be added to a <code>JoinRowSet</code> object, provided they can be related in a SQL <code>JOIN</code>. All five types of RowSet support the <code>Joinable</code> interface. The <code>Joinable</code> interface provides methods for specifying the columns based on which the <code>JOIN</code> will be performed, that is, the match columns.</p>
<p>A match column can be specified in the following ways:</p>
<ul>
<li>
<p>Using the <code>setMatchColumn</code> method</p>
<p>This method is defined in the <code>Joinable</code> interface. It is the only method that can be used to set the match column before a <code>RowSet</code> object is added to a <code>JoinRowSet</code> object. This method can also be used to reset the match column at any time.</p>
</li>
<li>
<p>Using the <code>addRowSet</code> method</p>
<p>This is an overloaded method in <code>JoinRowSet</code>. Four of the five implementations of this method take a match column as a parameter. These four methods can be used to set or reset a match column at the time a <code>RowSet</code> object is being added to a <code>JoinRowSet</code> object.</p>
</li>
</ul>
<p>In addition to the inherited methods, <code>OracleJoinRowSet</code> provides the following methods:</p>
<ul>
<li>
<pre>public void addRowSet(Joinable joinable) throws SQLException;
public void addRowSet(RowSet rowSet, int i) throws SQLException;
public void addRowSet(RowSet rowSet, String s) throws SQLException;
public void addRowSet(RowSet arowSet[], int an[]) throws SQLException;
public void addRowSet(RowSet arowSet[], String as[]) throws SQLException;
</pre>
<p>These methods are used to add a <code>RowSet</code> object to the <code>OracleJoinRowSet</code> object. You can pass one or more <code>RowSet</code> objects to be added to the <code>OracleJoinRowSet</code> object. You can also pass names or indexes of one or more columns, which need to be set as match column.</p>
</li>
<li>
<pre>public Collection getRowSets() throws SQLException;
</pre>
<p>This method retrieves the <code>RowSet</code> objects added to the <code>OracleJoinRowSet</code> object. The method returns a <code>java.util.Collection</code> object that contains the <code>RowSet</code> objects.</p>
</li>
<li>
<pre>public String[] getRowSetNames() throws SQLException;
</pre>
<p>This method returns a String array containing the names of the <code>RowSet</code> objects that are added to the <code>OracleJoinRowSet</code> object.</p>
</li>
<li>
<pre>public boolean supportsCrossJoin();
public boolean supportsFullJoin();
public boolean supportsInnerJoin();
public boolean supportsLeftOuterJoin();
public boolean supportsRightOuterJoin();
</pre>
<p>These methods return a boolean value indicating whether the <code>OracleJoinRowSet</code> object supports the corresponding <code>JOIN</code> type.</p>
</li>
<li>
<pre>public void setJoinType(int i) throws SQLException;
</pre>
<p>This method is used to set the <code>JOIN</code> type on the <code>OracleJoinRowSet</code> object. It takes an integer constant as defined in the <code>javax.sql.rowset.JoinRowSet</code> interface that specifies the <code>JOIN</code> type.</p>
</li>
<li>
<pre>public int getJoinType() throws SQLException;
</pre>
<p>This method returns an integer value that indicates the <code>JOIN</code> type set on the <code>OracleJoinRowSet</code> object. This method throws a <code>SQLException</code> exception.</p>
</li>
<li>
<pre>public CachedRowSet toCachedRowSet() throws SQLException;
</pre>
<p>This method creates a <code>CachedRowSet</code> object containing the data in the <code>OracleJoinRowSet</code> object.</p>
</li>
<li>
<pre>public String getWhereClause() throws SQLException;
</pre>
<p>This method returns a String containing the SQL-like description of the <code>WHERE</code> clause used in the <code>OracleJoinRowSet</code> object. This methods throws a <code>SQLException</code> exception.</p>
</li>
</ul>
<p>The following code illustrates how <code>OracleJoinRowSet</code> is used to perform an inner join on two RowSets, whose data come from two different tables. The resulting RowSet contains data as if they were the result of an inner join on these two tables. Assume that there are two tables, an <code>Order</code> table with two <code>NUMBER</code> columns <code>Order_id</code> and <code>Person_id</code>, and a <code>Person</code> table with a <code>NUMBER</code> column <code>Person_id</code> and a <code>VARCHAR2</code> column <code>Name</code>.</p>
<pre>...
// RowSet holding data from table Order
OracleCachedRowSet ocrsOrder = new OracleCachedRowSet();
...
ocrsOrder.setCommand(&#34;select order_id, person_id from order&#34;);
...
// Join on person_id column
ocrsOrder.setMatchColumn(2);
ocrsOrder.execute();

// Creating the JoinRowSet
OracleJoinRowSet ojrs = new OracleJoinRowSet();
ojrs.addRowSet(ocrsOrder);

// RowSet holding data from table Person
OracleCachedRowSet ocrsPerson = new OracleCachedRowSet();
...
ocrsPerson.setCommand(&#34;select person_id, name from person&#34;);
...
// do not set match column on this RowSet using setMatchColumn().
//use addRowSet() to set match column
ocrsPerson.execute();

// Join on person_id column, in another way
ojrs.addRowSet(ocrsPerson, 1);

// now we can go the JoinRowSet as usual
ojrs.beforeFirst();
while (ojrs.next())
System.out.println(&#34;order id = &#34; + ojrs.getInt(1) + &#34;, &#34; + &#34;person id = &#34; +
ojrs.getInt(2) + &#34;, &#34; + &#34;person&#39;s name = &#34; + ojrs.getString(3));
...
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2237">
<tr>
<td class="cellalignment2246">
<table class="cellalignment2242">
<tr>
<td class="cellalignment2241"><a href="resltset.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2241"><a href="global.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2249">
<table class="cellalignment2240">
<tr>
<td class="cellalignment2241"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2241"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2241"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2241"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2241"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2241"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>