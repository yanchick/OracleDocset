<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71003"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Working%20with%20Oracle%20Collections"></a><title>Working with Oracle Collections</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="description" content="This book describes how to use Oracle JDBC drivers to develop powerful Java database applications."/>
<meta name="dcterms.created" content="2014-06-30T1:22:37Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database JDBC Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49300-05"/>
<meta name="dcterms.isVersionOf" content="JJDBC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="oraoor.htm" title="Previous" type="text/html"/>
<link rel="Next" href="resltset.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49300-05.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">27/55</span> <!-- End Header -->
<div id="JJDBC28574" class="chapter"><a id="g1072333"></a>
<h1 class="chapter"><span class="secnum">16</span> Working with Oracle Collections</h1>
<p><a id="sthref594"></a><a id="sthref595"></a>This chapter describes Oracle extensions to standard Java Database Connectivity (JDBC) that let you access and manipulate Oracle collections, which map to Java arrays, and their data. The following topics are discussed:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>oracle.sql.ARRAY</code> class is deprecated and replaced with the <code>oracle.jdbc.OracleArray</code> interface, which is a part of the <code>oracle.jdbc</code> package. Oracle recommends you to use the methods available in the <code>java.sql</code> package, where possible, for standard compatibility and methods available in the <code>oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code>oracle.jdbc.OracleArray</code> interface.</div>
<ul>
<li>
<p><a href="#i1062057">Oracle Extensions for Collections</a></p>
</li>
<li>
<p><a href="#i1061578">Overview of Collection Functionality</a></p>
</li>
<li>
<p><a href="#CHDJEGDC">ARRAY Performance Extension Methods</a></p>
</li>
<li>
<p><a href="#i1059642">Creating and Using Arrays</a></p>
</li>
<li>
<p><a href="#i1049179">Using a Type Map to Map Array Elements</a></p>
</li>
<li>
<p><a href="#i1057327">Custom Collection Classes with JPublisher</a></p>
</li>
</ul>
<a id="i1062057"></a>
<div id="JJDBC28575" class="sect1">
<h2 class="sect1">Oracle Extensions for Collections</h2>
<p>An Oracle coll<a id="sthref596"></a>ection, either a variable array (VARRAY) or a nested table in the database, maps to an array in Java. JDBC 2.0 arr<a id="sthref597"></a><a id="sthref598"></a>ays are used to materialize Oracle collections in Java. The terms collection and array are sometimes used interchangeably. However, collection is more appropriate on the database side and array is more appropriate on the JDBC application side.</p>
<p>Oracle supports only <a id="sthref599"></a><a id="sthref600"></a>named collections, where you specify a SQL type name to describe a type of collection. JDBC enables you to use arrays as any of the following:</p>
<ul>
<li>
<p>Columns in a <code>SELECT</code> clause</p>
</li>
<li>
<p><code>IN</code> or <code>OUT</code> bind variables</p>
</li>
<li>
<p>Attributes in an Oracle object</p>
</li>
<li>
<p>Elements of other arrays</p>
</li>
</ul>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABHGCHA">Choices in Materializing Collections</a></p>
</li>
<li>
<p><a href="#BABEIJDG">Creating Collections</a></p>
</li>
<li>
<p><a href="#BABFABHE">Creating Multilevel Collection Types</a></p>
</li>
</ul>
<a id="BABHGCHA"></a>
<div id="JJDBC28576" class="sect2">
<h3 class="sect2">Choices in Materializing Collections</h3>
<p>In your application, you have the choice of materializing a collection as an instance of the <code><a id="sthref601"></a>oracle.sql.ARRAY</code> class, which is weakly typed, or materializing it as an instance of a custom Java class that you have created in advance, which is strongly typed. Custom Java classes used for collections are referred to as cus<a id="sthref602"></a>tom collection classes. A custom collection class must implement the Oracle <code>oracle.jdbc.OracleData</code> interface. In addition, the custom class or a companion class must implement <code>oracle.jdbc.OracleDataFactory</code>. The standard <code>java.sql.SQLData</code> interface is for mapping SQL object types only.</p>
<p>The <code>oracle.sql.ARRAY</code> class implements the standard <code>java.sql.Array</code> interface.</p>
<p>The <code>ARRAY</code> class includes functionality to retrieve the array as a whole, retrieve a subset of the array elements, and retrieve the SQL base type name of the array elements. However, you cannot write to the array, because there are no setter methods.</p>
<p>Custom collection classes, as with the <code>ARRAY</code> class, enable you to retrieve all or part of the array and get the SQL base type name. They also have the advantage of being strongly typed, which can help you find coding errors during compilation that might not otherwise be discovered until run time.</p>
<p>Furthermore, custom collection classes produced by JPublisher offer the feature of being writable, with individually accessible elements.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is no difference in the code between accessing VARRAYs and accessing nested tables. <code>ARRAY</code> class methods can determine if they are being applied to a VARRAY or nested table, and respond by taking the appropriate actions.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about custom collection classes, see <a href="#i1057327">&#34;Custom Collection Classes with JPublisher&#34;</a>.</div>
</div>
<!-- class="sect2" -->
<a id="BABEIJDG"></a>
<div id="JJDBC28577" class="sect2">
<h3 class="sect2">Creating Collections</h3>
<p>Because Oracle supports only named collections, you must declare a particular <code>VARRAY</code> type name or nested table type name. VARRAY and nested table are not types themselves, but categories of types.</p>
<p>A SQL type name is assigned to a collection when you create it using the SQL <code>CREATE TYPE</code> statement:</p>
<pre>CREATE TYPE &lt;<span class="italic">sql_type_name</span>&gt; AS &lt;<span class="italic">datatype</span>&gt;;
</pre>
<p>A VARRAY is an array of varying size. It has an ordered set of data elements, and all the elements are of the same data type. Each element has an index, which is a number corresponding to the position of the element in the VARRAY. The number of elements in a VARRAY is the size of the VARRAY. You must specify a maximum size when you declare the <code>VARRAY</code> type. For example:</p>
<pre>CREATE TYPE myNumType AS VARRAY(10) OF NUMBER;
</pre>
<p>This statement defines <code>myNumType</code> as a SQL type name that describes a VARRAY of <code>NUMBER</code> values that can contain no more than 10 elements.</p>
<p>A nested table is an unordered set of data elements, all of the same data type. The database stores a nested table in a separate table which has a single column, and the type of that column is a built-in type or an object type. If the table is an object type, then it can also be viewed as a multi-column table, with a column for each attribute of the object type. You can create a nested table as follows:</p>
<pre>CREATE TYPE myNumList AS TABLE OF integer;
</pre>
<p>This statement identifies <code>myNumList</code> as a SQL type name that defines the table type used for the nested tables of the type <code>INTEGER</code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABFABHE"></a>
<div id="JJDBC28578" class="sect2">
<h3 class="sect2">Creating Multilevel Collection Types</h3>
<p>The most common way to create a new multilevel collection type in JDBC is to pass the SQL <code>CREATE TYPE</code> statement to the <code>execute</code> method of the <code>java.sql.Statement</code> class. The following code creates a one-level nested table, <code>first_level</code>, and a two- levels nested table, <code>second_level</code>:</p>
<pre>Connection conn = ....                            // make a database
                                                  // connection 
Statement stmt = conn.createStatement();          // open a database
                                                  // cursor 
stmt.execute(&#34;CREATE TYPE first_level AS TABLE OF NUMBER&#34;);  // create a nested
                                                  // table of number 
stmt.execute(&#34;CREATE TYPE second_level AS TABLE OF first_level&#34;); // create a
           // two-levels nested table
...        // other operations here
stmt.close();                                     // release the
                                                  // resource 
conn.close();                                     // close the
                                                  // database connection
</pre>
<p>Once the multilevel collection types have been created, they can be used as both columns of a base table as well as attributes of a object type.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1061578"></a>
<div id="JJDBC28579" class="sect1">
<h2 class="sect1">Overview of Collection Functionality</h2>
<p>You can obtain collection data in an array instance through a result set or callable statement and pass it back as a bind variable in a prepared statement or callable statement.</p>
<p>The <code>oracle.sql.ARRAY</code> class, which implements the standard <code>java.sql.Array</code> interface, provides the necessary functionality to access and update the data of an Oracle collection.</p>
<p>This section covers Array Getter and Setter Methods. Use the following result set, callable statement, and prepared statement methods to retrieve and pass collections as Java arrays.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>oracle.sql.ARRAY</code> class is deprecated and replaced with the <code>oracle.jdbc.OracleArray</code> interface, which is a part of the <code>oracle.jdbc</code> package. Oracle recommends you to use the methods available in the <code>java.sql</code> package, where possible, for standard compatibility and methods available in the <code>oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code>oracle.jdbc.OracleArray</code> interface.</div>
<p class="subhead2"><a id="JJDBC28580"></a>Result Set and Callable Statement Getter Methods</p>
<p>The <code>OracleResultSet</code> and <code>OracleCallableStatement</code> interfaces support <code>getARRAY</code> and <code>getArray</code> methods to retrieve <code>ARRAY</code> objects as output parameters, either as <code>oracle.sql.ARRAY</code> instances or <code>java.sql.Array</code> instances. You can also use the <code>getObject</code> method. These methods take as input a <code>String</code> column name or <code>int</code> column index.</p>
<p class="subhead2"><a id="JJDBC28581"></a>Prepared and Callable Statement Setter Methods</p>
<p>The <code>OraclePreparedStatement</code> and <code>OracleCallableStatement</code> classes support <code>setARRAY</code> and <code>setArray</code> methods to take updated <code>ARRAY</code> objects as bind variables and pass them to the database. You can also use the <code>setObject</code> method. These methods take as input a <code>String</code> parameter name or <code>int</code> parameter index as well as an <code>oracle.sql.ARRAY</code> instance or a <code>java.sql.Array</code> instance.</p>
</div>
<!-- class="sect1" -->
<a id="CHDJEGDC"></a>
<div id="JJDBC28585" class="sect1">
<h2 class="sect1">ARRAY Performance Extension Methods</h2>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1059899">Accessing oracle.sql.ARRAY Elements as Arrays of Java Primitive Types</a></p>
</li>
<li>
<p><a href="#i1059905">ARRAY Automatic Element Buffering</a></p>
</li>
<li>
<p><a href="#i1059909">ARRAY Automatic Indexing</a></p>
</li>
</ul>
<a id="i1059899"></a>
<div id="JJDBC28586" class="sect2">
<h3 class="sect2">Accessing oracle.sql.ARRAY Elements as Arrays of Java Primitive Types</h3>
<p>The <code>oracle.sql.ARRAY</code> class contains methods that return array elements as Java primitive types. These methods enable you to access collection elements more efficiently than accessing them as <code>Datum</code> instances and then converting each <code>Datum</code><a id="sthref603"></a> instance to its Java primitive value.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
These specialized methods of the <code>oracle.sql.ARRAY</code> class are restricted to numeric collections.</div>
<p>Each method using the first signature returns collection elements as an <code><span class="codeinlineitalic">XXX</span></code><code>[]</code>, where <code><span class="codeinlineitalic">XXX</span></code> is a Java primitive type. Each method using the second signature returns a slice of the collection containing the number of elements specified by <code>count</code>, starting at the <code>index</code> location.</p>
</div>
<!-- class="sect2" -->
<a id="i1059905"></a>
<div id="JJDBC28587" class="sect2">
<h3 class="sect2">ARRAY Automatic Element Buffering</h3>
<p>Oracle JDBC driver provides public methods to enable and disable buffering of <code>ARRAY</code> contents.</p>
<p>The following methods are included with the <code><a id="sthref604"></a>oracle.sql.ARRAY</code> class:<code><a id="sthref605"></a></code></p>
<ul>
<li>
<p><code><a id="sthref606"></a>setAutoBuffering</code></p>
</li>
<li>
<p><code><a id="sthref607"></a>getAutoBuffering</code></p>
</li>
</ul>
<p>It is advisable to enable auto-buffering in a JDBC application when the <code>ARRAY</code> elements will be accessed more than once by the <code>getAttributes</code> and <code>getArray</code> methods, presuming the <code>ARRAY</code> data is able to fit into the Java Virtual Machine (JVM) memory without overflow.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
Buffering the converted elements may cause the JDBC application to consume a significant amount of memory.</div>
<p>When you enable auto-buffering, the <code>oracle.sql.ARRAY</code> object keeps a local copy of all the converted elements. This data is retained so that a second access of this information does not require going through the data format conversion process.</p>
</div>
<!-- class="sect2" -->
<a id="i1059909"></a>
<div id="JJDBC28588" class="sect2">
<h3 class="sect2">ARRAY Automatic Indexing</h3>
<p>If an array is in auto-indexing mode, then the array object maintains an index table to hasten array element access.</p>
<p>The <code>oracle.sql.ARRAY</code> class contains the following methods to support automatic array-indexing:</p>
<ul>
<li>
<p><code>setAutoIndexing<a id="sthref608"></a><a id="sthref609"></a></code></p>
</li>
<li>
<p><code>setAutoIndexing<a id="sthref610"></a><a id="sthref611"></a></code></p>
</li>
</ul>
<p>By default, auto-indexing is not enabled. For a JDBC application, enable auto-indexing for <code>ARRAY</code> objects if random access of array elements may occur through the <code><a id="sthref612"></a>getArray</code> and <code>get<a id="sthref613"></a>ResultSet</code> methods.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1059642"></a>
<div id="JJDBC28589" class="sect1">
<h2 class="sect1">Creating and Using Arrays</h2>
<p>This section discusses how to create array objects and how to retrieve and pass collections as array objects, including the following topics.</p>
<ul>
<li>
<p><a href="#i1056647">Creating ARRAY Objects</a></p>
</li>
<li>
<p><a href="#i1058506">Retrieving an Array and Its Elements</a></p>
</li>
<li>
<p><a href="#i1058512">Passing Arrays to Statement Objects</a></p>
</li>
</ul>
<a id="i1056647"></a>
<div id="JJDBC28590" class="sect2">
<h3 class="sect2">Creating ARRAY Objects</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle JDBC does not support the JDBC 4.0 method <code>createArrayOf</code> method of <code>java.sql.Connection</code> interface. This method only allows anonymous array types, while all Oracle array types are named. Use the Oracle specific method <code>oracle.jdbc.OracleConnection.createARRAY</code> instead.</div>
<p>This section describes how to create <code>ARRAY</code> objects. This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1056527">Steps in Creating ARRAY Objects</a></p>
</li>
<li>
<p><a href="#BABHIJHB">Creating Multilevel Collections</a></p>
</li>
</ul>
<p class="subhead2"><a id="i1056527"></a><a id="JJDBC28591"></a>Steps in Creating ARRAY Objects</p>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 1, you can use the <code>createARRAY</code> factory method of <code>oracle.jdbc.OracleConnection</code> interface to create an array object. The factory method for creating arrays has been defined as follows:</p>
<pre>public ARRAY createARRAY(java.lang.String typeName,java.lang.Object elements)throws SQLException
</pre>
<p>where, <code>typeName</code> is the name of the SQL type of the created object and <code>elements</code> is the elements of the created object.</p>
<p>Perform the following to create an array:<a id="sthref614"></a><a id="sthref615"></a></p>
<ol>
<li>
<p>Create a collection with the <code>CREATE</code> <code>TYPE</code> statement as follows:</p>
<pre>CREATE TYPE elements AS varray(22) OF NUMBER(5,2);
</pre>
<p>The two possibilities for the contents of <code>elements</code> are:</p>
<ul>
<li>
<p>An array of Java primitives. For example, <code>int[]</code>.</p>
</li>
<li>
<p>An array of Java objects, such as <code><span class="codeinlineitalic">xxx</span></code><code>[]</code>, where <code><span class="codeinlineitalic">xxx</span></code> is the name of a Java class. For example, <code>Integer[]</code>.</p>
</li>
</ul>
</li>
<li>
<p>Construct the <code>ARRAY</code> object <a id="sthref616"></a>by passing the Java string specifying the user-defined SQL type name of the array and a Java object containing the individual elements you want the array to contain.</p>
<pre>ARRAY array = oracle.jdbc.OracleConnection.createARRAY(sql_type_name, elements);
</pre></li>
</ol>
<p class="subhead2"><a id="BABHIJHB"></a><a id="JJDBC28592"></a>Creating Multilevel Collections</p>
<p>As with single-level collections, the JDBC application can create an <code>oracle.sql.ARRAY</code> instance to represent a multilevel collection, and then send the instance to the database. The same <code>createARRAY</code> factory method you use to create single-level collections, can be used to create multilevel collections as well. To create a single-level collection, the elements are a one dimensional Java array, while to create a multilevel collection, the elements can be either an array of <code>oracle.sql.ARRAY[]</code> elements or a nested Java array or the combinations.</p>
<p>The following code shows how to create collection types with a nested Java array:</p>
<pre>// prepare the multilevel collection elements as a nested Java array
int[][][] elements = { {{1}, {1, 2}}, {{2}, {2, 3}}, {{3}, {3, 4}} };

// create the ARRAY using the factory method
ARRAY array = oracle.jdbc.OracleConnection.createARRAY(sql_type_name, elements);

</pre></div>
<!-- class="sect2" -->
<a id="i1058506"></a>
<div id="JJDBC28595" class="sect2">
<h3 class="sect2">Retrieving an Array and Its Elements</h3>
<p>This section first discusses how to retrieve an <code>ARRAY</code> instance as a whole from a result set, and then how to retrieve the elements from the <code>ARRAY</code> instance. This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABCEGDD">Retrieving the Array</a></p>
</li>
<li>
<p><a href="#BABDEJBJ">Data Retrieval Methods</a></p>
</li>
<li>
<p><a href="#i1057008">Comparing the Data Retrieval Methods</a></p>
</li>
<li>
<p><a href="#BABBFFEI">Retrieving Elements of a Structured Object Array According to a Type Map</a></p>
</li>
<li>
<p><a href="#BABCBBEA">Retrieving a Subset of Array Elements</a></p>
</li>
<li>
<p><a href="#BABJCIFF">Retrieving Array Elements into an oracle.sql.Datum Array</a></p>
</li>
<li>
<p><a href="#BABDHBGD">Accessing Multilevel Collection Elements</a></p>
</li>
</ul>
<a id="BABCEGDD"></a>
<div id="JJDBC28596" class="sect3">
<h4 class="sect3"><a id="sthref617"></a>Retrieving the Array</h4>
<p>You can retrieve a SQL array from a result set by casting the result set to <code>OracleResultSet</code> and using the <code><a id="sthref618"></a>getARRAY</code> method, which returns an <code>oracle.sql.ARRAY</code> object. If you want to avoid casting the result set, then you can get the data with the standard <code>getObject</code> method specified by the <code>java.sql.ResultSet</code> interface and cast the output to <code>oracle.sql.ARRAY</code>.</p>
</div>
<!-- class="sect3" -->
<a id="BABDEJBJ"></a>
<div id="JJDBC28597" class="sect3">
<h4 class="sect3">Data Retrieval Methods</h4>
<p>Once you have an <code>ARRAY</code> object, you can retrieve the data using one of these three overloaded methods of the <code>oracle.sql.ARRAY</code> class:</p>
<ul>
<li>
<p><code><a id="sthref619"></a><a id="sthref620"></a>getArray</code></p>
</li>
<li>
<p><code>getOracleArray</code></p>
</li>
<li>
<p><code>getResultSet</code></p>
</li>
</ul>
<p>Oracle also provides methods that enable you to retrieve all the elements of an array, or a subset.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In case you are working with an array of structured objects, Oracle provides versions of these three methods that enable you to specify a type map so that you can choose how to map the objects to Java.</div>
<p class="subhead2"><a id="JJDBC28598"></a>getOracleArray</p>
<p>The <code>getOracleArray</code> method is an Oracle-specific extension that is not specified in the standard <code>Array</code> interface. The <code>getOracleArray</code> method retrieves the element values of the array into a <code>Datum[]</code> array. The elements are of the <code>oracle.sql.*</code> data type corresponding to the SQL type of the data in the original array.</p>
<p>For an array of structured objects, this method will use <code>oracle.jdbc.OracleStruct</code> instances for the elements.</p>
<p>Oracle also provides a <code>getOracleArray(</code><code><span class="codeinlineitalic">index</span></code><code>,</code><code><span class="codeinlineitalic">count</span></code><code>)</code> <code>method</code> to get a subset of the array elements.</p>
<p class="subhead2"><a id="JJDBC28599"></a>getResultSet</p>
<p>The <code>getResultSet</code> method returns a result set that contains elements of the array designated by the <code>ARRAY</code> object. The result set contains one row for each array element, with two columns in each row. The first column stores the index into the array for that element, and the second column stores the element value. In the case of VARRAYs, the index represents the position of the element in the array. In the case of nested tables, which are by definition unordered, the index reflects only the return order of the elements in the particular query.</p>
<p>Oracle recommends using <code>getResultSet</code> when getting data from nested tables. Nested tables can have an unlimited number of elements. The <code>ResultSet</code> object returned by the method initially points at the first row of data. You get the contents of the nested table by using the <code>next</code> method and the appropriate <code>get</code><code><span class="codeinlineitalic">XXX</span></code> method. In contrast, <code>getArray</code> returns the entire contents of the nested table at one time.</p>
<p>The <code>getResultSet</code> method uses the default type map of the connection to determine the mapping between the SQL type of the Oracle object and its corresponding Java data type. If you do not want to use the default type map of the connection, another version of the method, <code>getResultSet(</code><code><span class="codeinlineitalic">map</span></code><code>)</code>, enables you to specify an alternate type map.</p>
<p>Oracle also provides the <code>getResultSet(</code><code><span class="codeinlineitalic">index</span></code><code>,</code><code><span class="codeinlineitalic">count</span></code><code>)</code> and <code>getResultSet(</code><code><span class="codeinlineitalic">index</span></code><code>,</code><code><span class="codeinlineitalic">count</span></code><code>,</code><code><span class="codeinlineitalic">map</span></code><code>)</code> methods to retrieve a subset of the array elements.</p>
<p class="subhead2"><a id="JJDBC28600"></a>getArray</p>
<p>The <code>getArray</code> method is a standard JDBC method that returns the array elements as a <code>java.lang.Object</code>, which you can cast as appropriate. The elements are converted to the Java types corresponding to the SQL type of the data in the original array.</p>
<p>Oracle also provides a <code>getArray(</code><code><span class="codeinlineitalic">index</span></code><code>,</code><code><span class="codeinlineitalic">count</span></code><code>)</code> method to retrieve a subset of the array elements.</p>
</div>
<!-- class="sect3" -->
<a id="i1057008"></a>
<div id="JJDBC28601" class="sect3">
<h4 class="sect3">Comparing the Data Retrieval Methods</h4>
<p>If you use <code>getOracleArray</code> to return the array elements, then the use by that method of <code>oracle.sql.Datum</code> instances avoids the expense of data conversion from SQL to Java. The non-character data inside the instance of a <code>Datum</code> class or any of its subclass remains in raw SQL format.</p>
<p>If you use <code>getResultSet</code> to return an array of primitive data types, then the JDBC driver returns a <code>ResultSet</code> object that contains, for each element, the index into the array for the element and the element value. For example:</p>
<pre>ResultSet rset = intArray.getResultSet();
</pre>
<p>In this case, the result set contains one row for each array element, with two columns in each row. The first column stores the index into the array and the second column stores the element value.</p>
<p>If the elements of an array are of a SQL type that maps to a Java type, then <code>getArray</code> returns an array of elements of this Java type. The return type of the <code>getArray</code> method is <code>java.lang.Object</code>. Therefore, the result must be cast before it can be used.</p>
<pre>BigDecimal[] values = (BigDecimal[]) intArray.getArray();
</pre>
<p>Here <code>intArray</code> is an <code>oracle.sql.ARRAY</code>, corresponding to a VARRAY of type <code>NUMBER</code>. The <code>values</code> array contains an array of elements of type <code>java.math.BigDecimal</code>, because the SQL <code>NUMBER</code> data type maps to Java <code>BigDecimal</code>, by default, according to Oracle JDBC drivers.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Using <code>BigDecimal</code> is a resource-intensive operation in Java. Because Oracle JDBC maps numeric SQL data to <code>BigDecimal</code> by default, using <code>getArray</code> may impact performance, and is not recommended for numeric collections.</div>
</div>
<!-- class="sect3" -->
<a id="BABBFFEI"></a>
<div id="JJDBC28602" class="sect3">
<h4 class="sect3">Retrieving Elements of a Structured Object Array According to a Type Map</h4>
<p>By default, if you are working with an array whose elements are structured objects, and you use <code><a id="sthref621"></a>getArray</code> or <code>getResultSet</code>, then the Oracle objects in the array will be mapped to their corresponding Java data types according to the default mapping. This is because these methods use the default <a id="sthref622"></a>type map of the connection to determine the mapping.</p>
<p>However, if you do not want default behavior, then you can use the <code>getArray(</code><code><span class="codeinlineitalic">map</span></code><code>)</code> or <code>getResultSet(</code><code><span class="codeinlineitalic">map</span></code><code>)</code> method to specify a type map that contains alternate mappings. If there are entries in the type map corresponding to the Oracle objects in the array, then each object in the array is mapped to the corresponding Java type specified in the type map. For example:</p>
<pre>Object[] object = (Object[])objArray.getArray(map);
</pre>
<p>Where <code>objArray</code> is an <code>oracle.sql.ARRAY</code> object and <code>map</code> is a <code>java.util.Map</code> object.</p>
<p>If the type map does not contain an entry for a particular Oracle object, then the element is returned as an <code>oracle.jdbc.OracleStruct</code> object.</p>
<p>The <code>getResultSet(</code><code><span class="codeinlineitalic">map</span></code><code>)</code> method behaves similarly to the <code>getArray(</code><code><span class="codeinlineitalic">map</span></code><code>)</code> method.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1049179">&#34;Using a Type Map to Map Array Elements&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="BABCBBEA"></a>
<div id="JJDBC28603" class="sect3">
<h4 class="sect3">Retrieving a Subset of Array Elements</h4>
<p>If you do not want to retrieve the entire contents of an array, then you can use signatures of <code>getArray</code>, <code>getResultSet</code>, and <code>getOracleArray</code> that let you retrieve a subset. To retrieve a subset of the <a id="sthref623"></a>array, pass in an index and a count to indicate where in the array you want to start and how many elements you want to retrieve. As previously described, you can specify a type map or use the default type map for your connection to convert to Java types. For example:</p>
<pre>Object object = arr.getArray(<span class="italic">index</span>, <span class="italic">count</span>, <span class="italic">map</span>);
Object object = arr.getArray(<span class="italic">index</span>, <span class="italic">count</span>);
</pre>
<p>Similar examples using <code>getResultSet</code> are:</p>
<pre>ResultSet rset = arr.getResultSet(<span class="italic">index</span>, <span class="italic">count</span>, <span class="italic">map</span>);
ResultSet rset = arr.getResultSet(<span class="italic">index</span>, <span class="italic">count</span>);
</pre>
<p>A similar example using <code>getOracleArray</code> is:</p>
<pre>Datum[] arr = arr.getOracleArray(<span class="italic">index</span>, <span class="italic">count</span>);
</pre>
<p>Where <code><span class="codeinlineitalic">arr</span></code> is an <code>oracle.sql.ARRAY</code> object, <code><span class="codeinlineitalic">index</span></code> is type <code>long</code>, <code><span class="codeinlineitalic">count</span></code> is type <code>int</code>, and <code><span class="codeinlineitalic">map</span></code> is a <code><a id="sthref624"></a>java.util.Map</code> object.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is no performance advantage in retrieving a subset of an array, as opposed to the entire array.</div>
</div>
<!-- class="sect3" -->
<a id="BABJCIFF"></a>
<div id="JJDBC28604" class="sect3">
<h4 class="sect3">Retrieving Array Elements into an oracle.sql.Datum Array</h4>
<p>Use <code><a id="sthref625"></a>getOracleArray</code> to return an <code>oracle.sql.Datum[]</code> array. The elements of the returned array is of <code>oracle.sql.*</code> type that correspond to the SQL data type of the elements of the original array. For example:</p>
<pre>Datum arraydata[] = arr.getOracleArray();
</pre>
<p><code>arr</code> is an <code>oracle.sql.ARRAY</code> object.</p>
<p>The <a id="sthref626"></a>following example assumes that a connection object <code>conn</code> and a statement object <code>stmt</code> have already been created. In the example, an array with the SQL type name <code>NUM_ARRAY</code> is created to store a VARRAY of <code>NUMBER</code> data. The <code>NUM_ARRAY</code> is in turn stored in a table <code>VARRAY_TABLE</code>.</p>
<p>A query selects the contents of the <code>VARRAY_TABLE</code>. The result set is cast to <code>OracleResultSet</code>. The <code>getARRAY</code> method is applied to it to retrieve the array data into <code>my_array</code>, which is an <code>oracle.sql.ARRAY</code> object.</p>
<p>Because <code>my_array</code> is of type <code>oracle.sql.ARRAY</code>, you can apply the methods <code><a id="sthref627"></a><a id="sthref628"></a>getSQLTypeName</code> and <code>getBaseType</code> to it to return the name of the SQL type of each element in the array and its integer code.</p>
<p>The program then prints the contents of the array. Because the contents of <code>NUM_ARRAY</code> are of the SQL data type <code>NUMBER</code>, the elements of <code>my_array</code> are of the type, <code>BigDecimal</code>. Before you can use the elements, they must first be cast to <code>BigDecimal</code>. In the <code>for</code> loop, the individual values of the array are cast to <code>BigDecimal</code> and printed to standard output.</p>
<pre>stmt.execute (&#34;CREATE TYPE num_varray AS VARRAY(10) OF NUMBER(12, 2)&#34;);
stmt.execute (&#34;CREATE TABLE varray_table (col1 num_varray)&#34;);
stmt.execute (&#34;INSERT INTO varray_table VALUES (num_varray(100, 200))&#34;);

ResultSet rs = stmt.executeQuery(&#34;SELECT * FROM varray_table&#34;);
ARRAY my_array = ((OracleResultSet)rs).getARRAY(1);

// return the SQL type names, integer codes, 
// and lengths of the columns
System.out.println (&#34;Array is of type &#34; + array.getSQLTypeName());
System.out.println (&#34;Array element is of type code &#34; + array.getBaseType());
System.out.println (&#34;Array is of length &#34; + array.length());

// get Array elements 
BigDecimal[] values = (BigDecimal[]) my_array.getArray();

for (int i=0; i&lt;values.length; i++) 
{
   BigDecimal out_value = (BigDecimal) values[i];
   System.out.println(&#34;&gt;&gt; index &#34; + i + &#34; = &#34; + out_value.intValue());
}
</pre>
<p>Note that if you use <code>getResultSet</code> to obtain the array, then you must would first get the result set object, and then use the <code>next</code> method to iterate through it. Notice the use of the parameter indexes in the <code>getInt</code> method to retrieve the element index and the element value.</p>
<pre>ResultSet rset = my_array.getResultSet();
while (rset.next())
{
    // The first column contains the element index and the 
    // second column contains the element value
    System.out.println(&#34;&gt;&gt; index &#34; + rset.getInt(1)+&#34; = &#34; + rset.getInt(2));
}
</pre></div>
<!-- class="sect3" -->
<a id="BABDHBGD"></a>
<div id="JJDBC28605" class="sect3">
<h4 class="sect3">Accessing Multilevel Collection Elements</h4>
<p>The <code>oracle.sql.ARRAY</code> class provides three methods, which are overloaded, to access collection elements. The JDBC drivers extend these methods to support multilevel collections. These methods are:</p>
<ul>
<li>
<p><code>getArray</code> method</p>
</li>
<li>
<p><code>getOracleArray</code> method</p>
</li>
<li>
<p><code>getResultSet</code> method</p>
</li>
</ul>
<p>The <code>getArray</code> method returns a Java array that holds the collection elements. The array element type is determined by the collection element type and the JDBC default conversion matrix.</p>
<p>For example, the <code>getArray</code> method returns a <code>java.math.BigDecimal</code> array for collection of SQL <code>NUMBER</code>. The <code>getOracleArray</code> method returns a <code>Datum</code> array that holds the collection elements in <code>Datum</code> format. For multilevel collections, the <code>getArray</code> and <code>getOracleArray</code> methods both return a Java array of <code>oracle.sql.ARRAY</code> elements.</p>
<p>The <code>getResultSet</code> method returns a <code>ResultSet</code> object that wraps the multilevel collection elements. For multilevel collections, the JDBC applications use the <code>getObject</code>, <code>getARRAY</code>, or <code>getArray</code> method of the <code>ResultSet</code> class to access the collection elements as instances of <code>oracle.sql.ARRAY</code>.</p>
<p>The following code shows how to use the <code>getOracleArray</code>, <code>getArray</code>, and <code>getResultSet</code> methods:</p>
<pre>Connection conn = ...;          // make a JDBC connection 
Statement stmt = conn.createStatement (); 
ResultSet rset = stmt.executeQuery (&#34;select col2 from tab2 where idx=1&#34;); 

while (rset.next()) 
{ 
  ARRAY varray3 = (ARRAY) rset.getObject (1); 
  Object varrayElems = varray3.getArray (1);  
// access array elements of &#34;varray3&#34; 
  Datum[] varray3Elems = (Datum[]) varrayElems; 

  for (int i=0; i&lt;varray3Elems.length; i++) 
  { 
    ARRAY varray2 = (ARRAY) varray3Elems[i]; 
    Datum[] varray2Elems = varray2.getOracleArray(); 
    // access array elements of  &#34;varray2&#34; 

    for (int j=0; j&lt;varray2Elems.length; j++) 
    { 
      ARRAY varray1 = (ARRAY) varray2Elems[j]; 
      ResultSet varray1Elems = varray1.getResultSet(); 
      // access array elements   of &#34;varray1&#34; 

      while (varray1Elems.next()) 
        System.out.println (&#34;idx=&#34;+varray1Elems.getInt(1)+&#34;
          value=&#34;+varray1Elems.getInt(2)); 
    } 
  } 
} 
rset.close (); 
stmt.close (); 
conn.close (); 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1058512"></a>
<div id="JJDBC28606" class="sect2">
<h3 class="sect2">Passing Arrays to Statement Objects</h3>
<p>This section discusses how to pass arrays to prepared statement objects or callable statement objects.</p>
<p class="subhead2"><a id="i1054918"></a><a id="JJDBC28607"></a>Passing an Array to a Prepared Statement</p>
<p>Pass an array to a prepared statement as follows.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
you can use arrays as either <code>IN</code> or <code>OUT</code> bind variables.</div>
<ol>
<li>
<p>Define the array that you want to pass to the prepared statement as an <code>oracle.sql.ARRAY</code> object.</p>
<pre>ARRAY array = oracle.jdbc.OracleConnection.createARRAY(sql_type_name, elements);
</pre>
<p><code>sql_type_name</code> is a Java string specifying the user-defined SQL type name of the array and <code><span class="codeinlineitalic">elements</span></code> is a <code>java.lang.Object</code> containing a Java array of the elements.</p>
</li>
<li>
<p>Create a <code>java.sql.PreparedStatement</code> object containing the SQL statement to be run.</p>
</li>
<li>
<p>Cast your prepared statement to <code>OraclePreparedStatement</code>, and use <code>setARRAY</code> to pass the array to the prepared statement.</p>
<pre>(OraclePreparedStatement)stmt.setARRAY(<span class="italic">parameterIndex</span>, <span class="italic">array</span>);
</pre>
<p><code><span class="codeinlineitalic">parameterIndex</span></code> is the parameter index and <code><span class="codeinlineitalic">array</span></code> is the <code>oracle.sql.ARRAY</code> object you constructed previously.</p>
</li>
<li>
<p>Run the prepared statement.</p>
</li>
</ol>
<p class="subhead2"><a id="i1054923"></a><a id="JJDBC28608"></a>Passing an Array to a Callable Statement</p>
<p>To retrieve a <a id="sthref629"></a>collection as an <code>OUT</code> parameter in PL/SQL blocks, perform the following to register the bind type for your <code>OUT</code> parameter.</p>
<ol>
<li>
<p>Cast your callable statement to <code>OracleCallableStatement</code>, as follows:</p>
<pre>OracleCallableStatement ocs = (OracleCallableStatement)conn.prepareCall(&#34;{? = call func()}&#34;);
</pre></li>
<li>
<p>Register the <code>OUT</code> parameter with the following form of the <code>registerOutParameter</code> method:</p>
<pre>ocs.registerOutParameter
        (int <span class="italic">param_index</span>, int <span class="italic">sql_type</span>, string <span class="italic">sql_type_name</span>);
</pre>
<p><code><span class="codeinlineitalic">param_index</span></code> is the parameter index, <code><span class="codeinlineitalic">sql_type</span></code> is the SQL type code, and <code><span class="codeinlineitalic">sql_type_name</span></code> is the name of the array type. In this case, the <code><span class="codeinlineitalic">sql_type</span></code> is <code>OracleTypes.ARRAY</code>.</p>
</li>
<li>
<p>Run the call, as follows:</p>
<pre>ocs.execute();
</pre></li>
<li>
<p>Get the value, as follows:</p>
<pre>oracle.sql.ARRAY array = ocs.getARRAY(1);
</pre></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1049179"></a>
<div id="JJDBC28609" class="sect1">
<h2 class="sect1">Using a Type Map to Map Array Elements</h2>
<p>If your <a id="sthref630"></a><a id="sthref631"></a>array contains Oracle objects, then you can use a type map to associate the objects in the array with the corresponding Java class. If you do not specify a type map, or if the type map does not contain an entry for a particular Oracle object, then each element is returned as an <code>oracle.jdbc.OracleStruct</code> object.</p>
<p>If you want the type map to determine the mapping between the Oracle objects in the array and their associated Java classes, then you must add an appropriate entry to the map.</p>
<p>The following example illustrates how you can use a type map to map the elements of an array to a custom Java object class. In this case, the array is a nested table. The example begins by defining an <code>EMPLOYEE</code> object that has a name attribute and employee number attribute. <code>EMPLOYEE_LIST</code> is a nested table type of <code>EMPLOYEE</code> objects. Then an <code>EMPLOYEE_TABLE</code> is created to store the names of departments within a corporation and the employees associated with each department. In the <code>EMPLOYEE_TABLE</code>, the employees are stored in the form of <code>EMPLOYEE_LIST</code> tables.</p>
<pre>stmt.execute(&#34;CREATE TYPE EMPLOYEE AS OBJECT
            (EmpName VARCHAR2(50),EmpNo INTEGER))&#34;);

stmt.execute(&#34;CREATE TYPE EMPLOYEE_LIST AS TABLE OF EMPLOYEE&#34;);

stmt.execute(&#34;CREATE TABLE EMPLOYEE_TABLE (DeptName VARCHAR2(20), 
     Employees EMPLOYEE_LIST) NESTED TABLE Employees STORE AS ntable1&#34;);

stmt.execute(&#34;INSERT INTO EMPLOYEE_TABLE VALUES (&#34;SALES&#34;, EMPLOYEE_LIST
            (EMPLOYEE(&#39;Susan Smith&#39;, 123), EMPLOYEE(&#39;Lee Brown&#39;, 124)))&#34;);
</pre>
<p>If you want to retrieve all the employees belonging to the <code>SALES</code> department into an array of instances of the custom object class <code>EmployeeObj</code>, then you must add an entry to the type map to specify mapping between the <code>EMPLOYEE</code> SQL type and the <code>EmployeeObj</code> custom object class.</p>
<p>To do this, first create your statement and result set objects, then select the <code>EMPLOYEE_LIST</code> associated with the <code>SALES</code> department into the result set. Cast the result set to <code>OracleResultSet</code> so you can use the <code>getARRAY</code> method to retrieve the <code>EMPLOYEE_LIST</code> into an <code>ARRAY</code> object (<code>employeeArray</code> in the following example).</p>
<p>The <code>EmployeeObj</code> custom object class in this example implements the <code>SQLData</code> interface.</p>
<pre>Statement s = conn.createStatement();
OracleResultSet rs = (OracleResultSet)s.executeQuery
       (&#34;SELECT Employees FROM employee_table WHERE DeptName = &#39;SALES&#39;&#34;);

// get the array object 
ARRAY employeeArray = ((OracleResultSet)rs).getARRAY(1);
</pre>
<p>Now that you have the <code>EMPLOYEE_LIST</code> object, get the existing type map and add an entry that maps the <code>EMPLOYEE</code> SQL type to the <code>EmployeeObj</code> Java type.</p>
<pre>// add type map entry to map SQL type 
// &#34;EMPLOYEE&#34; to Java type &#34;EmployeeObj&#34; 
Map map = conn.getTypeMap();
map.put(&#34;EMPLOYEE&#34;, Class.forName(&#34;EmployeeObj&#34;));
</pre>
<p>Next, retrieve the SQL <code>EMPLOYEE</code> objects from the <code>EMPLOYEE_LIST</code>. To do this, call the <code>getArray</code> method of the <code>employeeArray</code> array object. This method returns an array of objects. The <code>getArray</code> method returns the <code>EMPLOYEE</code> objects into the <code>employees</code> object array.</p>
<pre>// Retrieve array elements 
Object[] employees = (Object[]) employeeArray.getArray();
</pre>
<p>Finally, create a loop to assign each of the <code>EMPLOYEE</code> SQL objects to the <code>EmployeeObj</code> Java object <code>emp</code>.</p>
<pre>// Each array element is mapped to EmployeeObj object.
for (int i=0; i&lt;employees.length; i++)
{
   EmployeeObj emp = (EmployeeObj) employees[i];
   ...
}
</pre></div>
<!-- class="sect1" -->
<a id="i1057327"></a>
<div id="JJDBC28610" class="sect1">
<h2 class="sect1">Custom Collection Classes with JPublisher</h2>
<p>This chapter primarily describes the functionality of the <code>oracle.sql.ARRAY</code> class, but it is also possible to access Oracle collections through custom Java classes or, more specifically, custo<a id="sthref632"></a>m collection classes.</p>
<p>You can create custom collection classes yourself, but the most convenient way is to use the Oracle JPu<a id="sthref633"></a>blisher utility. Custom collection classes generated by JPublisher offer all the functionality described earlier in this chapter, as well as the following advantages:</p>
<ul>
<li>
<p>They are strongly typed. This can help you find coding errors during compilation that might not otherwise be discovered until run time.</p>
</li>
<li>
<p>They can be changeable, or mu<a id="sthref634"></a>table. Custom collection classes produced by JPublisher, unlike the <code>ARRAY</code> class, allow you to get and set individual elements using the <code>getElement</code> and <code>setElement</code> methods.</p>
</li>
</ul>
<p>A custom collection class must satisfy three requirements:</p>
<ul>
<li>
<p>It must implement the <code>oracle.jdbc.OracleData</code> interface. Note that the standard JDBC <code>SQLData</code> interface, which is an alternative for custom object classes, is not intended for custom collection classes.</p>
</li>
<li>
<p>It, or a companion class, must implement the <code>oracle.jdbc.OracleDataFactory</code> interface, for creating instances of the custom collection class.</p>
</li>
<li>
<p>It must have a means of storing the collection data. Typically it will directly or indirectly include an <code>oracle.sql.ARRAY</code> attribute for this purpose.</p>
</li>
</ul>
<p>A JPublisher-generated custom <a id="sthref635"></a>collection class implements <code>OracleData</code> and <code>OracleDataFactory</code> and indirectly includes an <code>oracle.sql.ARRAY</code> attribute. The custom collection class will have an <code>oracle.jpub.runtime.MutableArray</code> attribute. The <code>MutableArray</code> class has an <code>oracle.sql.ARRAY</code> attribute.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use JPublisher to create a custom collection class, you must use the <code>OracleData</code> implementation. This will be true if the JPublisher <code>-usertypes</code> mapping option is set to <code>oracle</code>, which is the default.
<p>You cannot use a <code>SQLData</code> implementation for a custom collection class. Setting the <code>-usertypes</code> mapping option to <code>jdbc</code> is invalid.</p>
</div>
<p>As an example of custom collection classes being strongly typed, if you define an Oracle collection <code>MYVARRAY</code>, then JPublisher can generate a <code>MyVarray</code> custom collection class. Using <code>MyVarray</code> instances, instead of generic <code>oracle.sql.ARRAY</code> instances, makes it easier to catch errors during compilation instead of at run time. For example, if you accidentally assign some other kind of array into a <code>MyVarray</code> variable.</p>
<p>If you do not use custom collection classes, then you would use standard <code>java.sql.Array</code> instances, or <code>oracle.sql.ARRAY</code> instances, to map to your collections.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oraoot.htm#i1078761">&#34;Using JPublisher to Create Custom Object Classes&#34;</a></p>
</li>
<li>
<p><a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2237">
<tr>
<td class="cellalignment2246">
<table class="cellalignment2242">
<tr>
<td class="cellalignment2241"><a href="oraoor.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2241"><a href="resltset.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2249">
<table class="cellalignment2240">
<tr>
<td class="cellalignment2241"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2241"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2241"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2241"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2241"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2241"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>