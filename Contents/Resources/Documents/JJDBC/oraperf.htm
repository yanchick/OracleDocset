<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71008"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Performance%20Extensions"></a><title>Performance Extensions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="description" content="This book describes how to use Oracle JDBC drivers to develop powerful Java database applications."/>
<meta name="dcterms.created" content="2014-06-30T1:22:37Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database JDBC Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49300-05"/>
<meta name="dcterms.isVersionOf" content="JJDBC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="stmtcach.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ociconpl.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49300-05.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">33/55</span> <!-- End Header -->
<div id="JJDBC28752" class="chapter"><a id="g1068570"></a>
<h1 class="chapter"><span class="secnum">21</span> Performance Extensions</h1>
<p><a id="sthref743"></a><a id="sthref744"></a>This chapter describes the Oracle performance extensions to the Java Database Connectivity (JDBC) standard.</p>
<p><a id="i1059063"></a>This chapter covers the following topics:</p>
<ul>
<li>
<p><a href="#i1056232">Update Batching</a></p>
</li>
<li>
<p><a href="#i1053736">Additional Oracle Performance Extensions</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), Oracle update batching is deprecated. Oracle recommends that you use standard JDBC batching instead of Oracle update batching.</div>
<a id="i1056232"></a>
<div id="JJDBC28753" class="sect1">
<h2 class="sect1">Update Batching</h2>
<p>You can reduce the number of round-trips to the database, thereby improving application performance, by grouping multiple <code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code> statements into a single batch and having the whole batch sent to the database and processed in one trip. This is referred to as &#39;update batching&#39;.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The JDBC 2.0 specification refers to &#39;update batching&#39; as &#39;batch updates&#39;.</div>
<p>This is especially useful with prepared statements, when you are repeating the same statement with different bind variables.</p>
<p>Oracle JDBC supports two distinct models for update batching:</p>
<ul>
<li>
<p>The standard model, implementing the JDBC 2.0 specification, which is referred to as standard update batching</p>
</li>
<li>
<p>The Oracle-specific model, independent of the JDBC 2.0 specification, which is referred to as Oracle update batching</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
It is important to be aware that you cannot mix these models. In any single application, you can use one model or the other, but not both. Oracle JDBC driver will throw exceptions when you mix these.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1059054">Overview of Update Batching Models</a></p>
</li>
<li>
<p><a href="#i1058859">Oracle Update Batching</a></p>
</li>
<li>
<p><a href="#i1059053">Standard Update Batching</a></p>
</li>
<li>
<p><a href="#CHDIJADJ">Premature Batch Flush</a></p>
</li>
</ul>
<a id="i1059054"></a>
<div id="JJDBC28754" class="sect2">
<h3 class="sect2">Overview of Update Batching Models</h3>
<p>This section compares and contrasts the general models and types of statements supported for standard update batching and Oracle update batching.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), Oracle update batching is deprecated. Oracle recommends that you use standard JDBC batching instead of Oracle update batching.</div>
<p class="subhead2"><a id="JJDBC28755"></a>Ora<a id="sthref745"></a>cle Model Versus Standard Model</p>
<p>Oracle update batching uses a batch value that typically results in implicit processing of a batch. The batch value is the number of operations you want to add to a batch for each trip to the database. As soon as that many operations have been added to the batch, the batch is processed. Note the following:</p>
<ul>
<li>
<p>You can set a default batch for the connection object, which applies to any prepared statement run in that connection.</p>
</li>
<li>
<p>For any individual prepared statement object, you can set a statement batch value that overrides the connection batch value.</p>
</li>
<li>
<p>You can choose to explicitly process a batch at any time, overriding both the connection batch value and the statement batch value.</p>
</li>
</ul>
<p>Standard update batching is a manual, explicit model. There is no batch value. You manually add operations to the batch, and then, explicitly choose when to process the batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Oracle recommends that you use JDBC standard features when possible. This recommendation applies to update batching as well. Oracle update batching is retained primarily for backwards compatibility.</p>
</li>
<li>
<p>For both standard update batching and Oracle update batching, Oracle recommends you to keep the batch sizes in the general range of 50 to 100. This is because though the drivers support larger batches, they in turn result in a large memory footprint with no corresponding increase in performance. Very large batches usually result in a decline in performance compared to smaller batches.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JJDBC28756"></a>Types of Sta<a id="sthref746"></a>tements Supported</p>
<p>As implemented by Oracle, update batching is intended for use with prepared statements, when you are repeating the same statement with different bind variables. Be aware of the following:</p>
<ul>
<li>
<p>Oracle update batching supports <span class="italic">only</span> prepared statement objects. For a callable statement, both the connection default batch value and the statement batch value are overridden with a value of 1. In an Oracle generic statement, there is no statement batch value, and the connection default batch value is overridden with a value of 1.</p>
</li>
<li>
<p>To adhere to the JDBC 2.0 standard, Oracle implementation of standard update batching supports callable statements, without <code>OUT</code> parameters, and generic statements, as well as prepared statements. You can migrate standard update batching into an Oracle JDBC application without difficulty.</p>
</li>
<li>
<p>You can batch only <code>UPDATE</code>, <code>INSERT</code>, or <code>DELETE</code> operations. Processing a batch that includes an operation that attempts to return a result set will cause an exception.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle implementation of standard update batching does not implement true batching for generic statements and callable statements. Although Oracle JDBC supports the use of standard batching syntax for <code>Statement</code> and <code>CallableStatement</code> objects, you will see performance improvement for only <code>PreparedStatement</code> objects.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1058859"></a>
<div id="JJDBC28757" class="sect2">
<h3 class="sect2">Oracle Update Bat<a id="sthref747"></a>ching</h3>
<p>The Oracle update batching feature associates a batch value with each prepared statement object. With Oracle update batching, instead of the JDBC driver running a prepared statement operation each time the <code>executeUpdate</code> method is called, the driver adds the statement to a batch of accumulated processing requests. The driver will pass all the operations to the database for processing once the batch value is reached. For example, if the batch value is 10, then each batch of 10 operations will be sent to the database and processed in one trip.</p>
<p>A method in the <code>OracleConnection</code> class enables you to set a default batch value for the Oracle conn<a id="sthref748"></a><a id="sthref749"></a>ection as a whole, and this batch value applies to any Oracle prepared statement in the connection. For any particular Oracle prepared statement, a method in the <code>OraclePreparedStatement</code> class enables you to set a statement batch value that overrides the connection batch value. You can also override both batch values by choosing to manually process the pending batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not mix standard update batching with Oracle update batching in the same application. The JDBC driver will throw an exception when you mix these.</p>
</li>
<li>
<p>Disable auto-com<a id="sthref750"></a>mit mode if you use update batching model. In case an error occurs while you are processing a batch, this provides you the option of committing or rolling back the operations that ran successfully prior to the error.</p>
</li>
</ul>
</div>
<div id="JJDBC28758" class="sect3"><a id="sthref751"></a>
<h4 class="sect3">Oracle Update Batching Characteristics and Limitations<a id="sthref752"></a></h4>
<p>Note the following limitations and implementation details regarding Oracle update batching:</p>
<ul>
<li>
<p>By defa<a id="sthref753"></a><a id="sthref754"></a>ult, there is no statement batch value and the connection batch value is 1.</p>
</li>
<li>
<p>Batch values between 5 and 30 tend to be the most effective. Setting a very high value might even have a negative effect. It is worth trying different values to verify the effectiveness for your particular application.</p>
</li>
<li>
<p>Regardless of the batch value in effect, if any of the bind variables of an Oracle prepared statement is of a data type which requires data to be streamed, for instance LOB, CLOB, then Oracle JDBC driver sets the batch value to 1 and sends any queued requests to the database for processing.</p>
</li>
<li>
<p>Oracle JDBC driver implicitly runs the <code>sendBatch</code> method of an Oracle prepared statement in any of the following circumstances:</p>
<ul>
<li>
<p>The connection receives a <code>COMMIT</code> request as a result of calling the <code>commit</code> method.</p>
</li>
<li>
<p>The statement receives a <code>close</code> request.</p>
</li>
<li>
<p>The connection receives a <code>close</code> request.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
A connection <code>COMMIT</code> request, statement <code>close</code>, or connection <code>close</code> has an effect on a pending batch only if you use Oracle update batching. However, if you use standard update batching, then it has no effect on a pending batch.</div>
</li>
<li>
<p>If the connection receives a <code>ROLLBACK</code> request before <code>sendBatch</code> has been called, then the pending batched operations are not removed. You must explicitly call <code>clearBatch</code> to do this.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="JJDBC28759" class="sect3"><a id="sthref755"></a>
<h4 class="sect3">Setting the Connection Batch Value<a id="sthref756"></a><a id="sthref757"></a></h4>
<p>You can specify a default batch value for any Oracle prepared statement in your Oracle connection. To do this, use the <code>setDefaultExecuteBatch</code> method of the <code>OracleConnection</code> object. For example, the following code sets the default batch value to 20 for all prepared statement objects associated with the <code>conn</code> connection object:</p>
<pre>((OracleConnection)conn).set<a id="sthref758"></a>DefaultExecuteBatch(20);
</pre>
<p>The connection batch value will apply to statement objects created after this batch value was set.</p>
<p>Note that instead of calling the <code>setDefaultExecuteBatch</code> method, you can set the <code>defaultBatchValue</code> Java property if you use a Java <code>Properties</code> object in establishing the connection.</p>
</div>
<!-- class="sect3" -->
<div id="JJDBC28760" class="sect3"><a id="sthref759"></a>
<h4 class="sect3">Setting the Statement Batch Value<a id="sthref760"></a><a id="sthref761"></a></h4>
<p>Use the following steps to set the statement batch value for a particular Oracle prepared statement. This will override any connection batch value set using the <code>setDefaultExecuteBatch</code> method of the <code>OracleConnection</code> instance for the connection in which the statement is processed.</p>
<ol>
<li>
<p>Write your prepared statement, and specify input values for the first row, as follows:</p>
<pre>PreparedStatement ps = conn.prepareStatement(&#34;INSERT INTO dept VALUES (?,?,?)&#34;);
ps.setInt(1,12);
ps.setString(2,&#34;Oracle&#34;);
ps.setString(3,&#34;USA&#34;);
</pre></li>
<li>
<p>Cast your prepared statement to <code>OraclePreparedStatement</code>, and apply the <code>setExecuteBatch</code> method. In this example, the batch size of the statement is set to 2.</p>
<pre>((OraclePreparedStatement)ps).setExec<a id="sthref762"></a>uteBatch(2);
</pre>
<p>If you wish, insert the <code><a id="sthref763"></a>getExecuteBatch</code> method at any point in the program to check the default batch value for the statement, as follows:</p>
<pre>System.out.println(&#34; Statement Execute Batch Value &#34; +
                   ((OraclePreparedStatement)ps).getExecuteBatch());
</pre></li>
<li>
<p>If you send an execute-update call to the database at this point, then no data will be sent to the database, and the call will return 0.</p>
<pre>// No data is sent to the database by this call to executeUpdate
System.out.println(&#34;Number of rows inserted so far: &#34; + ps.executeUpdate ());
</pre></li>
<li>
<p>If you enter a set of input values for a second row and an execute-update, then the number of batch calls to <code>executeUpdate</code> will be equal to the batch value of 2. The data will be sent to the database, and both rows will be inserted in a single round-trip. Since this executeUpdate call is at the batch value boundary, and all the operations in the batch are executed on the server, it will return the total number of affected rows by the whole batch.</p>
<pre>ps.setInt(1, 11);
ps.setString(2, &#34;Applications&#34;);
ps.setString(3, &#34;Indonesia&#34;);

int rows = ps.executeUpdate();
System.out.println(&#34;Number of rows inserted now: &#34; + rows);

ps.close();
</pre></li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
The batch value counter will reset internally if the data type for a column changes in between the batch. The total value of affected rows by the whole batch of previously batched items before the data type change, and the newly batched items will be returned at the new batch value boundary. For instance:
<p>If the batch value is 8 after binding 4 integers to a <code>varchar2</code> column, a string is bound to the column. This will trigger an internal bind value counter reset, and if the application continues to bind strings, then the batch will be executed on the 12th <code>executeUpdate</code> call, and will return the affected row count of all 12 operations.</p>
</div>
</div>
<!-- class="sect3" -->
<div id="JJDBC28761" class="sect3"><a id="sthref764"></a>
<h4 class="sect3">Checking the Batch Value<a id="sthref765"></a><a id="sthref766"></a></h4>
<p>To check the overall connection batch value of an Oracle connection instance, use the <code>OracleConnection</code> class <code>getDefaultExecuteBatch</code> method:</p>
<pre>Integer batch_val = ((OracleConnection)conn).get<a id="sthref767"></a>DefaultExecuteBatch();
</pre>
<p>To check the particular statement batch value of an Oracle prepared statement, use the <code>OraclePreparedStatement</code> class <code>getExecuteBatch</code> method:</p>
<pre>Integer batch_val = ((OraclePreparedStatement)ps).get<a id="sthref768"></a>ExecuteBatch();
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If no statement batch value has been set, then <code>getExecuteBatch</code> will return the connection batch value.</div>
</div>
<!-- class="sect3" -->
<div id="JJDBC28762" class="sect3"><a id="sthref769"></a>
<h4 class="sect3">Overriding the Batch Value <a id="sthref770"></a><a id="sthref771"></a></h4>
<p>If you want to process accumulated operations before the batch value in effect is reached, then use the <code><a id="sthref772"></a>sendBatch</code> method of the <code>OraclePreparedStatement</code> object.</p>
<p>For this example, presume you set the connection batch value to 20. This sets the default batch value for all prepared statement objects associated with the connection to 20. You can accomplish this by casting your connection to <code>OracleConnection</code> and applying the <code>setDefaultExecuteBatch</code> method for the connection, as follows:</p>
<pre>((OracleConnection)conn).setDefaultExecuteBatch (20);
</pre>
<p>Override the batch value as follows:</p>
<ol>
<li>
<p>Write your prepared statement, specify input values for the first row, and then process the statement, as follows:</p>
<pre>PreparedStatement ps =
   conn.prepareStatement(&#34;insert into dept values (?, ?, ?)&#34;);
    
ps.setInt(1, 32);
ps.setString(2, &#34;Oracle&#34;);
ps.setString(3, &#34;USA&#34;);

System.out.println (ps.executeUpdate ()); 
</pre>
<p>The batch is not processed at this point. The <code>ps.executeUpdate</code> method returns <code>0</code>.</p>
</li>
<li>
<p>If you enter a set of input values for a second operation and call <code>executeUpdate</code> again, then the data will still not be sent to the database, because the batch value in effect for the statement is the connection batch value, which is <code>20</code>.</p>
<pre>ps.setInt(1, 33);
ps.setString(2, &#34;Applications&#34;);
ps.setString(3, &#34;Indonesia&#34;);

// this batch is still not executed at this point
int rows = ps.executeUpdate();
    
System.out.println(&#34;Number of rows updated before calling sendBatch: &#34;  + rows);
</pre>
<p>Note that the value of <code>rows</code> in the <code>println</code> statement is <code>0</code>.</p>
</li>
<li>
<p>If you apply the <code>sendBatch</code> method at this point, then the two previously batched operations will be sent to the database in a single round-trip. The <code>sendBatch</code> method also returns the total number of updated rows. This property of <code>sendBatch</code> is used by <code>println</code> to print the number of updated rows.</p>
<pre>// Execution of both previously batched executes will happen
// at this point. The number of rows updated will be
// returned by sendBatch.
rows = ((OraclePreparedStatement)ps).sendBatch();

System.out.println(&#34;Number of rows updated by calling sendBatch: &#34; + rows);
ps.close();
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<div id="JJDBC28763" class="sect3"><a id="sthref773"></a>
<h4 class="sect3">Committing the Changes in Oracle Batching<a id="sthref774"></a></h4>
<p>After you process the batch, you must still commit the changes, presuming auto-commit is disabled as recommended.</p>
<p>Calling the <code>commit</code> method on the connection object in Oracle batching not only commits operations in batches that have been processed, but also issues an implicit <code>sendBatch</code> call to process all pending batches. So, the <code>commit</code> method effectively commits changes for all operations that have been added to a batch.</p>
</div>
<!-- class="sect3" -->
<div id="JJDBC28764" class="sect3"><a id="sthref775"></a>
<h4 class="sect3">Update Counts in Oracle Batching<a id="sthref776"></a><a id="sthref777"></a></h4>
<p>In a nonbatching situation, the <code>executeUpdate</code> method of an <code>OraclePreparedStatement</code> object returns the number of database rows affected by the operation.</p>
<p>In an Oracle batching situation, this method returns the number of rows affected at the time the method is invoked, as follows:</p>
<ul>
<li>
<p>If an <code><a id="sthref778"></a>executeUpdate</code> call results in the operation being added to the batch, then the method returns a value of 0, because nothing was written to the database yet.</p>
</li>
<li>
<p>If an <code>executeUpdate</code> call results in the batch value being reached and the batch being processed, then the method returns the total number of rows affected by all operations in the batch.</p>
</li>
</ul>
<p>Similarly, the <code>send<a id="sthref779"></a>Batch</code> method of an <code>OraclePreparedStatement</code> object returns the total number of rows affected by all operations in the batch.</p>
<p><a href="#CHDCCEHD">Example 21-1</a> illustrates the use of Oracle update batching.</p>
<div id="JJDBC28765" class="example">
<p class="titleinexample"><a id="CHDCCEHD"></a>Example 21-1 Oracle Update Batching<a id="sthref780"></a></p>
<p>The following example illustrates how you use the Oracle update batching feature. It assumes you have imported the <code>oracle.driver.*</code> interfaces.</p>
<pre>...
OracleDataSource ods = new OracleDataSource();
ods.setURL(&#34;jdbc:oracle:oci);
ods.setUser(&#34;HR&#34;);
ods.setPassword(&#34;hr&#34;);

Connection conn = ods.getConnection();
conn.setAutoCommit(false);

PreparedStatement ps = 
  conn.prepareStatement(&#34;insert into dept values (?, ?, ?)&#34;); 
     
//Change batch size for this statement to 3 
((OraclePreparedStatement)ps).setExecuteBatch (3);
 
ps.setInt(1, 23); 
ps.setString(2, &#34;Sales&#34;); 
ps.setString(3, &#34;USA&#34;); 
ps.executeUpdate(); //JDBC queues this for later execution 
 
ps.setInt(1, 24); 
ps.setString(2, &#34;Blue Sky&#34;); 
ps.setString(3, &#34;Montana&#34;); 
ps.executeUpdate(); //JDBC queues this for later execution 
 
ps.setInt(1, 25); 
ps.setString(2, &#34;Applications&#34;); 
ps.setString(3, &#34;India&#34;); 
ps.executeUpdate(); //The queue size equals the batch value of 3 
                    //JDBC sends the requests to the database

ps.setInt(1, 26); 
ps.setString(2, &#34;HR&#34;); 
ps.setString(3, &#34;Mongolia&#34;); 
ps.executeUpdate(); //JDBC queues this for later execution
 
((OraclePreparedStatement)ps).sendBatch(); // JDBC sends the queued request
conn.commit();

ps.close();
...
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Updates deferred through batching can affect the results of other queries. In the following example, if the first query is deferred due to batching, then the second will return unexpected results:
<pre>UPDATE emp SET name = &#34;Sue&#34; WHERE name = &#34;Bob&#34;;
SELECT name FROM emp WHERE name = &#34;Sue&#34;;
</pre></div>
</div>
<!-- class="sect3" -->
<div id="JJDBC28766" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref781"></a>
<h4 class="sect3">Error Reporting in Oracle Update Batching</h4>
<p>If any one of the batched operations fails to complete successfully or attempts to return a result set during an <code>executeBatch</code> call, then the processing stops and a <code>java.sql.BatchUpdateException</code> is generated.</p>
<p>If the exception is raised, you can call the <code>getUpdateCounts</code> method on the <code>BatchUpdateException</code> object to retrieve the update count. This method returns an <code>int</code> array of update counts, just as the <code>executeBatch</code> method does.</p>
<p>Prior to Oracle Database 11g Release 1, the integer array returned contains <span class="italic">n</span> <code>Statement.EXECUTE_FAILED</code> entries, where <span class="italic">n</span> is the size of the batch. However, this does not indicate where in the batch the error occurred. The only option you have is to rollback the transaction.</p>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 1, the integer array returned contains <span class="italic">n</span> <code>Statement.SUCCESS_NO_INFO</code> entries, where <span class="italic">n</span> is the number of elements in the batch that have been successfully executed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The execution of the batch always stops with the first element of the batch that generates an error.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1059053"></a>
<div id="JJDBC28767" class="sect2">
<h3 class="sect2">Stand<a id="sthref782"></a>ard Update Batching</h3>
<p>JDBC standard update batching, unlike the Oracle update batching model, depends on explicitly adding statements to the batch using an <code>addBatch</code> method and explicitly processing the batch using an <code>executeBatch</code> method. In the Oracle model, you call <code>executeUpdate</code> as in a nonbatching situation, but whether an operation is added to the batch or the whole batch is processed is typically determined implicitly, depending on whether or not a predetermined batch value is reached.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not mix standard update batching with Oracle update batching in the same application. Oracle JDBC driver will throw exceptions when these are mixed.</p>
</li>
<li>
<p>Disable auto-commit mode if you use either update batching model. In case an error occurs while you are processing a batch, this provides you the option of committing or rolling back the operations that ran successfully prior to the error.</p>
</li>
</ul>
</div>
<div id="JJDBC28768" class="sect3"><a id="sthref783"></a>
<h4 class="sect3">Limitations in the Oracle Implementation of Standard Batching</h4>
<p>This section discusses the limitations and implementation details regarding the Oracle implementation of standard update batching.</p>
<p>In Oracle JDBC applications, update batching is intended for use with prepared statements that are being processed repeatedly with different sets of bind values.</p>
<p>The Oracle implementation of standard update batching does not implement true batching for generic statements and callable statements. Even though Oracle JDBC supports the use of standard batching for <code>Statement</code> and <code>CallableStatement</code> objects, you are unlikely to see performance improvement.</p>
</div>
<!-- class="sect3" -->
<div id="JJDBC28769" class="sect3"><a id="sthref784"></a>
<h4 class="sect3">Adding Operations to the Batch<a id="sthref785"></a></h4>
<p>When any statement object is first created, its statement batch is empty. Use the standard <code>ad<a id="sthref786"></a>dBatch</code> method to add an operation to the statement batch. This method is specified in the standard <code>java.sql.Statement</code>, <code>PreparedStatement</code>, and <code>CallableStatement</code> interfaces, which are implemented by the <code>oracle.jdbc.OracleStatement</code>, <code>OraclePreparedStatement</code>, and <code>OracleCallableStatement</code> interfaces, respectively.</p>
<p>For a <code>Statement</code> object, the <code>addBatch</code> method takes a Java <code>String</code> with a SQL operation as input. For example:</p>
<pre>...
Statement stmt = conn.createStatement();

stmt.addBatch(&#34;INSERT INTO emp VALUES(1000, &#39;Joe Jones&#39;)&#34;);
stmt.addBatch(&#34;INSERT INTO dept VALUES(260, &#39;Sales&#39;)&#34;);
stmt.addBatch(&#34;INSERT INTO emp_dept VALUES(1000, 260)&#34;);
...
</pre>
<p>At this point, three operations are in the batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Remember, however, that in the Oracle implementation of standard update batching, you will probably see no performance improvement in batching generic statements.</div>
<p>For prepared statements, update batching is used to batch multiple runs of the same statement with different sets of bind parameters. For a <code>PreparedStatement</code> or <code>OraclePreparedStatement</code> object, the <code>addBatch</code> method takes no input. It simply adds the operation to the batch using the bind parameters last set by the appropriate <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods. This is also true for <code>CallableStatement</code> or <code>OracleCallableStatement</code> objects, but remember that in the Oracle implementation of standard update batching, you will probably see no performance improvement in batching callable statements.</p>
<p>For example:</p>
<pre>...
PreparedStatement pstmt = 
          conn.prepareStatement(&#34;INSERT INTO employees VALUES(?, ?)&#34;);

pstmt.setInt(1, 2000);
pstmt.setString(2, &#34;Milo Mumford&#34;);
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, &#34;Sulu Simpson&#34;);
pstmt.addBatch();
...
</pre>
<p>At this point, two operations are in the batch.</p>
<p>Because a batch is associated with a single prepared statement object, you can batch only repeated runs of a single prepared statement, as in this example.</p>
</div>
<!-- class="sect3" -->
<div id="JJDBC28770" class="sect3"><a id="sthref787"></a>
<h4 class="sect3">Processing the Batch<a id="sthref788"></a></h4>
<p>To process the current batch of operations, use the <code>exec<a id="sthref789"></a>uteBatch</code> method of the statement object. This method is specified in the standard <code>Statement</code> interface, which is extended by the standard <code>PreparedStatement</code> and <code>CallableStatement</code> interfaces.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you add too many operations to a batch by calling the <code>addBatch</code> method several times and create a very large batch (for example, with more than or equal to 100,000 rows), then while calling the <code>executeBatch</code> method on the whole batch, you may face severe performance problems in terms of memory. To avoid this issue, the JDBC driver transparently breaks up the large batches into smaller internal batches and makes a roundtrip to the server for each internal batch. This makes your application slightly slower because of each round-trip overhead, but optimizes memory significantly. However, if each bound row is very large in size (for example, more than about 1MB each or so), then this process can impact the overall performance negatively because in such a case, the performance gained in terms of memory will be less than the performance lost in terms of time.</div>
<p>Following is an example that repeats the prepared statement <code>addBatch</code> calls shown previously and then processes the batch:</p>
<pre>...
PreparedStatement pstmt = 
          conn.prepareStatement(&#34;INSERT INTO employees VALUES(?, ?)&#34;);

pstmt.setInt(1, 2000);
pstmt.setString(2, &#34;Milo Mumford&#34;);
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, &#34;Sulu Simpson&#34;);
pstmt.addBatch();

int[] updateCounts = pstmt.executeBatch();
...
</pre></div>
<!-- class="sect3" -->
<a id="CHDCDBCH"></a>
<div id="JJDBC29182" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Row Count per Iteration for Array DMLs</h4>
<p>Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>executeBatch</code> method has been improved so that it returns an int array of size that is the same as the number of records in the batch and each item in the return array is the number of database table rows affected by the corresponding record of the batch. For example, if the batch size is 5, then the <code>executeBatch</code> method returns an array of size 5. In case of an error in between execution of the batch, the <code>executeBatch</code> method cannot return a value, instead it throws a <code>BatchUpdateException</code>. In this case, the exception itself carries an int array of size <code>n</code> as its data, where <code>n</code> is the number of successful record executions. For example, if the batch is of size 5 and the error occurs at the 4th record, then the <code>BatchUpdateException</code> has an array of size 3 (3 records executed successfully) and each item in the array represents how many rows were affected by each of them.</p>
</div>
<!-- class="sect3" -->
<div id="JJDBC28771" class="sect3"><a id="sthref790"></a>
<h4 class="sect3">Com<a id="sthref791"></a>mitting the Changes in the Oracle Implementation of Standard Batching</h4>
<p>After you process the batch, you must still commit the changes, presuming auto-commit is disabled as recommended.</p>
<p>Calling <code>commit</code>, commits nonbatched operations and batched operations for statement batches that have been processed, but for the Oracle implementation of standard batching, has no effect on pending statement batches that have <span class="italic">not</span> been processed.</p>
</div>
<!-- class="sect3" -->
<div id="JJDBC28772" class="sect3"><a id="sthref792"></a>
<h4 class="sect3">Clearing the Batch<a id="sthref793"></a></h4>
<p>To clear the current batch of operations instead of processing it, use the <code>cle<a id="sthref794"></a>arBatch</code> method of the statement object. This method is specified in the standard <code>Statement</code> interface, which is extended by the standard <code>PreparedStatement</code> and <code>CallableStatement</code> interfaces.</p>
<p>Keep the following things in mind:</p>
<ul>
<li>
<p>When a batch is processed, operations are performed in the order in which they were batched.</p>
</li>
<li>
<p>After calling <code>addBatch</code>, you must call either <code>executeBatch</code> or <code>clearBatch</code> before a call to <code>executeUpdate</code>, otherwise there will be a SQL exception.</p>
</li>
<li>
<p>A <code>clearBatch</code> or <code>executeBatch</code> call resets the statement batch to empty.</p>
</li>
<li>
<p>The statement batch is not reset to empty if the connection receives a <code>ROLLBACK</code> request. You must explicitly call <code>clearBatch</code> to reset it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Oracle recommends not to use the <code>clearBatch</code> method with Oracle update batching. With Oracle update batching, binds can be implicitly flushed to the server at any point of time due to various conditions. This makes the behavior of the <code>clearBatch</code> method vary with each case and unpredictable at run time because the method cannot clear any bound data that is already flushed to the server. However, it is OK to use the <code>clearBatch</code> method after a rollback to clear any traces.</p>
<p>Also, the <code>clearBatch</code> method displays this unpredictable behavior with only Oracle update batching and works correctly with standard update batching.</p>
</li>
<li>
<p>If you are using Oracle update batching in Oracle Database 12<span class="italic">c</span> Release 1 (12.1), then you do not have to clear your batches explicitly in the code after a rollback. However, if you are using Oracle update batching in an earlier release, then you have to invoke the <code>clearBatch</code> method to clear your batches explicitly after a rollback.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Invoking <code>clearBatch</code> method after a rollback works for all releases.</p>
</li>
<li>
<p>An <code>executeBatch</code> call closes the current result set of the statement object, if one exists.</p>
</li>
<li>
<p>Nothing is returned by the <code>clearBatch</code> method.</p>
</li>
</ul>
<p>Following is an example that repeats the prepared statement <code>addBatch</code> calls shown previously but then clears the batch under certain circumstances:</p>
<pre>...
PreparedStatement pstmt = 
          conn.prepareStatement(&#34;INSERT INTO employees VALUES(?, ?)&#34;);

pstmt.setInt(1, 2000);
pstmt.setString(2, &#34;Milo Mumford&#34;);
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, &#34;Sulu Simpson&#34;);
pstmt.addBatch();

if (...<span class="italic">condition</span>...)
{
   int[] updateCounts = pstmt.executeBatch();
   ...
}
else
{
   pstmt.clearBatch();
   ...
}
</pre></div>
<!-- class="sect3" -->
<a id="i1057545"></a>
<div id="JJDBC28773" class="sect3">
<h4 class="sect3">Update Counts in the Oracle Implementation of Standard Batching<a id="sthref795"></a><a id="sthref796"></a></h4>
<p>If a statement batch is processed successfully, then the integer array, or update counts array, returned by the statement <code>executeBatch</code> call will always have one element for each operation in the batch. In the Oracle implementation of standard update batching, the values of the array elements are as follows:</p>
<ul>
<li>
<p>For a prepared statement batch, the array contains the actual update counts indicating the number of rows affected by each operation.</p>
</li>
<li>
<p>For a generic statement batch, the array contains the actual update counts indicating the number of rows affected by each operation. The actual update counts can be provided only in the case of generic statements in the Oracle implementation of standard batching.</p>
</li>
<li>
<p>For a callable statement batch, the array contains the actual update counts indicating the number of rows affected by each operation.</p>
</li>
</ul>
<p>In your code, upon successful processing of a batch, you should be prepared to handle either <code>-2</code>, <code>1</code>, or true update counts in the array elements. For a successful batch processing, the array contains either all <code>-2</code>, <code>1</code>, or all positive integers.</p>
<p><a href="#CHDCBHEC">Example 21-2</a> illustrates the use of standard update batching.</p>
<div id="JJDBC28774" class="example">
<p class="titleinexample"><a id="CHDCBHEC"></a>Example 21-2 Stan<a id="sthref797"></a>dard Update Batching</p>
<p>This example combines the sample fragments in the previous sections, accomplishing the following steps:</p>
<ol>
<li>
<p>Disabling auto-commit mode, which you should always do when using either update batching model</p>
</li>
<li>
<p>Creating a prepared statement object</p>
</li>
<li>
<p>Adding operations to the batch associated with the prepared statement object</p>
</li>
<li>
<p>Processing the batch</p>
</li>
<li>
<p>Committing the operations from the batch</p>
</li>
</ol>
<pre>conn.setAutoCommit(false);

PreparedStatement pstmt = 
          conn.prepareStatement(&#34;INSERT INTO employees VALUES(?, ?)&#34;);

pstmt.setInt(1, 2000);
pstmt.setString(2, &#34;Milo Mumford&#34;);
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, &#34;Sulu Simpson&#34;);
pstmt.addBatch();

int[] updateCounts = pstmt.executeBatch();

conn.commit();

pstmt.close();
...
</pre>
<p>You can process the update counts array to determine if the batch processed successfully.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i1059009"></a>
<div id="JJDBC28775" class="sect3">
<h4 class="sect3">Error Handling in the Oracle Implementation of Standard Batching<a id="sthref798"></a></h4>
<p>If any one of the batched operations fails to complete successfully or attempts to return a result set during an <code>executeBatch</code> call, then the processing stops and a <code>java.sql.Batch<a id="sthref799"></a>UpdateException</code> is generated.</p>
<p>After a batch exception, the update counts array can be retrieved using the <code>get<a id="sthref800"></a>UpdateCounts</code> method of the <code>BatchUpdateException</code> object. This returns an <code>int</code> array of update counts, just as the <code>executeBatch</code> method does. In the Oracle implementation of standard update batching, contents of the update counts array are as follows, after a batch is processed:</p>
<ul>
<li>
<p>For a pr<a id="sthref801"></a><a id="sthref802"></a>epared statement batch, in case of an error in between execution of the batch, the <code>executeBatch</code> method cannot return a value, instead it throws a <code>BatchUpdateException</code>. In this case, the exception itself carries an int array of size <code>n</code> as its data, where <code>n</code> is the number of successful record executions. For example, if the batch is of size 5 and the error occurs at the 4th record, then the <code>BatchUpdateException</code> has an array of size 3 (3 records executed successfully) and each item in the array represents how many rows were affected by each of them.</p>
</li>
<li>
<p>For a generic statement batch or callable statement batch, the update counts array is only a partial array containing the actual update counts up to the point of the error. The actual update counts can be provided because Oracle JDBC cannot use true batching for generic and callable statements in the Oracle implementation of standard update batching.</p>
<p>For example, if there were 20 operations in the batch, the first 13 succeeded, and the 14th generated an exception, then the update counts array will have 13 elements, containing actual update counts of the successful operations.</p>
<p>You can either commit or roll back the successful operations in this situation, as you prefer.</p>
</li>
</ul>
<p>In your code, upon failed processing of a batch, you should be prepared to handle either <code>-3</code> or true update counts in the array elements when an exception occurs. For a failed batch processing, you will have either a full array of <code>-3</code> or a partial array of positive integers.</p>
</div>
<!-- class="sect3" -->
<div id="JJDBC28776" class="sect3"><a id="sthref803"></a>
<h4 class="sect3">Intermixing Batched Statements and Nonbatched Statements<a id="sthref804"></a></h4>
<p>You cannot call <code>executeUpdate</code> for regular, nonbatched processing of an operation if the statement object has a pending batch of operations.</p>
<p>However, you can intermix batched operations and nonbatched operations in a single statement object if you process nonbatched operations either prior to adding any operations to the statement batch or after processing the batch. Essentially, you can call <code>executeUpdate</code> for a statement object only when its update batch is empty. If the batch is non-empty, then an exception will be generated.</p>
<p>For example, it is valid to have a sequence, such as the following:</p>
<pre>...
PreparedStatement pstmt = 
          conn.prepareStatement(&#34;INSERT INTO employees VALUES(?, ?)&#34;);

pstmt.setInt(1, 2000);
pstmt.setString(2, &#34;Milo Mumford&#34;);

int scount = pstmt.executeUpdate();   // OK; no operations in pstmt batch

pstmt.setInt(1, 3000);
pstmt.setString(2, &#34;Sulu Simpson&#34;);
pstmt.addBatch();                    // Now start a batch

pstmt.setInt(1, 4000);
pstmt.setString(2, &#34;Stan Leland&#34;);
pstmt.addBatch();

int[] bcounts = pstmt.executeBatch();

pstmt.setInt(1, 5000);
pstmt.setString(2, &#34;Amy Feiner&#34;);

int scount = pstmt.executeUpdate();   // OK; pstmt batch was executed
...
</pre>
<p>Intermixing nonbatched operations on one statement object and batched operations on another statement object within your code is permissible. Different statement objects are independent of each other with regard to update batching operations. A <code>COMMIT</code> request will affect all nonbatched operations and all successful operations in processed batches, but will not affect any pending batches.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDIJADJ"></a>
<div id="JJDBC28777" class="sect2">
<h3 class="sect2">Premature Batch Flush</h3>
<p>Premature batch flush happens due to a change in cached metadata. Cached metadata can be changed due to various reasons, such as the following:</p>
<ul>
<li>
<p>The initial bind was null and the following bind is not null.</p>
</li>
<li>
<p>A scalar type is initially bound as string and then bound as scalar type or the reverse.</p>
</li>
</ul>
<p>The premature batch flush count is summed to the return value of the next <code>executeUpdate</code> or <code>sendBatch</code> method.</p>
<p>The old functionality lost all these batch flush values which can be obtained now. To switch back to the old functionality, you can set the <code>AccumulateBatchResult</code> property to <code>false</code>, as follows:</p>
<pre>java.util.Properties info = new java.util.Properties(); 
info.setProperty(&#34;user&#34;, &#34;HR&#34;); 
info.setProperty(&#34;passwd&#34;, &#34;hr&#34;); 
// other properties 
... 

// property: batch flush type 
info.setProperty(&#34;AccumulateBatchResult&#34;, &#34;false&#34;);

OracleDataSource ods = new OracleDataSource();
ods.setConnectionProperties(info);
ods.setURL(&#34;jdbc:oracle:oci:@&#34;&#34;);
Connection conn = ods.getConnection(); 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>AccumulateBatchResult</code> property is set to <code>true</code> by default.</div>
<p><a href="#CHDIJICJ">Example 21-3</a> illustrates premature batch flushing.</p>
<div id="JJDBC28778" class="example">
<p class="titleinexample"><a id="CHDIJICJ"></a>Example 21-3 Premature Batch Flushing</p>
<pre>((OraclePreparedStatement)pstmt).setExecuteBatch (2); 

pstmt.setNull(1, OracleTypes.NUMBER); 
pstmt.setString(2, &#34;test11&#34;); 
int count = pstmt.executeUpdate(); // returns 0 

/* 
* Premature batch flush happens here. 
*/ 
pstmt.setInt(1, 22);
pstmt.setString(2, &#34;test22&#34;); 
int count = pstmt.executeUpdate(); // returns 0 

pstmt.setInt(1, 33);
pstmt.setString(2, &#34;test33&#34;);
/* 
*  returns 3 with the new batching scheme where as, 
*  returns 2 with the old batching scheme. 
*/ 
int count = pstmt.executeUpdate();
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1053736"></a>
<div id="JJDBC28779" class="sect1">
<h2 class="sect1">Additional Oracle Performance Extensions</h2>
<p>In addition to update batching, Oracle JDBC drivers support the following extensions that improve performance by reducing round-trips to the database:</p>
<ul>
<li>
<p><a id="sthref805"></a>Prefetching rows</p>
<p>This reduces round-trips to the database by fetching multiple rows of data each time data is fetched. The extra data is stored in client-side buffers for later access by the client. The number of rows to prefetch can be set as desired.</p>
</li>
<li>
<p>Specifying <a id="sthref806"></a>column types</p>
<p>This avoids an inefficiency in the standard JDBC protocol for performing and returning the results of queries.</p>
</li>
<li>
<p>Suppressing database metadata <code><a id="sthref807"></a>TABLE_REMARKS</code> columns</p>
<p>This avoids an expensive outer join operation.</p>
</li>
</ul>
<p>Oracle provides several extensions to connection properties objects to support these performance extensions. These extensions enable you to set the <code><a id="sthref808"></a>remarksReporting</code> flag and default values for row prefetching and update batching.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CACGEEIB">Prefetching LOB Data</a></p>
</li>
<li>
<p><a href="#CHDHDADD">Oracle Row-Prefetching Limitations</a></p>
</li>
<li>
<p><a href="#i1059055">Defining Column Types</a></p>
</li>
<li>
<p><a href="#i1023518">Reporting DatabaseMetaData TABLE_REMARKS</a></p>
</li>
</ul>
<a id="CACGEEIB"></a>
<div id="JJDBC23210" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Prefetching LOB Data</h3>
<p>For the JDBC drivers prior to Oracle Database 11<span class="italic">g</span> Release 2 JDBC drivers, if you want to retrieve <code>LOB</code> data in one round trip, then you have to fetch the data as <code>VARCHAR2</code> type, that is, you have to use <code>OracleTypes.VARCHAR</code> or <code>OracleTypes.LONGVARCHAR</code> with the JDBC <code>defineColumnType</code> method. The limitation of this approach is that when <code>LOB</code> data is fetched as <code>CHAR</code> type, the locator cannot be fetched along with the data. So, if the application wants to get the <code>LOB</code> data at a later point of time, or if the application wants to perform other <code>LOB</code> operations, then one more round trip is required to get the <code>LOB</code> locator, as <code>LOB</code> locator is not available to the application.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Array operations on <code>LOB</code> locators are not supported in the JDBC APIs.</div>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 2 JDBC drivers, the number of round trips is reduced by prefetching frequently used metadata, such as the <code>LOB</code> length and the chunk size as well as the beginning of the <code>LOB</code> data along with the locator during regular fetch operations. For small <code>LOB</code>s, the data may be totally prefetched in one single round trip, that is, the <code>select</code> parse, execution, and fetch occurs in one round trip, and performance is improved greatly. For large <code>LOB</code>s that are larger than 5 times the prefetch size, the performance improvement is not very significant as only the round trip for retrieving the chunk size is not needed.</p>
<p class="subhead2"><a id="JJDBC28780"></a>defaultLobPrefetchSize Connection Property</p>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 2, there is a new connection property <code>oracle.jdbc.defaultLobPrefetchSize</code> that can be used to set the default <code>LOB</code> prefetch size for the connection. This connection property is defined as the following constant: <code>OracleConnection.CONNECTION_PROPERTY_DEFAULT_LOB_PREFETCH_SIZE</code>. The value of this property is used as the default <code>LOB</code> prefetch size for the current connection. The default value of this connection property is 4000. If you want to change the default value at the statement level, then use the <code>setLobPrefetchSize</code> method defined in <code>oracle.jdbc.OracleStatement</code> interface. You can change the default value to:</p>
<ul>
<li>
<p>-1 to disable <code>LOB</code> prefetch for the current connection</p>
</li>
<li>
<p>0 to enable <code>LOB</code> prefetch for metadata only</p>
</li>
<li>
<p>Any value greater than 0 to specify the number of bytes for <code>BLOB</code>s and the number of characters for <code>CLOB</code>s to be prefetched along with the locator during fetch operations</p>
</li>
</ul>
<p>Use <code>getLobPrefetchSize</code> method defined in <code>oracle.jdbc.OracleStatement</code> interface to retrieve the <code>LOB</code> prefetch size.</p>
<p>You can also set the value of <code>LOB</code> prefetch size at the column level by using the <code>defineColumnType</code> method. The column-level value overrides any value that is set at the connection or statement level.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The Javadoc for more information</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
If <code>LOB</code> prefetch is not disabled at the connection level or statement level, it cannot be disabled at the column level.</div>
</div>
<!-- class="sect2" -->
<a id="CHDHDADD"></a>
<div id="JJDBC28781" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle Row-Prefetching Limitations</h3>
<p>There is no maximum prefetch setting. <a id="sthref809"></a>The default value is 10. Larger or smaller values may be appropriate depending on the number of rows and columns expected from the query. You can set the default connection row-prefetch value using a <code>Properties</code> object.</p>
<p>When a statement object is created, it receives the default row-prefetch setting from the associated connection. Subsequent changes to the default connection row-prefetch setting will have no effect on the statement row-prefetch setting.</p>
<p>If a column of a result set is of data type <code>LONG</code>, <code>LONG</code> <code>RAW</code> or <code>LOB</code>s returned through the data interface, that is, the streaming types, then JDBC changes the statement row-prefetch setting to 1, even if you never actually read a value of either of these types.</p>
<p>Setting the prefetch size can affect the performance of an application. Increasing the prefetch size will reduce the number of round-trips required to get all the data, but will increase memory usage. This will depend on the number and size of the columns in the query and the number of rows expected to be returned. It will also depend on the memory and CPU loading of the JDBC client machine. The optimum for a standalone client application will be different from a heavily loaded application server. The speed and latency of the network connection should also be considered.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 11<span class="italic">g</span> Release 1, the Thin driver can fetch the first <code>prefetch_size</code> number of rows from the server in the very first round-trip. This saves one round-trip in SELECT statements.</div>
<p>If you are migrating an application from earlier releases of Oracle JDBC drivers to 10<span class="italic">g</span> Release 1 (10.1) or later releases of Oracle JDBC drivers, then you should revisit the optimizations that you had done earlier, because the memory usage and performance characteristics may have changed substantially.</p>
<p>A common situation that you may encounter is, say, you have a query that selects a unique key. The query will return only zero or one row. Setting the prefetch size to 1 will decrease memory and CPU usage and cannot increase round-trips. However, you must be careful to avoid the error of requesting an extra fetch by writing <code>while(rs.next())</code> instead of <code>if(rs.next())</code>.</p>
<p>If you are using the JDBC Thin driver, then use the <code>useFetchSizeWithLongColumn</code> connection property, because it will perform <code>PARSE</code>, <code>EXECUTE</code>, and <code>FETCH</code> in a single round-trip.</p>
<p>Tuning of the prefetch size should be done along with tuning of memory management in your JVM under realistic loads of the actual application.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not mix the JDBC 2.0 fetch size application programming interface (API) and the Oracle row-prefetching API in your application. You can use one or the other, but not both.</p>
</li>
<li>
<p>Be aware that setting the Oracle fetch size value can affect not only queries, but also explicitly refetching rows in a result set through the result set <code>refreshRow</code> method, which is relevant for scroll-sensitive/read-only, scroll-sensitive/updatable, and scroll-insensitive/updatable result sets, and the window size of a scroll-sensitive result set, affecting how often automatic refetches are performed. However, the Oracle fetch size value will be overridden by any setting of the fetch size.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="urls.htm#i1006362">&#34;Supported Connection Properties&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1059055"></a>
<div id="JJDBC28782" class="sect2">
<h3 class="sect2">Defining Column Types</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>defineColumnType</code> method is deprecated. For more information, refer to <a href="release_changes.htm#BABFIJJJ">&#34;Deprecated Features&#34;</a>.</div>
<p>The implementation of <code>defineColumnType</code> changed significantly since Oracle Database 10<span class="italic">g</span>. Previously, <code>defineColumnType</code> was used both as a performance optimization and to force data type conversion. In previous releases, all of the drivers benefited from calls to <code>defineColumnType</code>. Starting from Oracle Database 10<span class="italic">g</span>, the JDBC Thin driver no longer needs the information provided. The JDBC Thin driver achieves maximum performance without calls to <code>defineColumnType</code>. The JDBC Oracle Call Interface (OCI) and server-side internal drivers still get better performance when the application uses <code>defineColumnType</code>.</p>
<p>If your code is used with both the JDBC Thin and OCI drivers, you can disable the <code>defineColumnType</code> method when using the Thin driver by setting the connection property <code>disableDefineColumnType</code> to <code>true</code>. Doing this makes <code>defineColumnType</code> have no effect. Do not set this connection property to <code>true</code> when using the JDBC OCI or server-side internal drivers.</p>
<p>You can also use <code>defineColumnType</code> to control how much memory the client-side allocates or to limit the size of variable-length data.</p>
<p><a id="sthref810"></a><a id="sthref811"></a>Follow these general steps to define column types for a query:</p>
<ol>
<li>
<p>If necessary, cast your statement object to <code>OracleStatement</code>, <code>OraclePreparedStatement</code>, or <code>OracleCallableStatement</code>, as applicable.</p>
</li>
<li>
<p>If necessary, use the <code><a id="sthref812"></a>clearDefines</code> method of your <code>Statement</code> object to clear any previous column definitions for this <code>Statement</code> object.</p>
</li>
<li>
<p>On each column, call the <code><a id="sthref813"></a>defineColumnType</code> method of your <code>Statement</code> object, passing it these parameters:</p>
<ul>
<li>
<p>Column index (integer)</p>
</li>
<li>
<p>Type code (integer)</p>
<p>Use the <code>static</code> constants of the <code><a id="sthref814"></a>java.sql.Types</code> class or <code><a id="sthref815"></a>oracle.jdbc.OracleTypes</code> class, such as <code>Types.INTEGER</code>, <code>Types.FLOAT</code>, <code>Types.VARCHAR</code>, <code>OracleTypes.VARCHAR</code>, and <code>OracleTypes.ROWID</code>. Type codes for standard types are identical in these two classes.</p>
</li>
<li>
<p>Type name (string)</p>
<p>For structured objects, object references, and arrays, you must also specify the type name. For example, <code>Employee</code>, <code>EmployeeRef</code>, or <code>EmployeeArray</code>.</p>
</li>
<li>
<p>Maximum field size (integer)</p>
<p>Optionally specify a maximum data length for this column.</p>
<p>You cannot specify a maximum field size parameter if you are defining the column type for a structured object, object reference, or array. If you try to include this parameter, it will be ignored.</p>
</li>
<li>
<p>Form of use (short)</p>
<p>Optionally specify a form of use for the column. This can be <code>OraclePreparedStatement.FORM_CHAR</code> to use the database character set or <code>OraclePreparedStatement.FORM_NCHAR</code> to use the national character set. If this parameter is omitted, the default is <code>FORM_CHAR</code>.</p>
</li>
</ul>
<p>For example, assuming <code>stmt</code> is an Oracle statement, use:</p>
<pre>stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>);
</pre>
<p>If the column is <code>VARCHAR</code> or equivalent and you know the length limit:</p>
<pre>stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, <span class="italic">max_size</span>);
</pre>
<p>For an <code>NVARCHAR</code> column where the original maximum length is desired and conversion to the database character set is requested:</p>
<pre>stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, 0,
   OraclePreparedStatement.FORM_CHAR );
</pre>
<p>For structured object, object reference, and array columns:</p>
<pre>stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, <span class="italic">typeName</span>);
</pre>
<p>Set a maximum field size if you do not want to receive the full default length of the data. Calling the <code><a id="sthref816"></a>setMaxFieldSize</code> method of the standard JDBC <code>Statement</code> class sets a restriction on the amount of data returned. Specifically, the size of the data returned will be the minimum of the following:</p>
<ul>
<li>
<p>The maximum field size set in <code>defineColumnType</code></p>
</li>
<li>
<p>The maximum field size set in <code>setMaxFieldSize</code></p>
</li>
<li>
<p>The natural maximum size of the data type</p>
</li>
</ul>
</li>
</ol>
<p>After you complete these steps, use the <code>executeQuery</code> method of the statement to perform the query.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is no longer necessary to specify a data type for each column of the expected result set.</div>
<p><a href="#CHDJDDEA">Example 21-4</a> illustrates the use of this feature. It assumes you have imported the <code>oracle.jdbc.*</code> interfaces.</p>
<div id="JJDBC28783" class="example">
<p class="titleinexample"><a id="CHDJDDEA"></a>Example 21-4 Defining Column Types</p>
<pre>OracleDataSource ods = new OracleDataSource();
ods.setURL(&#34;jdbc:oracle:thin:@localhost:5221:orcl&#34;);
ods.setUser(&#34;HR&#34;);
ods.setPassword(&#34;hr&#34;);
Connection conn = ods.getConnection();

Statement stmt = conn.createStatement();
// Allocate only 2 chars for this column (truncation will happen)
((OracleStatement)stmt).defineColumnType(1, Types.VARCHAR, 2);
ResultSet rset = stmt.executeQuery(&#34;select ename from emp&#34;);
while(rset.next() )
  System.out.println(rset.getString(1));
stmt.close();
</pre></div>
<!-- class="example" -->
<p>As this example shows, you must cast the <code>Statement</code> object, <code>stmt</code>, to <code>OracleStatement</code> in the invocation of the <code>defineColumnType</code> method. The <code>createStatement</code> method of the connection returns an object of type <code>java.sql.Statement</code>, which does not have the <code>defineColumnType</code> and <code>clearDefines</code> methods. These methods are provided only in the <code>OracleStatement</code> implementation.</p>
<p>The define-extensions use JDBC types to specify the desired types. The allowed define types for columns depend on the internal Oracle type of the column.</p>
<p>All columns can be defined to their natural JDBC types. In most cases, they can be defined to the <code>Types.CHAR</code> or <code>Types.VARCHAR</code> type code.</p>
<p><a href="#g1060844">Table 21-1</a> lists the valid column definition arguments you can use in the <code>defineColumnType</code> method.</p>
<div id="JJDBC28784" class="tblformal">
<p class="titleintable"><a id="sthref817"></a><a id="g1060844"></a>Table 21-1 Valid Column Type Specifications</p>
<table class="cellalignment2244" title="Valid Column Type Specifications " summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t27">If the column has Oracle<br/>
SQL type:</th>
<th class="cellalignment2245" id="r1c2-t27">You can use defineColumnType<br/>
to define it as:</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t27" headers="r1c1-t27">
<p><code>NUMBER</code>, <code>VARNUM</code></p>
</td>
<td class="cellalignment2246" headers="r2c1-t27 r1c2-t27">
<p><code>BIGINT</code>, <code>TINYINT</code>, <code>SMALLINT</code>, <code>INTEGER</code>, <code>FLOAT</code>, <code>REAL</code>, <code>DOUBLE</code>, <code>NUMERIC</code>, <code>DECIMAL</code>, <code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r3c1-t27" headers="r1c1-t27">
<p><code>CHAR</code>, <code>VARCHAR2</code></p>
</td>
<td class="cellalignment2246" headers="r3c1-t27 r1c2-t27">
<p><code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r4c1-t27" headers="r1c1-t27">
<p><code>LONG</code></p>
</td>
<td class="cellalignment2246" headers="r4c1-t27 r1c2-t27">
<p><code>CHAR</code>, <code>VARCHAR</code>, <code>LONGVARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r5c1-t27" headers="r1c1-t27">
<p><code>LONGRAW</code></p>
</td>
<td class="cellalignment2246" headers="r5c1-t27 r1c2-t27">
<p><code>LONGVARBINARY</code>, <code>VARBINARY</code>, <code>BINARY</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r6c1-t27" headers="r1c1-t27">
<p><code>RAW</code></p>
</td>
<td class="cellalignment2246" headers="r6c1-t27 r1c2-t27">
<p><code>VARBINARY</code>, <code>BINARY</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r7c1-t27" headers="r1c1-t27">
<p><code>DATE</code></p>
</td>
<td class="cellalignment2246" headers="r7c1-t27 r1c2-t27">
<p><code>DATE</code>, <code>TIME</code>, <code>TIMESTAMP</code>, <code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r8c1-t27" headers="r1c1-t27">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment2246" headers="r8c1-t27 r1c2-t27">
<p><code>ROWID</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r9c1-t27" headers="r1c1-t27">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment2246" headers="r9c1-t27 r1c2-t27">
<p><code>VARBINARY</code>, <code>BINARY</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r10c1-t27" headers="r1c1-t27">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment2246" headers="r10c1-t27 r1c2-t27">
<p><code>LONG</code>, <code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>It is always valid to use <code>defineColumnType</code> with the original data type of the column.</p>
</div>
<!-- class="sect2" -->
<a id="i1023518"></a>
<div id="JJDBC28785" class="sect2">
<h3 class="sect2">Reporting DatabaseMetaData TABLE_REMARKS</h3>
<p>The <code><a id="sthref818"></a><a id="sthref819"></a><a id="sthref820"></a>getColumns</code>, <code>getProcedureColumns</code>, <code>getProcedures</code>, and <code>getTables</code> methods of the database metadata classes are slow if they must report <code><a id="sthref821"></a><a id="sthref822"></a>TABLE_REMARKS</code> columns, because this necessitates an expensive outer join. For this reason, the JDBC driver does <span class="italic">not</span> report <code>TABLE_REMARKS</code> columns by default.</p>
<p>You can enable <code>TABLE_REMARKS</code> reporting by passing a <code>true</code> argument to the <code><a id="sthref823"></a>setRemarksReporting</code> method of an <code>OracleConnection</code> object.</p>
<p>Equivalently, instead of calling <code>setRemarksReporting</code>, you can set the <code>remarksReporting</code> Java property if you use a Java <code>Properties</code> object in establishing the connection.</p>
<p>If you are using a standard <code>java.sql.Connection</code> object, you must cast it to <code>OracleConnection</code> to use <code>setRemarksReporting</code>.</p>
<p><a href="#CHDECFCC">Example 21-5</a> illustrates how to enable <code>TABLE_REMARKS</code> reporting.</p>
<div id="JJDBC28786" class="example">
<p class="titleinexample"><a id="CHDECFCC"></a>Example 21-5 TABLE_REMARKS Reporting</p>
<p>Assuming <code>conn</code> is the name of your standard <code>Connection</code> object, the following statement enables <code>TABLE_REMARKS</code> reporting:</p>
<pre>((oracle.jdbc.OracleConnection)conn ).setRemarksReporting(true);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="JJDBC28787"></a>Considerations for getColumns</p>
<p>By default, the <code>getColumns</code> method does not retrieve information about the columns if a synonym is specified. To enable the retrieval of information if a synonym is specified, you must call the <code>setIncludeSynonyms</code> method on the connection as follows:</p>
<pre>((oracle.jdbc.OracleConnection)conn ).setIncludeSynonyms(true)
</pre>
<p>This will cause all subsequent <code>getColumns</code> method calls on the connection to include synonyms. This is similar to <code>setRemarksReporting</code>. Alternatively, you can set the <code>includeSynonyms</code> connection property. This is similar to the <code>remarksReporting</code> connection property.</p>
<p>However, bear in mind that if <code>includeSynonyms</code> is <code>true</code>, then the name of the object returned in the <code>table_name</code> column will be the synonym name, if a synonym exists. This is true even if you pass the table name to <code>getColumns</code>.</p>
<p class="subhead2"><a id="CHDCHECH"></a><a id="JJDBC28788"></a>Considerations for getProcedures and getProcedureColumns Methods</p>
<p>According to JDBC versions 1.1 and 1.2, the methods <code>getProcedures</code> and <code>getProcedureColumns</code> treat the <code>catalog</code>, <code>schemaPattern</code>, <code>columnNamePattern</code>, and <code>procedureNamePattern</code> parameters in the same way. In the Oracle definition of these methods, the parameters are treated differently:</p>
<ul>
<li>
<p><code>catalog</code></p>
<p>Oracle does not have multiple catalogs, but it does have packages. Consequently, the <code>catalog</code> parameter is treated as the package name. This applies both on input, which is the <code>catalog</code> parameter, and the output, which is the <code>catalog</code> column in the returned <code>ResultSet</code>. On input, the construct <code>&#34;</code> <code>&#34;</code>, which is an empty string, retrieves procedures and arguments without a package, that is, standalone objects. A <code>null</code> value means to drop from the selection criteria, that is, return information about both standalone and packaged objects. That is, it has the same effect as passing in the percent sign (<code>%</code>). Otherwise, the <code>catalog</code> parameter should be a package name pattern, with SQL wild cards, if desired.</p>
</li>
<li>
<p><code>schemaPattern</code></p>
<p>All objects within Oracle database must have a schema, so it does not make sense to return information for those objects without one. Thus, the construct <code>&#34;</code> <code>&#34;</code>, which is an empty string, is interpreted on input to mean the objects in the current schema, that is, the one to which you are currently connected. To be consistent with the behavior of the <code>catalog</code> parameter, <code>null</code> is interpreted to drop the schema from the selection criteria. That is, it has the same effect as passing in <code>%</code>. It can also be used as a pattern with SQL wild cards.</p>
</li>
<li>
<p><code>procedureNamePattern</code> and <code>columnNamePattern</code></p>
<p>The empty string (&#34; &#34;) does not make sense for either parameter, because all procedures and arguments must have names. Thus, the construct <code>&#34;</code> <code>&#34;</code> will raise an exception. To be consistent with the behavior of other parameters, <code>null</code> has the same effect as passing in percent sign (<code>%</code>).</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2237">
<tr>
<td class="cellalignment2246">
<table class="cellalignment2242">
<tr>
<td class="cellalignment2241"><a href="stmtcach.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2241"><a href="ociconpl.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2249">
<table class="cellalignment2240">
<tr>
<td class="cellalignment2241"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2241"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2241"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2241"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2241"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2241"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>