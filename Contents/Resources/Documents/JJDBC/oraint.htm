<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71004"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Oracle%20Extensions"></a><title>Oracle Extensions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="description" content="This book describes how to use Oracle JDBC drivers to develop powerful Java database applications."/>
<meta name="dcterms.created" content="2014-06-30T1:22:36Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database JDBC Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49300-05"/>
<meta name="dcterms.isVersionOf" content="JJDBC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="jdbcvers.htm" title="Previous" type="text/html"/>
<link rel="Next" href="jdbcthin.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49300-05.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/55</span> <!-- End Header -->
<div id="JJDBC28120" class="chapter"><a id="g1090378"></a>
<h1 class="chapter"><span class="secnum">4</span> Oracle Extensions</h1>
<p><a id="sthref113"></a><a id="sthref114"></a>Oracle provides Java classes and interfaces that extend the Java Database Connectivity (JDBC) standard implementation, enabling you to access and manipulate Oracle data types and use Oracle performance extensions. This chapter provides an overview of the classes and interfaces provided by Oracle that extend the JDBC standard implementation. It also describes some of the key support features of the extensions.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i1052570">Overview of Oracle Extensions</a></p>
</li>
<li>
<p><a href="#i1060087">Features of the Oracle Extensions</a></p>
</li>
<li>
<p><a href="#i1023949">Oracle JDBC Packages</a></p>
</li>
<li>
<p><a href="#i1064650">Oracle Character Data Types Support</a></p>
</li>
<li>
<p><a href="#i1063951">Additional Oracle Type Extensions</a></p>
</li>
<li>
<p><a href="#BABFJDDG">DML Returning</a></p>
</li>
<li>
<p><a href="#BABBGDFA">Accessing PL/SQL Associative Arrays</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
This chapter focuses on type extensions, as opposed to performance extensions, which are discussed in detail in <a href="oraperf.htm#g1068570">Chapter 21, &#34;Performance Extensions&#34;</a>.</div>
<a id="i1052570"></a>
<div id="JJDBC28121" class="sect1">
<h2 class="sect1">Overview of Oracle Extensions</h2>
<p>Beyond standard features, Oracle JDBC drivers provide Oracle-specific type extensions and performance extensions. These extensions are provided through the following Java packages:</p>
<ul>
<li>
<p><code>oracle.sql</code></p>
<p>Provides classes that represent SQL data in Oracle format</p>
</li>
<li>
<p><code>oracle.jdbc</code></p>
<p>Provides interfaces to support database access and updates in Oracle type formats</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1023949">&#34;Oracle JDBC Packages&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i1060087"></a>
<div id="JJDBC28122" class="sect1">
<h2 class="sect1">Features of the <a id="sthref115"></a>Oracle Extensions</h2>
<p>The Oracle extensions to JDBC include a number of features that enhance your ability to work with Oracle Databases. These include the following:</p>
<ul>
<li>
<p><a href="#CHDGBJIG">Database Management Using JDBC</a></p>
</li>
<li>
<p><a href="#BABCJFDA">Support for Oracle Data Types</a></p>
</li>
<li>
<p><a href="#BABFGIAH">Support for Oracle Objects</a></p>
</li>
<li>
<p><a href="#BABFIEFG">Support for Schema Naming</a></p>
</li>
<li>
<p><a href="#BABBBIFA">DML Returning</a></p>
</li>
<li>
<p><a href="#i1018084">Accessing PL/SQL Associative Arrays</a></p>
</li>
</ul>
<a id="CHDGBJIG"></a>
<div id="JJDBC28123" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Database Management Using JDBC</h3>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 1, the <code>oracle.jdbc.OracleConnection</code> interface has two JDBC methods, <code>startup</code> and <code>shutdown</code>, which enable you to start up and shut down an Oracle Database instance. You also have support for the Database Change Notification feature of Oracle Database. These new features are discussed in details in <a href="dbmgmnt.htm#CHDJABJI">&#34;Database Administration&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
My Oracle Support Note 335754.1 announces the desupport of the <code>oracle.jdbc.driver.*</code> package in Oracle Database 11<span class="italic">g</span> JDBC drivers. In other words, Oracle Database 10<span class="italic">g</span> Release 2 was the last database to support this package and any API depending on the <code>oracle.jdbc.driver.*</code> package will fail to compile in the current release of the Database. You must remove such APIs and migrate to the standard APIs. For example, if your code uses the <code>oracle.jdbc.CustomDatum</code> and <code>oracle.jdbc.CustomDatumFactory</code> interfaces, then you must replace them with the <code>java.sql.Struct</code> or <code>java.sql.SQLData</code> interfaces.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
My Oracle Support Note 1364193.1, &#34;New JDBC Interfaces for Oracle types&#34; for more information</div>
</div>
<!-- class="sect2" -->
<a id="BABCJFDA"></a>
<div id="JJDBC28125" class="sect2">
<h3 class="sect2">Support for Oracle Data Types</h3>
<p>One of the features of the Oracle JDBC extensions is the type support in the <a id="sthref116"></a><code>oracle.sql</code> package. This package includes classes that are an exact representation of the data in Oracle format. Keep the following important points in mind, when you use <code>oracle.sql</code> types in your program:</p>
<ul>
<li>
<p>For numeric type of data, the conversion to standard Java types does not guarantee to retain full precision due to limitations of the data conversion process. Use the <code>BigDecimal</code> type to minimize any data loss issues.</p>
</li>
<li>
<p>For certain data types, the conversion to standard Java types can be dependent on the system settings and your program may not run as expected. This is a known limitation while converting data from <code>oracle.sql</code> types to standard Java types.</p>
</li>
<li>
<p>If the functionalities of your program is limited to reading data from one table and writing the same to another table, then for numeric and date data, <code>oracle.sql</code> types are slightly faster as compared to standard Java types. But, if your program involves even a simple data manipulation operation like compare or print, then standard Java types are faster.</p>
</li>
<li>
<p><code>oracle.sql.CHAR</code> is not an exact representation of the data in Oracle format. <code>oracle.sql.CHAR</code> is constructed from <code>java.lang.String</code>. There is no advantage of using <code>oracle.sql.CHAR</code> because <code>java.lang.String</code> is always faster and represents the same character sets, excluding a couple of desupported character sets.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle strongly recommends you to use standard Java types and convert any existing <code>oracle.sql</code> type of data to standard Java types. Internally, the Oracle JDBC drivers strive to maximize the performance of Java standard types. <code>oracle.sql</code> types are supported <span class="italic">only</span> for backward compatibility and their use is discouraged.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1023991">Package oracle.sql</a></p>
</li>
<li>
<p><a href="#i1064650">&#34;Oracle Character Data Types Support&#34;</a></p>
</li>
<li>
<p><a href="#i1063951">&#34;Additional Oracle Type Extensions&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABFGIAH"></a>
<div id="JJDBC28126" class="sect2">
<h3 class="sect2"><a id="sthref117"></a>Support for Oracle Objects</h3>
<p>Oracle JDBC supports the use of structured objects in the database, where an object data type is a user-defined type with nested attributes. For example, a user application could define an <code>Employee</code> object type, where each <code>Employee</code> object has a <code>firstname</code> attribute (character string), a <code>lastname</code> attribute (character string), and an <code>employeenumber</code> attribute (integer).</p>
<p>Oracle JDBC supports Oracle object data types. When you work with Oracle object data types in a Java application, you must consider the following:</p>
<ul>
<li>
<p>How to map between Oracle object data types and Java classes</p>
</li>
<li>
<p>How to store Oracle object attributes in corresponding Java objects</p>
</li>
<li>
<p>How to convert attribute data between SQL and Java formats</p>
</li>
<li>
<p>How to access data</p>
</li>
</ul>
<p>Oracle objects can be mapped either to the weak <code>java.sql.Struct</code> type or to strongly typed customized classes. These strong types are referred to as <a id="sthref118"></a>custom Java classes, which must implement either the standard <code>java.sql.SQLD<a id="sthref119"></a>ata</code> interface or the Oracle extension <code>oracle.jdbc.<a id="sthref120"></a>OracleData</code> interface. Each interface specifies methods to convert data between SQL and Java.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>OracleData</code> interface has replaced the <code>ORAData</code> interface.</div>
<p>Oracle recommends the use of the Oracle JPublisher utility to create custom Java classes to correspond to your Oracle objects. <a id="sthref121"></a>Oracle JPublisher performs this task seamlessly with command-line options and can generate either <code>SQLData</code> or <code>OracleData</code> interface implementations.</p>
<p>For <code>SQLData</code> interface implementations, a <a id="sthref122"></a>type map defines the correspondence between Oracle object data types and Java classes. <span class="bold">Type maps</span> are objects that specify which Java class corresponds to each Oracle object data type. Oracle JDBC uses these type maps to determine which Java class to instantiate and populate when it retrieves Oracle object data from a result set.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends using the <code>OracleData</code> interface, instead of the <code>SQLData</code> interface, in situations where portability is not a concern. The <code>OracleData</code> interface works more easily and flexibly in conjunction with other features of the Oracle platform offerings using Java.</div>
<p>JPublisher automatically defines <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods of the custom Java classes, which retrieve data into your Java application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oraoot.htm#g1104293">Chapter 13, &#34;Working with Oracle Object Types&#34;</a></p>
</li>
<li>
<p><a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABFIEFG"></a>
<div id="JJDBC28127" class="sect2">
<h3 class="sect2">Support for <a id="sthref123"></a>Schema Naming</h3>
<p>Oracle object data type classes have the ability to accept and return fully qualified schema names. A fully qualified schema name has this syntax:</p>
<pre>{[<span class="italic">schema_name</span>].}[<span class="italic">sql_type_name]</span> 
 
</pre>
<p>Where, <code><span class="codeinlineitalic">schema_name</span></code> is the name of the schema and <code><span class="codeinlineitalic">sql_type_name</span></code> is the SQL type name of the object. <code><span class="codeinlineitalic">schema_name</span></code> and <code><span class="codeinlineitalic">sql_type_name</span></code> are separated by a period (<code>.</code>).</p>
<p>To specify an object type in JDBC, use its fully qualified name. It is not necessary to enter a schema name if the type name is in the current naming space, that is, the current schema. Schema naming follows these rules:</p>
<ul>
<li>
<p>Both the schema name and the type name may or may not be within quotation marks. However, if the SQL type name has a period in it, such as <code>CORPORATE.EMPLOYEE</code>, the type name must be quoted.</p>
</li>
<li>
<p>The JDBC driver looks for the first period in the object name that is not within quotation marks and uses the string before the period as the schema name and the string following the period as the type name. If no period is found, then the JDBC driver takes the current schema as default. That is, you can specify only the type name, without indicating a schema, instead of specifying the fully qualified name if the object type name belongs to the current schema. This also explains why you must put the type name within quotation marks if the type name has a dot in it.</p>
<p>For example, assume that user <code>HR</code> creates a type called <code>person.address</code> and then wants to use it in his session. <code>HR</code> may want to skip the schema name and pass in <code>person.address</code> to the JDBC driver. In this case, if <code>person.address</code> is not within quotation marks, then the period is detected and the JDBC driver mistakenly interprets <code>person</code> as the schema name and <code>address</code> as the type name.</p>
</li>
<li>
<p>JDBC passes the object type name string to the database unchanged. That is, the JDBC driver does not change the character case even if the object type name is within quotation marks.</p>
<p>For example, if <code>HR.PersonType</code> is passed to the JDBC driver as an object type name, then the JDBC driver passes the string to the database unchanged. As another example, if there is white space between characters in the type name string, then the JDBC driver will not remove the white space.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABBBIFA"></a>
<div id="JJDBC28128" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref124"></a>DML Returning</h3>
<p>Oracle Database supports the use of the <code>RETURNING</code> clause with data manipulation language (DML) statements. This enables you to combine two SQL statements into one. Both the Oracle JDBC Oracle Call Interface (OCI) driver and the Oracle JDBC Thin driver support DML returning.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABFJDDG">&#34;DML Returning&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1018084"></a>
<div id="JJDBC28129" class="sect2">
<h3 class="sect2"><a id="sthref125"></a>Accessing PL/SQL Associative Arrays</h3>
<p>Oracle JDBC drivers enable JDBC applications to make PL/SQL calls with Associative Array parameters. Oracle JDBC drivers support PL/SQL Associative Arrays of scalar data types</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABBGDFA">&#34;Accessing PL/SQL Associative Arrays&#34;</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1023949"></a>
<div id="JJDBC28130" class="sect1">
<h2 class="sect1">Oracle JDBC Packages</h2>
<p>This section describes the following Java packages, which support the Oracle JDBC extensions:</p>
<ul>
<li>
<p><a href="#i1023991">Package oracle.sql</a></p>
</li>
<li>
<p><a href="#BABBGCIC">Package oracle.jdbc</a></p>
</li>
</ul>
<a id="i1023991"></a>
<div id="JJDBC28131" class="sect2">
<h3 class="sect2">Package oracle.sql</h3>
<p>The <code><a id="sthref126"></a>oracle.sql</code> package supports direct access to data in SQL format. This package consists primarily of classes that provide Java mappings to SQL data types and their support classes. Essentially, the classes act as Java containers for SQL data.</p>
<p>Each of the <code>oracle.sql.*</code> data type classes extends <code><a id="sthref127"></a>oracle.sql.Datum</code>, a superclass that encapsulates functionality common to all the data types. Some of the classes are for JDBC 2.0-compliant data types. These classes, implement standard JDBC 2.0 interfaces in the <code>java.sql</code> package, as well as extending the <code>oracle.sql.Datum</code> class.</p>
<p>The <code>LONG</code> and <code>LONG</code> <code>RAW</code> SQL types and <code>REF</code> <code>CURSOR</code> type category have no <code>oracle.sql.*</code> classes. Use standard JDBC functionality for these types. For example, retrieve <code>LONG</code> or <code>LONG</code> <code>RAW</code> data as input streams using the standard JDBC result set and callable statement methods <code>getBinaryStream</code> and <code>getCharacterStream</code>. Use the <code>getCursor</code> method for <code>REF</code> <code>CURSOR</code> types.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends the use of standard JDBC types or Java types whenever possible. The types in the package <code>oracle.sql.*</code> are provided primarily for backward compatibility or for support of a few Oracle specific features such as <code>OPAQUE</code>, <code>OracleData</code>, <code>TIMESTAMPTZ</code>, and so on.</div>
<p class="subhead2"><a id="JJDBC28132"></a>General oracle.sql.* Data Type Support</p>
<p>Each of the <a id="sthref128"></a>Oracle data type classes provides, among other things, the following:</p>
<ul>
<li>
<p>Data storage as Java byte arrays for SQL data</p>
</li>
<li>
<p>A <code><a id="sthref129"></a>getBytes()</code> method, which returns the SQL data as a byte array</p>
</li>
<li>
<p>A <code><a id="sthref130"></a>toJdbc()</code> method that converts the data into an object of a corresponding Java class as defined in the JDBC specification</p>
<p>The JDBC driver does not convert Oracle-specific data types that are not part of the JDBC specification, such as <code>BFILE</code>. The driver returns the object in the corresponding <code>oracle.sql.*</code> format.</p>
</li>
<li>
<p>Appropriate <code><span class="codeinlineitalic">xxx</span></code><code>Value</code> methods to convert SQL data to Java type. For example, <code>stringValue</code>, <code>intValue</code>, <code>booleanValue</code>, <code>dateValue</code>, and <code>bigDecimalValue</code></p>
</li>
<li>
<p>Additional conversion methods, <code>get</code><code><span class="codeinlineitalic">XXX</span></code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code>, as appropriate, for the functionality of the data type, such as methods in the large object (LOB) classes that get the data as a stream and methods in the <code>REF</code> class that get and set object data through the object reference.</p>
</li>
</ul>
<p class="subhead2"><a id="i1075337"></a><a id="JJDBC28133"></a>Overview of Class <a id="sthref131"></a><a id="sthref132"></a>oracle.sql.STRUCT</p>
<p><code>oracle.sql.STRUCT</code> class is the Oracle implementation of <code>java.sql.Struct</code> interface. This class is a value class and you should not change the contents of the class after construction. This class, as with all <code>oracle.sql.*</code> data type classes, is a subclass of the <code>oracle.sql.Datum</code> class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>oracle.sql.STRUCT</code> class is deprecated and replaced with the <code>oracle.jdbc.OracleStruct</code> interface, which is a part of the <code>oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code>java.sql</code> package, where possible, for standard compatibility and methods available in the <code>oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code>oracle.jdbc.OracleStruct</code> interface.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JAJDB" href="../JAJDB/toc.htm"><span class="italic">Oracle Database JDBC Java API Reference</span></a></div>
<p class="subhead2"><a id="JJDBC28134"></a>Overview of Class oracle.sql.REF</p>
<p>The <code><a id="sthref133"></a><a id="sthref134"></a>oracle.sql.REF</code> class is the generic class that supports Oracle object references. This class, as with all <code>oracle.sql.*</code> data type classes, is a subclass of the <code>oracle.sql.Datum</code> class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>oracle.sql.REF</code> class is deprecated and replaced with the <code>oracle.jdbc.OracleRef</code> interface, which is a part of the <code>oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code>java.sql</code> package, where possible, for standard compatibility and methods available in the <code>oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code>oracle.jdbc.OracleRef</code> interface.</div>
<p>The <code>REF</code> class has methods to retrieve and pass object references. However, selecting an object reference retrieves only a pointer to an object. This does not materialize the object itself. But the <code>REF</code> class also includes methods to retrieve and pass the object data. You cannot create <code>REF</code> objects in your JDBC application. You can only retrieve existing <code>REF</code> objects from the database.</p>
<p>You should use the JDBC standard type, <code>java.sql.Ref</code>, and the JDBC standard methods in preference to using <code>oracle.sql.REF</code>. If you want your code to be more portable, then you must use the standard type because only the Oracle JDBC drivers will use instances of <code>oracle.sql.REF</code> type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JAJDB" href="../JAJDB/toc.htm"><span class="italic">Oracle Database JDBC Java API Reference</span></a></div>
<p class="subhead2"><a id="JJDBC28136"></a>Overview of Classes oracle.sql.BLOB, oracle.sql.CLOB, oracle.sql.BFILE</p>
<p><a id="sthref135"></a><a id="sthref136"></a><a id="sthref137"></a><a id="sthref138"></a><a id="sthref139"></a><a id="sthref140"></a>Binary large objects (BLOBs), character large objects (CLOBs), and binary files (BFILEs) are for data items that are too large to store directly in a database table. Instead, the database table stores a locator that points to the location of the actual data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>oracle.sql.BLOB</code> and <code>Oracle.sql.CLOB</code> classes are deprecated and replaced with the <code>oracle.jdbc.OracleBlob</code> and <code>oracle.jdbc.OracleClob</code> interfaces respectively, which are a part of the <code>oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code>java.sql</code> package, where possible, for standard compatibility and methods available in the <code>oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code>oracle.jdbc.OracleBlob</code> and <code>oracle.jdbc.OracleClob</code> interfaces.</p>
</li>
<li>
<p><code>oracle.sql.BFILE</code> is an Oracle proprietary extension and there is no JDBC standard equivalent.</p>
</li>
</ul>
</div>
<p>The <code>oracle.sql</code> package supports these data types in several ways:</p>
<ul>
<li>
<p>BLOBs point to large unstructured binary data items and are supported by the <code>oracle.sql.BLOB</code> class.</p>
</li>
<li>
<p>CLOBs point to large character data items and are supported by the <code>oracle.sql.CLOB</code> class.</p>
</li>
<li>
<p>BFILEs point to the content of external files (operating system files) and are supported by the <code>oracle.sql.BFILE</code> class. BFiles are read-only.</p>
</li>
</ul>
<p>You can select a BLOB, <a id="sthref141"></a><a id="sthref142"></a>CLOB, or <a id="sthref143"></a>BFILE locator from the database using a standard <code>SELECT</code> statement. However, you receive only the locator, and not the data. Additional steps are necessary to retrieve the data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oralob.htm#g1070326">Chapter 14, &#34;Working with LOBs and BFILEs&#34;</a>.</div>
<p class="subhead2"><a id="JJDBC28137"></a>Overview of Classes oracle.sql.DATE, oracle.sql.NUMBER, and oracle.sql.RAW</p>
<p><a id="sthref144"></a><a id="sthref145"></a><a id="sthref146"></a><a id="sthref147"></a><a id="sthref148"></a><a id="sthref149"></a><a id="sthref150"></a><a id="sthref151"></a>These classes hold primitive SQL data types in Oracle native representation. In most cases, these types are not used internally by the drivers and you should use the standard JDBC types instead.</p>
<p>Java <code>Double</code> and <code>Float</code> <code>NaN</code> values do not have an equivalent Oracle <code>NUMBER</code> representation. For example, for Oracle <code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code> data types, negative zero is coerced to positive zero and all NaNs are coerced to the canonical one. So, a <code>NullPointerException</code> is thrown whenever a <code>Double.NaN</code> value or a <code>Float.NaN</code> value is converted into an Oracle <code>NUMBER</code> using the <code>oracle.sql.NUMBER</code> class. For instance, the following code throws a <code><a id="sthref152"></a>NullPointerException</code>:</p>
<pre>oracle.sql.NUMBER n = new oracle.sql.NUMBER(Double.NaN); 
System.out.println(n.doubleValue());  // throws NullPointerException
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00222" href="../SQLRF/sql_elements001.htm#SQLRF00222"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
<p class="subhead2"><a id="CHDCEDDD"></a><a id="JJDBC28138"></a>Overview of Classes oracle.sql.TIMESTAMP, oracle.sql.TIMESTAMPTZ, and oracle.sql.TIMESTAMPLTZ</p>
<p>The JDBC drivers support the following date/time data types:</p>
<ul>
<li>
<p><code>TIMESTAMP</code> (<code>TIMESTAMP</code>)</p>
</li>
<li>
<p><code>TIMESTAMP WITH TIME ZONE</code> (<code>TIMESTAMPTZ</code>)</p>
</li>
<li>
<p><code>TIMESTAMP WITH LOCAL TIME ZONE</code> (<code>TIMESTAMPLTZ</code>)</p>
</li>
</ul>
<p>The JDBC drivers allow conversions between <code>DATE</code> and date/time data types. For example, you can access a <code>TIMESTAMP WITH TIME ZONE</code> column as a <code>DATE</code> value.</p>
<p>The JDBC drivers support the most popular time zone names used in the industry as well as most of the time zone names defined in the JDK. Time zones are specified by using the <code>java.util.TimeZone</code> class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not use <code>TimeZone.getTimeZone</code> to create time zone objects. The Oracle time zone data types support more time zone names than JDK.</p>
</li>
<li>
<p>If a result set contains a <code>TIMESTAMPLTZ</code> column followed by a <code>LONG</code> column, then reading the <code>LONG</code> column results in an error.</p>
</li>
</ul>
</div>
<p>The following code shows how the <code>TimeZone</code> and <code>Calendar</code> objects are created for <code>US_PACIFIC</code>, which is a time zone name not defined in JDK:</p>
<pre>TimeZone tz = TimeZone.getDefault();
tz.setID(&#34;US_PACIFIC&#34;);
GregorianCalendar gcal = new GregorianCalendar(tz);
</pre>
<p>The following Java classes represent the SQL date/time types:</p>
<ul>
<li>
<p><code>oracle.sql.TIMESTAMP</code></p>
</li>
<li>
<p><code>oracle.sql.TIMESTAMPTZ</code></p>
</li>
<li>
<p><code>oracle.sql.TIMESTAMPLTZ</code></p>
</li>
</ul>
<p>Before accessing <code>TIMESTAMP WITH LOCAL TIME ZONE</code> data, call the <code>OracleConnection.setSessionTimeZone(String regionName)</code> method to set the session time zone. When this method is called, the JDBC driver sets the session time zone of the connection and saves the session time zone so that any <code>TIMESTAMP WITH LOCAL TIME ZONE</code> data accessed through JDBC can be adjusted using the session time zone.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>TIMESTAMP WITH TIME ZONE</code> and <code>TIMESTAMP WITH LOCAL TIME ZONE</code> types can be represented as standard <code>java.sql.Timestamp</code> type. The byte representation of <code>TIMESTAMP WITH TIME ZONE</code> and <code>TIMESTAMP WITH LOCAL TIME ZONE</code> types to <code>java.sql.Timestamp</code> is straight forward. This is because the internal format of <code>TIMESTAMP WITH TIME ZONE</code> and <code>TIMESTAMP WITH LOCAL TIME ZONE</code> data types is GMT, and <code>java.sql.Timestamp</code> type objects internally use a milliseconds time value that is the number of milliseconds since EPOCH. However, the <code>String</code> representation of these data types requires time zone information that is obtained dynamically from the server and cached on the client side.
<p>In earlier versions of JDBC drivers, the cache of time zone was shared across different connections. This used to cause problems sometimes due to incompatibility in various time zones. Starting from Oracle Database 11 Release 2 version of JDBC drivers, the time zone cache is based on the time zone version supplied by the database. This newly designed cache avoids any issues related to version incompatibility of time zones.</p>
</div>
<p class="subhead2"><a id="JJDBC28139"></a>Overview of Class oracle.sql.OPAQUE</p>
<p>The <code>oracle.sql.OPAQUE</code> class provides the name and characteristics of the <code>OPAQUE</code> type and any attributes. The <code>OPAQUE</code> type provides access only to the uninterrupted bytes of the instance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the <code>oracle.sql.OPAQUE</code> class is deprecated and replaced with the <code>oracle.jdbc.OracleOpaque</code> interface, which is a part of the <code>oracle.jdbc</code> package. Oracle recommends you to use the methods available in the <code>java.sql</code> package, where possible, for standard compatibility and methods available in the <code>oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code>oracle.jdbc.OracleOpaque</code> interface.</div>
</div>
<!-- class="sect2" -->
<a id="BABBGCIC"></a>
<div id="JJDBC28140" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Package oracle.jdbc</h3>
<p>The interfaces of the <code>oracle.jdbc</code> package define the Oracle extensions to the interfaces in <code>java.sql</code>. These extensions provide access to Oracle SQL-format data and other Oracle-specific functionality, including Oracle performance enhancements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1073534">&#34;The oracle.jdbc Package&#34;</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1064650"></a>
<div id="JJDBC28141" class="sect1">
<h2 class="sect1">Oracle Character Data Types Support</h2>
<p>Oracle character data types include the SQL CHAR and NCHAR data types. The following sections describe how these data types can be accessed using the <code>oracle.sql.*</code> classes:</p>
<ul>
<li>
<p><a href="#i1063506">SQL CHAR Data Types</a></p>
</li>
<li>
<p><a href="#i1073960">SQL NCHAR Data Types</a></p>
</li>
<li>
<p><a href="#i1064692">Class oracle.sql.CHAR</a></p>
</li>
</ul>
<a id="i1063506"></a>
<div id="JJDBC28142" class="sect2">
<h3 class="sect2">SQL CHAR Data Types</h3>
<p>The SQL CHAR data types include <code>CHAR</code>, <code>VARCHAR2</code>, and <code>CLOB</code>. These data types let you store character data in the database character set encoding scheme. The character set of the database is established when you create the database.</p>
</div>
<!-- class="sect2" -->
<a id="i1073960"></a>
<div id="JJDBC28143" class="sect2">
<h3 class="sect2">SQL NCHAR Data Types</h3>
<p>The SQL <code>NCHAR</code> data types were created for Globalization Support. The SQL <code>NCHAR</code> data types include <code>NCHAR</code>, <code>NVARCHAR2</code>, and <code>NCLOB</code>. These data types enable you to store <a id="sthref153"></a>Unicode data in the database <code>NCHAR</code> character set encoding. The <code>NCHAR</code> character set, which never changes, is established when you create the database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the <code>UnicodeStream</code> class is deprecated in favor of the <code>CharacterStream</code> class, the <code>setUnicodeStream</code> and <code>getUnicodeStream</code> methods are not supported for <code>NCHAR</code> data type access. Use the <code>setCharacterStream</code> method and the <code>getCharacterStream</code> method if you want to use stream access.</div>
<p>The usage of SQL <code>NCHAR</code> data types is similar to that of the SQL <code>CHAR</code> data types. JDBC uses the same classes and methods to access SQL <code>NCHAR</code> data types that are used for the corresponding SQL <code>CHAR</code> data types. Therefore, there are no separate, corresponding classes defined in the <code>oracle.sql</code> package for SQL <code>NCHAR</code> data types. Similarly, there is no separate, corresponding constant defined in the <code>oracle.jdbc.OracleTypes</code> class for SQL <code>NCHAR</code> data types.</p>
<p>The following code shows how to access SQL <code>NCHAR</code> data:</p>
<pre>// 
// Table TEST has the following columns: 
// - NUMBER 
// - NVARCHAR2 
// - NCHAR 
// 
oracle.jdbc.OraclePreparedStatement pstmt = 
  (oracle.jdbc.OraclePreparedStatement) 
conn.prepareStatement(&#34;insert into TEST values(?, ?, ?)&#34;);

// 
// oracle.jdbc.OraclePreparedStatement.FORM_NCHAR should be used for all NCHAR, 
// NVARCHAR2 and NCLOB data types.
//

pstmt.setInt(1, 1);                    // NUMBER column
pstmt.setNString(2, myUnicodeString1);  // NVARCHAR2 column
pstmt.setNString(3, myUnicodeString2);  // NCHAR column
pstmt.execute();
</pre></div>
<!-- class="sect2" -->
<a id="i1064692"></a>
<div id="JJDBC28144" class="sect2">
<h3 class="sect2">Class oracle.sql.CHAR</h3>
<p>The <code>oracle.sql.CHAR</code> class is used by Oracle JDBC in handling and converting character data. This class provides the Globalization Support functionality to convert character data. This class has two key attributes: Globalization Support character set and the character data. The Globalization Support character set defines the encoding of the character data. It is a parameter that is always passed when a <code>CHAR</code> object is constructed. Without the Globalization Support character set information, the data bytes in the <code>CHAR</code> object are meaningless. The <code>oracle.sql.CHAR</code> class is used for both SQL <code>CHAR</code> and SQL <code>NCHAR</code> data types.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In versions of Oracle JDBC drivers prior to 10<span class="italic">g</span> Release 1, there were performance advantages to using the <code>oracle.SQL.CHAR</code>. Starting from Oracle Database 10<span class="italic">g</span>, there are no longer any such advantages. In fact, optimum performance is achieved using the <code>java.lang.String</code>. All Oracle JDBC drivers handle all character data in the Java UCS2 character set. Using the <code>oracle.sql.CHAR</code> does not prevent conversions between the database character set and UCS2 character set.</div>
<p>The only remaining use of the <code>oracle.sql.CHAR</code> class is to handle character data in the form of raw bytes encoded in an Oracle Globalization Support character set. All character data retrieved from Oracle Database should be accessed using the <code>java.lang.String</code> class. When processing byte data from another source, you can use an <code>oracle.sql.CHAR</code> to convert the bytes to <code>java.lang.String</code>.</p>
<p>To convert an <code>oracle.sql.CHAR</code>, you must provide the data bytes and an <code>oracle.sql.CharacterSet</code> instance that represents the Globalization Support character set used to encode the data bytes.</p>
<p>The <code>CHAR</code> objects that are Oracle object attributes are returned in the database character set.</p>
<p>JDBC application code rarely needs to construct <code>CHAR</code> objects directly, because the JDBC driver automatically creates <code>CHAR</code> objects, when it is needed to create them on those rare occasions.</p>
<p>To construct a <code>CHAR</code> object, you must provide character set information to the <code>CHAR</code> object by way of an instance of the <code><a id="sthref154"></a>CharacterSet</code> class. Each instance of this class represents one of the Globalization Support character sets that Oracle supports. A <code>CharacterSet</code> instance encapsulates methods and attributes of the character set, mainly involving functionality to convert to or from other character sets.</p>
<p class="subhead2"><a id="JJDBC28145"></a>Constructing an oracle.sql.CHAR Object</p>
<p>Follow these general steps to construct a <code>CHAR</code> object:</p>
<ol>
<li>
<p>Create a <code>CharacterSet</code> object by calling the <code>static</code> <code>CharacterSet.make</code> method.</p>
<p>This method is a factory for the character set instance. The <code><a id="sthref155"></a>make</code> method takes an integer as input, which corresponds to a character set ID that Oracle supports. For example:</p>
<pre>int oracleId = CharacterSet.JA16SJIS_CHARSET; // this is character set ID,
                                              // 832
...
CharacterSet mycharset = CharacterSet.make(oracleId);
</pre>
<p>Each character set that Oracle supports has a unique, predefined Oracle ID.</p>
</li>
<li>
<p>Construct a <code>CHAR</code> object.</p>
<p>Pass a string, or the bytes that represent the string, to the constructor along with the <code>CharacterSet</code> object that indicates how to interpret the bytes based on the character set. For example:</p>
<pre>String mystring = &#34;teststring&#34;;
...
CHAR mychar = new CHAR(teststring, mycharset);
</pre>
<p>There are multiple constructors for <code>CHAR</code>, which can take a <code>String</code>, a <code>byte</code> array, or an object as input along with the <code>CharacterSet</code> object. In the case of a <code>String</code>, the string is converted to the character set indicated by the <code>CharacterSet</code> object before being placed into the <code>CHAR</code> object.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The <code>CharacterSet</code> object cannot be a null value.</p>
</li>
<li>
<p>The <code>CharacterSet</code> class is an abstract class, therefore it has no constructor. The only way to create instances is to use the <code>make</code> method.</p>
</li>
<li>
<p>The server recognizes the special value <code>CharacterSet.<a id="sthref156"></a>DEFAULT_CHARSET</code> as the database character set. For the client, this value is not meaningful.</p>
</li>
<li>
<p>Oracle does not intend or recommend that users extend the <code>CharacterSet</code> class.</p>
</li>
</ul>
</div>
</li>
</ol>
<p class="subhead2"><a id="JJDBC28146"></a>oracle.sql.CHAR Conversion Methods</p>
<p>The <code>CHAR</code> class provides the following methods for translating character data to strings:</p>
<ul>
<li>
<p><code><a id="sthref157"></a><a id="sthref158"></a>getString</code></p>
<p>This method converts the sequence of characters represented by the <code>CHAR</code> object to a string, returning a Java <code>String</code> object. If you enter an invalid <code>OracleID</code>, then the character set will not be recognized and the <code>getString</code> method will throw a <code>SQLException</code> exception.</p>
</li>
<li>
<p><code><a id="sthref159"></a><a id="sthref160"></a>toString</code></p>
<p>This method is identical to the <code>getString</code> method. But if you enter an invalid <code>OracleID</code>, then the character set will not be recognized and the <code>toString</code> method will return a hexadecimal representation of the <code>CHAR</code> data and will <span class="italic">not</span> throw a <code>SQLException</code> exception.</p>
</li>
<li>
<p><code><a id="sthref161"></a><a id="sthref162"></a>getStringWithReplacement</code></p>
<p>This method is identical to the <code>getString</code> method, except a default replacement character replaces characters that have no unicode representation in the <code>CHAR</code> object character set. This default character varies from character set to character set, but is often a question mark (<code>?</code>).</p>
</li>
</ul>
<p>The database server and the client, or application running on the client, can use different <a id="sthref163"></a>character sets. When you use the methods of the <code>CHAR</code> class to transfer data between the server and the client, the JDBC drivers must convert the data from the server character set to the client character set or vice versa. To convert the data, the drivers use Globalization Support.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="global.htm#CHDGGECB">Chapter 19, &#34;Globalization Support&#34;</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1063951"></a>
<div id="JJDBC28148" class="sect1">
<h2 class="sect1">Additional Oracle Type Extensions</h2>
<p>Oracle JDBC drivers support the Oracle-specific <code>BFILE</code> and <code>ROWID</code> data types and <code>REF</code> <code>CURSOR</code> types, which are not part of the standard JDBC specification. This section describes the <code>ROWID</code> and <code>REF CURSOR</code> type extensions. The <code>ROWID</code> is supported as a Java string, and <code>REF</code> <code>CURSOR</code> types are supported as JDBC result sets.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1058701">Oracle ROWID Type</a></p>
</li>
<li>
<p><a href="#i1058743">Oracle REF CURSOR Type Category</a></p>
</li>
<li>
<p><a href="#BABIJFGJ">Oracle BINARY_FLOAT and BINARY_DOUBLE Types</a></p>
</li>
<li>
<p><a href="#CHDEBICE">Oracle SYS.ANYTYPE and SYS.ANYDATA Types</a></p>
</li>
<li>
<p><a href="#i1073534">The oracle.jdbc Package</a></p>
</li>
</ul>
<a id="i1058701"></a>
<div id="JJDBC28149" class="sect2">
<h3 class="sect2">Oracle ROWID Type</h3>
<p>A <a id="sthref164"></a>ROWID is an identification tag unique for each row of an Oracle Database table. The ROWID can be thought of as a virtual column, containing the ID for each row.</p>
<p>The <code><a id="sthref165"></a>oracle.sql.ROWID</code> class is supplied as a container for <code>ROWID</code> SQL data type.</p>
<p>ROWIDs provide functionality similar to the <code>getCursorName</code> method specified in the <code>java.sql.ResultSet</code> interface and the <code>setCursorName</code> method specified in the <code>java.sql.Statement</code> interface.</p>
<p>If you include the ROWID pseudo-column in a query, then you can retrieve the ROWIDs with the result set <code><a id="sthref166"></a>getString</code> method. You can also bind a ROWID to a <code>PreparedStatement</code> parameter with the <code><a id="sthref167"></a>setString</code> method. This enables in-place updating, as in the example that follows.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use the <code>oracle.sql.ROWID</code> class, only when you are using J2SE 5.0. For JSE 6, you should use the standard <code>java.sql.RowId</code> interface instead.</div>
<p class="subhead2"><a id="JJDBC28150"></a>Example</p>
<p>The following example shows how to access and manipulate ROWID data:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following example works only with JSE 6.</div>
<pre>Statement stmt = conn.createStatement(); 

// Query the employee names with &#34;FOR UPDATE&#34; to lock the rows. 
// Select the ROWID to identify the rows to be updated. 

ResultSet rset =  
   stmt.executeQuery (&#34;SELECT first_name, rowid FROM employees FOR UPDATE&#34;); 

// Prepare a statement to update the first_name column at a given ROWID 

PreparedStatement pstmt = 
   conn.prepareStatement (&#34;UPDATE employees SET first_name = ? WHERE rowid = ?&#34;); 

// Loop through the results of the query 
while (rset.next ()) 
{ 
    String ename = rset.getString (1); 
 RowId rowid = rset.getROWID(2); // Get the ROWID as a String 
    pstmt.setString (1, ename.toLowerCase ()); 
    pstmt.setROWID (2, rowid); // Pass ROWID to the update statement 
    pstmt.executeUpdate ();     // Do the update 
} 
</pre></div>
<!-- class="sect2" -->
<a id="i1058743"></a>
<div id="JJDBC28151" class="sect2">
<h3 class="sect2">Oracle REF CURSOR Type Category</h3>
<p>A cursor variable holds the memory location of a query work area, rather than the contents of the area. Declaring a cursor variable creates a pointer. In SQL, a pointer has the data type <code>REF</code> <code><span class="codeinlineitalic">x</span></code>, where <code>REF</code> is short for <code>REFERENCE</code> and <code><span class="codeinlineitalic">x</span></code> represents the entity being referenced. A <code>REF CURSOR</code>, then, identifies a reference to a cursor variable. Because many cursor variables might exist to point to many work areas, <code>REF</code> <code>CURSOR</code> can be thought of as a category or data type specifier that identifies many different types of cursor variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>REF CURSOR</code> instances are not scrollable.</div>
<p>To create a cursor variable, begin by identifying a type that belongs to the <code>REF</code> <code>CURSOR</code> category. For example:</p>
<pre>DECLARE TYPE DeptCursorTyp IS REF CURSOR
</pre>
<p>Then, create the cursor variable by declaring it to be of the type <code>DeptCursorTyp</code>:</p>
<pre>dept_cv DeptCursorTyp  - - declare cursor variable
...
 
</pre>
<p><code>REF</code> <code>CURSOR</code>, then, is a category of data types, rather than a particular data type.</p>
<p>Stored procedures can return cursor variables of the <a id="sthref168"></a><code>REF</code> <code>CURSOR</code> category. This output is equivalent to a database cursor or a JDBC result set. A <code>REF CURSOR</code> essentially encapsulates the results of a query.</p>
<p>In JDBC, <code><a id="sthref169"></a></code>a <code>REF CURSOR</code> is materialized as a <code>ResultSet</code> object and can be accessed as follows:</p>
<ol>
<li>
<p>Use a JDBC callable statement to call a stored procedure. It must be a callable statement, as opposed to a prepared statement, because there is an output parameter.</p>
</li>
<li>
<p>The stored procedure returns a <code>REF CURSOR</code>.</p>
</li>
<li>
<p>The Java application casts the callable statement to an Oracle callable statement and uses the <code><a id="sthref170"></a>getCursor</code> method of the <code>OracleCallableStatement</code> class to materialize the <code>REF CURSOR</code> as a JDBC <code>ResultSet</code> object.</p>
</li>
<li>
<p>The result set is processed as requested.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
The cursor associated with a <code>REF CURSOR</code> is closed whenever the statement object that produced the <code>REF CURSOR</code> is closed.
<p>Unlike in past releases, the cursor associated with a <code>REF CURSOR</code> is <span class="italic">not</span> closed when the result set object in which the <code>REF CURSOR</code> was materialized is closed.</p>
</div>
</li>
</ol>
<p class="subhead2"><a id="JJDBC28152"></a>Example</p>
<p>This example shows how to access <code>REF CURSOR</code> data.</p>
<pre>import oracle.jdbc.*;
...
CallableStatement cstmt;
ResultSet cursor;

// Use a PL/SQL block to open the cursor
cstmt = conn.prepareCall
         (&#34;begin open ? for select first_name from employees; end;&#34;);

cstmt.registerOutParameter(1, OracleTypes.CURSOR);
cstmt.execute();
cursor = ((OracleCallableStatement)cstmt).getCursor(1);

// Use the cursor like a standard ResultSet
while (cursor.next ())
    {System.out.println (cursor.getString(1));} 
</pre>
<p>In the preceding example:</p>
<ul>
<li>
<p>A <code>CallableStatement</code> object is created by using the <code>prepareCall</code> method of the connection class.</p>
</li>
<li>
<p>The callable statement implements a PL/SQL procedure that returns a <code>REF CURSOR</code>.</p>
</li>
<li>
<p>As always, the output parameter of the callable statement must be registered to define its type. Use the type code <code><a id="sthref171"></a>OracleTypes.CURSOR</code> for a <code>REF CURSOR</code>.</p>
</li>
<li>
<p>The callable statement is run, returning the <code>REF CURSOR</code>.</p>
</li>
<li>
<p>The <code>CallableStatement</code> object is cast to <code>OracleCallableStatement</code> to use the <code><a id="sthref172"></a>getCursor</code> method, which is an Oracle extension to the standard JDBC API, and returns the <code>REF CURSOR</code> into a <code>ResultSet</code> object.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABIJFGJ"></a>
<div id="JJDBC28153" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle BINARY_FLOAT and BINARY_DOUBLE Types</h3>
<p>The Oracle <code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code> types are used to store IEEE 574 float and double data. These correspond to the Java <code>float</code> and <code>double</code> scalar types with the exception of negative zero and <code>NaN</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00209" href="../SQLRF/sql_elements001.htm#SQLRF00209"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
<p>If you include a <code>BINARY_DOUBLE</code> column in a query, then the data is retrieved from the database in the binary format. Also, the <code>getDouble</code> method will return the data in the binary format. In contrast, for a <code>NUMBER</code> data type column, the number bits are returned and converted to the Java <code>double</code> data type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle representation for the SQL <code>FLOAT</code>, <code>DOUBLE PRECISION</code>, and <code>REAL</code> data types use the Oracle <code>NUMBER</code> representation. The <code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code> data types can be regarded as proprietary types.</div>
<p>A call to the JDBC standard <code>setDouble(int, double)</code> method of the <code>PreparedStatement</code> interface converts the Java <code>double</code> argument to Oracle <code>NUMBER</code> style bits and send them to the database. In contrast, the <code>setBinaryDouble(int, double)</code> method of the <code>oracle.jdbc.OraclePreparedStatement</code> interface converts the data to the internal binary bits and sends them to the database.</p>
<p>You must ensure that the data format used matches the type of the target parameter of the <code>PreparedStatement</code> interface. This will result in correct data and least use of CPU. If you use <code>setBinaryDouble</code> for a <code>NUMBER</code> parameter, then the binary bits are sent to the server and converted to <code>NUMBER</code> format. The data will be correct, but server CPU load will be increased. If you use <code>setDouble</code> for a <code>BINARY_DOUBLE</code> parameter, then the data will first be converted to <code>NUMBER</code> bits on the client and sent to the server, where it will be converted back to binary format. This will increase the CPU load on both client and server and can result in data corruption as well.</p>
<p>The <code>SetFloatAndDoubleUseBinary</code> connection property when set to <code>true</code> causes the JDBC standard APIs, <code>setFloat(int,</code> <code>float)</code>, <code>setDouble(int,</code> <code>double)</code>, and all the variations, to send internal binary bits instead of <code>NUBMER</code> bits.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although this section largely discusses <code>BINARY_DOUBLE</code>, the same is true for <code>BINARY_FLOAT</code> as well.</div>
</div>
<!-- class="sect2" -->
<a id="CHDEBICE"></a>
<div id="JJDBC28154" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle SYS.ANYTYPE and SYS.ANYDATA Types</h3>
<p>Oracle Database 12<span class="italic">c</span> Release 1 (12.1) provides a Java interface to access the <a id="sthref173"></a><a id="sthref174"></a><code>SYS.ANYTYPE</code> and <a id="sthref175"></a><a id="sthref176"></a><code>SYS.ANYDATA</code> Oracle types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For information about these Oracle types, refer <a class="olink ARPLS" href="../ARPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></div>
<p>An instance of the <code>SYS.ANYTYPE</code> type contains a type description of any SQL type, persistent or transient, named or unnamed, including object types and collection types. You can use the <code>oracle.sql.TypeDescriptor</code> class to access the <code>SYS.ANYTYPE</code> type. An <code>ANYTYPE</code> instance can be retrieved from a PL/SQL procedure or a SQL <code>SELECT</code> statement where <code>SYS.ANYTYPE</code> is used as a column type. To retrieve an <code>ANYTYPE</code> instance from the database, use the <code>getObject</code> method. This method returns an instance of the <code>TypeDescriptor</code>.</p>
<p>The retrieved <code>ANYTYPE</code> instance could be any of the following:</p>
<ul>
<li>
<p>Transient object type</p>
</li>
<li>
<p>Transient predefined type</p>
</li>
<li>
<p>Persistent object type</p>
</li>
<li>
<p>Persistent predefined type</p>
</li>
</ul>
<div id="JJDBC28155" class="example">
<p class="titleinexample"><a id="sthref177"></a>Example 4-1 Accessing SYS.ANYTYPE Type</p>
<p>The following code snippet illustrates how to retrieve an instance of <code>ANYTYPE</code> from the database:</p>
<pre>...
ResultSet rs = stmt.executeQuery(&#34;select anytype_column from my_table&#34;);
TypeDescriptor td = (TypeDescriptor)rs.getObject(1);
short typeCode = td.getInternalTypeCode();
if(typeCode == TypeDescriptor.TYPECODE_OBJECT)
{
  // check if it&#39;s a transient type
  if(td.isTransientType())
  {
    AttributeDescriptor[] attributes = ((StructDescriptor)td).getAttributesDescriptor();
    for(int i=0; i&lt;attributes.length; i++)
      System.out.println(attributes[i].getAttributeName());
  }
  else
  {    System.out.println(td.getTypeName());  }}
...
</pre></div>
<!-- class="example" -->
<div id="JJDBC28156" class="example">
<p class="titleinexample"><a id="sthref178"></a>Example 4-2 Creating a Transient Object Type Through PL/SQL and Retrieving Through JDBC</p>
<p>This example provides a code snippet illustrating how to retrieve a transient object type through JDBC.</p>
<pre>...
OracleCallableStatement cstmt = (OracleCallableStatement)conn.prepareCall
  (&#34;BEGIN ? := transient_obj_type (); END;&#34;);
cstmt.registerOutParameter(1,OracleTypes.OPAQUE,&#34;SYS.ANYTYPE&#34;);
cstmt.execute();
TypeDescriptor obj = (TypeDescriptor)cstmt.getObject(1);
if(!obj.isTransient())
  System.out.println(&#34;This must be a JDBC bug&#34;);
cstmt.close();
return obj;
...
</pre></div>
<!-- class="example" -->
<div id="JJDBC28157" class="example">
<p class="titleinexample"><a id="sthref179"></a>Example 4-3 Calling a PL/SQL Stored Procedure That Takes an ANYTPE as IN Parameter</p>
<p>The following code snippet illustrates how to call a PL/SQL stored procedure that takes an <code>ANYTYPE</code> as <code>IN</code> parameter:</p>
<pre>...
CallableStatement cstmt = conn.prepareCall(&#34;BEGIN ? := dumpanytype(?); END;&#34;);
cstmt.registerOutParameter(1,OracleTypes.VARCHAR);
// obj is the instance of TypeDescriptor that you have retrieved
cstmt.setObject(2,obj);
cstmt.execute();
String str = (String)cstmt.getObject(1);
...
</pre></div>
<!-- class="example" -->
<p>The <code>oracle.sql.ANYDATA</code> class enables you to access <code>SYS.ANYDATA</code> instances from the database. An instance of this class can be obtained from any valid instance of <code>oracle.sql.Datum</code> class. The <code>convertDatum</code> factory method takes an instance of <code>Datum</code> and returns an instance of <code>ANYDATA</code>. The syntax for this factory method is as follows:</p>
<pre>public static ANYDATA convertDatum(Datum datum) throws SQLException
</pre>
<p>The following is sample code for creating an instance of <code>oracle.sql.ANYDATA</code>:</p>
<pre>// struct is a valid instance of oracle.sql.STRUCT that either comes from the 
// database or has been constructed in Java.
ANYDATA myAnyData = ANYDATA.convertDatum(struct);
</pre>
<div id="JJDBC28158" class="example">
<p class="titleinexample"><a id="sthref180"></a>Example 4-4 Accessing an Instance of ANYDATA from the Database</p>
<pre>...
// anydata_table has been created as:
// CREATE TABLE anydata_tab (data SYS.ANYDATA)
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(&#34;select data from my_anydata_tab&#34;);
while(rs.next())
{
  ANYDATA anydata = (ANYDATA)rs.getObject(1);
  if(!anydata.isNull())
  {
    TypeDescriptor td = anydata.getTypeDescriptor();
    if(td.getTypeCode() == OracleType.TYPECODE_OBJECT)
      STRUCT struct = (STRUCT)anydata.accessDatum();
  }
}
...
</pre></div>
<!-- class="example" -->
<div id="JJDBC28159" class="example">
<p class="titleinexample"><a id="sthref181"></a>Example 4-5 Inserting an Object as ANYDATA in a Database Table</p>
<p>Consider the following table and object type definition:</p>
<pre>CREATE TABLE anydata_tab ( id NUMBER, data SYS.ANYDATA)

CREATE OR REPLACE TYPE employee AS OBJECT ( employee_id NUMBER, first_name VARCHAR2(10) )
</pre>
<p>You can create an instance of the <code>EMPLOYEE</code> SQL object type and to insert it into <code>anydata_tab</code>le in the following way:</p>
<pre>...
PreparedStatement pstmt = conn.prepareStatement(&#34;insert into anydata_table values (?,?)&#34;);
Struct myEmployeeStr = conn.createStruct(&#34;EMPLOYEE&#34;, new Object[]{1120, &#34;Papageno&#34;});
ANYDATA anyda = ANYDATA.convertDatum(myEmployeeStr);
pstmt.setInt(1,123);
pstmt.setObject(2,anyda);
pstmt.executeUpdate();
...
</pre></div>
<!-- class="example" -->
<div id="JJDBC28160" class="example">
<p class="titleinexample"><a id="sthref182"></a>Example 4-6 Selecting an ANYDATA Column from a Database Table</p>
<pre>...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(&#34;select data from anydata_table&#34;);
while(rs.next())
{
  ANYDATA obj = (ANYDATA)rs.getObject(1);
  TypeDescriptor td = obj.getTypeDescriptor();
}
rs.close();
stmt.close();
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1073534"></a>
<div id="JJDBC28161" class="sect2">
<h3 class="sect2">The oracle.jdbc Package</h3>
<p>The interfaces of the <code><a id="sthref183"></a>oracle.jdbc</code> package define the Oracle extensions to the interfaces in <code>java.sql</code>. These extensions provide access to SQL-format data as described in this chapter. They also provide access to other Oracle-specific functionality, including Oracle performance enhancements.</p>
<p>For the <code>oracle.jdbc</code> package, <a href="#g1076271">Table 4-1</a> lists key interfaces and classes used for connections, statements, and result sets.</p>
<div id="JJDBC28162" class="tblformal">
<p class="titleintable"><a id="sthref184"></a><a id="g1076271"></a>Table 4-1 Key Interfaces and Classes of the oracle.jdbc Package</p>
<table class="cellalignment2244" title="Key Interfaces and Classes of the oracle.jdbc Package " summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t37">Name</th>
<th class="cellalignment2245" id="r1c2-t37">Interface or Class</th>
<th class="cellalignment2245" id="r1c3-t37">Key Functionality</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t37" headers="r1c1-t37">
<p><code>OracleDriver</code></p>
</td>
<td class="cellalignment2246" headers="r2c1-t37 r1c2-t37">
<p>Class</p>
</td>
<td class="cellalignment2246" headers="r2c1-t37 r1c3-t37">
<p>Implements <code>java.sql.Driver</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r3c1-t37" headers="r1c1-t37">
<p><code>OracleConnection</code></p>
</td>
<td class="cellalignment2246" headers="r3c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r3c1-t37 r1c3-t37">
<p>Provides methods to start and stop an Oracle Database instance and to return Oracle statement objects and methods to set Oracle performance extensions for any statement run in the current connection.</p>
<p>Implements <code>java.sql.Connection.</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r4c1-t37" headers="r1c1-t37">
<p><code>OracleStatement</code></p>
</td>
<td class="cellalignment2246" headers="r4c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r4c1-t37 r1c3-t37">
<p>Provides methods to set Oracle performance extensions for individual statement.</p>
<p>Is a supertype of <code>OraclePreparedStatement</code> and <code>OracleCallableStatement</code>.</p>
<p>Implements <code>java.sql.Statement.</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r5c1-t37" headers="r1c1-t37">
<p><code>OraclePreparedStatement</code></p>
</td>
<td class="cellalignment2246" headers="r5c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r5c1-t37 r1c3-t37">
<p>Provides <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods to bind <code>oracle.sql.*</code> types into a prepared statement.</p>
<p>Provides <code>getMetaData</code> method to get the metadata from the prepared statements without executing the SELECT statements.</p>
<p>Implements <code>java.sql.PreparedStatement.</code></p>
<p>Extends <code>OracleStatement.</code></p>
<p>Is a supertype of <code>OracleCallableStatement</code>.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r6c1-t37" headers="r1c1-t37">
<p><code>OracleCallableStatement</code></p>
</td>
<td class="cellalignment2246" headers="r6c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r6c1-t37 r1c3-t37">
<p>Provides <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods to retrieve data in <code>oracle.sql</code> format and <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods to bind <code>oracle.sql.*</code> types into a callable statement.</p>
<p>Implements <code>java.sql.CallableStatement.</code></p>
<p>Extends <code>OraclePreparedStatement.</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r7c1-t37" headers="r1c1-t37">
<p><code>OracleResultSet</code></p>
</td>
<td class="cellalignment2246" headers="r7c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r7c1-t37 r1c3-t37">
<p>Provides <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods to retrieve data in <code>oracle.sql</code> format.</p>
<p>Implements <code>java.sql.ResultSet</code>.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r8c1-t37" headers="r1c1-t37">
<p><code>OracleResultSetMetaData</code></p>
</td>
<td class="cellalignment2246" headers="r8c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r8c1-t37 r1c3-t37">
<p>Provides methods to get metadata information about Oracle result sets, such as column names and data types.</p>
<p>Implements <code>java.sql.ResultSetMetaData</code>.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r9c1-t37" headers="r1c1-t37">
<p><code>OracleDatabaseMetaData</code></p>
</td>
<td class="cellalignment2246" headers="r9c1-t37 r1c2-t37">
<p>Class</p>
</td>
<td class="cellalignment2246" headers="r9c1-t37 r1c3-t37">
<p>Provides methods to get metadata information about the database, such as database product name and version, table information, and default transaction isolation level.</p>
<p>Implements <code>java.sql.DatabaseMetaData</code>).</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r10c1-t37" headers="r1c1-t37">
<p><code>OracleTypes</code></p>
</td>
<td class="cellalignment2246" headers="r10c1-t37 r1c2-t37">
<p>Class</p>
</td>
<td class="cellalignment2246" headers="r10c1-t37 r1c3-t37">
<p>Defines integer constants used to identify SQL types.</p>
<p>For standard types, it uses the same values as the standard <code>java.sql.Types</code> class. In addition, it adds constants for Oracle extended types.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r11c1-t37" headers="r1c1-t37">
<p><code>OracleArray</code></p>
</td>
<td class="cellalignment2246" headers="r11c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r11c1-t37 r1c3-t37">
<p>Includes functionality to retrieve the array as a whole, retrieve a subset of the array elements, and retrieve the SQL base type name of the array elements.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r12c1-t37" headers="r1c1-t37">
<p><code>OracleStruct</code></p>
</td>
<td class="cellalignment2246" headers="r12c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r12c1-t37 r1c3-t37">&nbsp;</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r13c1-t37" headers="r1c1-t37">
<p><code>OracleClob</code></p>
</td>
<td class="cellalignment2246" headers="r13c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r13c1-t37 r1c3-t37">&nbsp;</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r14c1-t37" headers="r1c1-t37">
<p><code>OracleBlob</code></p>
</td>
<td class="cellalignment2246" headers="r14c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r14c1-t37 r1c3-t37">&nbsp;</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r15c1-t37" headers="r1c1-t37">
<p><code>OracleRef</code></p>
</td>
<td class="cellalignment2246" headers="r15c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r15c1-t37 r1c3-t37">&nbsp;</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r16c1-t37" headers="r1c1-t37">
<p><code>OracleOpaque</code></p>
</td>
<td class="cellalignment2246" headers="r16c1-t37 r1c2-t37">
<p>Interface</p>
</td>
<td class="cellalignment2246" headers="r16c1-t37 r1c3-t37">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABFCJHI">Interface oracle.jdbc.OracleConnection</a></p>
</li>
<li>
<p><a href="#BABIGCBI">Interface oracle.jdbc.OracleStatement</a></p>
</li>
<li>
<p><a href="#CHDIIDBE">Interface oracle.jdbc.OraclePreparedStatement</a></p>
</li>
<li>
<p><a href="#CHDBGJFG">Interface oracle.jdbc.OracleCallableStatement</a></p>
</li>
<li>
<p><a href="#BABIGIDG">Interface oracle.jdbc.OracleResultSet</a></p>
</li>
<li>
<p><a href="#BABFBEDH">Interface oracle.jdbc.OracleResultSetMetaData</a></p>
</li>
<li>
<p><a href="#i1070789">Class oracle.jdbc.OracleTypes</a></p>
</li>
</ul>
<a id="BABFCJHI"></a>
<div id="JJDBC28163" class="sect3">
<h4 class="sect3">Interface oracle.jdbc.OracleConnection</h4>
<p><a id="sthref185"></a><a id="sthref186"></a>This interface extends standard JDBC connection functionality to create and return Oracle statement objects, set flags and options for Oracle performance extensions, support type maps for Oracle objects, and support client identifiers.</p>
<p>In Oracle Database 11<span class="italic">g</span> Release 1, new methods were added to this interface that enable the starting up and shutting down of an Oracle Database instance. Also, for better visibility and clarity, all connection properties are defined as constants in the <code>OracleConnection</code> interface.</p>
<p>This interface also defines factory methods for constructing <code>oracle.sql</code> data values like <code>DATE</code> and <code>NUMBER</code>. Remember the following points while using factory methods:</p>
<ul>
<li>
<p>All code that constructs instances of the <code>oracle.sql</code> types should use the Oracle extension factory methods. For example, <code>ARRAY</code>, <code>BFILE</code>, <code>DATE</code>, <code>INTERVALDS</code>, <code>NUMBER</code>, <code>STRUCT</code>, <code>TIME</code>, <code>TIMESTAMP</code>, and so on.</p>
</li>
<li>
<p>All code that constructs instances of the standard types should use the JDBC 4.0 standard factory methods. For example, <code>CLOB</code>, <code>BLOB</code>, <code>NCLOB</code>, and so on.</p>
</li>
<li>
<p>There are no factory methods for <code>CHAR</code>, <code>JAVA_STRUCT</code>, <code>ArrayDescriptor</code>, and <code>StructDescriptor.</code> These types are for internal driver use only.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to Oracle Database 11<span class="italic">g</span> Release 1, you had to construct <code>ArrayDescriptors</code> and <code>StructDescriptors</code> for passing as arguments to the <code>ARRAY</code> and <code>STRUCT</code> class constructors. The new <code>ARRAY</code> and <code>Struct</code> factory methods do not have any descriptor arguments. The driver still uses descriptors internally, but you do not need to create them.</div>
</li>
</ul>
<p class="subhead2"><a id="JJDBC28164"></a>Client Identifiers</p>
<p>In a connection pooling environment, the client identifier can be used to identify the lightweight user using the database session currently. A client identifier can also be used to share the Globally Accessed Application Context between different database sessions. The client identifier set in a database session is audited when database auditing is turned on.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Development Guide</span></a> and <a class="olink JAJDB" href="../JAJDB/toc.htm"><span class="italic">Oracle Database JDBC Java API Reference</span></a></div>
</div>
<!-- class="sect3" -->
<a id="BABIGCBI"></a>
<div id="JJDBC28165" class="sect3">
<h4 class="sect3">Interface oracle.jdbc.OracleStatement</h4>
<p><a id="sthref187"></a><a id="sthref188"></a>This interface extends standard JDBC statement functionality and is the superinterface of the <code>OraclePreparedStatement</code> and <code>OracleCallableStatement</code> classes. Extended functionality includes support for setting flags and options for Oracle performance extensions on a statement-by-statement basis, as opposed to the <code>OracleConnection</code> interface that sets these on a connectionwide basis.</p>
</div>
<!-- class="sect3" -->
<a id="CHDIIDBE"></a>
<div id="JJDBC28166" class="sect3">
<h4 class="sect3">Interface oracle.jdbc.OraclePreparedStatement</h4>
<p><a id="sthref189"></a><a id="sthref190"></a>This interface extends the <code>OracleStatement</code> interface and extends standard JDBC prepared statement functionality. Also, the <code>oracle.jdbc.OraclePreparedStatement</code> interface is extended by the <code>OracleCallableStatement</code> interface. Extended functionality consists of the following:</p>
<ul>
<li>
<p><code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods for binding <code>oracle.sql.*</code> types and objects to prepared statements</p>
</li>
<li>
<p><code>getMetaData</code> method to get the metadata from the prepared statements without executing the SELECT statements</p>
</li>
<li>
<p>Methods to support Oracle performance extensions on a statement-by-statement basis</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not use the <code>PreparedStatement</code> interface to create a trigger that refers to a<code>:NEW</code> or <code>:OLD</code> column. Use <code>Statement</code> instead. Using <code>PreparedStatement</code> will cause execution to fail with the message <code>java.sql.SQLException: Missing IN or OUT parameter at index:: 1</code>.</div>
</div>
<!-- class="sect3" -->
<a id="CHDBGJFG"></a>
<div id="JJDBC28167" class="sect3">
<h4 class="sect3">Interface oracle.jdbc.OracleCallableStatement</h4>
<p><a id="sthref191"></a><a id="sthref192"></a>This interface extends the <code>OraclePreparedStatement</code> interface, which extends the <code>OracleStatement</code> interface and incorporates standard JDBC callable statement functionality.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not use the <code>CallableStatement</code> interface to create a trigger that refers to a<code>:NEW</code> or <code>:OLD</code> column. Use <code>Statement</code> instead; using <code>CallableStatement</code> will cause execution to fail with the message <code>java.sql.SQLException: Missing IN or OUT parameter at index::1</code></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>(String,...)</code> and <code>registerOutParameter(String,...)</code> methods can be used only if all binds are procedure or function parameters only. The statement can contain no other binds and the parameter binds must be indicated with a question mark (<code>?)</code> and not <code>:</code><code><span class="codeinlineitalic">XX</span></code>.</p>
</li>
<li>
<p>If you are using <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>(int,...) or</code> <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>AtName(String,...)</code> method, then any output parameter is bound with <code>registerOutParameter(int,...)</code> and not <code>registerOutParameter(String,...)</code>, which is for named parameter notation.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABIGIDG"></a>
<div id="JJDBC28168" class="sect3">
<h4 class="sect3">Interface oracle.jdbc.OracleResultSet</h4>
<p><a id="sthref193"></a><a id="sthref194"></a>This interface extends standard JDBC result set functionality, implementing <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods for retrieving data into <code>oracle.sql.*</code> objects.</p>
</div>
<!-- class="sect3" -->
<a id="BABFBEDH"></a>
<div id="JJDBC28169" class="sect3">
<h4 class="sect3">Interface oracle.jdbc.OracleResultSetMetaData</h4>
<p><a id="sthref195"></a><a id="sthref196"></a>This interface extends standard JDBC result set metadata functionality to retrieve information about Oracle <a id="sthref197"></a>result set objects.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="datacc.htm#i1059088">&#34;Using Result Set Metadata Extensions&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="i1070789"></a>
<div id="JJDBC28170" class="sect3">
<h4 class="sect3">Class oracle.jdbc.OracleTypes</h4>
<p><a id="sthref198"></a><a id="sthref199"></a>The <code>OracleTypes</code> class defines <a id="sthref200"></a><a id="sthref201"></a>constants that JDBC uses to identify SQL types. Each variable in this class has a constant integer value. The <code>oracle.jdbc.Or<a id="sthref202"></a><a id="sthref203"></a>acleTypes</code> class duplicates the type code definitions of the standard Java <code>java.sql.Types</code> class and contains these additional type codes for Oracle extensions:</p>
<ul>
<li>
<p><code>OracleTypes.BFILE</code></p>
</li>
<li>
<p><code>OracleTypes.ROWID</code></p>
</li>
<li>
<p><code>OracleTypes.CURSOR</code> (for <code>REF CURSOR</code> types)</p>
</li>
<li>
<p><code>OracleTypes.CHAR_BYTES</code> (for calling <code>setNull</code> and <code>setCHAR</code> methods on the same column)</p>
</li>
</ul>
<p>As in <code>java.sql.Types</code>, all the variable names are in uppercase text.</p>
<p>JDBC uses the SQL types identified by the elements of the <code>OracleTypes</code> class in two main areas: registering output parameters and in the <code>setNull</code> method of the <code>PreparedStatement</code> class.</p>
<p class="subhead2"><a id="JJDBC28171"></a>OracleTypes and Registering Output Parameters</p>
<p>The type codes in <code>java.sql.Types</code> or <code>oracle.jdbc.OracleTypes</code> identify the SQL types of the output parameters in the <code>registerOutParameter</code> method of the <code>java.sql.CallableStatement</code> and <code>oracle.jdbc.OracleCallableStatement</code> interfaces.</p>
<p>These are the forms that the <code>registerOutputParameter</code> method can take for the <code>CallableStatement</code> and <code>OracleCallableStatement</code> interfaces</p>
<pre>cs.registerOutParameter(int index, int sqlType);

cs.registerOutParameter(int index, int sqlType, String sql_name);

cs.registerOutParameter(int index, int sqlType, int scale);
</pre>
<p>In these signatures, <code>index</code> represents the parameter index, <code>sqlType</code> is the type code for the SQL data type, <code>sql_name</code> is the name given to the data type, for user-defined types, when <code>sqlType</code> is a <code>STRUCT</code>, <code>REF</code>, or <code>ARRAY</code> type code, and <code>scale</code> represents the number of digits to the right of the decimal point, when <code>sqlType</code> is a <code>NUMERIC</code> or <code>DECIMAL</code> type code.</p>
<p>The following example uses a <code>CallableStatement</code> interface to call a procedure named <code>charout</code>, which returns a <code>CHAR</code> data type. Note the use of the <code>OracleTypes.CHAR</code> type code in the <code>registerOutParameter</code> method.</p>
<pre>CallableStatement cs = conn.prepareCall (&#34;BEGIN charout (?); END;&#34;);
cs.registerOutParameter (1, OracleTypes.CHAR);
cs.execute ();
System.out.println (&#34;Out argument is: &#34; + cs.getString (1));
</pre>
<p>The next example uses a <code>CallableStatement</code> interface to call <code>structout</code>, which returns a <code>STRUCT</code> data type. The form of <code>registerOutParameter</code> requires you to specify the type code, <code>Types.STRUCT</code> or <code>OracleTypes.STRUCT</code>, as well as the SQL name, <code>EMPLOYEE</code>.</p>
<p>The example assumes that no type mapping has been declared for the <code>EMPLOYEE</code> type, so it is retrieved into a <code>STRUCT</code> data type. To retrieve the value of <code>EMPLOYEE</code> as an <code>oracle.sql.STRUCT</code> object, the statement object <code>cs</code> is cast to <code>OracleCallableStatement</code> and the Oracle extension <code>getSTRUCT</code> method is invoked.</p>
<pre>CallableStatement cs = conn.prepareCall (&#34;BEGIN structout (?); END;&#34;);
cs.registerOutParameter (1, OracleTypes.STRUCT, &#34;EMPLOYEE&#34;);
cs.execute ();

// get the value into a STRUCT because it 
// is assumed that no type map has been defined
STRUCT emp = ((OracleCallableStatement)cs).getSTRUCT (1);
</pre>
<p class="subhead2"><a id="JJDBC28172"></a>OracleTypes and the setNull Method</p>
<p>The type codes in <code>Types</code> and <code>OracleTypes</code> identify the SQL type of the data item, which the <code>setNull</code> method sets to <code>NULL</code>. The <code>setNull</code> method can be found in the <code>java.sql.PreparedStatement</code> and <code>oracle.jdbc.OraclePreparedStatement</code> interfaces.</p>
<p>These are the forms that the <code>setNull</code> method can take for the <code>PreparedStatement</code> and <code>OraclePreparedStatement</code> objects:</p>
<pre>ps.setNull(int index, int sqlType);

ps.setNull(int index, int sqlType, String sql_name);
</pre>
<p>In these signatures, <code>index</code> represents the parameter index, <code>sqlType</code> is the type code for the SQL data type, and <code>sql_name</code> is the name given to the data type, for user-defined types, when <code>sqlType</code> is a <code>STRUCT</code>, <code>REF</code>, or <code>ARRAY</code> type code. If you enter an invalid <code>sqlType</code>, a <code>ParameterTypeConflict</code> exception is thrown.</p>
<p>The following example uses a prepared statement to insert a null value into the database. Note the use of <code>OracleTypes.NUMERIC</code> to identify the numeric object set to <code>NULL</code>. Alternatively, <code>Types.NUMERIC</code> can be used.</p>
<pre>PreparedStatement pstmt =
    conn.prepareStatement (&#34;INSERT INTO num_table VALUES (?)&#34;);

pstmt.setNull (1, OracleTypes.NUMERIC);
pstmt.execute ();
</pre>
<p>In this example, the prepared statement inserts a <code>NULL</code> <code>STRUCT</code> object of type <code>EMPLOYEE</code> into the database.</p>
<pre>PreparedStatement pstmt = conn.prepareStatement 
                               (&#34;INSERT INTO employees VALUES (?)&#34;);

pstmt.setNull (1, OracleTypes.STRUCT, &#34;EMPLOYEE&#34;);
pstmt.execute ();
</pre>
<p>You can also use the <code>OracleTypes.CHAR_BYTES</code> type with the <code>setNull</code> method, if you also want to call the <code>setCHAR</code> method on the same column. For example:</p>
<pre> ps.setCHAR(n, aCHAR);
  ps.addBatch();
  ps.setNull(n, OracleTypes.CHAR_BYTES);
  ps.addBatch();
</pre>
<p>In this preceding example, any other type, apart from the <code>OracleTypes.CHAR_BYTES</code> type, will cause extra round trips to the Database. Alternatively, you can also write your code without using the <code>setNull</code> method. For example, you can also write your code as shown in the following example:</p>
<pre>ps.setCHAR(n, null);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFJDDG"></a>
<div id="JJDBC28174" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref204"></a>DML Returning</h2>
<p>The DML returning feature provides more functionality compared to retrieval of auto-generated keys. It can be used to retrieve not only auto-generated keys, but also other columns or values that the application may use.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The server-side internal driver does not support DML returning and retrieval of auto-generated keys.</p>
</li>
<li>
<p>You cannot use both DML returning and retrieval of auto-generated keys in the same statement.</p>
</li>
</ul>
</div>
<p>The following sections explain the support for DML returning:</p>
<ul>
<li>
<p><a href="#BABGDGCF">Oracle-Specific APIs</a></p>
</li>
<li>
<p><a href="#BABJJDDA">Running DML Returning Statements</a></p>
</li>
<li>
<p><a href="#BABHGJAA">Example of DML Returning</a></p>
</li>
<li>
<p><a href="#BABFCBHH">Limitations of DML Returning</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="jdbcvers.htm#CHDEGDHJ">&#34;Retrieval of Auto-Generated Keys&#34;</a></div>
<a id="BABGDGCF"></a>
<div id="JJDBC28175" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref205"></a>Oracle-Specific APIs</h3>
<p>The <code>OraclePreparedStatement</code> interface is enhanced with Oracle-specific application programming interfaces (APIs) to support DML returning. The <code>registerReturnParameter</code> and <code>getReturnResultSet</code> methods have been added to the <code>oracle.jdbc.OraclePreparedStatement</code> interface, to register parameters that are returned and data retrieved by DML returning.</p>
<p>The <code>registerReturnParameter</code> method is used to register the return parameter for DML returning. The method throws a <code>SQLException</code> instance if an error occurs. You must pass a positive integer specifying the index of the return parameter. You also must specify the type of the return parameter. You can also specify the maximum bytes or characters of the return parameter. This method can be used only with <code>char</code> or <code>RAW</code> types. You can also specify the fully qualified name of a SQL structure type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you do not know the maximum size of the return parameters, then you should use <code>registerReturnParameter(int paramIndex, int externalType)</code>, which picks the default maximum size. If you know the maximum size of return parameters, using <code>registerReturnParameter(int paramIndex, int externalType, int maxSize)</code> can reduce memory consumption.</div>
<p>The <code>getReturnResultSet</code> method fetches the data returned from DML returning and returns it as a <code>ResultSet</code> object. The method throws a <code>SQLException</code> exception if an error occurs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle-specific APIs for the DML returning feature are in <code>ojdbc6.jar</code> for Java Development Kit (JDK) 6.0 and in <code>ojdbc7.jar</code> for JDK 7.</div>
</div>
<!-- class="sect2" -->
<a id="BABJJDDA"></a>
<div id="JJDBC28176" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Running <a id="sthref206"></a>DML Returning Statements</h3>
<p>Before running a DML returning statement, the JDBC application must call one or more of the <code>registerReturnParameter</code> methods. The method provides the JDBC drivers with information, such as type and size, of the return parameters. The DML returning statement is then processed using one of the standard JDBC APIs, <code>executeUpdate</code> or <code>execute</code>. You can then fetch the returned parameters as a <code>ResultSet</code> object using the <code>getReturnResultSet</code> method of the <code>oracle.jdbc.OraclePreparedStatement</code> interface.</p>
<p>In order to read the values in the <code>ResultSet</code> object, the underlying <code>Statement</code> object must be open. When the underlying <code>Statement</code> object is closed, the returned <code>ResultSet</code> object is also closed. This is consistent with <code>ResultSet</code> objects that are retrieved by processing SQL query statements.</p>
<p>When a DML returning statement is run, the concurrency of the <code>ResultSet</code> object returned by the <code>getReturnResultSet</code> method must be <code>CONCUR_READ_ONLY</code> and the type of the <code>ResultSet</code> object must be <code>TYPE_FORWARD_ONLY</code> or <code>TYPE_SCROLL_INSENSITIVE</code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABHGJAA"></a>
<div id="JJDBC28177" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Example of <a id="sthref207"></a>DML Returning</h3>
<p>This section provides two code examples of DML returning.</p>
<p>The following code example illustrates the use of DML returning. In this example, assume that the maximum size of the <code>name</code> column is 100 characters. Because the maximum size of the <code>name</code> column is known, the <code>registerReturnParameter(int paramIndex, int externalType, int maxSize)</code> method is used.</p>
<pre>...
OraclePreparedStatement pstmt = (OraclePreparedStatement)conn.prepareStatement(
       &#34;delete from tab1 where age &lt; ? returning name into ?&#34;);
pstmt.setInt(1,18);

/** register returned parameter
  * in this case the maximum size of name is 100 chars
  */
pstmt.registerReturnParameter(2, OracleTypes.VARCHAR, 100);

// process the DML returning statement
count = pstmt.executeUpdate();
if (count&gt;0)
{
  ResultSet rset = pstmt.getReturnResultSet(); //rest is not null and not empty
  while(rset.next())
  {
    String name = rset.getString(1);
    ...
  }
}
...
</pre>
<p>The following code example also illustrates the use of DML returning. However, in this case, the maximum size of the return parameters is not known. Therefore, the <code>registerReturnParameter(int paramIndex, int externalType)</code> method is used.</p>
<pre>...
OraclePreparedStatement pstmt = (OraclePreparedStatement)conn.prepareStatement(
  &#34;insert into lobtab values (100, empty_clob()) returning col1, col2 into ?, ?&#34;);

// register return parameters
pstmt.registerReturnParameter(1, OracleTypes.INTEGER);
pstmt.registerReturnParameter(2, OracleTypes.CLOB);

// process the DML returning SQL statement
pstmt.executeUpdate();
ResultSet rset = pstmt.getReturnResultSet();
int r;
CLOB clob;
if (rset.next())
{
  r = rset.getInt(1);
  System.out.println(r);
  clob = (CLOB)rset.getClob(2);
  ...
}
...
</pre></div>
<!-- class="sect2" -->
<a id="BABFCBHH"></a>
<div id="JJDBC28178" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Limitations of <a id="sthref208"></a>DML Returning</h3>
<p>When using DML returning, be aware of the following:</p>
<ul>
<li>
<p>It is unspecified what the <code>getReturnResultSet</code> method returns when it is invoked more than once. You should not rely on any specific action in this regard.</p>
</li>
<li>
<p>The <code>ResultSet</code> objects returned from the execution of DML returning statements do not support the <code>ResultSetMetaData</code> type. Therefore, the applications must know the information of return parameters before running DML returning statements.</p>
</li>
<li>
<p>Streams are not supported with DML returning.</p>
</li>
<li>
<p>DML returning cannot be combined with batch update.</p>
</li>
<li>
<p>You cannot use both the auto-generated key feature and the DML returning feature in a single SQL DML statement. For example, the following is not allowed:</p>
<pre>...
PreparedStatement pstmt = conn.prepareStatement(&#39;insert into orders (?, ?, ?) returning order_id into ?&#34;);
pstmt.setInt(1, seq01.NEXTVAL);
pstmt.setInt(2, 100);
pstmt.setInt(3, 966431502);
pstmt.registerReturnParam(4, OracleTypes.INTEGER);
pstmt.executeUpdate;
ResultSet rset = pstmt.getGeneratedKeys;
...
</pre></li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBGDFA"></a>
<div id="JJDBC28179" class="sect1">
<h2 class="sect1">Accessing <a id="sthref209"></a>PL/SQL Associative Arrays</h2>
<p>Oracle JDBC drivers enable JDBC applications to make PL/SQL calls with Associative Arrays parameters. In PL/SQL, an Associative Array is a set of key-value pairs, where the keys may be <code>PLS_INTEGERs</code> or Strings. The keys may have any value and need not be dense. From a client application, you can work only with <code>PLS_INTEGER</code> keys that must be positive and dense.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Associative Arrays were previously known as index-by tables.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABDIEHE">Overview</a></p>
</li>
<li>
<p><a href="#BABCHCGF">Binding IN Parameters</a></p>
</li>
<li>
<p><a href="#BABDAIGD">Receiving OUT Parameters</a></p>
</li>
<li>
<p><a href="#BABJCCCH">Type Mappings</a></p>
</li>
</ul>
<a id="BABDIEHE"></a>
<div id="JJDBC28180" class="sect2">
<h3 class="sect2">Overview</h3>
<p>Oracle JDBC drivers support PL/SQL Associative Arrays of <code>VARCHAR</code> and <code>NUMBER</code> types. Typical Oracle JDBC input binding, output registration, and data access methods do not support PL/SQL Associative Arrays. This section discusses the additional methods to support these types.</p>
<p>The <code>OraclePreparedStatement</code> and <code>OracleCallableStatement</code> classes define the additional methods. These methods include the following:</p>
<ul>
<li>
<p><code><a id="sthref210"></a><a id="sthref211"></a><a id="sthref212"></a>setPlsqlIndexTable</code></p>
</li>
<li>
<p><code><a id="sthref213"></a><a id="sthref214"></a><a id="sthref215"></a>registerIndexTableOutParameter</code></p>
</li>
<li>
<p><code><a id="sthref216"></a><a id="sthref217"></a><a id="sthref218"></a>getOraclePlsqlIndexTable</code></p>
</li>
<li>
<p><code><a id="sthref219"></a><a id="sthref220"></a><a id="sthref221"></a>getPlsqlIndexTable</code></p>
</li>
</ul>
<p>These methods handle PL/SQL Associative Arrays as <code>IN</code>, <code>OUT</code>, or <code>IN OUT</code> parameters, including function return values.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use String data types, the size is limited to the size in PL/SQL that is 32767 characters. For the server-side internal driver, the limits are lower. Refer to the Javadoc for more information about these methods.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="BABCHCGF"></a>
<div id="JJDBC28182" class="sect2">
<h3 class="sect2">Binding IN Parameters</h3>
<p>To bind a PL/SQL Associative Array parameter in the <code><a id="sthref222"></a><a id="sthref223"></a>IN</code> parameter mode, use the <code><a id="sthref224"></a><a id="sthref225"></a><a id="sthref226"></a>setPlsqlIndexTable</code> method defined in the <code>OraclePreparedStatement</code> and <code>OracleCallableStatement</code> classes.</p>
<pre>synchronized public void setPlsqlIndexTable (int paramIndex, Object arrayData, int maxLen, int curLen, int elemSqlType,
 int elemMaxLen) throws SQLException
</pre>
<p><a href="#BABECHCJ">Table 4-2</a> describes the arguments of the <code>setPlsqlIndexTable</code> method.</p>
<div id="JJDBC28183" class="tblformal">
<p class="titleintable"><a id="sthref227"></a><a id="BABECHCJ"></a>Table 4-2 Arguments of the setPlsqlIndexTable Method</p>
<table class="cellalignment2244" title="Arguments of the setPlsqlIndexTable Method " summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t51">Argument</th>
<th class="cellalignment2245" id="r1c2-t51">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t51" headers="r1c1-t51">
<p><code>int paramIndex<a id="sthref228"></a></code></p>
</td>
<td class="cellalignment2246" headers="r2c1-t51 r1c2-t51">
<p>Indicates the parameter position within the statement.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r3c1-t51" headers="r1c1-t51">
<p><code><a id="sthref229"></a>Object arrayData</code></p>
</td>
<td class="cellalignment2246" headers="r3c1-t51 r1c2-t51">
<p>Is an array of values to be bound to the PL/SQL Associative Array parameter. The value is of type <code>java.lang.Object</code>. The value can be a Java primitive type array, such as <code>int[]</code>, or a Java object array, such as <code>BigDecimal[].</code></p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r4c1-t51" headers="r1c1-t51">
<p><code><a id="sthref230"></a>int maxLen</code></p>
</td>
<td class="cellalignment2246" headers="r4c1-t51 r1c2-t51">
<p>Specifies the maximum table length of the Associative Array bind value that defines the maximum possible <code>curLen</code> for batch updates. For standalone binds, <code>maxLen</code> should use the same value as <code>curLen.</code> This argument is required.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r5c1-t51" headers="r1c1-t51">
<p><code><a id="sthref231"></a>int curLen</code></p>
</td>
<td class="cellalignment2246" headers="r5c1-t51 r1c2-t51">
<p>Specifies the actual size of the Associative Array bind value in <code>arrayData</code>. If the <code>curLen</code> value is smaller than the size of <code>arrayData</code>, then only the <code>curLen</code> number of table elements is passed to the database. If the <code>curLen</code> value is larger than the size of <code>arrayData</code>, then the entire <code>arrayData</code> is sent to the database.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r6c1-t51" headers="r1c1-t51">
<p><code><a id="sthref232"></a>int elemSqlType</code></p>
</td>
<td class="cellalignment2246" headers="r6c1-t51 r1c2-t51">
<p>Specifies the Associative Array element type based on the values defined in the <code>OracleTypes</code> class.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r7c1-t51" headers="r1c1-t51">
<p><code><a id="sthref233"></a>int elemMaxLen</code></p>
</td>
<td class="cellalignment2246" headers="r7c1-t51 r1c2-t51">
<p>Specifies the Associative Array element maximum length in case the element type is <code>CHAR</code>, <code>VARCHAR</code>, or <code>RAW</code>. This value is ignored for other types.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The following code example uses the <code><a id="sthref234"></a>setPlsqlIndexTable</code> method to bind an Associative Array as an <code>IN</code> parameter:</p>
<pre>// Prepare the statement
OracleCallableStatement procin = (OracleCallableStatement) 
   conn.prepareCall (&#34;begin procin (?); end;&#34;); 

// Associative Array bind value 
int[] values = { 1, 2, 3 }; 

// maximum length of the Associative Array bind value. This 
// value defines the maximum possible &#34;currentLen&#34; for batch 
// updates. For standalone binds, &#34;maxLen&#34; should be the 
// same as &#34;currentLen&#34;. 
int maxLen = values.length; 

// actual size of the Associative Array bind value 
int currentLen = values.length; 

// Associative Array element type 
int elemSqlType = OracleTypes.NUMBER; 

// Associative Array element length in case the element type 
// is CHAR, VARCHAR or RAW. This value is ignored for other 
// types. 
int elemMaxLen = 0; 

// set the value 
procin.setPlsqlIndexTable (1, values, 
                           maxLen, currentLen, 
                           elemSqlType, elemMaxLen); 

// execute the call 
procin.execute (); 
</pre></div>
<!-- class="sect2" -->
<a id="BABDAIGD"></a>
<div id="JJDBC28184" class="sect2">
<h3 class="sect2">Receiving OUT Parameters</h3>
<p>This section describes how to register a PL/SQL Associative Array as an <code><a id="sthref235"></a><a id="sthref236"></a>OUT</code> parameter. In addition, it describes how to access the <code>OUT</code> bind values in various mapping styles.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The methods described in this section apply to function return values and the <code><a id="sthref237"></a><a id="sthref238"></a>IN OUT</code> parameter mode as well.</div>
<p class="subhead2"><a id="JJDBC28185"></a>Registering the OUT Parameters</p>
<p>To register a PL/SQL Associative Array as an <code><a id="sthref239"></a><a id="sthref240"></a>OUT</code> parameter, use the <code><a id="sthref241"></a><a id="sthref242"></a>registerIndexTableOutParameter</code> method defined in the <code>OracleCallableStatement</code> class.</p>
<pre>synchronized public void registerIndexTableOutParameter 
   (int paramIndex, int maxLen, int elemSqlType,
 int elemMaxLen) throws SQLException
</pre>
<p><a href="#BABDFEIH">Table 4-3</a> describes the arguments of the <code>registerIndexTableOutParameter</code> method.</p>
<div id="JJDBC28186" class="tblformal">
<p class="titleintable"><a id="sthref243"></a><a id="BABDFEIH"></a>Table 4-3 Arguments of the registerIndexTableOutParameter Method</p>
<table class="cellalignment2244" title="Arguments of the registerIndexTableOutParameter Method" summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t53">Argument</th>
<th class="cellalignment2245" id="r1c2-t53">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t53" headers="r1c1-t53">
<p><code>int paramIndex</code><a id="sthref244"></a></p>
</td>
<td class="cellalignment2246" headers="r2c1-t53 r1c2-t53">
<p>Indicates the parameter position within the statement.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r3c1-t53" headers="r1c1-t53">
<p><code><a id="sthref245"></a>int maxLen</code></p>
</td>
<td class="cellalignment2246" headers="r3c1-t53 r1c2-t53">
<p>Specifies the maximum table length of the Associative Array bind value to be returned.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r4c1-t53" headers="r1c1-t53">
<p><code><a id="sthref246"></a>int elemSqlType</code></p>
</td>
<td class="cellalignment2246" headers="r4c1-t53 r1c2-t53">
<p>Specifies the Associative Array element type based on the values defined in the <code>OracleTypes</code> class.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r5c1-t53" headers="r1c1-t53">
<p><code><a id="sthref247"></a>int elemMaxLen</code></p>
</td>
<td class="cellalignment2246" headers="r5c1-t53 r1c2-t53">
<p>Specifies the Associative Array element maximum length in case the element type is <code>CHAR</code>, <code>VARCHAR</code>, or <code>FIXED_CHAR</code>. This value is ignored for other types.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The following code example uses the <code><a id="sthref248"></a>registerIndexTableOutParameter</code> method to register an Associative Array as an <code>OUT</code> parameter:</p>
<pre>// maximum length of the Associative Array value. This 
// value defines the maximum table size to be returned.
int maxLen = 10;

// Associative Array element type
int elemSqlType = OracleTypes.NUMBER;

// Associative Array element length in case the element type
// is CHAR, VARCHAR or FIXED_CHAR. This value is ignored for other
// types
int elemMaxLen = 0;

// register the return value
funcnone.registerIndexTableOutParameter
   (1, maxLen, elemSqlType, elemMaxLen);
</pre>
<p class="subhead2"><a id="JJDBC28187"></a>Accessing the OUT Parameter Values</p>
<p>To access the <code><a id="sthref249"></a><a id="sthref250"></a>OUT</code> bind value, the <code>OracleCallableStatement</code> class defines multiple methods that return the Associative Array values in different mapping styles. There are three mapping choices available in JDBC drivers:<a id="sthref251"></a></p>
<div class="inftblinformal">
<table class="cellalignment2247" title="OUT Parameter Mapping Methods" summary="This table lists the supported index-by table mapping styles." dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t54">Mappings</th>
<th class="cellalignment2245" id="r1c2-t54">Methods to Use</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t54" headers="r1c1-t54">JDBC default mappings</td>
<td class="cellalignment2246" headers="r2c1-t54 r1c2-t54"><code><a id="sthref252"></a>getPlsqlIndexTable(int)</code></td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r3c1-t54" headers="r1c1-t54">Oracle mappings</td>
<td class="cellalignment2246" headers="r3c1-t54 r1c2-t54"><code><a id="sthref253"></a>getOraclePlsqlIndexTable(int)</code></td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r4c1-t54" headers="r1c1-t54">Java primitive type mappings</td>
<td class="cellalignment2246" headers="r4c1-t54 r1c2-t54"><code><a id="sthref254"></a>getPlsqlIndexTable(int, Class)</code></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<a id="BABJCCCH"></a>
<div id="JJDBC28188" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Type Mappings</h3>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABHJGDG">JDBC Default Mappings</a></p>
</li>
<li>
<p><a href="#BABCDGCC">Oracle Mappings</a></p>
</li>
<li>
<p><a href="#BABJDBBD">Java Primitive Type Mappings</a></p>
</li>
</ul>
<p class="subhead2"><a id="BABHJGDG"></a><a id="JJDBC28189"></a>JDBC Default Mappings</p>
<p>The <code><a id="sthref255"></a>getPlsqlIndexTable(int)</code> method returns Associative Array elements using the JDBC default mappings. The syntax for this method is the following:</p>
<pre>public Object getPlsqlIndexTable (int paramIndex)
   throws SQLException
</pre>
<p><a href="#BABIFGHH">Table 4-4</a> describes the argument of the <code>getPlsqlIndexTable</code> method.</p>
<div id="JJDBC28190" class="tblformal">
<p class="titleintable"><a id="sthref256"></a><a id="BABIFGHH"></a>Table 4-4 Argument of the getPlsqlIndexTable Method</p>
<table class="cellalignment2244" title="Argument of the getPlsqlIndexTable Method" summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t55">Argument</th>
<th class="cellalignment2245" id="r1c2-t55">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t55" headers="r1c1-t55">
<p><code>int paramIndex<a id="sthref257"></a></code></p>
</td>
<td class="cellalignment2246" headers="r2c1-t55 r1c2-t55">
<p>This argument indicates the parameter position within the statement.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The return value is a Java array. The elements of this array are of the default Java type corresponding to the SQL type of the elements. For example, for an Associative Array with elements of <code>NUMERIC</code> type code, the element values are mapped to <code>BigDecimal</code> by Oracle JDBC driver, and the <code>getPlsqlIndexTable</code> method returns a <code>BigDecimal[]</code> array. For a JDBC application, you must cast the return value to <code>BigDecimal[]</code> to access the table element values.</p>
<p>The following code example uses the <code><a id="sthref258"></a>getPlsqlIndexTable</code> method to return Associative Array elements with JDBC default mapping:</p>
<pre>// access the value using JDBC default mapping 
BigDecimal[] values = 
   (BigDecimal[]) procout.getPlsqlIndexTable (1); 

// print the elements 
for (int i=0; i&lt;values.length; i++) 
   System.out.println (values[i].intValue()); 
</pre>
<p class="subhead2"><a id="BABCDGCC"></a><a id="JJDBC28191"></a>Oracle Mappings</p>
<p>The <code><a id="sthref259"></a>getOraclePlsqlIndexTable</code> method returns Associative Array elements using Oracle mapping.</p>
<pre>public Datum[] getOraclePlsqlIndexTable (int paramIndex)
      throws SQLException 
</pre>
<p><a href="#BABDHJIF">Table 4-5</a> describes the argument of the <code>getOraclePlsqlIndexTable</code> method.</p>
<div id="JJDBC28192" class="tblformal">
<p class="titleintable"><a id="sthref260"></a><a id="BABDHJIF"></a>Table 4-5 Argument of the getOraclePlsqlIndexTable Method</p>
<table class="cellalignment2244" title="Argument of the getOraclePlsqlIndexTable Method" summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t56">Argument</th>
<th class="cellalignment2245" id="r1c2-t56">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t56" headers="r1c1-t56">
<p><code>int paramIndex<a id="sthref261"></a></code></p>
</td>
<td class="cellalignment2246" headers="r2c1-t56 r1c2-t56">
<p>Indicates the parameter position within the statement.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The return value is an <code><a id="sthref262"></a>oracle.sql.Datum</code> array, and the elements in the array are of the default <code>Datum</code> type corresponding to the SQL type of the element. For example, the element values of an Associative Array of numeric elements are mapped to the <code>oracle.sql.NUMBER</code> type in Oracle mapping, and the <code>getOraclePlsqlIndexTable</code> method returns an <code>oracle.sql.Datum</code> array that contains <code>oracle.sql.NUMBER</code> elements.</p>
<p>The following code example uses the <code><a id="sthref263"></a>getOraclePlsqlIndexTable</code> method to access the elements of a PL/SQL Associative Array <code>OUT</code> parameter, using Oracle mapping:</p>
<pre>// Prepare the statement 
OracleCallableStatement procout = (OracleCallableStatement)
                                  conn.prepareCall (&#34;begin procout (?); end;&#34;);

...

// run the call
procout.execute ();
 
// access the value using Oracle JDBC mapping
Datum[] outvalues = procout.getOraclePlsqlIndexTable (1);

// print the elements
for (int i=0; i&lt;outvalues.length; i++)
   System.out.println (outvalues[i].intValue());
</pre>
<p class="subhead2"><a id="BABJDBBD"></a><a id="JJDBC28193"></a>Java Primitive Type Mappings</p>
<p>The <code><a id="sthref264"></a>getPlsqlIndexTable(int, Class)</code> method returns Associative Array elements in Java primitive types. The return value is a Java array. The syntax for this method is the following:</p>
<pre>synchronized public Object getPlsqlIndexTable
   (int paramIndex, Class primitiveType) throws SQLException
</pre>
<p><a href="#BABHAJGH">Table 4-6</a> describes the arguments of the <code>getPlsqlIndexTable</code> method.</p>
<div id="JJDBC28194" class="tblformal">
<p class="titleintable"><a id="sthref265"></a><a id="BABHAJGH"></a>Table 4-6 Arguments of the getPlsqlIndexTable Method</p>
<table class="cellalignment2244" title="Arguments of the getPlsqlIndexTable Method" summary="table" dir="ltr">
<thead>
<tr class="cellalignment2238">
<th class="cellalignment2245" id="r1c1-t57">Argument</th>
<th class="cellalignment2245" id="r1c2-t57">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r2c1-t57" headers="r1c1-t57">
<p><code>int paramIndex<a id="sthref266"></a></code></p>
</td>
<td class="cellalignment2246" headers="r2c1-t57 r1c2-t57">
<p>Indicates the parameter position within the statement.</p>
</td>
</tr>
<tr class="cellalignment2238">
<td class="cellalignment2246" id="r3c1-t57" headers="r1c1-t57">
<p><code>Class primitiveType<a id="sthref267"></a></code></p>
</td>
<td class="cellalignment2246" headers="r3c1-t57 r1c2-t57">
<p>Specifies a Java primitive type to which the Associative Array elements are to be converted. For example, if you specify <code>java.lang.Integer.TYPE</code>, the return value is an <code>int</code> array.</p>
<p>The following are the possible values of this parameter:</p>
<p><code>java.lang.Integer.TYPE</code></p>
<p><code>java.lang.Long.TYPE</code></p>
<p><code>java.lang.Float.TYPE</code></p>
<p><code>java.lang.Double.TYPE</code></p>
<p><code>java.lang.Short.TYPE</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The following code example uses the <code><a id="sthref268"></a>getPlsqlIndexTable</code> method to access the elements of a PL/SQL Associative Array of numbers. In the example, the second parameter specifies <code>java.lang.Integer.TYPE</code> and the return value of the <code>getPlsqlIndexTable</code> method is an <code>int</code> array.</p>
<pre>OracleCallableStatement funcnone = (OracleCallableStatement) 
   conn.prepareCall (&#34;begin ? := funcnone; end;&#34;); 

// maximum length of the Associative Array value. This 
// value defines the maximum table size to be returned. 
int maxLen = 10; 

// Associative Array element type 
int elemSqlType = OracleTypes.NUMBER; 

// Associative Array element length in case the element type 
// is CHAR, VARCHAR or RAW. This value is ignored for other 
// types 
int elemMaxLen = 0; 

// register the return value 
funcnone.registerIndexTableOutParameter (1, maxLen, 
                                        elemSqlType, elemMaxLen); 
// execute the call 
funcnone.execute (); 

// access the value as a Java primitive array. 
int[] values = (int[]) 
   funcnone.getPlsqlIndexTable (1, java.lang.Integer.TYPE); 

// print the elements 
for (int i=0; i&lt;values.length; i++) 
   System.out.println (values[i]); 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2237">
<tr>
<td class="cellalignment2246">
<table class="cellalignment2242">
<tr>
<td class="cellalignment2241"><a href="jdbcvers.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2241"><a href="jdbcthin.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2249">
<table class="cellalignment2240">
<tr>
<td class="cellalignment2241"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2241"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2241"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2241"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2241"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2241"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>