<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-113905"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Working%20with%20Data%20in%20a%20TimesTen%20Database"></a><title>Working with Data in a TimesTen Database</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748"/>
<meta name="dcterms.created" content="2014-09-30T15:13:4Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database Operations Guide"/>
<meta name="dcterms.identifier" content="E21633-12"/>
<meta name="dcterms.isVersionOf" content="TTOPR"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="trans.htm" title="Previous" type="text/html"/>
<link rel="Next" href="query.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21633-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/16</span> <!-- End Header -->
<div id="TTOPR327" class="chapter"><a id="BABHBICB"></a>
<h1 class="chapter"><span class="secnum">8</span> Working with Data in a TimesTen Database</h1>
<p>This chapter provides detailed information on the basic components in a TimesTen database and simple examples of how you can use SQL to manage these components. For more information about SQL, see the <a class="olink TTSQL" href="../TTSQL/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span></a>.</p>
<p>For information on how to execute SQL from within an application, see the appropriate TimesTen developer&#39;s guide.</p>
<p>This chapter includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDBEDHC">Database overview</a></p>
</li>
<li>
<p><a href="#CHDGAGED">Understanding tables</a></p>
</li>
<li>
<p><a href="#CHDDHBJF">Understanding views</a></p>
</li>
<li>
<p><a href="#CHDEAFCA">Understanding materialized views</a></p>
</li>
<li>
<p><a href="#CHDGBEJB">Understanding indexes</a></p>
</li>
<li>
<p><a href="#CHDFDFFF">Understanding rows</a></p>
</li>
<li>
<p><a href="#BABBAHAF">Understanding synonyms</a></p>
</li>
</ul>
<a id="CHDBEDHC"></a>
<div id="TTOPR328" class="sect1">
<h2 class="sect1">Database overview</h2>
<p>The following sections describe the main TimesTen database elements and features:</p>
<ul>
<li>
<p><a href="#CHDDBACA">Database components</a></p>
</li>
<li>
<p><a href="#CHDIGABI">Database users and owners</a></p>
</li>
<li>
<p><a href="#CHDFEAFC">Database persistence</a></p>
</li>
</ul>
<a id="CHDDBACA"></a>
<div id="TTOPR329" class="sect2">
<h3 class="sect2">Database components</h3>
<p>A TimesTen <a id="sthref877"></a><a id="sthref878"></a>database has the following permanent components:</p>
<ul>
<li>
<p><span class="bold">Tables</span>. The primary components of a TimesTen database are the tables that contain the application data. See <a href="#CHDGAGED">&#34;Understanding tables&#34;</a>.</p>
</li>
<li>
<p><span class="bold">Materialized Views</span>. Read-only tables that hold a summary of data selected from one or more &#34;regular&#34; TimesTen tables. See <a href="#CHDEAFCA">&#34;Understanding materialized views&#34;</a>.</p>
</li>
<li>
<p><span class="bold">Views</span>. Logical tables that are based on one or more tables called <span class="italic">detail tables</span>. A view itself contains no data. See <a href="#CHDDHBJF">&#34;Understanding views&#34;</a>.</p>
</li>
<li>
<p><span class="bold">Indexes</span>. Indexes on one or more columns of a table may be created for faster access to tables. See <a href="#CHDGBEJB">&#34;Understanding indexes&#34;</a>.</p>
</li>
<li>
<p><span class="bold">Rows</span>. Every table consists of 0 or more rows. A row is a formatted list of values. See <a href="#CHDFDFFF">&#34;Understanding rows&#34;</a>.</p>
</li>
<li>
<p><span class="bold">System tables</span>. System tables contain TimesTen metadata, such as a table of all tables. See <a class="olink TTSYS346" href="../TTSYS/systemtables.htm#TTSYS346">&#34;System Tables&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database System Tables and Views Reference</span>.</p>
</li>
</ul>
<p>There are also many temporary components, including prepared commands, cursors and locks.</p>
</div>
<!-- class="sect2" -->
<a id="CHDIGABI"></a>
<div id="TTOPR330" class="sect2">
<h3 class="sect2">Databas<a id="sthref879"></a><a id="sthref880"></a><a id="sthref881"></a>e users and owners</h3>
<p>The TimesTen Data Manager authenticates user names with passwords. TimesTen Client/Server also authenticates users with passwords. Applications should choose one UID for the application itself because by default the login name that is being used to run the application becomes the owner of the database. If two different logins are used, TimesTen may have difficulty finding the correct tables. If you omit the <code>UID</code> connection attribute in the connection string, TimesTen uses the current user&#39;s login name. TimesTen converts all user names to upper case characters.</p>
<p>Users cannot access TimesTen databases as user <code>SYS</code>. TimesTen determines the user name by the value of the<a id="sthref882"></a><a id="sthref883"></a><a id="sthref884"></a> <code>UID</code> connection attribute, or if not present, then by the login name of the connected user. If a user&#39;s login is <code>SYS</code>, set the <code>UID</code> connection to override the login name.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFEAFC"></a>
<div id="TTOPR331" class="sect2">
<h3 class="sect2">Database persistence</h3>
<p>When a database is created, it has either the permanent or temporary attribute set:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can define database persistence by setting the value of the <code>Temporary</code> connection attribute. You cannot change the <code>Temporary</code> attribute on a database after it is created. For more information on the <code>Temporary</code> attribute, see &#34;<a class="olink TTREF751" href="../TTREF/attribute.htm#TTREF751">Temporary&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<ul>
<li>
<p><a id="sthref885"></a><a id="sthref886"></a><span class="bold">Permanent databases</span> are stored to disk <a id="sthref887"></a><a id="sthref888"></a>automatically through a procedure called checkpointing. TimesTen automatically performs background checkpoints based on the settings of the connection attributes <code>CkptFrequency</code> and <code>CkptLogVolume</code>. TimesTen also checkpoints the database when the last application disconnects. Applications can also checkpoint a database directly to disk by calling the <code>ttCkptBlocking</code> built-in procedure. For more information, see <a class="olink TTREF239" href="../TTREF/proced.htm#TTREF239">&#34;ttCkptBlocking&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</li>
<li>
<p><span class="bold">Temporary databases</span><a id="sthref889"></a><a id="sthref890"></a><a id="sthref891"></a><a id="sthref892"></a> are not stored to disk. A temporary database is automatically destroyed when no applications are connected to it; that is, when the last connection disconnects or when there is a system or application failure. TimesTen removes all disk-based files when the last application disconnects.</p>
<p>A temporary database cannot be backed up or replicated. Temporary databases are never fully checkpointed to disk, although Checkpoint operations can have significant overhead for permanent databases, depending on database size and activity, but have very little impact for temporary databases. Checkpoints are still necessary to remove transaction log files.</p>
<p>However, temporary databases do have a transaction log, which is periodically written to disk, so transactions can be rolled back. The amount of data written to the transaction log for temporary databases is less than that written for permanent databases, allowing better performance for temporary databases. Recovery is never performed for temporary databases.</p>
<p>You can increase your performance with temporary databases. If you do not need to save the database to disk, you can save checkpoint overhead by creating a temporary database.</p>
<p>Details for setting up a temporary database are described in <a href="using.htm#BCGJAJDI">&#34;Setting up a temporary database&#34;</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDGAGED"></a>
<div id="TTOPR332" class="sect1">
<h2 class="sect1">Understanding tables</h2>
<p>A TimesTen table consists of rows that have a common format or <a id="sthref893"></a><a id="sthref894"></a><a id="sthref895"></a>structure. This format is described by the table&#39;s columns.</p>
<p>The following sections describes tables, its columns and how to manage them:</p>
<ul>
<li>
<p><a href="#BABFBGBB">Overview of tables</a></p>
</li>
<li>
<p><a href="#CHDCAGEC">Working with tables</a></p>
</li>
<li>
<p><a href="#CHDHIJBA">Implementing aging in your tables</a></p>
</li>
</ul>
<a id="BABFBGBB"></a>
<div id="TTOPR333" class="sect2">
<h3 class="sect2">Overview of tables</h3>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#BABCEGGI">Column overview</a></p>
</li>
<li>
<p><a href="#CHDGJBHJ">Inline and out-of-line columns</a></p>
</li>
<li>
<p><a href="#CHDEHEHI">Default column values</a></p>
</li>
<li>
<p><a href="#CHDDEGGI">Table names</a></p>
</li>
<li>
<p><a href="#CHDBCGIE">Table access</a></p>
</li>
<li>
<p><a href="#CHDEGADH">Primary keys, foreign keys and unique indexes</a></p>
</li>
<li>
<p><a href="#CHDBHGFD">System tables</a></p>
</li>
</ul>
<a id="BABCEGGI"></a>
<div id="TTOPR334" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Column overview</h4>
<p>When you create the columns in the table, the column names are case-insensitive.</p>
<p>Each column has the following:</p>
<ul>
<li>
<p>A data type</p>
</li>
<li>
<p>Optional nullability, primary key and foreign key properties</p>
</li>
<li>
<p>An optional default value</p>
</li>
</ul>
<p>Unless you explicitly declare a column <code>NOT NULL</code>, columns are nullable. <a id="sthref896"></a>If a column in a table is nullable, it can contain a <code>NULL</code> value. Otherwise, each row in the table must have a non-NULL value in that column.</p>
<p><a id="sthref897"></a><a id="sthref898"></a><a id="sthref899"></a><a id="sthref900"></a><a id="sthref901"></a>The format of TimesTen columns cannot be altered. It is possible to add or remove columns but not to change column definitions. To add or remove columns, use the <a id="sthref902"></a><code>ALTER TABLE</code> statement. To change column definitions, an application must first drop the table and then recreate it with the new definitions.</p>
</div>
<!-- class="sect3" -->
<a id="CHDGJBHJ"></a>
<div id="TTOPR335" class="sect3">
<h4 class="sect3">Inline and out-of-line columns</h4>
<p>The in-memory layout of the rows of a table is designed to provide fast access to rows while minimizing wasted space. TimesTen designates each <code>VARBINARY</code>, <code>NVARCHAR2</code> and <code>VARCHAR2</code> column of a table as either <span class="italic"><a id="sthref903"></a><a id="sthref904"></a><a id="sthref905"></a><a id="sthref906"></a>inline</span> or <span class="italic">out-of-line</span>.</p>
<ul>
<li>
<p>An inline column has a fixed length. All values of fixed-length columns of a table are stored row wise.</p>
</li>
<li>
<p>A not inline column (also referred to as an out-of-line column) has a varying length. Some <code>VARCHAR2</code>, <code>NVARCHAR2</code> or <code>VARBINARY</code> data type columns are stored out-of-line. Out-of-line columns are not stored contiguously with the row but are allocated. By default, TimesTen stores <code>VARCHAR2</code>, <code>NVARCHAR2</code> and <code>VARBINARY</code> columns whose declared column length is &gt; 128 bytes as out-of-line. In addition, all LOB data types are stored out-of-line. By default, TimesTen stores variable-length columns whose declared column length is &lt;= 128 bytes as inline.</p>
</li>
</ul>
<p>Most operations are slightly slower when performed on an out-of-line column instead of an inline column. There are several performance considerations when you use out-of-line columns instead of inline columns:</p>
<ul>
<li>
<p>Accessing data is slower because TimesTen does not store data from out-of-line columns contiguously with the row.</p>
</li>
<li>
<p>Populating data is slower because TimesTen generates more logging operations.</p>
</li>
<li>
<p>Deleting data is slower because TimesTen performs more reclaim and logging operations. If you are deleting a large number of rows (100,000 or more) consider using multiple smaller <code>DELETE FROM</code> statements, a <code>TRUNCATE TABLE</code> statement, or the <code>DELETE FIRST</code> clause. For more information, see <a href="perform.htm#BABDGDCI">&#34;Avoid large DELETE statements&#34;</a>.</p>
</li>
<li>
<p>Storing a column requires less overhead.</p>
</li>
</ul>
<p><a id="sthref907"></a>The maximum sizes of inline and out-of-line portions of a row are listed in <a href="ttisql.htm#CHDDEIAJ">&#34;Using the ttIsql tablesize command&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDEHEHI"></a>
<div id="TTOPR336" class="sect3">
<h4 class="sect3">Default <a id="sthref908"></a><a id="sthref909"></a>column values</h4>
<p>When you create a table, you can specify default values for the columns. The default value you specify must be compatible with the data type of the column. You can specify one of the following default values for a column:</p>
<ul>
<li>
<p><code>NULL</code> for any column type</p>
</li>
<li>
<p>A constant value</p>
</li>
<li>
<p><code>SYSDATE</code> for <code>DATE</code> and <code>TIMESTAMP</code> columns</p>
</li>
<li>
<p><code>USER</code> for <code>CHAR</code> columns</p>
</li>
<li>
<p><code>CURRENT_USER</code> for <code>CHAR</code> columns</p>
</li>
<li>
<p><code>SYSTEM_USER</code> for <code>CHAR</code> columns</p>
</li>
</ul>
<p>If you use the <code>DEFAULT</code> clause of the <code>CREATE TABLE</code> statement but do not specify the default value, the default value is <code>NULL</code>. See <a class="olink TTSQL302" href="../TTSQL/state.htm#TTSQL302">&#34;CREATE TABLE&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDDEGGI"></a>
<div id="TTOPR337" class="sect3">
<h4 class="sect3">Table names</h4>
<p><a id="sthref910"></a><a id="sthref911"></a><a id="sthref912"></a><a id="sthref913"></a>A TimesTen table is identified uniquely by its owner name and table name. Every table has an owner. By default, TimesTen defines the owner as the user who created the table. Tables created by TimesTen, such as system tables, have the owner name <code>SYS</code>.</p>
<p>To uniquely refer to a table, specify both its owner and name separated by a period (&#34;.&#34;), such as <code>MARY.PAYROLL</code>. If an application does not specify an owner, TimesTen looks for the table under the user name of the caller, then under the user name <code>SYS</code>.</p>
<p><a id="sthref914"></a><a id="sthref915"></a><a id="sthref916"></a><a id="sthref917"></a><a id="sthref918"></a>A name is an alphanumeric value that begins with a letter. A name can include underscores. The maximum length of a table name is 30 characters. The maximum length of an owner name is also 30 characters. TimesTen displays all table, column and owner names to upper case characters. See <a class="olink TTSQL187" href="../TTSQL/names.htm#TTSQL187">&#34;Names, Namespace and Parameters&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for additional information.</p>
</div>
<!-- class="sect3" -->
<a id="CHDBCGIE"></a>
<div id="TTOPR338" class="sect3">
<h4 class="sect3">Table access</h4>
<p>Applications access tables through SQL statements. The TimesTen query optimizer automatically chooses a fast way to access tables. It uses existing indexes or, if necessary, creates temporary indexes to speed up access. For improved performance, applications should explicitly<a id="sthref919"></a><a id="sthref920"></a> create indexes for frequently searched columns because the <a id="sthref921"></a><a id="sthref922"></a>automatic creation and destruction of temporary indexes incurs a <a id="sthref923"></a>performance overhead. For more details, see <a href="perform.htm#CACJDFBA">&#34;Tune statements and use indexes&#34;</a>. You can use optimizer hints (statement or transaction level) to tune the TimesTen execution plan for a specific application. For more information on optimizer hints, see <a href="query.htm#CBAEHHAB">&#34;Use optimizer hints to modify the execution plan&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDEGADH"></a>
<div id="TTOPR339" class="sect3">
<h4 class="sect3">Primary keys, foreign keys and unique indexes</h4>
<p>You can create a <a id="sthref924"></a>primary key on one or more columns to indicate that duplicate values for that set of columns should be rejected. Primary key columns cannot be <a id="sthref925"></a><a id="sthref926"></a>nullable. A table can have at most one primary key. TimesTen automatically creates a range index on the primary key to enforce uniqueness on the primary key and to improve access speeds through the primary key. Once a row is inserted, its primary key columns cannot be modified, except to change a range index to a hash index.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Indexes are discussed in <a href="#CHDGBEJB">&#34;Understanding indexes&#34;</a>.</div>
<p>Although a table may have only one primary key, additional uniqueness properties may be added to the table using <a id="sthref927"></a>unique indexes. See <a class="olink TTSQL292" href="../TTSQL/state.htm#TTSQL292">&#34;CREATE INDEX&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for more information.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Columns of a primary key cannot be nullable; a unique index can be built on nullable columns.</div>
<p>A table may also have one or more foreign keys through which rows correspond to rows in another table. Foreign keys relate to a primary key or uniquely indexed columns in the other table. Foreign keys use a range index on the referencing columns. See <a class="olink TTSQL302" href="../TTSQL/state.htm#TTSQL302">&#34;CREATE TABLE&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for more information.</p>
</div>
<!-- class="sect3" -->
<a id="CHDBHGFD"></a>
<div id="TTOPR340" class="sect3">
<h4 class="sect3">System tables</h4>
<p><a id="sthref928"></a><a id="sthref929"></a>In addition to tables created by applications, a TimesTen database contains system tables. System tables contain TimesTen metadata such as descriptions of all tables and indexes in the database, as well as other information such as optimizer plans. Applications may query system tables just as they query user tables. Applications may not update system tables. TimesTen system tables are described in the <a class="olink TTSYS346" href="../TTSYS/systemtables.htm#TTSYS346">&#34;System Tables&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database System Tables and Views Reference</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
TimesTen system table formats may change between releases and are different between the 32- and 64-bit versions of TimesTen.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDCAGEC"></a>
<div id="TTOPR341" class="sect2">
<h3 class="sect2">Working with tables</h3>
<p>To perform any operation that creates, drops or manages a table, the user must have the appropriate privileges, which are described along with the syntax for all SQL statements in the <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDEHBGE">Creating a table</a></p>
</li>
<li>
<p><a href="#CHDFGGIC">Dropping a table</a></p>
</li>
<li>
<p><a href="#CHDHBCHH">Estimating table size</a></p>
</li>
</ul>
<a id="CHDEHBGE"></a>
<div id="TTOPR342" class="sect3">
<h4 class="sect3">Creating a table</h4>
<p><a id="sthref930"></a><a id="sthref931"></a><a id="sthref932"></a>To create a table, use the SQL statement <code>CREATE TABLE</code>. The syntax for all SQL statements is provided in the <a class="olink TTSQL" href="../TTSQL/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span></a>. TimesTen converts table names to upper case characters.</p>
<div id="TTOPR343" class="example">
<p class="titleinexample"><a id="sthref933"></a>Example 8-1 Create a table</p>
<p>The following SQL statement creates a table, called <code>NameID</code>, with two columns: <code>CustId</code> and <code>CustName</code> of two different data types.</p>
<pre>CREATE TABLE NameID (CustId TT_INTEGER, CustName VARCHAR2(50));
</pre></div>
<!-- class="example" -->
<div id="TTOPR344" class="example">
<p class="titleinexample"><a id="BABJBCFA"></a>Example 8-2 Create a table with a hash index</p>
<p>This example creates a table, called <code>Customer</code>, with the columns: <code>CustId</code>, <code>CustName</code>, <code>Addr</code>, <code>Zip</code>, and <code>Region</code>. The <code>CustId</code> column is designated as the primary key, so that the <code>CustId</code> value in a row uniquely identifies that row in the table, as described in <a href="#CHDEGADH">&#34;Primary keys, foreign keys and unique indexes&#34;</a>.</p>
<p>The <code>UNIQUE HASH ON</code> <code>custId</code> <code>PAGES</code> value indicates that there are 30 pages in the hash index. This means that the expected number of rows in the table is 30 * 256 = 7680. If the table ends up with significantly more rows than this, performance can be degraded, and the hash index should be resized. For more details on pages in a hash index, see information for <code>SET PAGES</code> in the <a class="olink TTSQL286" href="../TTSQL/state.htm#TTSQL286">&#34;ALTER TABLE&#34;</a> section in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>. For details on how to size pages in a hash table, see <a href="perform.htm#CACFIFGD">&#34;Size hash indexes appropriately&#34;</a>.</p>
<pre>CREATE TABLE Customer
(custId NUMBER NOT NULL PRIMARY KEY,
custName CHAR(100) NOT NULL,
Addr CHAR(100),
Zip NUMBER,
Region CHAR(10))
UNIQUE HASH ON (custId) PAGES = 30;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDFGGIC"></a>
<div id="TTOPR345" class="sect3">
<h4 class="sect3">Dropping a table</h4>
<p><a id="sthref934"></a><a id="sthref935"></a><a id="sthref936"></a>To drop a TimesTen table, call the SQL statement <code>DROP TABLE</code>.</p>
<div id="TTOPR346" class="example">
<p class="titleinexample"><a id="sthref937"></a>Example 8-3 Drop a table</p>
<p>The following example drops the table <code>NameID</code>.</p>
<pre>DROP TABLE NameID;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDHBCHH"></a>
<div id="TTOPR347" class="sect3">
<h4 class="sect3">E<a id="sthref938"></a><a id="sthref939"></a><a id="sthref940"></a>stimating table size</h4>
<p>Increasing the size of a TimesTen database can be done on first connect. To avoid having to increase the size of a database, it is important not to underestimate the eventual database size. Use the <code>ttSize</code> utility to estimate table size.</p>
<p>The following example shows that the <code>ttSize</code> utility estimates the rows, inline row bytes, size of any indexes on the table, and the total size of the table:</p>
<pre>ttSize -tbl Pat.tab1 MyDb

Rows = 2

Total in-line row bytes = 17524
Indexes:

 Bitmap index PAT.BITMAP_ID adds 6282 bytes
  Total index bytes = 6282

Total = 23806
</pre>
<p>You can also calculate the size of an existing table with the <code>ttIsql tablesize</code> command. For more information, see <a href="ttisql.htm#CHDDEIAJ">&#34;Using the ttIsql tablesize command&#34;</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDHIJBA"></a>
<div id="TTOPR348" class="sect2">
<h3 class="sect2">Implementing aging in your tables</h3>
<p><a id="sthref941"></a><a id="sthref942"></a><a id="sthref943"></a>You can define an aging policy for one or more tables in your database. An aging policy refers to the type of aging and the aging attributes, as well as the aging state (<code>ON</code> or <code>OFF</code>). You can specify one of the following types of aging policies: usage-based or time-based. Usage-based aging removes least recently used (LRU) data within a specified database usage range. Time-based aging removes data based on the specified data lifetime and frequency of the aging process. You can define both usage-based aging and time-based aging in the same database, but you can define only one type of aging on a specific table.</p>
<p>You can define an aging policy for a new table with the <code>CREATE TABLE</code> statement. You can add an aging policy to an existing table with the <code>ALTER TABLE</code> statement if the table does not already have an aging policy defined. You can change the aging policy by dropping aging and adding a new aging policy.</p>
<p>You <a id="sthref944"></a>cannot specify aging on the following types of tables:</p>
<ul>
<li>
<p>Global temporary tables</p>
</li>
<li>
<p>Detail tables for materialized views</p>
</li>
</ul>
<p>You can also implement aging in cache groups. See <a class="olink TTCAC249" href="../TTCAC/define.htm#TTCAC249">&#34;Implementing aging in a cache group&#34;</a> in the <span class="italic">Oracle TimesTen Application-Tier Database Cache User&#39;s Guide</span>.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDCCFAC">Usage-based aging</a></p>
</li>
<li>
<p><a href="#CHDCJGAA">Time-based aging</a></p>
</li>
<li>
<p><a href="#CHDJHFBJ">Aging and foreign keys</a></p>
</li>
<li>
<p><a href="#CHDBBCBC">Scheduling when aging starts</a></p>
</li>
<li>
<p><a href="#CHDHIBII">Aging and replication</a></p>
</li>
</ul>
<a id="CHDCCFAC"></a>
<div id="TTOPR349" class="sect3">
<h4 class="sect3">Usage-based aging</h4>
<p>Usage-based aging <a id="sthref945"></a><a id="sthref946"></a><a id="sthref947"></a><a id="sthref948"></a>enables you to maintain the amount of memory used in a database within a specified threshold by removing the least recently used (LRU) data.</p>
<p>Define LRU aging for a new table by using the <code>AGING LRU</code> clause of the <code>CREATE TABLE</code> statement. Aging begins automatically if the aging state is <code>ON</code>.</p>
<p>Call the <code>ttAgingLRUConfig</code> built-in procedure to specify the <a id="sthref949"></a>LRU <a id="sthref950"></a><a id="sthref951"></a><a id="sthref952"></a>aging attributes. The attribute values apply to all tables in the database that have an LRU aging policy. If you do not call the <code>ttAgingLRUConfig</code> built-in procedure, then the default values for the attributes are used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>ttAgingLRUConfig</code> built-in procedure requires that the user have <code>ADMIN</code> privilege if you want to modify any attributes. You do not need any privileges for viewing existing attributes. For more information, see <a class="olink TTREF213" href="../TTREF/proced.htm#TTREF213">&#34;Built-In Procedures&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<p>The following table summarizes the LRU aging attributes:</p>
<div class="inftblhruleinformal">
<table class="cellalignment3233" title="LRU aging attributes" summary="This table contains descriptions of LRU aging attributes." dir="ltr">
<thead>
<tr class="cellalignment3224">
<th class="cellalignment3234" id="r1c1-t7">LRU Aging Attribute</th>
<th class="cellalignment3234" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3224">
<td class="cellalignment3230" id="r2c1-t7" headers="r1c1-t7"><code><span class="codeinlineitalic">LowUsageThreshhold</span></code></td>
<td class="cellalignment3230" headers="r2c1-t7 r1c2-t7">The percent of the database <code>PermSize</code> at which LRU aging is deactivated.</td>
</tr>
<tr class="cellalignment3224">
<td class="cellalignment3230" id="r3c1-t7" headers="r1c1-t7"><code><span class="codeinlineitalic">HighUsageThreshhold</span></code></td>
<td class="cellalignment3230" headers="r3c1-t7 r1c2-t7">The percent of the database <code>PermSize</code> at which LRU aging is activated.</td>
</tr>
<tr class="cellalignment3224">
<td class="cellalignment3230" id="r4c1-t7" headers="r1c1-t7"><code><span class="codeinlineitalic">AgingCycle</span></code></td>
<td class="cellalignment3230" headers="r4c1-t7 r1c2-t7">The number of minutes between aging cycles.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<p>If you set a new value for <code><span class="codeinlineitalic">AgingCycle</span></code> after an LRU aging policy has already been defined, aging occurs based on the current time and the new cycle time. For example, if the original aging cycle is 15 minutes and LRU aging occurred 10 minutes ago, aging is expected to occur again in 5 minutes. However, if you change the <code><span class="codeinlineitalic">AgingCycle</span></code> parameter to 30 minutes, then aging occurs 30 minutes from the time you call the <code>ttAgingLRUConfig</code> procedure with the new value for <code><span class="codeinlineitalic">AgingCycle</span></code>.</p>
<p>If a row has been accessed or referenced since the last aging cycle, it is not eligible for LRU aging. A row is considered to be accessed or referenced if one of the following is true:</p>
<ul>
<li>
<p>The row is used to build the result set of a <code>SELECT</code> statement.</p>
</li>
<li>
<p>The row has been flagged to be updated or deleted.</p>
</li>
<li>
<p>The row is used to build the result set of an <code>INSERT SELECT</code> statement.</p>
</li>
</ul>
<p>You can use the <code>ALTER TABLE</code> statement to perform the following tasks:</p>
<ul>
<li>
<p>Enable or disable the aging state on a table that has an aging policy defined by using the <code>ALTER TABLE</code> statement with the <code>SET AGING</code> {<code>ON</code>|<code>OFF</code>} clause.</p>
</li>
<li>
<p>Add an LRU aging policy to an existing table by using the <code>ALTER TABLE</code> statement with the <code>ADD AGING LRU</code> [<code>ON</code>|<code>OFF</code>] clause.</p>
</li>
<li>
<p>Drop aging on a table by using the <code>ALTER TABLE</code> statement with the <code>DROP AGING</code> clause.</p>
</li>
</ul>
<p>Call the <code>ttAgingScheduleNow</code> built-in procedure to schedule when aging starts. For more information, see <a href="#CHDBBCBC">&#34;Scheduling when aging starts&#34;</a>.</p>
<p>To change aging from LRU to time-based on a table, first drop aging on the table by using the <code>ALTER TABLE</code> statement with the <code>DROP AGING</code> clause. Then add time-based aging by using the <code>ALTER TABLE</code> statement with the <code>ADD AGING USE</code> clause.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you drop LRU aging or add LRU aging to tables that are referenced in commands, TimesTen marks the compiled commands invalid. The commands need to be recompiled.</div>
</div>
<!-- class="sect3" -->
<a id="CHDCJGAA"></a>
<div id="TTOPR350" class="sect3">
<h4 class="sect3">Time-based aging</h4>
<p>Time-based <a id="sthref953"></a><a id="sthref954"></a><a id="sthref955"></a>aging removes data from a table based on the specified data lifetime and frequency of the aging process. Specify a time-based aging policy for a new table with the <code>AGING USE</code> clause of the <code>CREATE TABLE</code> statement. Add a time-based aging policy to an existing table with the <code>ADD AGING USE</code> clause of the <code>ALTER TABLE</code> statement.</p>
<p>The <code>AGING USE</code> clause has a <code><span class="codeinlineitalic">ColumnName</span></code> argument. <code><span class="codeinlineitalic">ColumnName</span></code> is the name of the column that is used for time-based aging, also called the <span class="italic">timestamp column</span>. The timestamp column must be defined as follows:</p>
<ul>
<li>
<p><code>ORA_TIMESTAMP</code>, <code>TT_TIMESTAMP</code>, <code>ORA_DATE</code> or <code>TT_DATE</code> data type</p>
</li>
<li>
<p><code>NOT NULL</code></p>
</li>
</ul>
<p>Your application updates the values of the timestamp column. If the value of this column is unknown for some rows and you do not want the rows to be aged, then define the column with a large default value. You can create an<a id="sthref956"></a><a id="sthref957"></a> index on the timestamp column for better performance of the aging process.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot add or modify a column in an existing table and then use that column as a timestamp column because you cannot add or modify a column and define it to be <code>NOT NULL</code>.</div>
<p>You cannot drop the timestamp column from a table that has a time-based aging policy.</p>
<p>If the data type of the timestamp column is <code>ORA_TIMESTAMP</code>, <code>TT_TIMESTAMP</code>, or <code>ORA_DATE</code>, you can specify the lifetime in days, hours, or minutes in the <code>LIFETIME</code> clause of the <code>CREATE TABLE</code> statement. If the data type of the timestamp column is <code>TT_DATE</code>, specify the lifetime in days.</p>
<p>The value in the timestamp column is subtracted from <code>SYSDATE</code>. The result is truncated the result using the specified unit (minute, hour, day) and compared with the specified <code>LIFETIME</code> value. If the result is greater than the <code>LIFETIME</code> value, then the row is a candidate for aging.</p>
<p>Use the <code>CYCLE</code> clause to indicate how often the system should examine the rows to remove data that has exceeded the specified lifetime. If you do not specify <code>CYCLE</code>, aging occurs every five minutes. If you specify 0 for the cycle, then aging is continuous. Aging begins automatically if the state is <code>ON</code>.</p>
<p>Use the <code>ALTER TABLE</code> statement to perform the following tasks:</p>
<ul>
<li>
<p>Enable or disable the aging state on a table with a time-based aging policy by using the <code>SET AGING</code> {<code>ON</code>|<code>OFF</code>} clause.</p>
</li>
<li>
<p>Change the aging cycle on a table with a time-based aging policy by using the <code>SET AGING CYCLE</code> clause.</p>
</li>
<li>
<p>Change the lifetime by using the <code>SET AGING LIFETIME</code> clause.</p>
</li>
<li>
<p>Add time-based aging to an existing table with no aging policy by using the <code>ADD AGING USE</code> clause.</p>
</li>
<li>
<p>Drop aging on a table by using the <code>DROP AGING</code> clause.</p>
</li>
</ul>
<p>Call the <code>ttAgingScheduleNow</code> built-in procedure to schedule when aging starts. For more information, see <a href="#CHDBBCBC">&#34;Scheduling when aging starts&#34;</a>.</p>
<p>To change the aging policy from time-based aging to LRU aging on a table, first drop time-based aging on the table. Then add LRU aging by using the <code>ALTER TABLE</code> statement with the <code>ADD AGING LRU</code> clause.</p>
</div>
<!-- class="sect3" -->
<a id="CHDJHFBJ"></a>
<div id="TTOPR351" class="sect3">
<h4 class="sect3">Aging and foreign keys</h4>
<p>Tables that are related by foreign keys must have the same aging policy.</p>
<ul>
<li>
<p>If LRU <a id="sthref958"></a><a id="sthref959"></a>aging is in effect and a row in a child table is recently accessed, then neither the parent row nor the child row is deleted.</p>
</li>
<li>
<p>If time-based aging is in effect and a row in a parent table is a candidate for aging out, then the parent row and all of its children are deleted.</p>
</li>
<li>
<p>If a table has <a id="sthref960"></a><code>ON DELETE CASCADE</code> enabled, the setting is ignored.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDBBCBC"></a>
<div id="TTOPR352" class="sect3">
<h4 class="sect3">Scheduling when aging starts</h4>
<p>Call the <code>ttAgingScheduleNow</code> built-in procedure to schedule the aging process. The aging process starts as soon as you call the procedure unless there is already an aging process in progress, in which case it begins when that aging process has completed.</p>
<p>When you call <code>ttAgingScheduleNow</code>, the aging process starts regardless of whether the state is <code>ON</code> or <code>OFF</code>.</p>
<p>The aging process starts only once as a result of calling <code>ttAgingScheduleNow</code> does not change the aging state. If the aging state is <code>OFF</code> when you call <code>ttAgingScheduleNow</code>, then the aging process starts, but it does not continue after the process is complete. To continue aging, you must call <code>ttAgingScheduleNow</code> again or change the aging state to <code>ON</code>.</p>
<p>If the aging state is already set to <code>ON</code>, then <code>ttAgingScheduleNow</code> resets the aging cycle based on the time ttAgingScheduleNow was called.</p>
<p>You can control aging externally by disabling aging by using the <code>ALTER TABLE</code> statement with the <code>SET AGING OFF</code> clause. Then use <code>ttAgingScheduleNow</code> to start aging at the desired time.</p>
<p>Use <code>ttAgingScheduleNow</code> to start or reset aging for an individual table by specifying its name when you call the procedure. If you do not specify a table name, then <code>ttAgingScheduleNow</code> starts or resets aging on all of the tables in the database that have aging defined.</p>
</div>
<!-- class="sect3" -->
<a id="CHDHIBII"></a>
<div id="TTOPR353" class="sect3">
<h4 class="sect3">Aging and replication</h4>
<p>For active standby pairs, implement <a id="sthref961"></a><a id="sthref962"></a><a id="sthref963"></a><a id="sthref964"></a>aging on the active master database. Deletes that occur as a result of aging are replicated to the standby master database and the read-only subscribers. If a failover to the standby master database occurs, aging is enabled on the database after its role changes to <code>ACTIVE</code>.</p>
<p>For all other types of replication schemes, implement aging separately on each node. The aging policy must be the same on all nodes.</p>
<p>If you implement LRU aging on a multimaster replication scheme used as a hot standby, LRU aging may provide unintended results. After a failover, you may not have all of the desired data because aging occurs locally.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDHBJF"></a>
<div id="TTOPR354" class="sect1">
<h2 class="sect1">Understanding <a id="sthref965"></a>views</h2>
<p>A <span class="italic">view</span> is a logical table that is based on one or more tables. The view itself contains no data. It is sometimes called a <span class="italic">non-materialized view</span> to distinguish it from a materialized view, which does contain data that has already been calculated from <span class="italic">detail tables</span>. Views cannot be updated directly, but changes to the data in the detail tables are immediately reflected in the view.</p>
<p>To choose whether to create a view or a materialized view, consider where the cost of calculation lies. For a materialized view, the cost falls on the users who update the detail tables because calculations must be made to update the data in the materialized views. For a nonmaterialized view, the cost falls on a connection that queries the view, because the calculations must be made at the time of the query.</p>
<p>To perform any operation that creates, drops or manages a view, the user must have the appropriate privileges, which are described along with the syntax for all SQL statements in the <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDBDFCJ">Creating a view</a></p>
</li>
<li>
<p><a href="#CHDHAAJE">Dropping a view</a></p>
</li>
<li>
<p><a href="#CHDIDAJG">Restrictions on views and detail tables</a></p>
</li>
</ul>
<a id="CHDBDFCJ"></a>
<div id="TTOPR355" class="sect2">
<h3 class="sect2">Creating a <a id="sthref966"></a>view</h3>
<p>To create a view, use the <code>CREATE VIEW</code> SQL statement. The syntax for all SQL statements is provided in the <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<pre>CREATE VIEW ViewName AS SelectQuery;
</pre>
<p>This selects columns from the detail tables to be used in the view.</p>
<p>For example, create a view from the table <code>t1</code>:</p>
<pre>CREATE VIEW v1 AS SELECT * FROM t1;
</pre>
<p>Now create a view from an aggregate query on the table <code>t1</code>:</p>
<pre>CREATE VIEW v1 (max1) AS SELECT max(x1) FROM t1;
</pre>
<div id="TTOPR356" class="sect3"><a id="sthref967"></a>
<h4 class="sect3">The SELECT query in the CREATE VIEW statement</h4>
<p>The <code>SELECT</code> query <a id="sthref968"></a>used to define the contents of a materialized view is similar to the top-level SQL <code>SELECT</code> statement described in <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>, with the following restrictions:</p>
<ul>
<li>
<p>A <code>SELECT *</code> query in a view definition is expanded at view creation time. Any columns added after a view is created do not affect the view.</p>
</li>
<li>
<p>The following cannot be used in a <code>SELECT</code> statement that is creating a view:</p>
</li>
<li>
<p><code>DISTINCT</code></p>
</li>
<li>
<p><code>FIRST</code></p>
</li>
<li>
<p><code>ORDER BY</code></p>
</li>
<li>
<p>Arguments</p>
</li>
<li>
<p>Temporary tables</p>
</li>
<li>
<p>Each expression in the select list must have a unique name. A name of a simple column expression would be that column&#39;s name unless a column alias is defined. <span class="italic">RowId</span> is considered an expression and needs an alias.</p>
</li>
<li>
<p>No <code>SELECT FOR UPDATE</code> or <code>SELECT FOR INSERT</code> statements can be used on a view.</p>
</li>
<li>
<p>Certain TimesTen query restrictions are not checked when a non-materialized view is created. Views that violate those restrictions may be allowed to be created, but an error is returned when the view is referenced later in an executed statement.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDHAAJE"></a>
<div id="TTOPR357" class="sect2">
<h3 class="sect2">Dropping a view</h3>
<p>The <code>DROP VIEW</code> statement <a id="sthref969"></a>deletes the specified view.</p>
<p>The following statement drops the <code>CustOrder</code> view:</p>
<pre>DROP VIEW CustOrder;
</pre></div>
<!-- class="sect2" -->
<a id="CHDIDAJG"></a>
<div id="TTOPR358" class="sect2">
<h3 class="sect2">Restrictions on views and detail tables</h3>
<p>Views <a id="sthref970"></a>have the following restrictions:</p>
<ul>
<li>
<p>When a view is referenced in the <code>FROM</code> clause of a <code>SELECT</code> statement, its name is replaced by its definition as a derived table at parsing time. If it is not possible to merge all clauses of a view to the same clause in the original select to form a legal query without the derived table, the content of this derived table is <span class="bold">materialized</span>. For example, if both the view and the referencing select specify aggregates, the view is <span class="bold">materialized</span> before its result can be joined with other tables of the select.</p>
</li>
<li>
<p>A view cannot be dropped with a <code>DROP TABLE</code> statement. You must use the <code>DROP VIEW</code> statement.</p>
</li>
<li>
<p>A view cannot be altered with an <code>ALTER TABLE</code> statement.</p>
</li>
<li>
<p>Referencing a view can fail due to dropped or altered detail tables.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDEAFCA"></a>
<div id="TTOPR359" class="sect1">
<h2 class="sect1">Understanding materialized views<a id="sthref971"></a></h2>
<p>The following sections describes materialized views and how to manage them:</p>
<ul>
<li>
<p><a href="#BABGJIDF">Overview of materialized views</a></p>
</li>
<li>
<p><a href="#CHDBIHFC">Working with materialized views</a></p>
</li>
</ul>
<a id="BABGJIDF"></a>
<div id="TTOPR360" class="sect2">
<h3 class="sect2">Overview of materialized views</h3>
<p>A materialized view is a read-only table that maintains a summary of data selected from one or more regular TimesTen tables. The TimesTen tables queried to make up the result set for the materialized view are called <a id="sthref972"></a><a id="sthref973"></a>detail tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Materialized views are not supported on cache tables.</div>
<p><a href="#CEGHEEJH">Figure 8-1</a> shows a materialized view created from detail tables. An application updates the detail tables and can select data from the materialized view.</p>
<div id="TTOPR361" class="figure">
<p class="titleinfigure"><a id="CEGHEEJH"></a>Figure 8-1 Materialized view</p>
<img width="230" height="338" src="./img/materialized_views.gif" alt="Description of Figure 8-1 follows"/><br/>
<a id="sthref974" href="./img_text/materialized_views.htm">Description of &#34;Figure 8-1 Materialized view&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>There are two types of materialized views based upon how the result set for the materialized view is updated.</p>
<ul>
<li>
<p><a href="#BABIDEAB">Synchronous materialized view</a></p>
</li>
<li>
<p><a href="#BABJHJBA">Asynchronous materialized view</a></p>
</li>
</ul>
<p>In addition, learn when to use each type of materialized views in the section: <a href="#BABBDJIE">&#34;When to use synchronous or asynchronous materialized views&#34;</a>.</p>
<a id="BABIDEAB"></a>
<div id="TTOPR362" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Synchronous materialized view</h4>
<p><a id="sthref975"></a>The synchronous materialized view, by default, updates the result set data from the detail tables at the time of the detail table transaction. Every time data is updated in the detail tables, the result set is updated. Thus, the synchronous materialized view is never out of sync with the detail tables. However, this can affect your performance. A single transaction, the user transaction, executes the updates for both the detail table and any synchronous materialized views.</p>
</div>
<!-- class="sect3" -->
<a id="BABJHJBA"></a>
<div id="TTOPR363" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Asynchronous materialized view</h4>
<p><a id="sthref976"></a>The materialized view is populated and it is in sync with the detail tables at creation. When the detail tables are updated, the asynchronous materialized views are not updated immediately. At any moment, they can be out of sync with the corresponding detail tables. The asynchronous materialized view defers updates to the result set as a trade-off for performance. You decide when and how the result set is refreshed either manually by the user or automatically within a pre-configured interval. The asynchronous materialized view is always refreshed in its own transaction, not within the user transaction that updates the detail tables. Thus, the user transaction is not blocked by any updates for the asynchronous materialized view.</p>
<p>The asynchronous refresh may use either of the following refresh method configurations:</p>
<ul>
<li>
<p><code>FAST</code>, which updates only the incremental changes since the last update.</p>
</li>
<li>
<p><code>COMPLETE</code>, which provides a full refresh.</p>
</li>
</ul>
<p>To facilitate a <code>FAST</code> refresh, you must create a materialized view log to manage the deferred incremental transactions for each detail table used by the asynchronous materialized view. Each detail table requires only one materialized view log for managing all deferred transactions, even if it is included in more than one <code>FAST</code> asynchronous materialized view.</p>
<p>The detail table cannot be dropped if there is an associated materialized view or materialized view log.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use XLA in conjunction with asynchronous materialized views, you cannot depend on the ordering of the DDL statements. In general, there are no operational differences between the XLA mechanisms used to track changes to a table or a materialized view. However, for asynchronous materialized views, be aware that the order of XLA notifications for an asynchronous view is not necessarily the same as it would be for the associated detail tables, or the same as it would be for asynchronous view. For example, if there are two inserts to a detail table, they may be done in the opposite order in the asynchronous materialized view. Furthermore, updates may be treated as a delete followed by an insert, and multiple operations, such as multiple inserts or multiple deletes, may be combined. Applications that depend on ordering should not use asynchronous materialized views.</div>
</div>
<!-- class="sect3" -->
<a id="BABBDJIE"></a>
<div id="TTOPR364" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">When to use synchronous or asynchronous materialized views</h4>
<p>The following sections provide guidelines on when to use synchronous or asynchronous materialized views:</p>
<ul>
<li>
<p><a href="#BABIAEDG">Joins and aggregate functions turn into super locks</a></p>
</li>
<li>
<p><a href="#BABIBJCE">Freshness of the materialized view</a></p>
</li>
<li>
<p><a href="#BABGJGEB">Overhead cost</a></p>
</li>
</ul>
<a id="BABIAEDG"></a>
<div id="TTOPR365" class="sect4">
<h5 class="sect4">Joins and aggregate functions turn into super locks</h5>
<p>If a synchronous materialized view has joins or uses aggregate functions, there is a super lock effect. For example, if you have a single table with a synchronous materialized view that aggregates on average 1000 rows into 1. When you update a row in the detail table of the synchronous materialized view, you lock that row for the remainder of the transaction. Any other transaction that attempts to update that row blocks and waits until the transaction commits.</p>
<p>But since there is a synchronous materialized view on that table, the materialized view is also updated. The single row in the materialized view is locked and updated to reflect the change. However, there are 999 other rows from the base table that also aggregate to that same materialized view row. These 999 other base table rows are also effectively locked because if you try to update any of them, you block and wait while retrieving the lock on the materialized view row. This is referred to as a super lock.</p>
<p>The same effect occurs across joins. If you have a synchronous materialized view that joins five tables and you update a row in any one of the five tables, you acquire a super lock on all the rows in the other four tables that join to the one that you updated.</p>
<p>Obviously, the combination of joins and aggregate functions compound the problem for synchronous materialized views. However, asynchronous materialized views with COMPLETE refresh diminish the super lock because the locks on the asynchronous materialized view rows with COMPLETE refresh are only held during the refresh process. The super locks with synchronous materialized views are held until the updating transaction commits. Thus, if you have short transactions, then super locks on synchronous materialized view are not a problem. However, if you have long transactions, use asynchronous materialized views with COMPLETE refresh that minimize the effect of any super lock.</p>
</div>
<!-- class="sect4" -->
<a id="BABIBJCE"></a>
<div id="TTOPR366" class="sect4">
<h5 class="sect4">Freshness of the materialized view</h5>
<p>Synchronous materialized views are always fresh and they always return the latest data. Asynchronous materialized views can become stale after an update until refreshed. If you must have the most current data all the time, use synchronous materialized views. However, you may consider using asynchronous if your application does not need the most current data.</p>
<p>For example, you may execute a series of analytical queries each with variations. In this case, you can use an asynchronous materialized view to isolate the differences that result from the query variations from the differences that result from newly arrived or updated data.</p>
</div>
<!-- class="sect4" -->
<a id="BABGJGEB"></a>
<div id="TTOPR367" class="sect4">
<h5 class="sect4">Overhead cost</h5>
<p>An asynchronous materialized view is not updated in the user transaction, which updates the detail tables. The refresh of an asynchronous materialized view is always performed in an independent transaction. This means that the user is free to execute any other transaction. By comparison, for synchronous materialized views, a single transaction executes the updates for both the detail table and any synchronous materialized views, which does affect your performance.</p>
<p>While the asynchronous materialized view logs for asynchronous materialized views with FAST refresh incur overhead, it is generally less overhead than the cost of updating a synchronous materialized view. This is especially true even if the asynchronous materialized view is complicated with joins. For asynchronous materialized views with COMPLETE refresh, there is no overhead at the time of updating the detail table.</p>
<p>You can defer asynchronous materialized view maintenance cost. The asynchronous materialized view log costs less than the incremental maintenance of the synchronous materialized view because the asynchronous materialized view logs perform simple inserts, whereas synchronous materialized view maintenance has to compute the delta for the materialized view and joins and then apply results in an update operation. Updates are more expensive than inserts. The cost difference reduces if the synchronous materialized view is simple in structure.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBIHFC"></a>
<div id="TTOPR368" class="sect2">
<h3 class="sect2">Working with materialized views</h3>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDHFCEJ">Creating a materialized view</a></p>
</li>
<li>
<p><a href="#CHDHIDDA">Dropping a materialized view or a materialized view log</a></p>
</li>
<li>
<p><a href="#CHDBAEBJ">Restrictions on materialized views and detail tables</a></p>
</li>
<li>
<p><a href="#CHDIHICJ">Performance implications of materialized views</a></p>
</li>
</ul>
<a id="CHDHFCEJ"></a>
<div id="TTOPR369" class="sect3">
<h4 class="sect3">Creating a materialized view</h4>
<p><a id="sthref977"></a>To create a materialized view, use the SQL statement <code>CREATE MATERIALIZED VIEW</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In order to create a materialized view, the user must have the appropriate privileges, which are described along with the syntax for all SQL statements in the <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.
<p>If the owner has these privileges revoked for any of the detail tables on which the materialized view is created, the materialized view becomes invalid. See <a href="accesscontrol.htm#BABEICBH">&#34;Object privileges for materialized views&#34;</a> for details.</p>
</div>
<p>When creating a materialized view, you can establish primary keys and the size of the hash table in the same manner as described for tables in <a href="#CHDEGADH">&#34;Primary keys, foreign keys and unique indexes&#34;</a>.</p>
<p>The materialized view examples are based on the following two tables:</p>
<pre>CREATE TABLE customer(custId int not null,
  custName char(100) not null,
  Addr char(100),
  Zip int,
  Region char(10),
  PRIMARY KEY (custId));

CREATE TABLE bookOrder(orderId int not null,
  custId int not null,
  book char(100),
  PRIMARY KEY (orderId),
  FOREIGN KEY (custId) REFERENCES Customer(custId));
</pre>
<p>The following sections provide details and examples for creating materialized views:</p>
<ul>
<li>
<p><a href="#BABHHABI">Creating a synchronous materialized view</a></p>
</li>
<li>
<p><a href="#BABEDIBC">Creating an asynchronous materialized view</a></p>
</li>
<li>
<p><a href="#BABBBIDJ">The SELECT query in the CREATE MATERIALIZED VIEW statement</a></p>
</li>
</ul>
<a id="BABHHABI"></a>
<div id="TTOPR370" class="sect4">
<h5 class="sect4">Creating a synchronous materialized view</h5>
<p><a id="sthref978"></a>A synchronous materialized view is automatically updated each time the detail tables are updated. You can create a synchronous materialized view with the <code>CREATE MATERIALIZED VIEW</code> statement.</p>
<p>The following creates a synchronous materialized view, named <code>SampleMV</code>, that generates a result set from selected columns in the <code>customer</code> and <code>bookOrder</code> detail tables described above.</p>
<pre>CREATE MATERIALIZED VIEW SampleMV AS
 SELECT customer.custId, custName, orderId, book
 FROM customer, bookOrder
 WHERE customer.custId=bookOrder.custId;
</pre></div>
<!-- class="sect4" -->
<a id="BABEDIBC"></a>
<div id="TTOPR371" class="sect4">
<h5 class="sect4">Creating an asynchronous materialized view</h5>
<p><a id="sthref979"></a>An asynchronous materialized view is updated as specified by the refresh method and refresh interval, which are configured during the creation of the materialized view.</p>
<p>When you create an asynchronous materialized view, you specify the <code>REFRESH</code> clause with at least one of the following:</p>
<ul>
<li>
<p>Refresh method: For the asynchronous materialized view, specify either <code>FAST</code> or <code>COMPLETE</code> for the refresh method. <code>FAST</code> denotes an incremental refresh. <code>COMPLETE</code> indicates a full refresh. If the refresh method is omitted, then <code>COMPLETE</code> is the default refresh method. If you specify <code>FAST</code>, you must create the asynchronous materialized view log for each detail table associated with the materialized view.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Aggregate functions and outer joins are not supported in a <code>FAST</code> refresh.</div>
</li>
<li>
<p>Refresh interval:</p>
<ul>
<li>
<p>Manual update: If the refresh interval is not specified, the interval defaults to manual update. You can manually refresh the view by using the <code>REFRESH MATERIALIZED VIEW</code> statement, which is described at the end of this section.</p>
</li>
<li>
<p>Specify refresh after every commit: When you specify <code>NEXT SYSDATE</code> without specifying <code>NUMTODSINTERVL()</code>, the refresh is performed after every commit of any user transaction that updates the detail tables. This refresh is always performed in a separate transaction. The user transaction does not wait for the refresh to complete. The option to refresh at every commit is only supported for the fast refresh method.</p>
</li>
<li>
<p>Specify interval: The asynchronous materialized view is updated at a specified interval when you use the <code>NEXT SYSDATE + NUMTODSINTERVAL(</code><code><span class="codeinlineitalic">IntegerLiteral</span></code><code>,</code><code><span class="codeinlineitalic">IntervalUnit</span></code>) clause. This option is supported for both <code>FAST</code> and <code>COMPLETE</code> refresh methods.</p>
<p>This clause specifies that the materialized view is refreshed at the specified interval. <code><span class="codeinlineitalic">IntegerLiteral</span></code> must be an integer. <code><span class="codeinlineitalic">IntervalUnit</span></code> must be one of the following values: <code>&#39;DAY&#39;</code>, <code>&#39;HOUR&#39;</code>, <code>&#39;MINUTE&#39;</code>, or <code>&#39;SECOND&#39;</code>.</p>
<p>The last refresh time is saved in order to determine the next refresh time. Refresh is skipped if there are no changes to the any of the detail tables of the asynchronous materialized view since the last refresh. If you want to modify a configured refresh interval, you must drop and recreate the asynchronous materialized view.</p>
</li>
</ul>
</li>
</ul>
<p>If you use the <code>FAST</code> refresh method, the deferred transactions are saved in a materialized view log. Thus, before you create an asynchronous materialized view, you must create a materialized view log for each detail table included in the asynchronous materialized view that uses <code>FAST</code> refresh. Each detail table can have only one materialized view log even if they are used by more than one asynchronous materialized view with <code>FAST</code> refresh. All columns referenced in an asynchronous materialized view must be included in the corresponding asynchronous materialized view log. If there is more than one asynchronous materialized view with <code>FAST</code> refresh created on a detail table, make sure to include all columns that are used in the different asynchronous materialized views created for that detail table in its asynchronous materialized view log.</p>
<p>The following example creates an asynchronous materialized view that uses <code>FAST</code> refresh, where the deferred transactions are updated every hour after creation. First, create the materialized view log for each detail table, <code>customer</code> and <code>bookOrder</code>. The following statements create the materialized log views for <code>customer</code> and <code>bookOrder</code> to track the deferred transactions for the <code>FAST</code> refresh. The materialized view log for <code>customer</code> tracks the primary key and the customer name as follows:</p>
<pre>CREATE MATERIALIZED VIEW LOG ON customer WITH PRIMARY KEY (custName);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the <code>CREATE MATERIALIZED VIEW LOG</code> syntax, the primary key is included if you specify <code>WITH PRIMARY KEY</code> or do not mention either <code>PRIMARY KEY</code> or <code>ROWID</code>. All non-primary key columns that you want included in the materialized view log must be specified in the parenthetical column list.</div>
<p>The materialized view log for the <code>bookorder</code> table tracks the primary key of <code>orderId</code> and columns <code>custId</code>, and <code>book</code>.</p>
<pre>CREATE MATERIALIZED VIEW LOG ON bookOrder WITH (custId, book);
</pre>
<p>Once you create the materialized view log for both the <code>customer</code> and <code>bookOrder</code> detail tables, you can create an asynchronous materialized view. The asynchronous materialized view must include either the <code>ROWID</code> or primary key columns for all the detail tables.</p>
<p>The following example creates an asynchronous materialized view named <code>SampleAMV</code> that generates a result set from selected columns in the <code>customer</code> and <code>bookOrder</code> detail tables. The statement specifies a <code>FAST</code> refresh to update the deferred transactions every hour from the moment of creation.</p>
<pre>CREATE MATERIALIZED VIEW SampleAMV 
 REFRESH 
     FAST 
     NEXT SYSDATE + NUMTODSINTERVAL(1, &#39;HOUR&#39;)
 AS SELECT customer.custId, custName, orderId, book
 FROM customer, bookOrder
 WHERE customer.custId=bookOrder.custId;
</pre>
<p>If you want to manually refresh the materialized view, execute the <code>REFRESH MATERIALIZED VIEW</code> statement. You can manually refresh the materialized view at any time, even if a <code>REFRESH</code> interval is specified. For example, if there were multiple updates to the detail tables, you can manually refresh the <code>SampleAMV</code> materialized view as follows:</p>
<pre>REFRESH MATERIALIZED VIEW SampleAMV;
</pre></div>
<!-- class="sect4" -->
<a id="BABBBIDJ"></a>
<div id="TTOPR372" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">The SELECT query in the CREATE MATERIALIZED VIEW statement</h5>
<p>The <a id="sthref980"></a><code>SELECT</code> query used to define the contents of a materialized view is similar to the top-level SQL <code>SELECT</code> statement described in <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> with some restrictions, which are described in <a class="olink TTSQL293" href="../TTSQL/state.htm#TTSQL293">&#34;CREATE MATERIALIZED VIEW&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDHIDDA"></a>
<div id="TTOPR373" class="sect3">
<h4 class="sect3">Dropping a materialized view or a materialized view log</h4>
<p><a id="sthref981"></a><a id="sthref982"></a><a id="sthref983"></a><a id="sthref984"></a><a id="sthref985"></a><a id="sthref986"></a><a id="sthref987"></a><a id="sthref988"></a><a id="sthref989"></a>To drop any materialized view, execute the <code>DROP VIEW</code> statement.</p>
<p>The following statement drops the <code>sampleMV</code> materialized view.</p>
<pre>DROP VIEW sampleMV;
</pre>
<p>When there are no asynchronous materialized views referencing a table, the materialized view log on that table can be dropped. For example, if you have dropped the materialized view <code>sampleAMV</code>, then the following statements drop the associated materialized view logs.</p>
<pre>DROP MATERIALIZED VIEW LOG ON customer;
DROP MATERIALIZED VIEW LOG ON bookOrder;
</pre>
<p>The syntax for all SQL statements is provided in the <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<div id="TTOPR374" class="sect4"><a id="sthref990"></a>
<h5 class="sect4">Identifying the table associated with a materialized view log</h5>
<p>Materialized view logs are represented in the TimesTen system tables as a table named <code>MVLOG$_</code><code><span class="codeinlineitalic">detailTableId</span></code>, where <code><span class="codeinlineitalic">detailTableId</span></code> is the table id of the table on which it was created. The table id and table name are both recorded in <code>SYS.TABLES</code>. For example, if the materialized view log file name is <code>MVLOG$_507244</code>, then you can retrieve the table name from <code>SYS.TABLES</code> where the table id is 507244 as follows:</p>
<pre>select tblname from sys.tables where tblid = 507244;
&lt; T1 &gt;
1 row found.
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDBAEBJ"></a>
<div id="TTOPR375" class="sect3">
<h4 class="sect3">Restrictions<a id="sthref991"></a> on materialized views and detail tables</h4>
<p>A materialized view is a read-only table that cannot be updated directly. This means a materialized view cannot be updated by an <code>INSERT</code>, <code>DELETE</code>, or <code>UPDATE</code> statement by replication, XLA, or the cache agent.</p>
<p>For example, any attempt to update a row in a materialized view generates the following error:</p>
<pre>805: Update view table directly has not been implemented
</pre>
<p>Readers familiar with other implementations of materialized views should note the following characteristics of TimesTen views:</p>
<ul>
<li>
<p>Detail tables can be replicated, but materialized views cannot.</p>
</li>
<li>
<p>Neither a materialized view nor its detail tables can be part of a cache group.</p>
</li>
<li>
<p>No referential indexes can be defined on the materialized view.</p>
</li>
<li>
<p>To drop a materialized view must use the <code>DROP VIEW</code> statement.</p>
</li>
<li>
<p>You cannot alter a materialized view. You must use the <code>DROP VIEW</code> statement and then create a new materialized view with a <code>CREATE MATERIALIZED VIEW</code> statement.</p>
</li>
<li>
<p>Materialized views must be explicitly created by the application. The TimesTen query optimizer has no facility to automatically create materialized views.</p>
</li>
<li>
<p>The TimesTen query optimizer does not rewrite queries on the detail tables to reference materialized views. Application queries must directly reference views, if they are to be used.</p>
</li>
<li>
<p>There are some restrictions to the SQL used to create materialized views. See <a class="olink TTSQL293" href="../TTSQL/state.htm#TTSQL293">&#34;CREATE MATERIALIZED VIEW&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for details.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDIHICJ"></a>
<div id="TTOPR376" class="sect3">
<h4 class="sect3">Performance implications of materialized views</h4>
<p>The following sections describes performance implications for each type of materialized view:</p>
<ul>
<li>
<p><a href="#BABBDHHC">Managing performance for asynchronous materialized views</a></p>
</li>
<li>
<p><a href="#BABIGFFB">Managing performance for synchronous materialized views</a></p>
</li>
</ul>
<a id="BABBDHHC"></a>
<div id="TTOPR377" class="sect4">
<h5 class="sect4">Managing performance for asynchronous materialized views</h5>
<p>For managing performance, you can defer the refresh of the materialized view until an optimal time. Rows in the materialized view logs, detail table and materialized view may be locked during the refresh. If these locks interfere with the user transaction updating the detail tables, then the user can adjust the refresh interval. If performance is the highest priority and the asynchronous materialized view can be out of sync with the detail tables, set the refresh interval to execute when the system load is low.</p>
<ul>
<li>
<p>FAST refresh incrementally updates the materialized view based on the changes captured in the materialized view log. The time for this refresh depends on the number of modifications captured in the materialized view log and the complexities of the <code>SELECT</code> statement used in the <code>CREATE MATERIALIZED VIEW</code> statement. After every refresh, the processed rows in the materialized view log are deleted.</p>
<p>Update table statistics on the detail table, materialized view log tables and the materialized view at periodic intervals to improve the refresh performance. If the view involves joins, update table statistics before inserting any row in any of the detail tables. Table statistics can be updated using one of two built-in procedures for computing statistics: <code>ttOptUpdateStats</code> and <a id="sthref992"></a><a id="sthref993"></a><a id="sthref994"></a><a id="sthref995"></a><a id="sthref996"></a><a id="sthref997"></a><code>ttOptEstimateStats</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more details on updating table statistics and when it is appropriate to update statistics, see <a href="perform.htm#CACBAGDC">&#34;Compute exact or estimated statistics&#34;</a>.</div>
</li>
<li>
<p>A complete refresh is similar to the initial loading of the materialized view at creation time. The time for this refresh depends on the number of rows in the detail tables.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BABIGFFB"></a>
<div id="TTOPR378" class="sect4">
<h5 class="sect4"><a id="sthref998"></a>Managing performance for synchronous materialized views</h5>
<p>The performance of <code>UPDATE</code> and <code>INSERT</code> operations may be impacted if the updated table is referenced in a materialized view. The performance impact depends on many factors, such as the following:</p>
<ul>
<li>
<p>Nature of the materialized view: How many detail tables, whether outer join or aggregation, are used.</p>
</li>
<li>
<p>Which indexes are present on the detail table and on the materialized view.</p>
</li>
<li>
<p>How many materialized view rows are affected by the change.</p>
</li>
</ul>
<p>A view is a persistent, up-to-date copy of a query result. To keep the view up to date, TimesTen must perform &#34;view maintenance&#34; when you change a view&#39;s detail table. For example, if you have a view named <code>V</code> that selects from tables <code>T1</code>, <code>T2</code>, and <code>T3</code>, then any time you insert into <code>T1</code>, or update <code>T2</code>, or delete from <code>T3</code>, TimesTen performs &#34;view maintenance.&#34;</p>
<p>View maintenance needs appropriate indexes just like regular database operations. If they are not there, view maintenance performs poorly.</p>
<p>All update, insert, or delete statements on detail tables have execution plans, as described in <a href="query.htm#BABEJFHI">&#34;The TimesTen Query Optimizer&#34;</a>. For example, an update of a row in <code>T1</code> initiates the first stage of the plan where it updates the view <code>V</code>, followed by a second stage where it updates T1.</p>
<p>For fast view maintenance, you should evaluate the plans for all the operations that update the detail tables, as follows:</p>
<ol>
<li>
<p>Examine all the <code>WHERE</code> clauses for the update or delete statements that frequently occur on the detail tables. Note any clause that uses an index key. For example, if the operations that an application performs 95 percent of the time are as follows:</p>
<pre>UPDATE T1 set A=A+1 WHERE K1=? AND K2=?
DELETE FROMT2 WHERE K3=?
</pre>
<p>Then the keys to note are (<code>K1</code>, <code>K2</code>) and <code>K3</code>.</p>
</li>
<li>
<p>Ensure that the view selects all of those key columns. In this example, the view should select <code>K1</code>, <code>K2</code>, and <code>K3</code>.</p>
</li>
<li>
<p>Create an index on the view on each of those keys. In this example, the view should have two indexes, one on (<code>V.K1</code>, <code>V.K2</code>) and one on <code>V.K3</code>. The indexes do not have to be unique. The names of the view columns can be different from the names of the table columns, though they are the same in this example.</p>
</li>
</ol>
<p>With this method, when you update a detail table, your <code>WHERE</code> clause is used to do the corresponding update of the view. This allows maintenance to be executed in a batch, which has better performance.</p>
<p>The above method may not always work, however. For example, an application may have many different methods to update the detail tables. The application would have to select far too many items in the view or create too many indexes on the view, taking up more space or more performance than you might wish. An alternative method is as follows:</p>
<ol>
<li>
<p>For each table in the view&#39;s <code>FROM</code> clause (each detail table), check which ones are frequently changed by <code>UPDATE</code>, <code>INSERT</code> and <code>CREATE VIEW</code> statements. For example, a view&#39;s <code>FROM</code> clause may have tables <code>T1</code>, <code>T2</code>, <code>T3</code>, <code>T4</code>, and <code>T5</code>, but of those, only <code>T2</code> and <code>T3</code> are frequently changed.</p>
</li>
<li>
<p>For each of those tables, make sure the view selects its rowids. In this example, the view should select <code>T2</code>.rowid and <code>T3</code>.rowid.</p>
</li>
<li>
<p>Create an index on the view on each of those rowid columns. In this example, the columns might be called <code>T2rowid</code> and <code>T3rowid</code>, and indexes would be created on <code>V.T2rowid</code> and <code>V.T3rowid</code>.</p>
</li>
</ol>
<p>With this method, view maintenance is done on a row-by-row basis, rather than on a batch basis. But the rows can be matched very efficiently between a view and its detail tables, which speeds up the maintenance. It is generally not as fast as the first method, but it is still good.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDGBEJB"></a>
<div id="TTOPR379" class="sect1">
<h2 class="sect1">Understanding indexes</h2>
<p><a id="sthref999"></a>Indexes are auxiliary data structures that greatly improve the performance of table searches. You can use the Index Advisor to recommend indexes for a particular SQL workload. For more details, see <a href="#BABJDBFD">&#34;Using the Index Advisor to recommend indexes&#34;</a>.</p>
<p>Indexes are used automatically by the query optimizer to speed up the execution of a query. For information about the query optimizer, see <a href="query.htm#BABEJFHI">&#34;The TimesTen Query Optimizer&#34;</a>.</p>
<p>You can designate an index as <a id="sthref1000"></a><a id="sthref1001"></a><a id="sthref1002"></a>unique, which means that each row in the table has a unique value for the indexed column or columns. Unique indexes can be created over nullable columns. In conformance with the SQL standard, multiple null values are permitted in a unique index.</p>
<p><a id="sthref1003"></a><a id="sthref1004"></a>When sorting data values, TimesTen considers null values to be larger than all non-null values. For more information on null values, see <a class="olink TTSQL173" href="../TTSQL/types.htm#TTSQL173">&#34;Null values&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>To perform any operation that creates, drops, or alters an index, the user must have the appropriate privileges, which are described along with the syntax for all SQL statements in the <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>The following sections describe how to manage your index:</p>
<ul>
<li>
<p><a href="#BABJDEAF">Overview of index types</a></p>
</li>
<li>
<p><a href="#CHDEFHIJ">Creating an index</a></p>
</li>
<li>
<p><a href="#CHDBAIDI">Altering an index</a></p>
</li>
<li>
<p><a href="#CHDFBJFE">Dropping an index</a></p>
</li>
<li>
<p><a href="#CHDHFFFD">Estimating index size</a></p>
</li>
<li>
<p><a href="#BABJDBFD">Using the Index Advisor to recommend indexes</a></p>
</li>
</ul>
<a id="BABJDEAF"></a>
<div id="TTOPR380" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Overview of index types</h3>
<p>TimesTen provides three types of indexes to enable fast access to tables.</p>
<ul>
<li>
<p><span class="bold">Range Indexes</span>. Range <a id="sthref1005"></a>indexes are useful for finding rows with column values within a certain range. You can create range indexes over one or more columns of a table. Up to 32 range indexes may be created on one table.</p>
<p>Range indexes and equijoins can be used for equality and range searches, such as greater than or equal to, less than or equal to, and so on. If you have a primary key on a field and want to see if <code>FIELD &gt; 10</code>, then the primary key index does not expedite finding the answer, but a separate index will.</p>
<p>See the <a class="olink TTSQL292" href="../TTSQL/state.htm#TTSQL292">&#34;CREATE INDEX&#34;</a> section of the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for more information on how to create range indexes.</p>
</li>
<li>
<p><span class="bold">Hash Indexes</span>. Hash <a id="sthref1006"></a>indexes are useful for equality searches. <a id="sthref1007"></a><a id="sthref1008"></a>A hash index is created with either of the following:</p>
<ul>
<li>
<p>You can create a hash index or a unique hash index on one or more columns of a table or materialized view with the <code>CREATE INDEX</code> statement.</p>
</li>
<li>
<p>You can create a unique hash index on the primary key of a table during table creation with the <code>CREATE TABLE... UNIQUE HASH ON</code> statement.</p>
</li>
</ul>
<p>See the <a class="olink TTSQL292" href="../TTSQL/state.htm#TTSQL292">&#34;CREATE INDEX&#34;</a> and <a class="olink TTSQL302" href="../TTSQL/state.htm#TTSQL302">&#34;CREATE TABLE&#34;</a> sections of the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for details on creating hash indexes. For an example of how to create a hash index, see <a href="#BABJACGH">Example 8-4</a>. For details on how to size a hash table, see <a href="perform.htm#CACFIFGD">&#34;Size hash indexes appropriately&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Hash indexes are faster than range indexes for exact match lookups, but they require more space than range indexes. Hash indexes cannot be used for lookups involving ranges.
<p>Range indexes are optimized for in-memory data management and provide efficient sorting by column value.</p>
<p>TimesTen may create temporary hash and range indexes automatically during query processing to speed up query execution.</p>
</div>
</li>
<li>
<p><span class="bold">Bitmap Indexes</span>. <a id="sthref1009"></a>Bitmap indexes are useful when searching and retrieving data from columns with low cardinality. That is, these columns can have only a few unique possible values. Bitmap indexes encode information about a unique value in a row in a bitmap. Each bit in the bitmap corresponds to a row in the table. Use a bitmap index for columns that do not have many unique values. An example of such a column is a column that records gender as one of two values.</p>
<p>Bitmap indexes increase the performance of complex queries that specify multiple predicates on multiple columns connected by <code>AND</code> and <code>OR</code> operators.</p>
<p>See <a class="olink TTSQL292" href="../TTSQL/state.htm#TTSQL292">&#34;CREATE INDEX&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for how to create and more information on bitmap indexes.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Alternatively, you can perform lookups by RowID for fast access to data. For more information, see <a class="olink TTSQL150" href="../TTSQL/types.htm#TTSQL150">&#34;ROWID data type&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDEFHIJ"></a>
<div id="TTOPR381" class="sect2">
<h3 class="sect2">Creating an index</h3>
<p><a id="sthref1010"></a><a id="sthref1011"></a><a id="sthref1012"></a><a id="sthref1013"></a>To create an index, execute the SQL statement <code>CREATE INDEX</code>. TimesTen converts index names to upper case characters.</p>
<p>Every index has an <a id="sthref1014"></a><a id="sthref1015"></a>owner. The owner is the user who created the underlying table. Indexes created by TimesTen itself, such as indexes on <a id="sthref1016"></a>system tables, are created with the user name <code>SYS</code> or with the user name <code>TTREP</code> if created during replication.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot create an index (range, hash, or bitmap) on LOB columns.</div>
<div id="TTOPR382" class="example">
<p class="titleinexample"><a id="BABJACGH"></a>Example 8-4 Create an index</p>
<p>The following creates an <a id="sthref1017"></a><a id="sthref1018"></a>index <code>IxID</code> over column <code>CustID</code> of table <code>NameID</code>.</p>
<pre>CREATE INDEX IxID ON NameID (CustID);
</pre>
<p>The following creates a unique hash index on the <code>customer</code> table as part of the table creation:</p>
<pre>CREATE TABLE customer
(cust_id NUMBER NOT NULL PRIMARY KEY,
cust_name CHAR(100) NOT NULL,
addr CHAR(100),
zip NUMBER,
region CHAR(10))
UNIQUE HASH ON (cust_id) PAGES = 30;
</pre>
<p>The following creates a nonunique hash index on the <code>customer</code> table over the customer name:</p>
<pre>Command&gt; CREATE HASH INDEX custname_idx ON customer(cust_name);
</pre></div>
<!-- class="example" -->
<p>For more examples on the different indexes and how to create them, see <a class="olink TTSQL292" href="../TTSQL/state.htm#TTSQL292">&#34;CREATE INDEX&#34;</a> and <a class="olink TTSQL286" href="../TTSQL/state.htm#TTSQL286">&#34;ALTER TABLE&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBAIDI"></a>
<div id="TTOPR383" class="sect2">
<h3 class="sect2">Altering an index</h3>
<p>You can use the <code>ALTER TABLE</code> statement to add (or change) a primary key constraint to use either a range or hash index.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot alter an index to be transformed from a hash to a range index or from a range to a hash index if it was created with the <code>CREATE INDEX</code> statement.</div>
<p>You can change a primary key constraint to use a range index instead of a hash index with the <code>USE RANGE INDEX</code> clause of the <code>ALTER TABLE</code> statement; you can change a primary key constraint to use a hash index instead of a range index with the <code>USE HASH INDEX</code> of the <code>ALTER TABLE</code> statement. See <a class="olink TTSQL286" href="../TTSQL/state.htm#TTSQL286">&#34;ALTER TABLE&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFBJFE"></a>
<div id="TTOPR384" class="sect2">
<h3 class="sect2">Dropping an index</h3>
<p><a id="sthref1019"></a><a id="sthref1020"></a><a id="sthref1021"></a>To uniquely refer to an index, an application must specify both its owner and name. If the application does not specify an owner, TimesTen looks for the index first under the user name of the caller, then under the user name <code>SYS</code>.</p>
<div id="TTOPR385" class="example">
<p class="titleinexample"><a id="sthref1022"></a>Example 8-5 Drop an index</p>
<p>The following drops the index named <code>IxID</code>.</p>
<pre>DROP INDEX IxID;
</pre></div>
<!-- class="example" -->
<p><a id="sthref1023"></a><a id="sthref1024"></a>To drop a TimesTen index, execute the <code>DROP INDEX</code> SQL statement. All indexes in a table are dropped automatically when the table is dropped.</p>
</div>
<!-- class="sect2" -->
<a id="CHDHFFFD"></a>
<div id="TTOPR386" class="sect2">
<h3 class="sect2">E<a id="sthref1025"></a><a id="sthref1026"></a><a id="sthref1027"></a>stimating index size</h3>
<p>Increasing the size of a TimesTen database can be done on first connect. To avoid having to increase the size of a database, it is important not to underestimate the eventual database size. You can use the <code>ttSize</code> utility to estimate database size, including any indexes.</p>
<p>The following example shows that the <code>ttSize</code> utility estimates the rows, inline row bytes, size of any indexes on the table, and the total size of the table:</p>
<pre>ttSize -tbl Pat.tab1 MyDb

Rows = 2

Total in-line row bytes = 17524
Indexes:

 Bitmap index PAT.BITMAP_ID adds 6282 bytes
  Total index bytes = 6282

Total = 23806
</pre></div>
<!-- class="sect2" -->
<a id="BABJDBFD"></a>
<div id="TTOPR740" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the Index Advisor to recommend indexes<a id="sthref1028"></a><a id="sthref1029"></a></h3>
<p>The right set of indexes can make a difference in query performance. The Index Advisor can be used to recommend indexes for improving the performance of a specific SQL workload. The Index Advisor is intended for read-intensive complex queries. The use of the Index Advisor is not recommended for a write-intensive workload.</p>
<p>The Index Advisor evaluates a SQL workload and recommends indexes that can improve the performance for the following: joins, single table scans, and <code>ORDER BY</code> or <code>GROUP BY</code> operations. The Index Advisor does not differentiate tables that are used for specific intentions, such as the base table for a materialized view or as a table within a cache group. As long as the table is used in queries in the SQL workload, the Index Advisor may recommend indexes on that table.</p>
<p>The Index Advisor generates the <code>CREATE</code> statement for each recommended index, which you can choose to execute. A database administrator should review each <code>CREATE</code> statement recommended for new indexes before they are applied since the Index Advisor may recommend the following:</p>
<ul>
<li>
<p>Indexes that are duplicates of existing indexes.</p>
</li>
<li>
<p>Indexes for tables or columns of tables that are created and dropped during a SQL workload. However, you could add the <code>CREATE</code> statement for the recommended index in the SQL workload after the DDL that creates the tables or columns of tables and before they are dropped.</p>
</li>
<li>
<p>Indexes that cannot be created, such as a unique index for a data set where the data is not unique. In this case, you should ignore this recommendation.</p>
</li>
<li>
<p>Index creation options where you can create an index as either a <code>UNIQUE</code> or non-unique index. The Index Advisor suggests both index types. You can only create one of the indexes as both suggested indexes have the same index name. While the optimizer thinks that the <code>UNIQUE</code> index is better for the specified workload, you can choose to create the non-unique index. Consider creating the <code>UNIQUE</code> index if the column only contains unique values. Consider creating the non-unique index if the column contains non-unique value.</p>
</li>
</ul>
<p>The Index Advisor does not cover the following:</p>
<ul>
<li>
<p>It does not optimize for memory use.</p>
</li>
<li>
<p>It does not consider maintenance costs.</p>
</li>
<li>
<p>It does not recommend that existing indexes be dropped if they are not useful.</p>
</li>
<li>
<p>It does not recommend indexes for global temporary tables.</p>
</li>
</ul>
<p>The recommended steps to use the Index Advisor are as follows:</p>
<ul>
<li>
<p><a href="#BABEBIFG">Prepare for executing the Index Advisor</a></p>
</li>
<li>
<p><a href="#BABDHBDD">Capture the data used for generating index recommendations</a></p>
</li>
<li>
<p><a href="#BABBFGHB">Retrieve index recommendations and data collection information</a></p>
</li>
<li>
<p><a href="#BABIEDBF">Drop data collected for the index advisor and finalize results</a></p>
</li>
</ul>
<a id="BABEBIFG"></a>
<div id="TTOPR741" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Prepare for executing the Index Advisor<a id="sthref1030"></a></h4>
<p>Before you execute the Index Advisor, you should optionally perform the following:</p>
<ol>
<li>
<p>Since the Index Advisor relies on the query plan, set any relevant optimizer hints that you would use for the SQL workload before enabling the Index Advisor and running the workload. For more details on optimizer hints, see <a href="query.htm#CBAEHHAB">&#34;Use optimizer hints to modify the execution plan&#34;</a>.</p>
</li>
<li>
<p><a id="sthref1031"></a><a id="sthref1032"></a><a id="sthref1033"></a><a id="sthref1034"></a>Update statistics for tables included in the SQL workload and force statements to be re-prepared during the capture. This provides the most up-to-date statistics for the data collection and causes the statements to be re-prepared based on the latest statistics.</p>
</li>
</ol>
<p>Update statistics for tables included in the SQL workload with one of the following built-in procedures: <code>ttOptUpdateStats</code>, <code>ttOptEstimateStats</code>, or <code>ttOptSetTblStats</code>. In the built-in procedures, set the <code>invalidate</code> parameter to 1 to invalidate all commands that reference the indicated tables and force these commands to be automatically prepared again when re-executed. This ensures that statistics are up to date.</p>
<ul>
<li>
<p>The <code>ttOptUpdateStats</code> built-in procedure provides a full update of all statistics for the tables. However, it can be time consuming.</p>
</li>
<li>
<p>The <code>ttOptEstimateStats</code> evaluates statistics based upon a small percentage of rows in the indicated tables.</p>
</li>
<li>
<p>The <code>ttOptSetTblStats</code> sets the statistics to known values provided by you.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information on these built-in procedures, see <a class="olink TTREF277" href="../TTREF/proced.htm#TTREF277">&#34;ttOptUpdateStats,&#34;</a> <a class="olink TTREF264" href="../TTREF/proced.htm#TTREF264">&#34;ttOptEstimateStats,&#34;</a> and <a class="olink TTREF275" href="../TTREF/proced.htm#TTREF275">&#34;ttOptSetTblStats&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<p>The following example estimates statistics for all tables for the current user by evaluating a random sample of ten percent of the rows in these tables. It also invalidates all commands already prepared that reference these tables.</p>
<pre>CALL ttOptEstimateStats ( &#39;&#39;, 1, &#39;10 PERCENT&#39; );
</pre></div>
<!-- class="sect3" -->
<a id="BABDHBDD"></a>
<div id="TTOPR742" class="sect3">
<h4 class="sect3">Capture the data used for generating index recommendations<a id="sthref1035"></a><a id="sthref1036"></a><a id="sthref1037"></a></h4>
<p>Call the <code>ttIndexAdviceCaptureStart</code> and <code>ttIndexAdviceCaptureEnd</code> built-in procedures to capture the information needed by the Index Advisor to generate index recommendations, as follows:</p>
<ol>
<li>
<p>Call the <code>ttIndexAdviceCaptureStart</code> built-in procedure to start the process to collect index information.</p>
</li>
<li>
<p>Run the SQL workload.</p>
</li>
<li>
<p>Call the <code>ttIndexAdviceCaptureEnd</code> built-in procedure to end the index information collection process.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
After the data collection process ends, you can retrieve the index recommendations as described in <a href="#BABBFGHB">&#34;Retrieve index recommendations and data collection information&#34;</a>.</div>
<p>When you call the <code>ttIndexAdviceCaptureStart</code> built-in procedure to initiate the data collection process, provide the following:</p>
<ul>
<li>
<p>In the <code>captureLevel</code> parameter, specify whether the index information is to be collected for the current connection or for the entire database. You can execute multiple connection-level captures concurrently for independent connections without conflict. A database-level capture can take place in parallel with a connection-level capture. Since there is no conflict between a database-level and a connection-level capture, any outstanding connection-level captures that are already in progress when a database-level capture is initiated completes as intended. However, an error is returned if you initiate a second request for a database-level capture while the first is still active; an error is also returned if a second request for a connection-level capture from the same connection is initiated while the first connection-level capture is still active.</p>
<p>If you invoke <code>ttIndexAdviceCaptureStart</code> for a database-level capture, any outstanding connection-level captures that are already in progress complete.</p>
</li>
<li>
<p>The <code>captureMode</code> parameter designates that you want the data collection performed on one of the following scenarios:</p>
<ul>
<li>
<p>Perform the collection of index information using the current execution of the SQL workload.</p>
</li>
<li>
<p>Base the collection of index information not on a current execution of the SQL workload, but on existing computed statistics and query plan analysis. In this scenario, the SQL statements have been prepared, but not executed. This mode can only be executed with a connection-level capture.</p>
</li>
</ul>
</li>
</ul>
<p>To complete the capture, call the <code>ttIndexAdviceCaptureEnd</code> built-in procedure that ends either an active connection-level capture from the same connection or an active database-level capture. Completing a database-level capture requires the <code>ADMIN</code> privilege.</p>
<p>If a connection fails during a capture, the following occurs:</p>
<ul>
<li>
<p>If the capture is a connection-level capture, the capture ends and all associated resources are freed.</p>
</li>
<li>
<p>If the capture is a database-level capture, the capture continues until another user with <code>ADMIN</code> privileges connects and invokes the <code>ttIndexAdviceCaptureEnd</code> built-in procedure to end a database-level capture.</p>
</li>
</ul>
<p>If temporary space becomes full during a capture, an active capture ends and the data collected during the capture is saved.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Execute <code>ttIndexAdviceCaptureDrop</code> to free the temporary space after a capture. See <a href="#BABIEDBF">&#34;Drop data collected for the index advisor and finalize results&#34;</a> for more information on <code>ttIndexAdviceCaptureDrop</code>.</div>
<p>The following example starts a collection for the Index Advisor at the connection-level for the current execution of a SQL workload:</p>
<pre>Call ttIndexAdviceCaptureStart(0,0);
</pre>
<p>The following example ends the collection for the connection-level capture:</p>
<pre>Call ttIndexAdviceCaptureEnd(0)
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information on these built-in procedures, see <a class="olink TTREF775" href="../TTREF/proced.htm#TTREF775">&#34;ttIndexAdviceCaptureStart&#34;</a> and <a class="olink TTREF774" href="../TTREF/proced.htm#TTREF774">&#34;ttIndexAdviceCaptureEnd&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
</div>
<!-- class="sect3" -->
<a id="BABBFGHB"></a>
<div id="TTOPR743" class="sect3">
<h4 class="sect3">Retrieve index recommendations and data collection information<a id="sthref1038"></a><a id="sthref1039"></a><a id="sthref1040"></a><a id="sthref1041"></a></h4>
<ol>
<li>
<p>Call the <code>ttIndexAdviceCaptureInfoGet</code> built-in procedure to retrieve data collection overview information for the Index Advisor.</p>
</li>
<li>
<p>Call the <code>ttIndexAdviceCaptureOutput</code> built-in procedure to retrieve the recommended indexes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
These built-in procedures retrieve the data collection overview and Index Advisor recommendations. Execute either or both for the data you want.</div>
</li>
<li>
<p>After a DBA has evaluated the recommended index creation statements, apply the desired index creation recommendations.</p>
</li>
</ol>
<div id="TTOPR744" class="sect4"><a id="sthref1042"></a>
<h5 class="sect4">Retrieve data collection information with ttIndexAdviceCaptureInfoGet</h5>
<p>The <code>ttIndexAdviceCaptureInfoGet</code> built-in procedure retrieves information about the data collected for the Index Advisor. For both a connection-level capture and a database-level capture, only a single row is returned.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database-level capture row can only be returned to a user with <code>ADMIN</code> privileges.</div>
<p>The <code>ttIndexAdviceCaptureInfoGet</code> built-in procedure captures data if:</p>
<ul>
<li>
<p>The data capture was started and has not ended.</p>
</li>
<li>
<p>A previous capture that was started and stopped, and the data was not deleted.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If no capture is in progress or no data exists, then no rows are returned.</div>
<p>The rows returned include the following information:</p>
<ul>
<li>
<p>The capture state: Returns 0 if a capture is completed. Returns 1 if a capture is still in progress.</p>
</li>
<li>
<p>The connection identifier, if appropriate.</p>
</li>
<li>
<p>The capture level and mode set for this capture.</p>
</li>
<li>
<p>The number of prepared and executed statements during the capture interval.</p>
</li>
<li>
<p>The time that the capture was started and stopped.</p>
</li>
</ul>
<p>The following shows capture information for a completed connection-level capture for 363 prepared statements and 369 executed statements:</p>
<pre>Command&gt; CALL ttIndexAdviceCaptureInfoGet();
&lt; 0, 1, 0, 0, 363, 369, 2012-07-27 11:44:08.136833, 2012-07-27 12:07:35.410993 &gt;
1 row found.
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more details and syntax for this built-in procedure, see <a class="olink TTREF777" href="../TTREF/proced.htm#TTREF777">&#34;ttIndexAdviceCaptureInfoGet&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
</div>
<!-- class="sect4" -->
<div id="TTOPR745" class="sect4"><a id="sthref1043"></a>
<h5 class="sect4">Retrieve index recommendations with ttIndexAdviceCaptureOutput</h5>
<p>The <code>ttIndexAdviceCaptureOutput</code> built-in procedure retrieves the list of index recommendations from the last recorded capture at the specified level (connection or database-level). The list contains the <code>CREATE</code> statement for each recommended index.</p>
<p>To request index recommendations for a connection-level capture, execute <code>ttIndexAdviceCaptureOutput</code> with <code>captureLevel</code> set to 0 in the same connection that initiated the capture. For a database-level capture, execute <code>ttIndexAdviceCaptureOutput</code> with <code>captureLevel</code> set to 1 in a connection where the user has <code>ADMIN</code> privilege.</p>
<p>The returned row contains:</p>
<ul>
<li>
<p><code>stmtCount</code> - The number of times the index would be useful to speed up the executed SQL workload.</p>
</li>
<li>
<p><code>createStmt</code> - The executable statement that can be used to create the recommended index. All database object names in these statements are fully qualified.</p>
</li>
</ul>
<p>The following example provides the <code>CREATE</code> statement for an index called <code>PURCHASE_i1</code> on the <code>HR.PURCHASE</code> table, which would be useful 4 times for this SQL workload.</p>
<pre>CALL ttIndexAdviceCaptureOutput();
&lt; 4, create index PURCHASE_i1 on HR.PURCHASE(AMOUNT); &gt;
1 row found. 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information and syntax for this built-in procedure, see <a class="olink TTREF776" href="../TTREF/proced.htm#TTREF776">&#34;ttIndexAdviceCaptureOutput&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABIEDBF"></a>
<div id="TTOPR769" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Drop data collected for the index advisor and finalize results<a id="sthref1044"></a><a id="sthref1045"></a></h4>
<p>After you have applied the <code>CREATE</code> statements for the new indexes that have been approved by the DBA, you can drop the captured data collected for the Index Advisor. The <code>ttIndexAdviceCaptureDrop</code> built-in procedure drops the existing data collected for the specified <code>captureLevel</code>, which can either be a connection or database-level capture.</p>
<pre>Call ttIndexAdviceCaptureDrop(0);
</pre>
<p>You must call this built-in procedure twice to drop both a connection-level and database-level capture. You may not invoke this built-in procedure while a capture at the same level is in progress.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information and syntax for this built-in procedure, see <a class="olink TTREF773" href="../TTREF/proced.htm#TTREF773">&#34;ttIndexAdviceCaptureDrop&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<p>You can repeat the steps in <a href="#BABEBIFG">&#34;Prepare for executing the Index Advisor&#34;</a> and <a href="#BABBFGHB">&#34;Retrieve index recommendations and data collection information&#34;</a> until a SQL workload is executed with no more index recommendations. You can keep updating the statistics for the tables on which the new indexes were applied and re-execute the Index Advisor to see if any new indexes are now recommended.</p>
</div>
<!-- class="sect3" -->
<div id="TTOPR747" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1046"></a>
<h4 class="sect3">Example using Index Advisor built-in procedures<a id="sthref1047"></a></h4>
<p>The following shows the flow of a data collection for a SQL workload and the resulting index advice provided by the Index Advisor built-in procedures.</p>
<pre>Command&gt; CALL ttOptUpdateStats();

Command&gt; CALL ttIndexAdviceCaptureStart();

Command&gt; SELECT employee_id, first_name, last_name FROM employees;
&lt; 100, Steven, King &gt;
&lt; 101, Neena, Kochhar &gt;
&lt; 102, Lex, De Haan &gt;
&lt; 103, Alexander, Hunold &gt;
&lt; 104, Bruce, Ernst &gt;
...
&lt; 204, Hermann, Baer &gt;
&lt; 205, Shelley, Higgins &gt;
&lt; 206, William, Gietz &gt;
107 rows found.

Command&gt; SELECT MAX(salary) AS MAX_SALARY 
FROM employees 
WHERE employees.hire_date &gt; &#39;2000-01-01 00:00:00&#39;;
&lt; 10500 &gt;
1 row found.

Command&gt; SELECT employee_id, job_id FROM job_history
       &gt; WHERE (employee_id, job_id) NOT IN (SELECT employee_id, job_id
       &gt; FROM employees);
&lt; 101, AC_ACCOUNT &gt;
&lt; 101, AC_MGR &gt;
&lt; 102, IT_PROG &gt;
&lt; 114, ST_CLERK &gt;
&lt; 122, ST_CLERK &gt;
&lt; 176, SA_MAN &gt;
&lt; 200, AC_ACCOUNT &gt;
&lt; 201, MK_REP &gt;
8 rows found.

Command&gt; WITH dept_costs AS (
       &gt; SELECT department_name, SUM(salary) dept_total
       &gt; FROM employees e, departments d
       &gt; WHERE e.department_id = d.department_id
       &gt; GROUP BY department_name),
       &gt; avg_cost AS (
       &gt; SELECT SUM(dept_total)/COUNT(*) avg
       &gt; FROM dept_costs)
       &gt; SELECT * FROM dept_costs
       &gt; WHERE dept_total &gt;
       &gt; (SELECT avg FROM avg_cost)
       &gt; ORDER BY department_name;
&lt; Sales, 304500 &gt;
&lt; Shipping, 156400 &gt;
2 rows found.

Command&gt; call ttIndexAdviceCaptureEnd();

Command&gt; call ttIndexAdviceCaptureInfoGet();
&lt; 0, 1, 0, 0, 9, 6, 2012-07-27 11:44:08.136833, 2012-07-27 12:07:35.410993 &gt;
1 row found.

Command&gt; call ttIndexAdviceCaptureOutput();
&lt; 1, create index EMPLOYEES_i1 on HR.EMPLOYEES(SALARY); &gt;
&lt; 1, create index EMPLOYEES_i2 on HR.EMPLOYEES(HIRE_DATE); &gt;
2 rows found.

Command&gt; call ttIndexAdviceCaptureDrop();
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDFDFFF"></a>
<div id="TTOPR387" class="sect1">
<h2 class="sect1">Understanding <a id="sthref1048"></a><a id="sthref1049"></a>rows</h2>
<p>Rows are used to store TimesTen data. TimesTen supports several data types for fields in a row, including:</p>
<ul>
<li>
<p>One-byte, two-byte, four-byte and eight-byte integers.</p>
</li>
<li>
<p>Four-byte and eight-byte floating-point numbers.</p>
</li>
<li>
<p>Fixed-length and variable-length character strings, both ASCII and Unicode.</p>
</li>
<li>
<p>Fixed-length and variable-length binary data.</p>
</li>
<li>
<p>Fixed-length fixed-point numbers.</p>
</li>
<li>
<p>Time represented as <code>hh:mi:ss [AM|am|PM|pm]</code>.</p>
</li>
<li>
<p>Date represented as <code>yyyy-mm-dd</code>.</p>
</li>
<li>
<p>Timestamp represented as <code>yyyy-mm-dd hh:mi:ss</code>.</p>
</li>
</ul>
<p>The <a class="olink TTSQL123" href="../TTSQL/types.htm#TTSQL123">&#34;Data Types&#34;</a> section in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> contains a detailed description of these data types.</p>
<p>To perform any operation for inserting or deleting rows, the user must have the appropriate privileges, which are described along with the syntax for all SQL statements in the <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> chapter in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>The following sections describe how to manage your rows:</p>
<ul>
<li>
<p><a href="#CHDJADEG">Inserting rows</a></p>
</li>
<li>
<p><a href="#CHDCJEFB">Deleting rows</a></p>
</li>
</ul>
<a id="CHDJADEG"></a>
<div id="TTOPR388" class="sect2">
<h3 class="sect2"><a id="sthref1050"></a><a id="sthref1051"></a><a id="sthref1052"></a>Inserting rows</h3>
<p>To insert a row, execute <code>INSERT</code> or <code>INSERT SELECT</code>. You can also use the <code>ttBulkCp</code> utility.</p>
<div id="TTOPR389" class="example">
<p class="titleinexample"><a id="sthref1053"></a>Example 8-6 Insert a row in a table</p>
<p>To insert a row in the table <code>NameID</code>, enter:</p>
<pre>INSERT INTO NameID VALUES(23125, &#39;John Smith&#39;;
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
When inserting multiple rows into a table, it is more efficient to use prepared commands and parameters in your code. Create Indexes after the bulk load is completed.</div>
</div>
<!-- class="sect2" -->
<a id="CHDCJEFB"></a>
<div id="TTOPR390" class="sect2">
<h3 class="sect2"><a id="sthref1054"></a><a id="sthref1055"></a><a id="sthref1056"></a><a id="sthref1057"></a>Deleting rows</h3>
<p>To delete a row, execute the <code>DELETE</code> statement.</p>
<div id="TTOPR391" class="example">
<p class="titleinexample"><a id="sthref1058"></a>Example 8-7 Delete a row</p>
<p>The following deletes all the rows from the table <code>NameID</code> for names that start with the letter &#34;S.&#34;</p>
<pre>DELETE FROM NameID WHERE CustName LIKE &#39;S%&#39;;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBAHAF"></a>
<div id="TTOPR674" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Understanding synonyms</h2>
<p>A <a id="sthref1059"></a><a id="sthref1060"></a><a id="sthref1061"></a><a id="sthref1062"></a><a id="sthref1063"></a>synonym is an alias for a database object. Synonyms are often used for security and convenience, because they can be used to mask object name and object owner. In addition, you can use a synonym to simplify SQL statements. Synonyms provide independence in that they permit applications to function without modification regardless of which object a synonym refers to. Synonyms can be used in DML statements and some DDL and TimesTen cache statements.</p>
<p>Synonyms are categorized into two classes:</p>
<ul>
<li>
<p>Private synonyms: A private synonym is owned by a specific user and exists in the schema of a specific user. A private synonym shares the same namespace as other object names, such as table names, view names, sequence names, and so on. Therefore, a private synonym cannot have the same name as a table name or a view name in the same schema.</p>
</li>
<li>
<p>Public synonyms: A public synonym is owned by all users and every user in the database can access it. A public synonym is accessible for all users and it does not belong to any user schema. Therefore, a public synonym can have the same name as a private synonym name or a table name.</p>
</li>
</ul>
<p>In order to create and use synonyms, the user must have the correct privileges, which are described in <a href="accesscontrol.htm#BABHHHEH">&#34;Object privileges for synonyms&#34;</a>.</p>
<p>After synonyms are created, they can be viewed using the following views:</p>
<ul>
<li>
<p><code>SYS.ALL_SYNONYMS</code>: describes the synonyms accessible to the current user. For more information, see <a class="olink TTSYS437" href="../TTSYS/systemtables.htm#TTSYS437">&#34;SYS.ALL_SYNONYMS&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database System Tables and Views Reference</span>.</p>
</li>
<li>
<p><code>SYS.DBA_SYNONYMS</code>: describes all synonyms in the database. For more information, see <a class="olink TTSYS438" href="../TTSYS/systemtables.htm#TTSYS438">&#34;SYS.DBA_SYNONYMS&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database System Tables and Views Reference</span>.</p>
</li>
<li>
<p><code>SYS.USER_SYNONYMS</code>: describes the synonyms owned by the current user. For more information, see <a class="olink TTSYS440" href="../TTSYS/systemtables.htm#TTSYS440">&#34;SYS.USER_SYNONYMS&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database System Tables and Views Reference</span>.</p>
</li>
</ul>
<div id="TTOPR675" class="sect2"><a id="sthref1064"></a>
<h3 class="sect2">Creating synonyms</h3>
<p><a id="sthref1065"></a><a id="sthref1066"></a><a id="sthref1067"></a>Create the synonym with the <code>CREATE SYNONYM</code> statement. You can use the <code>CREATE OR REPLACE SYNONYM</code> statement to change the definition of an existing synonym without needing to drop it first. The <code>CREATE SYNONYM</code> and <code>CREATE OR REPLACE SYNONYM</code> statements specify the synonym name and the schema name in which the synonym is created. If the schema is omitted, the synonym is created in the user&#39;s schema. However, when creating public synonyms, do not provide the schema name as it is defined in the <code>PUBLIC</code> namespace.</p>
<p>In order to execute the <code>CREATE SYNONYM</code> or <code>CREATE OR REPLACE SYNONYM</code> statements, the user must have the appropriate privileges, as described in <a href="accesscontrol.htm#BABHHHEH">&#34;Object privileges for synonyms&#34;</a>.</p>
<ul>
<li>
<p><span class="italic">Object types for synonyms:</span> The <code>CREATE SYNONYM</code> and <code>CREATE OR REPLACE SYNONYM</code> statements define an alias for a particular object, which can be one of the following object types: table, view, synonym, sequence, PL/SQL stored procedure, PL/SQL function, PL/SQL package, materialized view, or cache group.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you try to create a synonym for unsupported object types, you may not be able to use the synonym.</div>
</li>
<li>
<p><span class="italic">Naming considerations:</span> A private synonym shares the same namespace as all other object names, such as table names and so on. Therefore, a private synonym cannot have the same name as a table name or other objects in the same schema.</p>
<p>A public synonym is accessible for all users and does not belong to any particular user schema. Therefore, a public synonym can have the same name as a private synonym name or other object name. However, you cannot create a public synonym that has the same name as any objects in the SYS schema.</p>
</li>
</ul>
<p>In the following example, the user creates a private synonym of <code>synjobs</code> for the <code>jobs</code> table. Execute a <code>SELECT</code> statement on both the <code>jobs</code> table and the <code>synjobs</code> synonym to show that selecting from <code>synjobs</code> is the same as selecting from the <code>jobs</code> table. Finally, to display the private synonym, the example executes a <code>SELECT</code> statement on the <code>SYS.USER_SYNONYMS</code> table.</p>
<pre>Command&gt; CREATE SYNONYM synjobs FOR jobs;
Synonym created.

Command&gt; SELECT FIRST 2 * FROM jobs;
&lt; AC_ACCOUNT, Public Accountant, 4200, 9000 &gt;
&lt; AC_MGR, Accounting Manager, 8200, 16000 &gt;
2 rows found.
Command&gt; SELECT FIRST 2 * FROM synjobs;
&lt; AC_ACCOUNT, Public Accountant, 4200, 9000 &gt;
&lt; AC_MGR, Accounting Manager, 8200, 16000 &gt;
2 rows found.

Command&gt; SELECT * FROM sys.user_synonyms;
&lt; SYNJOBS, TTUSER, JOBS, &lt;NULL&gt; &gt;
1 row found.
</pre>
<p>For full details, more examples, and rules on creating or replacing a synonym, see the <a class="olink TTSQL435" href="../TTSQL/state.htm#TTSQL435">&#34;CREATE SYNONYM&#34;</a> section in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</div>
<!-- class="sect2" -->
<div id="TTOPR676" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1068"></a>
<h3 class="sect2">Dropping synonyms</h3>
<p>Use the <a id="sthref1069"></a><a id="sthref1070"></a><code>DROP SYNONYM</code> statement to drop an existing synonym from the database. A user cannot be dropped unless all objects, including synonyms, owned by this user are dropped.</p>
<p>For example, the following drops the public synonym <code>pubemp</code>:</p>
<pre>DROP PUBLIC SYNONYM pubemp;
Synonym dropped.
</pre>
<p>In order drop a public synonym or a private synonym in another user&#39;s schema, the user must have the appropriate privileges. For full details, more examples, and rules on creating or replacing a synonym, see the <a class="olink TTSQL436" href="../TTSQL/state.htm#TTSQL436">&#34;DROP SYNONYM&#34;</a> section in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</div>
<!-- class="sect2" -->
<div id="TTOPR677" class="sect2"><a id="sthref1071"></a>
<h3 class="sect2">Synonyms may cause invalidation or recompilation of SQL queries</h3>
<p><a id="sthref1072"></a><a id="sthref1073"></a>When a synonym or object is newly created or dropped, some SQL queries and DDL statements may be invalidated or recompiled. The following lists the invalidation and recompilation behavior for SQL queries and DDL statements:</p>
<ol>
<li>
<p>All SQL queries that depend on a public synonym are invalidated if you create a private synonym with the same name for one of the following objects:</p>
<ul>
<li>
<p>private synonym</p>
</li>
<li>
<p>table</p>
</li>
<li>
<p>view</p>
</li>
<li>
<p>sequence</p>
</li>
<li>
<p>materialized view</p>
</li>
<li>
<p>cache group</p>
</li>
<li>
<p>PL/SQL object including procedures, functions, and packages</p>
</li>
</ul>
</li>
<li>
<p>All SQL queries that depend on a private synonym or schema object are invalidated when a private synonym or schema object is dropped.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3223">
<tr>
<td class="cellalignment3230">
<table class="cellalignment3228">
<tr>
<td class="cellalignment3227"><a href="trans.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3227"><a href="query.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3232">
<table class="cellalignment3226">
<tr>
<td class="cellalignment3227"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3227"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3227"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3227"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3227"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3227"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>