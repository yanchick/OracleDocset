<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-6019"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Basic%20Materialized%20Views"></a><title>Basic Materialized Views</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="data warehouse, dimension tables, dimensions, lookup tables, See dimension tables, tables, dimension tables (lookup tables), fact tables, detail tables, schemas, design guidelines for materialized views, materialized views, schema design guidelines, aggregates, containing only joins, build methods, restrictions, query rewrite, refreshing, fast refresh"/>
<meta name="dcterms.created" content="2017-06-07T18:07:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Warehousing Guide"/>
<meta name="dcterms.identifier" content="E41670-11"/>
<meta name="dcterms.isVersionOf" content="DWHSG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="part3.htm" title="Previous" type="text/html"/>
<link rel="Next" href="advmv.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41670-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF"></a> <span id="PAGE" style="display:none;">11/32</span> <!-- End Header -->
<h1 id="DWHSG-GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" class="sect1"><span class="enumeration_chapter">5</span> Basic Materialized Views</h1>
<div>
<p>This chapter describes the use of materialized views. It contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-FC9E665B-8AB2-4B64-AB8A-FAA732511839">Overview of Data Warehousing with Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-63E162FE-8957-4C1D-9494-041A8B2B7917">Types of Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52">Creating Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-4BCA1300-C03E-4C24-AD19-50EB9BBA8806">Creating Materialized View Logs</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-4DE39B8B-8452-4581-A841-6AF77019986D">Registering Existing Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83">Choosing Indexes for Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-2932186A-CA03-47B7-A11A-FF30BD62AB57">Dropping Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-651B08EB-4D32-4A93-A260-A965C40AE136">Analyzing Materialized View Capabilities</a></p>
</li>
</ul>
</div>
<a id="DWHSG0081"></a>
<div class="props_rev_3"><a id="GUID-FC9E665B-8AB2-4B64-AB8A-FAA732511839"></a>
<h2 id="DWHSG-GUID-FC9E665B-8AB2-4B64-AB8A-FAA732511839" class="sect2">Overview of Data Warehousing with Materialized Views</h2>
<div>
<p><a id="d14086e81" class="indexterm-anchor"></a><a id="d14086e83" class="indexterm-anchor"></a><a id="d14086e87" class="indexterm-anchor"></a>Typically, data flows from one or more online transaction processing (OLTP) database into a data warehouse on a monthly, weekly, or daily basis. The data is normally processed in a<a id="d14086e92" class="indexterm-anchor"></a> <a href="glossary.htm#GUID-534190F8-A767-42E3-866C-3166B300D21B"><span class="xrefglossterm">staging file</span></a> before being added to the data warehouse. Data warehouses commonly range in size from hundreds of gigabytes to a few terabytes. Usually, the vast majority of the data is stored in a few very large <a href="glossary.htm#GUID-5E1E8221-92AE-47F6-BB30-5F2D7BCD68F5"><span class="xrefglossterm">fact table</span></a>s.</p>
<p>One technique employed in data warehouses to improve performance is the creation of summaries. Summaries are special types of aggregate views that improve query execution times by precalculating expensive joins and aggregation operations prior to execution and storing the results in a table in the database. For example, you can create a summary table to contain the sums of sales by region and by product.</p>
<p>The summaries or aggregates that are referred to in this book and in literature on data warehousing are created in Oracle Database using a schema object called<a id="d14086e109" class="indexterm-anchor"></a> a <a href="glossary.htm#GUID-AC1E7D15-7178-4C7E-89CA-809D13AB2513"><span class="xrefglossterm">materialized view</span></a>. Materialized views can perform a number of roles, such as improving query performance or providing replicated data.</p>
<p>The database administrator creates one or more materialized views, which are the equivalent of a summary. The end user queries the tables and views at the detail data level. The <a href="glossary.htm#GUID-BD33929F-FA4E-4E15-BAA7-2E62E2CF6B7B"><span class="xrefglossterm">query rewrite</span></a> mechanism in the Oracle server automatically rewrites the SQL query to use the summary tables. This mechanism reduces response time for returning results from the query. Materialized views within the data warehouse are transparent to the end user or to the database application.</p>
<p>Although materialized views are usually accessed through the query rewrite mechanism, an end user or database application can construct queries that directly access the materialized views. However, serious consideration should be given to whether users should be allowed to do this because any change to the materialized views affects the queries that reference them.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-26AB0CB6-F8E5-41B8-B357-9B182597F732">About Materialized Views for Data Warehouses</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-881E9280-3C16-4893-A5AE-7FAE20746664">About Materialized Views for Distributed Computing</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43">About Materialized Views for Mobile Computing</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-E4538195-1C38-429C-B10F-8722C6A8A06F">The Need for Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF">Components of Summary Management</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-543AB802-DA73-408B-9FE5-686E26D0F44B">Data Warehousing Terminology</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27">About Materialized View Schema Design</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05">About Loading Data into Data Warehouses</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-6D7B8BA6-9217-48B5-A6F9-87FF0834DA46">Overview of Materialized View Management Tasks</a></p>
</li>
</ul>
</div>
<a id="DWHSG8161"></a>
<div class="props_rev_3"><a id="GUID-26AB0CB6-F8E5-41B8-B357-9B182597F732"></a>
<h3 id="DWHSG-GUID-26AB0CB6-F8E5-41B8-B357-9B182597F732" class="sect3">About Materialized Views for Data Warehouses</h3>
<div>
<p>In data warehouses, you can use materialized views to precompute and store aggregated data such as the sum of sales. Materialized views in these environments are often referred to as summaries, because they store summarized data. They can also be used to precompute joins with or without aggregations. A materialized view eliminates the overhead associated with expensive joins and aggregations for a large or important class of queries.</p>
</div>
</div>
<a id="DWHSG8162"></a>
<div class="props_rev_3"><a id="GUID-881E9280-3C16-4893-A5AE-7FAE20746664"></a>
<h3 id="DWHSG-GUID-881E9280-3C16-4893-A5AE-7FAE20746664" class="sect3">About Materialized Views for Distributed Computing</h3>
<div>
<p>In distributed environments, you can use materialized views to replicate data at distributed sites and to synchronize updates done at those sites with conflict resolution methods. These replica materialized views provide local access to data that otherwise would have to be accessed from remote sites. Materialized views are also useful in remote data marts.</p>
<div class="infoboxnotealso" id="GUID-881E9280-3C16-4893-A5AE-7FAE20746664__GUID-018DF864-8DF8-458B-B100-4C97F497B920">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink HETER006" target="_blank" href="../HETER/GUID-38A89AFD-B5E1-4710-A11B-2A05A1276A30.htm#HETER006"><span class="italic">Oracle Database Heterogeneous Connectivity User&#39;s Guide</span></a></p>
</li>
<li>
<p><a class="olink REPLN003" target="_blank" href="../REPLN/repmview.htm#REPLN003"><span class="italic">Oracle Database Advanced Replication</span></a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8163"></a>
<div class="props_rev_3"><a id="GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43"></a>
<h3 id="DWHSG-GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43" class="sect3">About Materialized Views for Mobile Computing</h3>
<div>
<p>You can also use materialized views to download a subset of data from central servers to mobile clients, with periodic refreshes and updates between clients and the central servers. This chapter focuses on the use of materialized views in data warehouses.</p>
<div class="infoboxnotealso" id="GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43__GUID-5D8AB9FA-4BDA-4BA0-B927-14796765C28A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink HETER006" target="_blank" href="../HETER/GUID-38A89AFD-B5E1-4710-A11B-2A05A1276A30.htm#HETER006"><span class="italic">Oracle Database Heterogeneous Connectivity User&#39;s Guide</span></a></p>
</li>
<li>
<p><a class="olink REPLN003" target="_blank" href="../REPLN/repmview.htm#REPLN003"><span class="italic">Oracle Database Advanced Replication</span></a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8165"></a><a id="DWHSG8164"></a>
<div class="props_rev_3"><a id="GUID-E4538195-1C38-429C-B10F-8722C6A8A06F"></a>
<h3 id="DWHSG-GUID-E4538195-1C38-429C-B10F-8722C6A8A06F" class="sect3">The Need for Materialized Views</h3>
<div>
<p>You can use materialized views to increase the speed of queries on very large databases. Queries to large databases often involve joins between tables, aggregations such as <code class="codeph">SUM</code>, or both. These operations are expensive in terms of time and processing power. The type of materialized view you create determines how the materialized view is refreshed and used by query rewrite.</p>
<p>Materialized views improve query performance by precalculating expensive join and aggregation operations on the database prior to execution and storing the results in the database. The query optimizer automatically recognizes when an existing materialized view can and should be used to satisfy a request. It then transparently rewrites the request to use the materialized view. Queries go directly to the materialized view and not to the underlying detail tables. In general, rewriting queries to use materialized views rather than detail tables improves response time. <a href="basicmv.htm#GUID-E4538195-1C38-429C-B10F-8722C6A8A06F__CACGIDEI">Figure 5-1</a> illustrates how query rewrite works.</p>
<div class="figure" id="GUID-E4538195-1C38-429C-B10F-8722C6A8A06F__CACGIDEI">
<p class="titleinfigure">Figure 5-1 Transparent Query Rewrite</p>
<img width="595" height="302" src="img/GUID-6BC1A874-4149-463B-B6FF-86FD4CAD60F7-default.gif" alt="Description of Figure 5-1 follows" title="Description of Figure 5-1 follows"/><br/>
<a href="img_text/GUID-6BC1A874-4149-463B-B6FF-86FD4CAD60F7-print.htm">Description of &#34;Figure 5-1 Transparent Query Rewrite&#34;</a></div>
<!-- class="figure" -->
<p>When using query rewrite, create materialized views that satisfy the largest number of queries. For example, if you identify 20 queries that are commonly applied to the detail or fact tables, then you might be able to satisfy them with five or six well-written materialized views. A materialized view definition can include any number of aggregations (<code class="codeph">SUM</code>, <code class="codeph">COUNT(x)</code>, <code class="codeph">COUNT(*)</code>, <code class="codeph">COUNT(DISTINCT&nbsp;x)</code>, <code class="codeph">AVG</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>, <code class="codeph">MIN</code>, and <code class="codeph">MAX</code>). It can also include any number of joins. If you are unsure of which materialized views to create, Oracle Database provides the SQL Access Advisor, which is a set of advisory procedure<a id="d14086e334" class="indexterm-anchor"></a>s in the <code class="codeph">DBMS_ADVISOR</code> package to help in designing and evaluating materialized views for query rewrite.</p>
<p>If a materialized view is to be used by query rewrite, it must be stored in the same database as the detail tables on which it depends. A materialized view can be partitioned, and you can define a materialized view on a partitioned table. You can also define one or more indexes on the materialized view.</p>
<p>Unlike indexes, materialized views can be accessed directly using a <code class="codeph">SELECT</code> statement. However, it is recommended that you try to avoid writing SQL statements that directly reference the materialized view, because then it is difficult to change them without affecting the application. Instead, let query rewrite transparently rewrite your query to use the materialized view.</p>
<p>Note that the techniques shown in this chapter illustrate how to use materialized views in data warehouses. Materialized views can also be used by Oracle Replication.</p>
<div class="infoboxnotealso" id="GUID-E4538195-1C38-429C-B10F-8722C6A8A06F__GUID-37C9DC9E-6AC9-46CA-9DE5-7B37629F24FC">
<p class="notep1">See Also:</p>
<p><a class="olink REPLN003" target="_blank" href="../REPLN/repmview.htm#REPLN003"><span class="italic">Oracle Database Advanced Replication</span></a></p>
</div>
</div>
</div>
<a id="DWHSG8167"></a><a id="DWHSG8166"></a>
<div class="props_rev_3"><a id="GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF"></a>
<h3 id="DWHSG-GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF" class="sect3">Components of Summary Management</h3>
<div>
<p>Summary <a id="d14086e380" class="indexterm-anchor"></a>management consists of:</p>
<ul style="list-style-type: disc;">
<li>
<p>Mechanisms to define <a href="glossary.htm#GUID-AC1E7D15-7178-4C7E-89CA-809D13AB2513"><span class="xrefglossterm">materialized view</span></a>s and <a href="glossary.htm#GUID-51168741-F40B-41B8-83DE-F159BEB2DE75"><span class="xrefglossterm">dimension</span></a>s.</p>
</li>
<li>
<p>A <a href="glossary.htm#GUID-649991BA-18DC-4416-9AB5-D7CF69E202F9"><span class="xrefglossterm">refresh</span></a> mechanism to ensure that all materialized views contain the latest data.</p>
</li>
<li>
<p>A <a href="glossary.htm#GUID-BD33929F-FA4E-4E15-BAA7-2E62E2CF6B7B"><span class="xrefglossterm">query rewrite</span></a> capability to transparently rewrite a query to use a materialized view.</p>
</li>
<li>
<p>The <a href="glossary.htm#GUID-5C0A9E85-E776-4D52-A9A0-C57198FE4165"><span class="xrefglossterm">SQL Access Advisor</span></a>, which recommends materialized views, partitions, and indexes to create.</p>
</li>
<li>
<p>The <code class="codeph">TUNE_MVIEW</code> package, which shows you how to make your materialized view fast refreshable and use general query rewrite.</p>
</li>
</ul>
<p>The use of summary management features imposes no schema restrictions, and can enable some existing DSS database applications to improve performance without the need to redesign the database or the application.</p>
<p><a href="basicmv.htm#GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF__i1012580">Figure 5-2</a> illustrates the use of summary management in the warehousing cycle. After the data has been transformed, staged, and loaded into the detail data in the warehouse, you can invoke the summary management process. First, use the SQL Access Advisor to plan how you will use materialized views. Then, create materialized views and design how queries will be rewritten. If you are having problems trying to get your materialized views to work then use <code class="codeph">TUNE_MVIEW</code> to obtain an optimized materialized view.</p>
<div class="figure" id="GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF__i1012580">
<p class="titleinfigure">Figure 5-2 Overview of Summary Management</p>
<img width="388" height="552" src="img/GUID-2D210A5D-21DE-4E87-8B3E-FBAFC4627F18-default.gif" alt="Description of Figure 5-2 follows" title="Description of Figure 5-2 follows"/><br/>
<a href="img_text/GUID-2D210A5D-21DE-4E87-8B3E-FBAFC4627F18-print.htm">Description of &#34;Figure 5-2 Overview of Summary Management&#34;</a></div>
<!-- class="figure" -->
<p>Understanding the summary management process during the earliest stages of data warehouse design can yield large dividends later in the form of higher performance, lower summary administration costs, and reduced storage requirements.</p>
</div>
</div>
<a id="DWHSG8168"></a>
<div class="props_rev_3"><a id="GUID-543AB802-DA73-408B-9FE5-686E26D0F44B"></a>
<h3 id="DWHSG-GUID-543AB802-DA73-408B-9FE5-686E26D0F44B" class="sect3">Data Warehousing Terminology</h3>
<div>
<p>Some basic data warehousing terms are defined as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Dimension</span> <span class="bold">tables</span> describe the business entities of an enterprise, represented as hierarchical, categorical information such as time, departments, locations, and products. Dimension tables are sometimes called<a id="d14086e501" class="indexterm-anchor"></a> lookup or <a id="d14086e506" class="indexterm-anchor"></a>reference tables.</p>
<p>Dimension tables usually change slowly over time and are not modified on a periodic schedule. They are used in long-running decision support queries to aggregate the data returned from the query into appropriate levels of the dimension hierarchy.</p>
</li>
<li>
<p><span class="bold">Hierarchies</span> describe the business relationships and common access patterns in the database. An analysis of the dimensions, combined with an understanding of the typical work load, can be used to create materialized views. See <a href="dimen.htm#GUID-106BE703-0D67-41F1-8CAC-6432B95FBF82">Dimensions</a> for more information.</p>
</li>
<li>
<p><span class="bold">Fact</span> <span class="bold">tables</span> describe the business transactions of an enterprise.</p>
<p>The vast majority of data in a data warehouse is stored in a few very large fact tables that are updated periodically with data from one or more operational OLTP databases.</p>
<p>Fact tables includ<a id="d14086e534" class="indexterm-anchor"></a>e facts (also called measures) such as sales, units, and inventory.</p>
<ul style="list-style-type: disc;">
<li>
<p>A simple measure is a numeric or character column of one table such as <code class="codeph">fact.sales</code>.</p>
</li>
<li>
<p>A computed measure is an expression involving measures of one table, for example, <code class="codeph">fact.revenues</code> - <code class="codeph">fact.expenses</code>.</p>
</li>
<li>
<p>A multitable measure is a computed measure defined on multiple tables, for example, <code class="codeph">fact_a.revenues</code> - <code class="codeph">fact_b.expenses</code>.</p>
</li>
</ul>
<p>Fact tables also contain one or more foreign <a id="d14086e564" class="indexterm-anchor"></a>keys that organize the business transactions by the relevant business entities such as time, product, and market. In most cases, these foreign keys are non-null, form a unique compound key of the fact table, and each foreign key joins with exactly one row of a<a id="d14086e567" class="indexterm-anchor"></a> <a href="glossary.htm#GUID-168122D2-C615-4834-BA3D-B578B3EDC4A4"><span class="xrefglossterm">dimension table</span></a>.</p>
</li>
<li>
<p>A materialized view is a precomputed table comprising aggregated and joined data from fact and possibly from dimension tables.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8169"></a>
<div class="props_rev_3"><a id="GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27"></a>
<h3 id="DWHSG-GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27" class="sect3">About Materialized View Schema Design</h3>
<div>
<p>Summary management<a id="d14086e609" class="indexterm-anchor"></a> can perform many useful functions, including query rewrite and materialized view refresh, even if your data warehouse design does not follow these guidelines. However, you realize significantly greater query execution performance and materialized view refresh performance benefits and you require fewer materialized views if your schema design complies with these guidelines.</p>
<p>A materialized view definition includes any number of aggregates, as well as any number of joins. In several ways, a materialized view behaves like an index:</p>
<ul style="list-style-type: disc;">
<li>
<p>The purpose of a materialized view is to increase query execution performance.</p>
</li>
<li>
<p>The existence of a materialized view is transparent to SQL applications, so that a database administrator can create or drop materialized views at any time without affecting the validity of SQL applications.</p>
</li>
<li>
<p>A materialized view consumes storage space.</p>
</li>
<li>
<p>The contents of the materialized view must be updated when the underlying detail tables are modified.</p>
</li>
</ul>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-0EB40435-5B01-4333-8C7F-CC3D6E73BF23">Schemas and Dimension Tables</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4">Guidelines for Materialized View Schema Design</a></p>
</li>
</ul>
</div>
<a id="DWHSG8170"></a>
<div class="props_rev_3"><a id="GUID-0EB40435-5B01-4333-8C7F-CC3D6E73BF23"></a>
<h4 id="DWHSG-GUID-0EB40435-5B01-4333-8C7F-CC3D6E73BF23" class="sect4">Schemas and Dimension Tables</h4>
<div>
<p>In the case of normalized or partially normalized dimension tables (a dimension that is stored in multiple tables), identify how these tables are joined. Note whether the joins between the dimension tables can guarantee that each child-side row joins with one and only one parent-side row. In the case of denormalized dimensions, determine whether the child-side columns uniquely determine the parent-side (or attribute) columns. These relationships can be enabled with constraints, using the <code class="codeph">NOVALIDATE</code> and <code class="codeph">RELY</code> options if the relationships represented by the constraints are guaranteed by other means. Note that if the joins between fact and dimension tables do not support the parent-child relationship described previously, you still gain significant performance advantages from defining the dimension with the <code class="codeph">CREATE</code> <code class="codeph">DIMENSION</code> statement. Another alternative, subject to some restrictions, is to use outer joins in the materialized view definition (that is, in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement).</p>
<p>You must not create dimensions in any schema that does not satisfy these relationships. Incorrect results can be returned from queries otherwise.</p>
</div>
</div>
<a id="DWHSG8171"></a>
<div class="props_rev_3"><a id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4"></a>
<h4 id="DWHSG-GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4" class="sect4">Guidelines for Materialized View Schema Design</h4>
<div>
<p>Before starting to define and use the various components of summary management, you should review your schema design to abide by the following guidelines wherever possible. Guidelines 1 and 2 are more important than guideline 3. If your schema design does not follow guidelines 1 and 2, it does not then matter whether it follows guideline 3. Guidelines 1, 2, and 3 affect both query rewrite performance and materialized view refresh performance.</p>
<div class="section">
<p class="subhead3">Dimensions Guideline 1</p>
<p>Dimensions should either be denormalized (each dimension contained in one table) or the joins between tables in a normalized or partially normalized dimension should guarantee that each child-side row joins with exactly one parent-side row.</p>
<p>You can enforce this condition by adding <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> and <code class="codeph">NOT NULL</code> constraints on the child-side join keys and <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> constraints on the parent-side join keys.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Dimensions Guideline 2</p>
<p>If dimensions are denormalized or partially denormalized, hierarchical integrity must be maintained between the key columns of the dimension table. Each child key value must uniquely identify its parent key value, even if the dimension table is denormalized. Hierarchical integrity in a denormalized dimension can be verified by calling the <code class="codeph">VALIDATE_DIMENSION</code> procedure of the <code class="codeph">DBMS_DIMENSION</code> package.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Dimensions Guideline 3</p>
<p>Fact and dimension tables should similarly guarantee that each fact table row joins with exactly one dimension table row. This condition must be declared, and optionally enforced, by adding <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> and <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints on the fact key column(s) and <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> constraints on the dimension key column(s), or by using outer joins. In a data warehouse, constraints are typically enabled with the <code class="codeph">NOVALIDATE</code> and <code class="codeph">RELY</code> clauses to avoid constraint enforcement performance overhead.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Dimensions Guideline 4</p>
<p>After each load and before refreshing your materialized view, use the <code class="codeph">VALIDATE_DIMENSION</code> procedure of the <code class="codeph">DBMS_DIMENSION</code> package to incrementally verify dimensional integrity.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Incremental Loads Guideline</p>
<p>Incremental loads of your detail data should be done using the SQL*Loader direct-path option, or any bulk loader utility that uses Oracle&#39;s direct-path interface. This includes <code class="codeph">INSERT</code> ... <code class="codeph">AS SELECT</code> with the <code class="codeph">APPEND</code> or <code class="codeph">PARALLEL</code> hints, where the hints cause the direct loader log to be used during the insert.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Partitions Guideline</p>
<p>Range/composite partition your tables by a monotonically increasing time column if possible (preferably of type <code class="codeph">DATE</code>).</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Time Dimensions Guideline</p>
</div>
<!-- class="section" -->
<div class="section">
<p>If a time dimension appears in the materialized view as a time column, partition and index the materialized view in the same manner as you have the fact tables.</p>
<p>If you are concerned with the time required to enable constraints and whether any constraints might be violated, then use the <code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code> with the <code class="codeph">RELY</code> clause to turn on constraint checking without validating any of the existing constraints. The risk with this approach is that incorrect query results could occur if any constraints are broken. Therefore, as the designer, you must determine how clean the data is and whether the risk of incorrect results is too great.</p>
<div class="infoboxnotealso" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-20A7AE13-61D9-4540-8FA7-0E4006EEBD4D">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="basicmv.htm#GUID-63E162FE-8957-4C1D-9494-041A8B2B7917">Types of Materialized Views</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="dimen.htm#GUID-C924590B-C481-4202-9243-1EEB66560C6D">Creating Dimensions</a>&#34;</span> for details on the benefits of maintaining a child-side row join with a parent-side row</p>
</li>
<li>
<p><a class="olink SQLRF01302" target="_blank" href="../SQLRF/statements_6002.htm#SQLRF01302"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8173"></a>
<div class="props_rev_3"><a id="GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05"></a>
<h3 id="DWHSG-GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05" class="sect3">About Loading Data into Data Warehouses</h3>
<div>
<p>A popular and efficient way to load data into a data warehouse or data mart is to use SQL*Loader with the <code class="codeph">DIRECT</code> or <code class="codeph">PARALLEL</code> option, Data Pump, or to use another loader tool that uses the Oracle direct-path API. See <a class="olink SUTIL003" target="_blank" href="../SUTIL/GUID-DD843EE2-1FAB-4E72-A115-21D97A501ECC.htm#SUTIL003"><span class="italic">Oracle Database Utilities</span></a> for the restrictions and considerations when using SQL*Loader with the <code class="codeph">DIRECT</code> or <code class="codeph">PARALLEL</code> keywords.</p>
<p>Loading strategies can be classified as one-phase or two-phase. In one-phase loading, data is loaded directly into the target table, quality assurance tests are performed, and errors are resolved by performing DML operations prior to refreshing materialized views. If a large number of deletions are possible, then storage utilization can be adversely affected, but temporary space requirements and load time are minimized.</p>
<p>In a two-phase loading process:</p>
<ul style="list-style-type: disc;">
<li>
<p>Data is first loaded into a temporary table in the warehouse.</p>
</li>
<li>
<p>Quality assurance procedures are applied to the data.</p>
</li>
<li>
<p>Referential integrity constraints on the target table are disabled, and the local index in the target partition is marked unusable.</p>
</li>
<li>
<p>The data is copied from the temporary area into the appropriate partition of the target table using <code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> with the <code class="codeph">PARALLEL</code> or <code class="codeph">APPEND</code> hint. The temporary table is then dropped. Alternatively, if the target table is partitioned, you can create a new (empty) partition in the target table and use <code class="codeph">ALTER TABLE ... EXCHANGE PARTITION</code> to incorporate the temporary table into the target table. See <a class="olink SQLRF53492" target="_blank" href="../SQLRF/statements_3001.htm#SQLRF53492"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
</li>
<li>
<p>The constraints are enabled, usually with the <code class="codeph">NOVALIDATE</code> option.</p>
</li>
</ul>
<p>Immediately after loading the detail data and updating the indexes on the detail data, the database can be opened for operation, if desired. You can disable query rewrite at the system level by issuing an <code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> <code class="codeph">SET</code> <code class="codeph">QUERY_REWRITE_ENABLED</code> = <code class="codeph">FALSE</code> statement until all the materialized views are refreshed.</p>
<p>If <code class="codeph">QUERY_REWRITE_INTEGRITY</code> is set to <code class="codeph">STALE_TOLERATED</code>, access to the materialized view can be allowed at the session level to any users who do not require the materialized views to reflect the data from the latest load by issuing an <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">SET</code> <code class="codeph">QUERY_REWRITE_ENABLED</code> = <code class="codeph">TRUE</code> statement. This scenario does not apply when <code class="codeph">QUERY_REWRITE_INTEGRITY</code> is either <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> because the system ensures in these modes that only materialized views with updated data participate in a query rewrite.</p>
</div>
</div>
<a id="DWHSG8174"></a>
<div class="props_rev_3"><a id="GUID-6D7B8BA6-9217-48B5-A6F9-87FF0834DA46"></a>
<h3 id="DWHSG-GUID-6D7B8BA6-9217-48B5-A6F9-87FF0834DA46" class="sect3">Overview of Materialized View Management Tasks</h3>
<div>
<p>The motivation for using materialized views is to improve performance, but the overhead associated with materialized view management can become a significant system management problem. When reviewing or evaluating some of the necessary materialized view management activities, consider some of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Identifying what materialized views to create initially.</p>
</li>
<li>
<p>Indexing the materialized views.</p>
</li>
<li>
<p>Ensuring that all materialized views and materialized view indexes are refreshed properly each time the database is updated.</p>
</li>
<li>
<p>Checking which materialized views have been used.</p>
</li>
<li>
<p>Determining how effective each materialized view has been on workload performance.</p>
</li>
<li>
<p>Measuring the space being used by materialized views.</p>
</li>
<li>
<p>Determining which new materialized views should be created.</p>
</li>
<li>
<p>Determining which existing materialized views should be dropped.</p>
</li>
<li>
<p>Archiving old detail and materialized view data that is no longer useful.</p>
</li>
</ul>
<p>After the initial effort of creating and populating the data warehouse or data mart, the major administration overhead is the update process, which involves:</p>
<ul style="list-style-type: disc;">
<li>
<p>Periodic extraction of incremental changes from the operational systems.</p>
</li>
<li>
<p>Transforming the data.</p>
</li>
<li>
<p>Verifying that the incremental changes are correct, consistent, and complete.</p>
</li>
<li>
<p>Bulk-loading the data into the warehouse.</p>
</li>
<li>
<p>Refreshing indexes and materialized views so that they are consistent with the detail data.</p>
</li>
</ul>
<p>The update process must generally be performed within a limited period of time known as the <a id="d14086e1054" class="indexterm-anchor"></a><a href="glossary.htm#GUID-3924FE75-A719-428A-B7AB-714D15A456A0"><span class="xrefglossterm">update window</span></a>. The update window depends on the <a id="d14086e1060" class="indexterm-anchor"></a><a href="glossary.htm#GUID-6AEAFA62-131A-4B0B-990D-42DD06C68438"><span class="xrefglossterm">update frequency</span></a> (such as daily or weekly) and the nature of the business. For a daily update frequency, an update window of two to six hours might be typical.</p>
<p>You need to know your update window for the following activities:</p>
<ul style="list-style-type: disc;">
<li>
<p>Loading the detail data</p>
</li>
<li>
<p>Updating or rebuilding the indexes on the detail data</p>
</li>
<li>
<p>Performing quality assurance tests on the data</p>
</li>
<li>
<p>Refreshing the materialized views</p>
</li>
<li>
<p>Updating the indexes on the materialized views</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG0082"></a>
<div class="props_rev_3"><a id="GUID-63E162FE-8957-4C1D-9494-041A8B2B7917"></a>
<h2 id="DWHSG-GUID-63E162FE-8957-4C1D-9494-041A8B2B7917" class="sect2">Types of Materialized Views</h2>
<div>
<p><a id="d14086e1105" class="indexterm-anchor"></a>The <code class="codeph">SELECT</code> clause in the materialized view creation statement defines the data that the materialized view is to contain. Only a few restrictions limit what can be specified. Any number of tables can be joined together. Besides tables, other elements such as views, inline views (subqueries in the <code class="codeph">FROM</code> clause of a <code class="codeph">SELECT</code> statement), subqueries, and materialized views can all be joined or referenced in the <code class="codeph">SELECT</code> clause. You cannot, however, define a materialized view with a subquery in the <code class="codeph">SELECT</code> list of the defining query. You can, however, include subqueries elsewhere in the defining query, such as in the <code class="codeph">WHERE</code> clause.</p>
<p>The types of materialized views are:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E">About Materialized Views with Aggregates</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-3B903558-0C98-4033-9BCD-4A146220E868">About Materialized Views Containing Only Joins</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-BA7DBCFF-67F2-44A6-BCE2-931A469F553C">About Nested Materialized Views</a></p>
</li>
</ul>
</div>
<a id="DWHSG8176"></a><a id="DWHSG8177"></a><a id="DWHSG8178"></a><a id="DWHSG8175"></a>
<div class="props_rev_3"><a id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E"></a>
<h3 id="DWHSG-GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E" class="sect3">About Materialized Views with Aggregates</h3>
<div>
<p>In<a id="d14086e1178" class="indexterm-anchor"></a> data warehouses, materialized views normally contain aggregates as shown in <a href="basicmv.htm#GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__i1006540">Example 5-1</a>. For <a href="glossary.htm#GUID-4D70E5C0-17A2-4AD5-B75D-3C81B5110FBF"><span class="xrefglossterm">fast refresh</span></a> to be possible, the <code class="codeph">SELECT</code> list must contain all of the <code class="codeph">GROUP</code> <code class="codeph">BY</code> columns (if present), and there must be a <code class="codeph">COUNT(*)</code> and a <code class="codeph">COUNT(column)</code> on any aggregated columns. Also, <a href="glossary.htm#GUID-EDB1A012-531D-4BE8-8826-F6D3DC477E33"><span class="xrefglossterm">materialized view log</span></a>s must be present on all tables referenced in the query that defines the materialized view. The valid aggregate functions are: <code class="codeph">SUM</code>, <code class="codeph">COUNT(x)</code>, <code class="codeph">COUNT(*)</code>, <code class="codeph">AVG</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>, <code class="codeph">MIN</code>, and <code class="codeph">MAX</code>, and the expression to be aggregated can be any SQL value expression. See <span class="q">&#34;<a href="basicmv.htm#GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024">Restrictions on Fast Refresh on Materialized Views with Aggregates</a>&#34;</span>.</p>
<div class="infoboxnotealso" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-3BA10586-294C-478E-B949-016C50571746">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="basicmv.htm#GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE">Requirements for Using Materialized Views with Aggregates</a>&#34;</span></p>
</div>
<p>Fast refresh for a materialized view containing joins and aggregates is possible after any type of DML to the base tables (direct load or conventional <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code>). It can be defined to be refreshed <code class="codeph">ON</code> <code class="codeph">COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code>. A <code class="codeph">REFRESH ON</code> <code class="codeph">COMMIT</code> materialized view is refreshed automatically when a transaction that does DML to one of the materialized view&#39;s detail tables commits. The time taken to complete the commit may be slightly longer than usual when this method is chosen. This is because the refresh operation is performed as part of the commit process. Therefore, this method may not be suitable if many users are concurrently changing the tables upon which the materialized view is based.</p>
<p>Here are some examples of materialized views with aggregates. Note that materialized view logs are only created because this materialized view is fast refreshed.</p>
<div class="example" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__i1006540">
<p class="titleinexample">Example 5-1 <span class="bold">Creating a Materialized View</span> (Total Number and Value of Sales)</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON products WITH SEQUENCE, ROWID
(prod_id, prod_name, prod_desc, prod_subcategory, prod_subcategory_desc, 
prod_category, prod_category_desc, prod_weight_class, prod_unit_of_measure,
 prod_pack_size, supplier_id, prod_status, prod_list_price, prod_min_price)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW LOG ON sales
WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW product_sales_mv
PCTFREE 0  TABLESPACE demo
STORAGE (INITIAL 8M)
BUILD IMMEDIATE
REFRESH FAST
ENABLE QUERY REWRITE
AS SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales,
COUNT(*) AS cnt, COUNT(s.amount_sold) AS cnt_amt
FROM sales s, products p
WHERE s.prod_id = p.prod_id GROUP BY p.prod_name;
</pre>
<p>This example creates a materialized view <code class="codeph">product_sales_mv</code> that computes total number and value of sales for a product. It is derived by joining the tables <code class="codeph">sales</code> and <code class="codeph">products</code> on the column <code class="codeph">prod_id</code>. The materialized view is populated with data immediately because the build method is immediate and it is available for use by query rewrite. In this example, the default refresh method is <code class="codeph">FAST</code>, which is allowed because the appropriate materialized view logs have been created on tables <code class="codeph">products</code> and <code class="codeph">sales</code>.</p>
<p>You can achieve better fast refresh performance for local materialized views if you use a materialized view log that contains a <code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code> clause. An example is the following:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID(prod_id, cust_id, time_id),
  COMMIT SCN INCLUDING NEW VALUES;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-6E37B03D-750D-4E30-9718-168EB4039E95">
<p class="titleinexample">Example 5-2 <span class="bold">Creating a Materialized View</span> (Computed Sum of Sales)</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW product_sales_mv
PCTFREE 0 TABLESPACE demo
STORAGE (INITIAL 8M)
BUILD DEFERRED
REFRESH COMPLETE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales
FROM sales s, products p WHERE s.prod_id = p.prod_id
GROUP BY p.prod_name;
</pre>
<p>This example creates a materialized view <code class="codeph">product_sales_mv</code> that computes the sum of sales by <code class="codeph">prod_name</code>. It is derived by joining the tables <code class="codeph">sales</code> and <code class="codeph">products</code> on the column <code class="codeph">prod_id</code>. The materialized view does not initially contain any data, because the build method is <code class="codeph">DEFERRED</code>. A complete refresh is required for the first refresh of a build deferred materialized view. When it is refreshed and once populated, this materialized view can be used by query rewrite.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-B6CFF335-0EC9-4EEC-9CD6-26F63B098D8E">
<p class="titleinexample">Example 5-3 <span class="bold">Creating a Materialized View</span> (Aggregates on a Single Table)</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW sum_sales
PARALLEL
BUILD IMMEDIATE  
REFRESH FAST ON COMMIT AS  
SELECT s.prod_id, s.time_id, COUNT(*) AS count_grp,
   SUM(s.amount_sold) AS sum_dollar_sales,
   COUNT(s.amount_sold) AS count_dollar_sales,
   SUM(s.quantity_sold) AS sum_quantity_sales,
   COUNT(s.quantity_sold) AS count_quantity_sales
FROM sales s
GROUP BY s.prod_id, s.time_id;
</pre>
<p>This example creates a materialized view that contains aggregates on a single table. Because the materialized view log has been created with all referenced columns in the materialized view&#39;s defining query, the materialized view is fast refreshable. If DML is applied against the <code class="codeph">sales</code> table, then the changes are reflected in the materialized view when the commit is issued.</p>
<div class="infoboxnotealso" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-D57F74C8-777A-4FE1-B3CF-3CF52758DDCD">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF01302" target="_blank" href="../SQLRF/statements_6002.htm#SQLRF01302"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax of the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> and <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code> statements</p>
</div>
</div>
<!-- class="example" --></div>
<a id="DWHSG8180"></a><a id="DWHSG8179"></a>
<div class="props_rev_3"><a id="GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE"></a>
<h4 id="DWHSG-GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE" class="sect4">Requirements for Using Materialized Views with Aggregates</h4>
<div>
<p><a href="basicmv.htm#GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE__G1014280" title="This table illustrates the requirements for materialized views with aggregates">Table 5-1</a> illustrates the aggregate requirements for materialized views. If aggregate <code class="codeph">X</code> is present, aggregate <code class="codeph">Y</code> is required and aggregate <code class="codeph">Z</code> is optional.</p>
<div class="tblformal" id="GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE__G1014280">
<p class="titleintable">Table 5-1 Requirements for Materialized Views with Aggregates</p>
<table class="cellalignment1516" title="Requirements for Materialized Views with Aggregates" summary="This table illustrates the requirements for materialized views with aggregates">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1552" id="d14086e1436">X</th>
<th class="cellalignment1524" id="d14086e1439">Y</th>
<th class="cellalignment1582" id="d14086e1442">Z</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1447" headers="d14086e1436">
<p><code class="codeph">COUNT(expr)</code></p>
</td>
<td class="cellalignment1527" headers="d14086e1447 d14086e1439">
<p><code class="codeph">-</code></p>
</td>
<td class="cellalignment1583" headers="d14086e1447 d14086e1442">
<p><code class="codeph">-</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1460" headers="d14086e1436">
<p><code class="codeph">MIN(expr)</code></p>
</td>
<td class="cellalignment1527" headers="d14086e1460 d14086e1439">&nbsp;</td>
<td class="cellalignment1583" headers="d14086e1460 d14086e1442">&nbsp;</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1469" headers="d14086e1436">
<p><code class="codeph">MAX(expr)</code></p>
</td>
<td class="cellalignment1527" headers="d14086e1469 d14086e1439">&nbsp;</td>
<td class="cellalignment1583" headers="d14086e1469 d14086e1442">&nbsp;</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1478" headers="d14086e1436">
<p><code class="codeph">SUM(expr)</code></p>
</td>
<td class="cellalignment1527" headers="d14086e1478 d14086e1439">
<p><code class="codeph">COUNT(expr)</code></p>
</td>
<td class="cellalignment1583" headers="d14086e1478 d14086e1442">
<p><code class="codeph">-</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1491" headers="d14086e1436">
<p><code class="codeph">SUM(col)</code>, <code class="codeph">col</code> has <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint</p>
</td>
<td class="cellalignment1527" headers="d14086e1491 d14086e1439">
<p>-</p>
</td>
<td class="cellalignment1583" headers="d14086e1491 d14086e1442">&nbsp;</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1511" headers="d14086e1436">
<p><code class="codeph">AVG(expr)</code></p>
</td>
<td class="cellalignment1527" headers="d14086e1511 d14086e1439">
<p><code class="codeph">COUNT(expr)</code></p>
</td>
<td class="cellalignment1583" headers="d14086e1511 d14086e1442">
<p><code class="codeph">SUM(expr)</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1524" headers="d14086e1436">
<p><code class="codeph">STDDEV(expr)</code></p>
</td>
<td class="cellalignment1527" headers="d14086e1524 d14086e1439">
<p><code class="codeph">COUNT(expr) SUM(expr)</code></p>
</td>
<td class="cellalignment1583" headers="d14086e1524 d14086e1442">
<p><code class="codeph">SUM(expr * expr)</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d14086e1537" headers="d14086e1436">
<p><code class="codeph">VARIANCE(expr)</code></p>
</td>
<td class="cellalignment1527" headers="d14086e1537 d14086e1439">
<p><code class="codeph">COUNT(expr) SUM(expr)</code></p>
</td>
<td class="cellalignment1583" headers="d14086e1537 d14086e1442">
<p><code class="codeph">SUM(expr * expr)</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Note that <code class="codeph">COUNT(*)</code> must always be present to guarantee all types of fast refresh. Otherwise, you may be limited to fast refresh after inserts only. Oracle recommends that you include the optional aggregates in column <code class="codeph">Z</code> in the materialized view in order to obtain the most efficient and accurate fast refresh of the aggregates.</p>
</div>
</div>
</div>
<a id="DWHSG8181"></a>
<div class="props_rev_3"><a id="GUID-3B903558-0C98-4033-9BCD-4A146220E868"></a>
<h3 id="DWHSG-GUID-3B903558-0C98-4033-9BCD-4A146220E868" class="sect3">About Materialized Views Containing Only Joins</h3>
<div>
<p>Some materialized views contain only joins and no aggregates, such as in <a href="basicmv.htm#GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10__i1006694">Example 5-4</a>, where a materialized view is created that joins the <code class="codeph">sales</code> table to the <code class="codeph">times</code> and <code class="codeph">customers</code> tables. The advantage of creating this type of materialized view is that expensive joins are precalculated.</p>
<div class="infoboxnotealso" id="GUID-3B903558-0C98-4033-9BCD-4A146220E868__GUID-B5AA2F20-C6B7-4119-8F7F-E74702970FA8">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="basicmv.htm#GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10">Materialized Join Views FROM Clause Considerations</a>&#34;</span></p>
</div>
<p>Fast refresh for a materialized view containing only joins is possible after any type of DML to the base tables (direct-path or conventional <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code>).</p>
<p>A materialized view containing only joins can be defined to be refreshed <code class="codeph">ON COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code>. If it is <code class="codeph">ON</code> <code class="codeph">COMMIT</code>, the refresh is performed at commit time of the transaction that does DML on the materialized view&#39;s detail table.</p>
<p>If you specify <code class="codeph">REFRESH</code> <code class="codeph">FAST</code>, Oracle Database performs further verification of the query definition to ensure that fast refresh can be performed if any of the detail tables change. These additional checks are:</p>
<ul style="list-style-type: disc;">
<li>
<p>A materialized view log must be present for each detail table unless the table supports partition change tracking (PCT). Also, when a materialized view log is required, the <code class="codeph">ROWID</code> column must be present in each materialized view log.</p>
</li>
<li>
<p>The rowids of all the detail tables must appear in the <code class="codeph">SELECT</code> list of the materialized view query definition.</p>
</li>
</ul>
<p>If some of these restrictions are not met, you can create the materialized view as <code class="codeph">REFRESH</code> <code class="codeph">FORCE</code> to take advantage of fast refresh when it is possible. If one of the tables did not meet all of the criteria, but the other tables did, the materialized view would still be fast refreshable with respect to the other tables for which all the criteria are met.</p>
<p>To achieve an optimally efficient refresh, you should ensure that the defining query does not use an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join.</p>
<div class="infoboxnotealso" id="GUID-3B903558-0C98-4033-9BCD-4A146220E868__GUID-7DA8543B-D858-4D40-B02D-3CF4337E376C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="basicmv.htm#GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1">Restrictions on Fast Refresh on Materialized Views with Joins Only</a>&#34;</span> for more information regarding the conditions that cause refresh performance to degrade.</p>
</li>
<li>
<p><span class="q">&#34;<a href="refresh.htm#GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD">About Partition Change Tracking (PCT) Refresh for Materialized Views</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8183"></a><a id="DWHSG8182"></a>
<div class="props_rev_3"><a id="GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10"></a>
<h4 id="DWHSG-GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10" class="sect4">Materialized Join Views FROM Clause Considerations</h4>
<div>
<p>If the materialized view contains only joins, the <code class="codeph">ROWID</code> columns for each table (and each instance of a table that occurs multiple times in the <code class="codeph">FROM</code> list) must be present in the <code class="codeph">SELECT</code> list of the materialized view.</p>
<p>If the materialized view has remote tables in the <code class="codeph">FROM</code> clause, all tables in the <code class="codeph">FROM</code> clause must be located on that same site. Further, <code class="codeph">ON</code> <code class="codeph">COMMIT</code> refresh is not supported for materialized view with remote tables. Except for SCN-based materialized view logs, materialized view logs must be present on the remote site for each detail table of the materialized view and <code class="codeph">ROWID</code> columns must be present in the <code class="codeph">SELECT</code> list of the materialized view, as shown in the following example.</p>
<div class="example" id="GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10__i1006694">
<p class="titleinexample">Example 5-4 Materialized View Containing Only Joins</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON times WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;
CREATE MATERIALIZED VIEW detail_sales_mv 
PARALLEL BUILD IMMEDIATE
REFRESH FAST AS
SELECT s.rowid &#34;sales_rid&#34;, t.rowid &#34;times_rid&#34;, c.rowid &#34;customers_rid&#34;,
       c.cust_id, c.cust_last_name, s.amount_sold, s.quantity_sold, s.time_id
FROM sales s, times t, customers c 
WHERE  s.cust_id = c.cust_id(+) AND s.time_id = t.time_id(+);
</pre>
<p>Alternatively, if the previous example did not include the columns <code class="codeph">times_rid</code> and <code class="codeph">customers_rid</code>, and if the refresh method was <code class="codeph">REFRESH</code> <code class="codeph">FORCE</code>, then this materialized view would be fast refreshable only if the sales table was updated but not if the tables <code class="codeph">times</code> or <code class="codeph">customers</code> were updated.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW detail_sales_mv 
PARALLEL
BUILD IMMEDIATE
REFRESH FORCE AS
SELECT s.rowid &#34;sales_rid&#34;, c.cust_id, c.cust_last_name, s.amount_sold,
   s.quantity_sold, s.time_id
FROM sales s, times t, customers c 
WHERE s.cust_id = c.cust_id(+) AND s.time_id = t.time_id(+);
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8184"></a>
<div class="props_rev_3"><a id="GUID-BA7DBCFF-67F2-44A6-BCE2-931A469F553C"></a>
<h3 id="DWHSG-GUID-BA7DBCFF-67F2-44A6-BCE2-931A469F553C" class="sect3">About Nested Materialized Views</h3>
<div>
<p><a id="d14086e1779" class="indexterm-anchor"></a><a id="d14086e1783" class="indexterm-anchor"></a>A nested materialized view is a materialized view whose definition is based on another materialized view. A nested materialized view can reference other relations in the database in addition to referencing materialized views.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-6516CC0D-1F11-4127-A497-114AD84128DF">Why Use Nested Materialized Views?</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-179C8C8A-585B-49E6-8970-09396DB53DE3">About Nesting Materialized Views with Joins and Aggregates</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-8B2C0915-2FC8-4866-BDF7-7F74ABDC1D5D">Nested Materialized View Usage Guidelines</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-6DABD06E-555C-4C39-9DA5-7601E2464FDA">Restrictions When Using Nested Materialized Views</a></p>
</li>
</ul>
</div>
<a id="DWHSG8186"></a><a id="DWHSG8185"></a>
<div class="props_rev_3"><a id="GUID-6516CC0D-1F11-4127-A497-114AD84128DF"></a>
<h4 id="DWHSG-GUID-6516CC0D-1F11-4127-A497-114AD84128DF" class="sect4">Why Use Nested Materialized Views?</h4>
<div>
<p>In a data warehouse, you typically create many aggregate views on a single join (for example, rollups along different dimensions). Incrementally maintaining these distinct materialized aggregate views can take a long time, because the underlying join has to be performed many times.</p>
<p>Using nested materialized views, you can create multiple single-table materialized views based on a joins-only materialized view and the join is performed just once. In addition, optimizations can be performed for this class of single-table aggregate materialized view and thus refresh is very efficient.</p>
<div class="example" id="GUID-6516CC0D-1F11-4127-A497-114AD84128DF__GUID-35F7AA61-B4A1-4620-B7AA-B7E120FC012B">
<p class="titleinexample">Example 5-5 Nested Materialized View</p>
<p>You can create a nested materialized view on materialized views, but all parent and base materialized views must contain joins or aggregates. If the defining queries for a materialized view do not contain joins or aggregates, it cannot be nested. All the underlying objects (materialized views or tables) on which the materialized view is defined must have a materialized view log. All the underlying objects are treated as if they were tables. In addition, you can use all the existing options for materialized views.</p>
<p>Using the tables and their columns from the <code class="codeph">sh</code> sample schema, the following materialized views illustrate how nested materialized views can be created.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON times WITH ROWID;

/*create materialized view join_sales_cust_time as fast refreshable at
   COMMIT time */
CREATE MATERIALIZED VIEW join_sales_cust_time 
REFRESH FAST ON COMMIT AS
SELECT c.cust_id, c.cust_last_name, s.amount_sold, t.time_id,
       t.day_number_in_week, s.rowid srid, t.rowid trid, c.rowid crid 
FROM sales s, customers c, times t
WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id;
</pre>
<p>To create a nested materialized view on the table <code class="codeph">join_sales_cust_time</code><span class="italic">,</span> you would have to create a materialized view log on the table. Because this will be a single-table aggregate materialized view on <code class="codeph">join_sales_cust_time</code>, you must log all the necessary columns and use the <code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code> clause.</p>
<pre dir="ltr">/* create materialized view log on join_sales_cust_time */
CREATE MATERIALIZED VIEW LOG ON join_sales_cust_time 
WITH ROWID (cust_last_name, day_number_in_week, amount_sold)
INCLUDING NEW VALUES;

/* create the single-table aggregate materialized view sum_sales_cust_time 
on join_sales_cust_time as fast refreshable at COMMIT time */
CREATE MATERIALIZED VIEW sum_sales_cust_time 
REFRESH FAST ON COMMIT AS
SELECT COUNT(*) cnt_all, SUM(amount_sold) sum_sales, COUNT(amount_sold)
       cnt_sales, cust_last_name, day_number_in_week
FROM join_sales_cust_time
GROUP BY cust_last_name, day_number_in_week;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8187"></a>
<div class="props_rev_3"><a id="GUID-179C8C8A-585B-49E6-8970-09396DB53DE3"></a>
<h4 id="DWHSG-GUID-179C8C8A-585B-49E6-8970-09396DB53DE3" class="sect4">About Nesting Materialized Views with Joins and Aggregates</h4>
<div>
<p>Some types of nested materialized views cannot be fast refreshed. Use <code class="codeph">EXPLAIN_MVIEW</code> to identify those types of materialized views. You can refresh a tree of nested materialized views in the appropriate dependency order by specifying the <code class="codeph">nested = TRUE</code> parameter with the <code class="codeph">DBMS_MVIEW.REFRESH</code> parameter. For example, if you call <code class="codeph">DBMS_MVIEW.REFRESH (&#39;SUM_SALES_CUST_TIME&#39;, nested =&gt; TRUE)</code>, the <code class="codeph">REFRESH</code> procedure will first refresh the <code class="codeph">join_sales_cust_time</code> materialized view, and then refresh the <code class="codeph">sum_sales_cust_time</code> materialized view.</p>
</div>
</div>
<a id="DWHSG8188"></a>
<div class="props_rev_3"><a id="GUID-8B2C0915-2FC8-4866-BDF7-7F74ABDC1D5D"></a>
<h4 id="DWHSG-GUID-8B2C0915-2FC8-4866-BDF7-7F74ABDC1D5D" class="sect4">Nested Materialized View Usage Guidelines</h4>
<div>
<p>You should keep the following in mind when deciding whether to use nested materialized views:</p>
<ul style="list-style-type: disc;">
<li>
<p>If you want to use fast refresh, you should fast refresh all the materialized views along any chain.</p>
</li>
<li>
<p>If you want the highest level materialized view to be fresh with respect to the detail tables, you must ensure that all materialized views in a tree are refreshed in the correct dependency order before refreshing the highest-level. You can automatically refresh intermediate materialized views in a nested hierarchy using the <code class="codeph">nested = TRUE</code> parameter, as described in <span class="q">&#34;<a href="basicmv.htm#GUID-179C8C8A-585B-49E6-8970-09396DB53DE3">About Nesting Materialized Views with Joins and Aggregates</a>&#34;</span>. If you do not specify <code class="codeph">nested = TRUE</code> and the materialized views under the highest-level materialized view are stale, refreshing only the highest-level will succeed, but makes it fresh only with respect to its underlying materialized view, not the detail tables at the base of the tree.</p>
</li>
<li>
<p>When refreshing materialized views, you must ensure that all materialized views in a tree are refreshed. If you only refresh the highest-level materialized view, the materialized views under it will be stale and you must explicitly refresh them. If you use the <code class="codeph">REFRESH</code> procedure with the <code class="codeph">nested</code> parameter value set to <code class="codeph">TRUE</code>, only specified materialized views and their child materialized views in the tree are refreshed, and not their top-level materialized views. Use the <code class="codeph">REFRESH_DEPENDENT</code> procedure with the nested parameter value set to <code class="codeph">TRUE</code> if you want to ensure that all materialized views in a tree are refreshed.</p>
</li>
<li>
<p>If complete refresh is the only refresh option supported for a particular nested materialized view, then a complete refresh is performed even when a fast refresh is specified.</p>
</li>
<li>
<p>Freshness of a materialized view is calculated relative to the objects directly referenced by the materialized view. When a materialized view references another materialized view, the freshness of the topmost materialized view is calculated relative to changes in the materialized view it directly references, not relative to changes in the tables referenced by the materialized view it references.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8189"></a>
<div class="props_rev_3"><a id="GUID-6DABD06E-555C-4C39-9DA5-7601E2464FDA"></a>
<h4 id="DWHSG-GUID-6DABD06E-555C-4C39-9DA5-7601E2464FDA" class="sect4">Restrictions When Using Nested Materialized Views</h4>
<div>
<div class="section">
<p><a id="d14086e1997" class="indexterm-anchor"></a><a id="d14086e2001" class="indexterm-anchor"></a>You cannot create both a materialized view and a prebuilt materialized view on the same table. For example, If you have a table <code class="codeph">costs</code> with a materialized view <code class="codeph">cost_mv</code> based on it, you cannot then create a prebuilt materialized view on table <code class="codeph">costs</code>. The result would make <code class="codeph">cost_mv</code> a nested materialized view and this method of conversion is not supported.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<a id="DWHSG8190"></a><a id="DWHSG0083"></a>
<div class="props_rev_3"><a id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52"></a>
<h2 id="DWHSG-GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52" class="sect2">Creating Materialized Views</h2>
<div>
<div class="section">
<p><a id="d14086e2042" class="indexterm-anchor"></a>A materialized view can be created with the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement or using Enterprise Manager.<a href="basicmv.htm#GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52__i1006810">Example 5-6</a> illustrates creating a materialized view called <code class="codeph">cust_sales_mv</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52__i1006810">
<p class="titleinexample">Example 5-6 Creating a Materialized View</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW cust_sales_mv
PCTFREE 0 TABLESPACE demo
STORAGE (INITIAL 8M)
PARALLEL
BUILD IMMEDIATE
REFRESH COMPLETE
ENABLE QUERY REWRITE AS
SELECT  c.cust_last_name, SUM(amount_sold) AS sum_amount_sold
FROM customers c, sales s WHERE s.cust_id = c.cust_id
GROUP BY c.cust_last_name;
</pre>
<p>It is not uncommon in a data warehouse to have already created summary or aggregation tables, and you might not wish to repeat this work by building a new materialized view. In this case, the table that already exists in the database can be registered as a<a id="d14086e2068" class="indexterm-anchor"></a><a id="d14086e2070" class="indexterm-anchor"></a> prebuilt materialized view. This technique is described in <span class="q">&#34;<a href="basicmv.htm#GUID-4DE39B8B-8452-4581-A841-6AF77019986D">Registering Existing Materialized Views</a>&#34;</span>.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52__GUID-935189E9-21ED-462E-AEEE-5DA17AF6B76F">
<p>Once you have selected the materialized views you want to create, follow these steps for each materialized view.</p>
<ol>
<li>
<p>Design the materialized view. Existing user-defined materialized views do not require this step. If the materialized view contains many rows, then, if appropriate, the materialized view should be partitioned (if possible) and should match the partitioning of the largest or most frequently updated detail or fact table (if possible). Refresh performance benefits from partitioning, because it can take advantage of parallel DML capabilities and possible PCT-based refresh.</p>
</li>
<li>
<p>Use the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement to create and, optionally, populate the materialized view. If a user-defined materialized view already exists, then use the <code class="codeph">ON</code> <code class="codeph">PREBUILT</code> <code class="codeph">TABLE</code> clause in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. Otherwise, use the <code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code> clause to populate the materialized view immediately, or the <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> clause to populate the materialized view later. A <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> materialized view is disabled for use by query rewrite until the first <code class="codeph">COMPLETE</code> <code class="codeph">REFRESH</code>, after which it is automatically enabled, provided the <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> clause has been specified.</p>
<div class="infoboxnotealso" id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52__GUID-8A5A1CB4-A761-4E88-89DC-FA19D87F61CD">
<p class="notep1">See Also:</p>
<p><a id="d14086e2155" class="indexterm-anchor"></a><a id="d14086e2157" class="indexterm-anchor"></a><a id="d14086e2159" class="indexterm-anchor"></a><a class="olink SQLRF01302" target="_blank" href="../SQLRF/statements_6002.htm#SQLRF01302"><span class="italic">Oracle Database SQL Language Reference</span></a> for descriptions of the SQL statements <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>, <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>, and <code class="codeph">DROP</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code></p>
</div>
</li>
</ol>
<div class="infoboxnotealso" id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52__GUID-A7B036E7-8FF9-423F-B6EA-3831C1DE0AA0">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-701F4C59-4FA0-4CF4-B7B1-5AAA0A12515B">Creating Materialized Views with Column Alias Lists</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-9C3332BB-53E2-4179-B05C-5C8D1E46EFDF">About Materialized Views Names</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266">About Storage And Table Compression for Materialized Views</a></p>
</li>
</ul>
</div>
</div>
<!-- class="example" --></div>
<a id="DWHSG00831"></a>
<div class="props_rev_3"><a id="GUID-701F4C59-4FA0-4CF4-B7B1-5AAA0A12515B"></a>
<h3 id="DWHSG-GUID-701F4C59-4FA0-4CF4-B7B1-5AAA0A12515B" class="sect3">Creating Materialized Views with Column Alias Lists</h3>
<div>
<div class="section">
<p>Currently, when a materialized view is created, if its defining query contains same-name columns in the <code class="codeph">SELECT</code> list, the name conflicts need to be resolved by specifying unique aliases for those columns. Otherwise, the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement fails with the error messages of columns ambiguously defined. However, the standard method of attaching aliases in the <code class="codeph">SELECT</code> clause for name resolution restricts the use of the full text match query rewrite and it will occur only when the text of the materialized view&#39;s defining query and the text of user input query are identical. Thus, if the user specifies select aliases in the materialized view&#39;s defining query while there is no alias in the query, the full text match comparison fails. This is particularly a problem for queries from Discoverer, which makes extensive use of column aliases.</p>
<p>The following is an example of the problem. <code class="codeph">sales_mv</code> is created with column aliases in the <code class="codeph">SELECT</code> clause but the input query <code class="codeph">Q1</code> does not have the aliases. The full text match rewrite fails. The materialized view is as follows:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW sales_mv
ENABLE QUERY REWRITE AS
SELECT s.time_id sales_tid, c.time_id costs_tid
FROM sales s, products p, costs c
WHERE s.prod_id = p.prod_id AND c.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre>
<p>Input query statement <code class="codeph">Q1</code> is as follows:</p>
<pre dir="ltr">SELECT s.time_id, c1.time_id
FROM sales s, products p, costs c1
WHERE s.prod_id = p.prod_id AND c1.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre>
<p>Even though the materialized view&#39;s defining query is almost identical and logically equivalent to the user&#39;s input query, query rewrite does not happen because of the failure of full text match that is the only rewrite possibility for some queries (for example, a subquery in the <code class="codeph">WHERE</code> clause).</p>
<p>You can add a column alias list to a <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. The column alias list explicitly resolves any column name conflict without attaching aliases in the <code class="codeph">SELECT</code> clause of the materialized view. The syntax of the materialized view column alias list is illustrated in the following example:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW sales_mv (sales_tid, costs_tid)
ENABLE QUERY REWRITE AS
SELECT s.time_id, c.time_id
FROM sales s, products p, costs c
WHERE s.prod_id = p.prod_id AND c.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre>
<p>In this example, the defining query of <code class="codeph">sales_mv</code> now matches exactly with the user query <code class="codeph">Q1</code>, so full text match rewrite takes place.</p>
<p>Note that when aliases are specified in both the <code class="codeph">SELECT</code> clause and the new alias list clause, the alias list clause supersedes the ones in the <code class="codeph">SELECT</code> clause.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG00832"></a>
<div class="props_rev_3"><a id="GUID-9C3332BB-53E2-4179-B05C-5C8D1E46EFDF"></a>
<h3 id="DWHSG-GUID-9C3332BB-53E2-4179-B05C-5C8D1E46EFDF" class="sect3">About Materialized Views Names</h3>
<div>
<p><a id="d14086e2326" class="indexterm-anchor"></a>The name of a materialized view must conform to standard Oracle naming conventions. However, if the materialized view is based on a user-defined prebuilt table, then the name of the materialized view must exactly match that table name.</p>
<p>If you already have a naming convention for tables and indexes, you might consider extending this naming scheme to the materialized views so that they are easily identifiable. For example, instead of naming the materialized view <code class="codeph">sum_of_sales</code>, it could be called <code class="codeph">sum_of_sales_mv</code> to denote that this is a materialized view and not a table or view.</p>
</div>
</div>
<a id="DWHSG00833"></a>
<div class="props_rev_3"><a id="GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266"></a>
<h3 id="DWHSG-GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266" class="sect3">About Storage And Table Compression for Materialized Views</h3>
<div>
<p><a id="d14086e2361" class="indexterm-anchor"></a>Unless the materialized view is based on <a id="d14086e2366" class="indexterm-anchor"></a><a id="d14086e2370" class="indexterm-anchor"></a><a id="d14086e2374" class="indexterm-anchor"></a><a id="d14086e2378" class="indexterm-anchor"></a>a user-defined prebuilt table, it requires and occupies storage space inside the database. Therefore, the storage needs for the materialized view should be specified in terms of the tablespace where it is to reside and the size of the extents.</p>
<p>If you do not know how much space the materialized view requires, then the <code class="codeph">DBMS_MVIEW.ESTIMATE_MVIEW_SIZE</code> package can estimate the number of bytes required to store this uncompressed materialized view. This information can then assist the design team in determining the tablespace in which the materialized view should reside.</p>
<p>You should use table compression with highly redundant data, such as tables with many foreign keys. This is particularly useful for materialized views created with the <code class="codeph">ROLLUP</code> clause. Table compression reduces disk use and memory use (specifically, the buffer cache), often leading to a better scaleup for read-only operations. Table compression can also speed up query execution at the expense of update cost.</p>
<div class="infoboxnotealso" id="GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266__GUID-8064D264-5A74-4998-8014-2FA55C22CF2C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink VLDBG004" target="_blank" href="../VLDBG/GUID-FA29787B-8700-49EA-B80D-54D667CF2752.htm#VLDBG004"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about table compression</p>
</li>
<li>
<p><a class="olink ADMIN13948" target="_blank" href="../ADMIN/tables.htm#ADMIN13948"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about table compression</p>
</li>
<li>
<p><a class="olink SQLRF017" target="_blank" href="../SQLRF/statements_10.htm#SQLRF017"><span class="italic">Oracle Database SQL Language Reference</span></a> for a complete description of <code class="codeph">STORAGE</code> semantics</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8192"></a><a id="DWHSG8191"></a>
<div class="props_rev_3"><a id="GUID-43C2E761-7188-43F6-9678-A80098C1D521"></a>
<h3 id="DWHSG-GUID-43C2E761-7188-43F6-9678-A80098C1D521" class="sect3">About Build Methods for Materialized Views</h3>
<div>
<p>Two build methods are available for creating the materialized view, as shown in <a href="basicmv.htm#GUID-43C2E761-7188-43F6-9678-A80098C1D521__G1014320" title="This table describes the build methods supported for materialized views">Table 5-2</a>. If you select <code class="codeph">BUILD IMMEDIATE</code> , the materialized view definition is added to the schema objects in the data dictionary, and then the fact or detail tables are scanned according to the <code class="codeph">SELECT</code> expression and the results are stored in the materialized view. Depending on the size of the tables to be scanned, this build process can take a considerable amount of time.</p>
<p>An alternative approach is to use the <code class="codeph">BUILD DEFERRED</code> clause, which creates the materialized view without data, thereby enabling it to be populated at a later date using the <code class="codeph">DBMS_MVIEW.REFRESH</code> package.</p>
<div class="infoboxnotealso" id="GUID-43C2E761-7188-43F6-9678-A80098C1D521__GUID-5E1CF3BB-027B-4851-BFB2-7B0223F2D0A5">
<p class="notep1">See Also:</p>
<p><a href="refresh.htm#GUID-64068234-BDB0-4C12-AE70-75571046A586">Refreshing Materialized Views</a></p>
</div>
<div class="tblformal" id="GUID-43C2E761-7188-43F6-9678-A80098C1D521__G1014320">
<p class="titleintable">Table 5-2 Build Methods</p>
<table class="cellalignment1516" title="Build Methods" summary="This table describes the build methods supported for materialized views">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1534" id="d14086e2483">Build Method</th>
<th class="cellalignment1540" id="d14086e2486">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1536" id="d14086e2491" headers="d14086e2483">
<p><code class="codeph">BUILD IMMEDIATE</code></p>
</td>
<td class="cellalignment1541" headers="d14086e2491 d14086e2486">
<p>Create the materialized view and then populate it with data.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1536" id="d14086e2500" headers="d14086e2483">
<p><code class="codeph">BUILD DEFERRED</code></p>
</td>
<td class="cellalignment1541" headers="d14086e2500 d14086e2486">
<p>Create the materialized view definition but do not populate it with data.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="DWHSG8193"></a>
<div class="props_rev_3"><a id="GUID-AC92B31A-C6B0-45AE-95A6-B1DE3630EB8A"></a>
<h3 id="DWHSG-GUID-AC92B31A-C6B0-45AE-95A6-B1DE3630EB8A" class="sect3">About Enabling Query Rewrite for Materialized Views</h3>
<div>
<p>Before <a id="d14086e2530" class="indexterm-anchor"></a>creating a materialized view, you can verify what types of query rewrite are possible by calling the procedure <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code>, or use <code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code> to optimize the materialized view so that many types of query rewrite are possible. Once the materialized view has been created, you can use <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> to find out if (or why not) it will rewrite a specific query.</p>
<p>Even though a materialized view is defined, it will not automatically be used by the query rewrite facility. Even though query rewrite is enabled by default, you also must specify the <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> clause if the materialized view is to be considered available for rewriting queries.</p>
<p>If this clause is omitted or specified as <code class="codeph">DISABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> when the materialized view is created, the materialized view can subsequently be enabled for query rewrite with the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement.</p>
<p>If you define a materialized view as <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code>, it is not eligible for query rewrite until it is populated with data through a complete refresh.</p>
</div>
</div>
<a id="DWHSG8194"></a>
<div class="props_rev_3"><a id="GUID-580EF7BC-4C61-4030-B42D-BFF47469C1E6"></a>
<h3 id="DWHSG-GUID-580EF7BC-4C61-4030-B42D-BFF47469C1E6" class="sect3">About Query Rewrite Restrictions</h3>
<div>
<div class="section">
<p><a id="d14086e2607" class="indexterm-anchor"></a><a id="d14086e2611" class="indexterm-anchor"></a><a id="d14086e2617" class="indexterm-anchor"></a><a id="d14086e2623" class="indexterm-anchor"></a>Query rewrite is not possible with all materialized views. If query rewrite is not occurring when expected, <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> can help provide reasons why a specific query is not eligible for rewrite. If this shows that not all types of query rewrite are possible, use the procedure <code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code> to see if the materialized view can be defined differently so that query rewrite is possible. Also, check to see if your materialized view satisfies all of the following conditions:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-6A80266B-444E-4BB6-8A48-911E4619338B">About Materialized View Restrictions for Query Rewrite</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-A5409962-E85D-46DD-B34A-820074CA579C">General Query Rewrite Restrictions</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8195"></a>
<div class="props_rev_3"><a id="GUID-6A80266B-444E-4BB6-8A48-911E4619338B"></a>
<h4 id="DWHSG-GUID-6A80266B-444E-4BB6-8A48-911E4619338B" class="sect4">About Materialized View Restrictions for Query Rewrite</h4>
<div>
<div class="section">
<p>You should keep in mind the following restrictions:</p>
<ul style="list-style-type: disc;">
<li>
<p>The defining query of the materialized view cannot contain any non-repeatable expressions (<code class="codeph">ROWNUM</code>, <code class="codeph">SYSDATE</code>, non-repeatable PL/SQL functions, and so on).</p>
</li>
<li>
<p>The query cannot contain any references to <code class="codeph">LONG</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> data types or object <code class="codeph">REF</code>s.</p>
</li>
<li>
<p>If the materialized view was registered as <code class="codeph">PREBUILT</code>, the precision of the columns must agree with the precision of the corresponding <code class="codeph">SELECT</code> expressions unless overridden by the <code class="codeph">WITH</code> <code class="codeph">REDUCED</code> <code class="codeph">PRECISION</code> clause.</p>
</li>
<li>
<p>The defining query cannot contain any references to objects or <code class="codeph">XMLTYPE</code>s.</p>
</li>
<li>
<p>A materialized view is a noneditioned object and cannot depend on editioned objects unless it mentions an evaluation edition in which names of editioned objects are to be resolved.</p>
</li>
<li>
<p>A materialized view may only be eligible for query rewrite in a specific range of editions. The <span class="italic"><code class="codeph">query_rewrite_clause</code></span> in the <code class="codeph">CREATE</code> or <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement lets you specify the range of editions in which a materialized view is eligible for query rewrite.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-6A80266B-444E-4BB6-8A48-911E4619338B__GUID-322BC2A6-F960-45EF-80BC-5CD0DD7B7C41">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="qradv.htm#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36">Advanced Query Rewrite for Materialized Views</a></p>
</li>
<li>
<p><a class="olink SQLRF54175" target="_blank" href="../SQLRF/statements_6002.htm#SQLRF54175"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8196"></a>
<div class="props_rev_3"><a id="GUID-A5409962-E85D-46DD-B34A-820074CA579C"></a>
<h4 id="DWHSG-GUID-A5409962-E85D-46DD-B34A-820074CA579C" class="sect4">General Query Rewrite Restrictions</h4>
<div>
<div class="section">
<p>You should keep in mind the following restrictions:</p>
<ul style="list-style-type: disc;">
<li>
<p>A query can reference both local and remote tables. Such a query can be rewritten as long as an eligible materialized view referencing the same tables is available locally.</p>
</li>
<li>
<p>Neither the detail tables nor the materialized view can be owned by <code class="codeph">SYS</code>.</p>
</li>
<li>
<p>If a column or expression is present in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of the materialized view, it must also be present in the <code class="codeph">SELECT</code> list.</p>
</li>
<li>
<p>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code class="codeph">AVG(AVG(x))</code> or <code class="codeph">AVG(x)</code>+ <code class="codeph">AVG(x)</code> are not allowed.</p>
</li>
<li>
<p><code class="codeph">CONNECT</code> <code class="codeph">BY</code> clauses are not allowed.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-A5409962-E85D-46DD-B34A-820074CA579C__GUID-1AFBC5C0-2A4A-48AD-A8FB-90BEBE472A2E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="qradv.htm#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36">Advanced Query Rewrite for Materialized Views</a></p>
</li>
<li>
<p><a class="olink SQLRF54175" target="_blank" href="../SQLRF/statements_6002.htm#SQLRF54175"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8197"></a>
<div class="props_rev_3"><a id="GUID-11109A1B-1E8A-4F10-9BB3-DEB4D1AAEC36"></a>
<h3 id="DWHSG-GUID-11109A1B-1E8A-4F10-9BB3-DEB4D1AAEC36" class="sect3">About Refresh Options for Materialized Views</h3>
<div>
<p><a id="d14086e2869" class="indexterm-anchor"></a>When you define a materialized view, you can specify three refresh options: how to refresh, what type of refresh, and can trusted constraints be used. If unspecified, the defaults are assumed as <code class="codeph">ON</code> <code class="codeph">DEMAND</code>, <code class="codeph">FORCE</code>, and <code class="codeph">ENFORCED</code> constraints respectively.</p>
<div class="infoboxnotealso" id="GUID-11109A1B-1E8A-4F10-9BB3-DEB4D1AAEC36__GUID-4C2B1E31-6F24-46C2-A292-FB3ADBEB0CCE">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D">About Refresh Modes for Materialized Views</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5">About Types of Materialized View Refresh</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82">About Using Trusted Constraints and Materialized View Refresh</a></p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8198"></a>
<div class="props_rev_3"><a id="GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D"></a>
<h4 id="DWHSG-GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D" class="sect4">About Refresh Modes for Materialized Views</h4>
<div>
<p>The two refresh execution modes are <code class="codeph">ON</code> <code class="codeph">COMMIT</code> and <code class="codeph">ON</code> <code class="codeph">DEMAND</code>. Depending on the materialized view you create, some options may not be available. The following table describes the refresh modes.</p>
<div class="tblformal" id="GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D__G1014263">
<p class="titleintable">Table 5-3 Refresh Modes</p>
<table class="cellalignment1516" title="Refresh Modes" summary="This table describes the refresh modes supported for materialized views.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1558" id="d14086e2947">Refresh Mode</th>
<th class="cellalignment1559" id="d14086e2950">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e2955" headers="d14086e2947">
<p><code class="codeph">ON COMMIT</code><a id="d14086e2959" class="indexterm-anchor"></a></p>
</td>
<td class="cellalignment1561" headers="d14086e2955 d14086e2950">
<p>Refresh occurs automatically when a transaction that modified one of the materialized view&#39;s detail tables commits. This can be specified as long as the materialized view is fast refreshable (in other words, not complex). The <code class="codeph">ON</code> <code class="codeph">COMMIT</code> privilege is necessary to use this mode.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e2971" headers="d14086e2947">
<p><code class="codeph">ON DEMAND</code><a id="d14086e2975" class="indexterm-anchor"></a></p>
</td>
<td class="cellalignment1561" headers="d14086e2971 d14086e2950">
<p>Refresh occurs when a user manually executes one of the available refresh procedures contained in the <code class="codeph">DBMS_MVIEW</code> package (<code class="codeph">REFRESH</code>, <code class="codeph">REFRESH_ALL_MVIEWS</code>, <code class="codeph">REFRESH_DEPENDENT</code>).</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>When a materialized view is maintained using the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> method, the time required to complete the commit may be slightly longer than usual. This is because the refresh operation is performed as part of the commit process. Therefore, this method may not be suitable if many users are concurrently changing the tables upon which the materialized view is based.</p>
<p>If you anticipate performing insert, update or delete operations on tables referenced by a materialized view concurrently with the refresh of that materialized view, and that materialized view includes joins and aggregation, Oracle recommends you use <code class="codeph">ON</code> <code class="codeph">COMMIT</code> fast refresh rather than <code class="codeph">ON</code> <code class="codeph">DEMAND</code> fast refresh.</p>
<p>If you think the materialized view did not refresh, check the alert log or trace file.</p>
<p>If a materialized view fails during refresh at <code class="codeph">COMMIT</code> time, you must explicitly invoke the refresh procedure using the <code class="codeph">DBMS_MVIEW</code> package after addressing the errors specified in the trace files. Until this is done, the materialized view will no longer be refreshed automatically at commit time.</p>
</div>
</div>
<a id="DWHSG8199"></a>
<div class="props_rev_3"><a id="GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5"></a>
<h4 id="DWHSG-GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5" class="sect4">About Types of Materialized View Refresh</h4>
<div>
<p>You can specify how you want your materialized views to be refreshed from the detail tables by selecting one of four options: <code class="codeph">COMPLETE</code>, <code class="codeph">FAST</code>, <code class="codeph">FORCE</code>, and <code class="codeph">NEVER</code>. <a href="basicmv.htm#GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5__G1014333" title="This table describes the refresh options supported for materialized views.">Table 5-4</a> describes the refresh options.</p>
<div class="tblformal" id="GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5__G1014333">
<p class="titleintable">Table 5-4 Refresh Options</p>
<table class="cellalignment1516" title="Refresh Options" summary="This table describes the refresh options supported for materialized views.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1558" id="d14086e3079">Refresh Option</th>
<th class="cellalignment1559" id="d14086e3082">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e3087" headers="d14086e3079">
<p><code class="codeph">COMPLETE</code></p>
</td>
<td class="cellalignment1561" headers="d14086e3087 d14086e3082">
<p>Refreshes by recalculating the materialized view&#39;s defining query.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e3095" headers="d14086e3079">
<p><code class="codeph">FAST</code></p>
</td>
<td class="cellalignment1561" headers="d14086e3095 d14086e3082">
<p>Applies incremental changes to refresh the materialized view using the information logged in the materialized view logs, or from a SQL*Loader direct-path or a partition maintenance operation.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e3103" headers="d14086e3079">
<p><code class="codeph">FORCE</code></p>
</td>
<td class="cellalignment1561" headers="d14086e3103 d14086e3082">
<p>Applies <code class="codeph">FAST</code> refresh if possible; otherwise, it applies <code class="codeph">COMPLETE</code> refresh.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e3117" headers="d14086e3079">
<p><code class="codeph">NEVER</code></p>
</td>
<td class="cellalignment1561" headers="d14086e3117 d14086e3082">
<p>Indicates that the materialized view will not be refreshed with refresh mechanisms.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Whether the fast refresh option is available depends upon the type of materialized view. You can call the procedure <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code> to determine whether fast refresh is possible.</p>
<div class="infoboxnotealso" id="GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5__GUID-14A67537-1080-4C89-8157-AF18DB0CC061">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-505C24CF-5D56-4820-88AA-2221410950E7">General Restrictions on Fast Refresh</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1">Restrictions on Fast Refresh on Materialized Views with Joins Only</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024">Restrictions on Fast Refresh on Materialized Views with Aggregates</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6">Restrictions on Fast Refresh on Materialized Views with UNION ALL</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-00879D7D-D517-463F-9052-2FD8F9CE9EAD">About Achieving Refresh Goals</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B">Refreshing Nested Materialized Views</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8200"></a>
<div class="props_rev_3"><a id="GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82"></a>
<h4 id="DWHSG-GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82" class="sect4">About Using Trusted Constraints and Materialized View Refresh</h4>
<div>
<p>You can also specify if it is acceptable to use trusted constraints and <code class="codeph">QUERY_REWRITE_INTEGRITY = TRUSTED</code> during refresh. Any nonvalidated <code class="codeph">RELY</code> constraint is a trusted constraint. For example, nonvalidated foreign key/primary key relationships, functional dependencies defined in dimensions or a materialized view in the <code class="codeph">UNKNOWN</code> state. If query rewrite is enabled during refresh, these can improve the performance of refresh by enabling more performant query rewrites. Any materialized view that can use <code class="codeph">TRUSTED</code> constraints for refresh is left in a state of trusted freshness (the <code class="codeph">UNKNOWN</code> state) after refresh.</p>
<p>This is reflected in the column <code class="codeph">STALENESS</code> in the view <code class="codeph">USER_MVIEWS</code>. The column <code class="codeph">UNKNOWN_TRUSTED_FD</code> in the same view is also set to <code class="codeph">Y</code>, which means yes.</p>
<p>You can define this property of the materialized view either during create time by specifying <code class="codeph">REFRESH USING TRUSTED [ENFORCED] CONSTRAINTS</code> or by using <code class="codeph">ALTER MATERIALIZED VIEW</code> DDL.</p>
<div class="tblformal" id="GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82__GUID-5B66D2E9-33C3-44FF-A0AD-9821B1A82354">
<p class="titleintable">Table 5-5 Constraints</p>
<table class="cellalignment1516" title="Constraints" summary="This table describes the options for using constraints with materialized views.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1558" id="d14086e3225">Constraints to Use</th>
<th class="cellalignment1559" id="d14086e3228">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e3233" headers="d14086e3225">
<pre dir="ltr">TRUSTED CONSTRAINTS
</pre></td>
<td class="cellalignment1561" headers="d14086e3233 d14086e3228">
<p>Refresh can use trusted constraints and <code class="codeph">QUERY_REWRITE_INTEGRITY</code> <code class="codeph">= TRUSTED</code> during refresh.This allows use of non-validated <code class="codeph">RELY</code> constraints and rewrite against materialized views in <code class="codeph">UNKNOWN</code> or <code class="codeph">FRESH</code> state during refresh.</p>
<p>The <code class="codeph">USING TRUSTED CONSTRAINTS</code> clause enables you to create a materialized view on top of a table that has a non-NULL Virtual Private Database (VPD) policy on it. In this case, ensure that the materialized view behaves correctly. Materialized view results are computed based on the rows and columns filtered by VPD policy. Therefore, you must coordinate the materialized view definition with the VPD policy to ensure the correct results. Without the <code class="codeph">USING TRUSTED CONSTRAINTS</code> clause, any VPD policy on a base table will prevent a materialized view from being created.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d14086e3263" headers="d14086e3225">
<pre dir="ltr">ENFORCED CONSTRAINTS
</pre></td>
<td class="cellalignment1561" headers="d14086e3263 d14086e3228">
<p>Refresh can use validated constraints and <code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code> during refresh. This allows use of only validated, enforced constraints and rewrite against materialized views in <code class="codeph">FRESH</code> state during refresh.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The fast refresh of a materialized view is optimized using the available primary and foreign key constraints on the join columns. This foreign key/primary key optimization can significantly improve refresh performance. For example, for a materialized view that contains a join between a fact table and a dimension table, if only new rows were inserted into the dimension table with no change to the fact table since the last refresh, then there will be nothing to refresh for this materialized view. The reason is that, because of the primary key constraint on the join column(s) of the dimension table and foreign key constraint on the join column(s) of the fact table, the new rows inserted into the dimension table will not join with any fact table rows, thus there is nothing to refresh. Another example of this refresh optimization is when both the fact and dimension tables have inserts since the last refresh. In this case, Oracle Database will only perform a join of delta fact table with the dimension table. Without the foreign key/primary key optimization, two joins during the refresh would be required, a join of delta fact with the dimension table, plus a join of delta dimension with an image of the fact table from before the inserts.</p>
<p>Note that this optimized fast refresh using primary and foreign key constraints on the join columns is available with and without constraint enforcement. In the first case, primary and foreign key constraints are enforced by the Oracle Database. This, however, incurs the cost of constraint maintenance. In the second case, the application guarantees primary and foreign key relationships so the constraints are declared <code class="codeph">RELY NOVALIDATE</code> and the materialized view is defined with the <code class="codeph">REFRESH FAST USING TRUSTED CONSTRAINTS</code> option.</p>
</div>
</div>
<a id="DWHSG8201"></a>
<div class="props_rev_3"><a id="GUID-505C24CF-5D56-4820-88AA-2221410950E7"></a>
<h4 id="DWHSG-GUID-505C24CF-5D56-4820-88AA-2221410950E7" class="sect4">General Restrictions on Fast Refresh</h4>
<div>
<div class="section">
<p>The defining query of the materialized view is restricted as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>The materialized view must not contain references to non-repeating expressions like <code class="codeph">SYSDATE</code> and <code class="codeph">ROWNUM</code>.</p>
</li>
<li>
<p>The materialized view must not contain references to <code class="codeph">RAW</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> data types.</p>
</li>
<li>
<p>It cannot contain a <code class="codeph">SELECT</code> list subquery.</p>
</li>
<li>
<p>It cannot contain analytic functions (for example, <code class="codeph">RANK</code>) in the <code class="codeph">SELECT</code> clause.</p>
</li>
<li>
<p>It cannot reference a table on which an <code class="codeph">XMLIndex</code> index is defined.</p>
</li>
<li>
<p>It cannot contain a <code class="codeph">MODEL</code> clause.</p>
</li>
<li>
<p>It cannot contain a <code class="codeph">HAVING</code> clause with a subquery.</p>
</li>
<li>
<p>It cannot contain nested queries that have <code class="codeph">ANY</code>, <code class="codeph">ALL</code>, or <code class="codeph">NOT</code> <code class="codeph">EXISTS</code>.</p>
</li>
<li>
<p>It cannot contain a <code class="codeph">[START WITH &hellip;] CONNECT BY</code> clause.</p>
</li>
<li>
<p>It cannot contain multiple detail tables at different sites.</p>
</li>
<li>
<p><code class="codeph">ON</code> <code class="codeph">COMMIT</code> materialized views cannot have remote detail tables.</p>
</li>
<li>
<p>Nested materialized views must have a join or aggregate.</p>
</li>
<li>
<p>Materialized join views and materialized aggregate views with a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause cannot select from an index-organized table.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8202"></a>
<div class="props_rev_3"><a id="GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1"></a>
<h4 id="DWHSG-GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1" class="sect4">Restrictions on Fast Refresh on Materialized Views with Joins Only</h4>
<div>
<div class="section">
<p>Defining queries for materialized views with joins only and no aggregates have the following restrictions on fast refresh:</p>
<ul style="list-style-type: disc;">
<li>
<p>All restrictions from <span class="q">&#34;<a href="basicmv.htm#GUID-505C24CF-5D56-4820-88AA-2221410950E7">General Restrictions on Fast Refresh</a>&#34;</span>.</p>
</li>
<li>
<p>They cannot have <code class="codeph">GROUP</code> <code class="codeph">BY</code> clauses or aggregates.</p>
</li>
<li>
<p>Rowids of all the tables in the <code class="codeph">FROM</code> list must appear in the <code class="codeph">SELECT</code> list of the query.</p>
</li>
<li>
<p>Materialized view logs must exist with rowids for all the base tables in the <code class="codeph">FROM</code> list of the query.</p>
</li>
<li>
<p>You cannot create a fast refreshable materialized view from multiple tables with simple joins that include an object type column in the <code class="codeph">SELECT</code> statement.</p>
</li>
</ul>
<p>Also, the refresh method you choose will not be optimally efficient if:</p>
<ul style="list-style-type: disc;">
<li>
<p>The defining query uses an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join.</p>
</li>
<li>
<p>The <code class="codeph">SELECT</code> list of the materialized view contains expressions on columns from multiple tables.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8203"></a>
<div class="props_rev_3"><a id="GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024"></a>
<h4 id="DWHSG-GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024" class="sect4">Restrictions on Fast Refresh on Materialized Views with Aggregates</h4>
<div>
<div class="section">
<p>Defining queries for materialized views with aggregates or joins have the following restrictions on fast refresh:</p>
<ul style="list-style-type: disc;">
<li>
<p>All restrictions from <span class="q">&#34;<a href="basicmv.htm#GUID-505C24CF-5D56-4820-88AA-2221410950E7">General Restrictions on Fast Refresh</a>&#34;</span>.</p>
</li>
</ul>
<p>Fast refresh is supported for both <code class="codeph">ON</code> <code class="codeph">COMMIT</code> and <code class="codeph">ON</code> <code class="codeph">DEMAND</code> materialized views, however the following restrictions apply:</p>
<ul style="list-style-type: disc;">
<li>
<p>All tables in the materialized view must have materialized view logs, and the materialized view logs must:</p>
<ul style="list-style-type: disc;">
<li>
<p>Contain all columns from the table referenced in the materialized view.</p>
</li>
<li>
<p>Specify with <code class="codeph">ROWID</code> and <code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code>.</p>
</li>
<li>
<p>Specify the <code class="codeph">SEQUENCE</code> clause if the table is expected to have a mix of inserts/direct-loads, deletes, and updates.</p>
</li>
</ul>
</li>
<li>
<p>Only <code class="codeph">SUM</code>, <code class="codeph">COUNT</code>, <code class="codeph">AVG</code>, <code class="codeph">STDDEV</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">MIN</code> and <code class="codeph">MAX</code> are supported for fast refresh.</p>
</li>
<li>
<p><code class="codeph">COUNT(*)</code> must be specified.</p>
</li>
<li>
<p>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code class="codeph">AVG(AVG(x))</code> or <code class="codeph">AVG(x)</code>+ <code class="codeph">AVG(x)</code> are not allowed.</p>
</li>
<li>
<p>For each aggregate such as <code class="codeph">AVG(expr)</code>, the corresponding <code class="codeph">COUNT(expr)</code> must be present. Oracle recommends that <code class="codeph">SUM(expr)</code> be specified. See <a href="basicmv.htm#GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE">Requirements for Using Materialized Views with Aggregates</a> for further details.</p>
</li>
<li>
<p>If <code class="codeph">VARIANCE(expr)</code> or <code class="codeph">STDDEV(expr</code>) is specified, <code class="codeph">COUNT(expr)</code> and <code class="codeph">SUM(expr)</code> must be specified. Oracle recommends that <code class="codeph">SUM(expr *expr)</code> be specified. See <a href="basicmv.htm#GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE">Requirements for Using Materialized Views with Aggregates</a> for further details.</p>
</li>
<li>
<p>The <code class="codeph">SELECT</code> column in the defining query cannot be a complex expression with columns from multiple base tables. A possible workaround to this is to use a nested materialized view.</p>
</li>
<li>
<p>The <code class="codeph">SELECT</code> list must contain all <code class="codeph">GROUP</code> <code class="codeph">BY</code> columns.</p>
</li>
<li>
<p>The materialized view is not based on one or more remote tables.</p>
</li>
<li>
<p>If you use a <code class="codeph">CHAR</code> data type in the filter columns of a materialized view log, the character sets of the master site and the materialized view must be the same.</p>
</li>
<li>
<p>If the materialized view has one of the following, then fast refresh is supported only on conventional DML inserts and direct loads.</p>
<ul style="list-style-type: disc;">
<li>
<p>Materialized views with <code class="codeph">MIN</code> or <code class="codeph">MAX</code> aggregates</p>
</li>
<li>
<p>Materialized views which have <code class="codeph">SUM(expr)</code> but no <code class="codeph">COUNT(expr)</code></p>
</li>
<li>
<p>Materialized views without <code class="codeph">COUNT(*)</code></p>
</li>
</ul>
<p>Such a materialized view is called an insert-only materialized view.</p>
</li>
<li>
<p>A materialized view with <code class="codeph">MAX</code> or <code class="codeph">MIN</code> is fast refreshable after delete or mixed DML statements if it does not have a <code class="codeph">WHERE</code> clause.</p>
<p>The max/min fast refresh after delete or mixed DML does not have the same behavior as the insert-only case. It deletes and recomputes the max/min values for the affected groups. You need to be aware of its performance impact.</p>
</li>
<li>
<p>Materialized views with named views or subqueries in the <code class="codeph">FROM</code> clause can be fast refreshed provided the views can be completely merged. For information on which views will merge, see <a class="olink TGSQL591" target="_blank" href="../TGSQL/tgsql_sqlaccess.htm#TGSQL591"><span class="italic">Oracle Database SQL Tuning Guide</span></a>.</p>
</li>
<li>
<p>If there are no outer joins, you may have arbitrary selections and joins in the <code class="codeph">WHERE</code> clause.</p>
</li>
<li>
<p>Materialized aggregate views with outer joins are fast refreshable after conventional DML and direct loads, provided only the outer table has been modified. Also, unique constraints must exist on the join columns of the inner join table. If there are outer joins, all the joins must be connected by <code class="codeph">AND</code>s and must use the equality (<code class="codeph">=</code>) operator.</p>
</li>
<li>
<p>For materialized views with <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, grouping sets, or concatenation of them, the following restrictions apply:</p>
<ul style="list-style-type: disc;">
<li>
<p>The <code class="codeph">SELECT</code> list should contain grouping distinguisher that can either be a <code class="codeph">GROUPING_ID</code> function on all <code class="codeph">GROUP</code> <code class="codeph">BY</code> expressions or <code class="codeph">GROUPING</code> functions one for each <code class="codeph">GROUP</code> <code class="codeph">BY</code> expression. For example, if the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of the materialized view is &#34;<code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">CUBE(a, b)</code>&#34;, then the <code class="codeph">SELECT</code> list should contain either &#34;<code class="codeph">GROUPING_ID(a, b)</code>&#34; or &#34;<code class="codeph">GROUPING(a)</code> <code class="codeph">AND</code> <code class="codeph">GROUPING(b)</code>&#34; for the materialized view to be fast refreshable.</p>
</li>
<li>
<p><code class="codeph">GROUP</code> <code class="codeph">BY</code> should not result in any duplicate groupings. For example, &#34;<code class="codeph">GROUP BY a, ROLLUP(a, b)</code>&#34; is not fast refreshable because it results in duplicate groupings &#34;<code class="codeph">(a), (a, b), AND (a)</code>&#34;.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8204"></a>
<div class="props_rev_3"><a id="GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6"></a>
<h4 id="DWHSG-GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6" class="sect4">Restrictions on Fast Refresh on Materialized Views with UNION ALL</h4>
<div>
<div class="section">
<p>Materialized views with the <code class="codeph">UNION</code> <code class="codeph">ALL</code> set operator support the <code class="codeph">REFRESH</code> <code class="codeph">FAST</code> option if the following conditions are satisfied:</p>
<ul style="list-style-type: disc;">
<li>
<p>The defining query must have the <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator at the top level.</p>
<p>The <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator cannot be embedded inside a subquery, with one exception: The <code class="codeph">UNION</code> <code class="codeph">ALL</code> can be in a subquery in the <code class="codeph">FROM</code> clause provided the defining query is of the form <code class="codeph">SELECT * FROM</code> (view or subquery with <code class="codeph">UNION</code> <code class="codeph">ALL</code>) as in the following example:</p>
<pre dir="ltr">CREATE VIEW view_with_unionall AS
(SELECT c.rowid crid, c.cust_id, 2 umarker
 FROM customers c WHERE c.cust_last_name = &#39;Smith&#39;
 UNION ALL
 SELECT c.rowid crid, c.cust_id, 3 umarker
 FROM customers c WHERE c.cust_last_name = &#39;Jones&#39;);

CREATE MATERIALIZED VIEW unionall_inside_view_mv
REFRESH FAST ON DEMAND AS
SELECT * FROM view_with_unionall;
</pre>
<p>Note that the view <code class="codeph">view_with_unionall</code> satisfies the requirements for fast refresh.</p>
</li>
<li>
<p>Each query block in the <code class="codeph">UNION</code> <code class="codeph">ALL</code> query must satisfy the requirements of a fast refreshable materialized view with aggregates or a fast refreshable materialized view with joins.</p>
<p>The appropriate materialized view logs must be created on the tables as required for the corresponding type of fast refreshable materialized view.</p>
<p>Note that the Oracle Database also allows the special case of a single table materialized view with joins only provided the <code class="codeph">ROWID</code> column has been included in the <code class="codeph">SELECT</code> list and in the materialized view log. This is shown in the defining query of the view <code class="codeph">view_with_unionall</code>.</p>
</li>
<li>
<p>The <code class="codeph">SELECT</code> list of each query must include a <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker, and the <code class="codeph">UNION</code> <code class="codeph">ALL</code> column must have a distinct constant numeric or string value in each <code class="codeph">UNION</code> <code class="codeph">ALL</code> branch. Further, the marker column must appear in the same ordinal position in the <code class="codeph">SELECT</code> list of each query block. See <span class="q">&#34;<a href="qradv.htm#GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6">UNION ALL Marker and Query Rewrite</a>&#34;</span> for more information regarding <code class="codeph">UNION</code> <code class="codeph">ALL</code> markers.</p>
</li>
<li>
<p>Some features such as outer joins, insert-only aggregate materialized view queries and remote tables are not supported for materialized views with <code class="codeph">UNION</code> <code class="codeph">ALL</code>. Note, however, that materialized views used in replication, which do not contain joins or aggregates, can be fast refreshed when <code class="codeph">UNION</code> <code class="codeph">ALL</code> or remote tables are used.</p>
</li>
<li>
<p>The compatibility initialization parameter must be set to 9.2.0 or higher to create a fast refreshable materialized view with <code class="codeph">UNION</code> <code class="codeph">ALL</code>.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8205"></a>
<div class="props_rev_3"><a id="GUID-00879D7D-D517-463F-9052-2FD8F9CE9EAD"></a>
<h4 id="DWHSG-GUID-00879D7D-D517-463F-9052-2FD8F9CE9EAD" class="sect4">About Achieving Refresh Goals</h4>
<div>
<p>In addition to the <code class="codeph">EXPLAIN_MVIEW</code> procedure, which is discussed throughout this chapter, you can use the <code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code> procedure to optimize a <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement to achieve <code class="codeph">REFRESH</code> <code class="codeph">FAST</code> and <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> goals.</p>
<p>See <a href="basicmv.htm#GUID-FE444279-E7A0-4BF4-B4CA-0F54CB0ACA52">Refreshing Materialized Views on Prebuilt Tables</a>.</p>
</div>
<a id="DWHSG9298"></a>
<div class="props_rev_3"><a id="GUID-FE444279-E7A0-4BF4-B4CA-0F54CB0ACA52"></a>
<h5 id="DWHSG-GUID-FE444279-E7A0-4BF4-B4CA-0F54CB0ACA52" class="sect5">Refreshing Materialized Views on Prebuilt Tables</h5>
<div>
<div class="section">
<p>For materialized views created with the prebuilt option, the index <code class="codeph">I_snap$</code> is not created by default. This index helps fast refresh performance, and a description of how to create this index is illustrated in <span class="q">&#34;<a href="basicmv.htm#GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83">Choosing Indexes for Materialized Views</a>&#34;</span>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8207"></a><a id="DWHSG8206"></a>
<div class="props_rev_3"><a id="GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B"></a>
<h4 id="DWHSG-GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B" class="sect4">Refreshing Nested Materialized Views</h4>
<div>
<div class="section">
<p>A nested materialized view is considered to be fresh as long as its data is synchronized with the data in its detail tables, even if some of its detail tables could be stale materialized views.</p>
<p>You can refresh nested materialized views in two ways: <code class="codeph">DBMS_MVIEW.REFRESH</code> with the <code class="codeph">nested</code> flag set to <code class="codeph">TRUE</code> and <code class="codeph">REFRESH_DEPENDENT</code> with the <code class="codeph">nested</code> flag set to <code class="codeph">TRUE</code> on the base tables. If you use <code class="codeph">DBMS_MVIEW.REFRESH</code>, the entire materialized view chain is refreshed and the coverage starting from the specified materialized view in top-down fashion. That is, the specified materialized view and all its child materialized views in the dependency hierarchy are refreshed in order. With <code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT</code>, the entire chain is refreshed from the bottom up. That is, all the parent materialized views in the dependency hierarchy starting from the specified table are refreshed in order.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B__GUID-1A319C2D-FBF7-4C68-879F-4EF313462D7A">
<p class="titleinexample">Example 5-7 Example of Refreshing a Nested Materialized View</p>
<p>The following statement shows an example of refreshing a nested materialized view:</p>
<pre dir="ltr">DBMS_MVIEW.REFRESH(&#39;SALES_MV,COST_MV&#39;, nested =&gt; TRUE);
</pre>
<p>This statement will first refresh all child materialized views of <code class="codeph">sales_mv</code> and <code class="codeph">cost_mv</code> based on the dependency analysis and then refresh the two specified materialized views.</p>
<p>You can query the <code class="codeph">STALE_SINCE</code> column in the <code class="codeph">*_MVIEWS</code> views to find out when a materialized view became stale.</p>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8208"></a>
<div class="props_rev_3"><a id="GUID-CBE901D0-B358-4007-8B87-F18966F9A72E"></a>
<h3 id="DWHSG-GUID-CBE901D0-B358-4007-8B87-F18966F9A72E" class="sect3">ORDER BY Clause in Materialized Views</h3>
<div>
<p><a id="d14086e4173" class="indexterm-anchor"></a>An <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause is allowed in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. It is used only during the initial creation of the materialized view. It is not used during a full refresh or a fast refresh.</p>
<p>To improve the performance of queries against large materialized views, store the rows in the materialized view in the order specified in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause. This initial ordering provides physical clustering of the data. If indexes are built on the columns by which the materialized view is ordered, accessing the rows of the materialized view using the index often reduces the time for disk I/O due to the physical clustering.</p>
<p>The <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause is not considered part of the materialized view definition. As a result, there is no difference in the manner in which Oracle Database detects the various types of materialized views (for example, materialized join views with no aggregates). For the same reason, query rewrite is not affected by the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause. This feature is similar to the <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> ... <code class="codeph">ORDER</code> <code class="codeph">BY</code> capability.</p>
</div>
</div>
<a id="DWHSG8212"></a>
<div class="props_rev_3"><a id="GUID-EC2E9E41-9C37-44D5-BCE5-568BD5F6E792"></a>
<h3 id="DWHSG-GUID-EC2E9E41-9C37-44D5-BCE5-568BD5F6E792" class="sect3">Using Oracle Enterprise Manager to Create Materialized Views</h3>
<div>
<p>A materialized view can also be created using Enterprise Manager by selecting the materialized view object type. There is no difference in the information required if this approach is used.</p>
</div>
</div>
<a id="DWHSG8213"></a>
<div class="props_rev_3"><a id="GUID-4845AEBC-1AA9-4CD8-AE91-2E4379291FDE"></a>
<h3 id="DWHSG-GUID-4845AEBC-1AA9-4CD8-AE91-2E4379291FDE" class="sect3">Using Materialized Views with NLS Parameters</h3>
<div>
<p>When using certain materialized views, you must ensure that your NLS parameters are the same as when you created the materialized view. Materialized views with this restriction are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>Expressions that may return different values, depending on NLS parameter settings. For example, (<code class="codeph">date &gt; &#34;01/02/03&#34;</code>) or (<code class="codeph">rate &lt;= &#34;2.150&#34;</code>) are NLS parameter dependent expressions.</p>
</li>
<li>
<p>Equijoins where one side of the join is character data. The result of this equijoin depends on collation and this can change on a session basis, giving an incorrect result in the case of query rewrite or an inconsistent materialized view after a refresh operation.</p>
</li>
<li>
<p>Expressions that generate internal conversion to character data in the <code class="codeph">SELECT</code> list of a materialized view, or inside an aggregate of a materialized aggregate view. This restriction does not apply to expressions that involve only numeric data, for example, <code class="codeph">a+b</code> where <code class="codeph">a</code> and <code class="codeph">b</code> are numeric fields.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG9299"></a><a id="DWHSG8214"></a>
<div class="props_rev_3"><a id="GUID-99476E65-CC39-49CF-A619-C4D947662040"></a>
<h3 id="DWHSG-GUID-99476E65-CC39-49CF-A619-C4D947662040" class="sect3">Adding Comments to Materialized Views</h3>
<div>
<div class="section">
<p>You can add comments to materialized views.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Example: Adding Comments to a Materialized View</p>
</div>
<!-- class="section" -->
<div class="section">
<p>The following statement adds a comment to data dictionary views for an existing materialized view:</p>
<pre dir="ltr">COMMENT ON MATERIALIZED VIEW sales_mv IS &#39;sales materialized view&#39;;
</pre>
<p>To view the comment after the preceding statement execution, you can query the catalog views, <code class="codeph">{USER</code>, <code class="codeph">DBA}</code> <code class="codeph">ALL_MVIEW_COMMENTS</code>. For example, consider the following example:</p>
<pre dir="ltr">SELECT MVIEW_NAME, COMMENTS
FROM USER_MVIEW_COMMENTS WHERE MVIEW_NAME = &#39;SALES_MV&#39;;
</pre>
<p>The output will resemble the following:</p>
<pre dir="ltr">MVIEW_NAME                      COMMENTS
-----------      -----------------------
SALES_MV         sales materialized view
</pre>
<p>Note: If the compatibility is set to 10.0.1 or higher, <code class="codeph">COMMENT</code> <code class="codeph">ON</code> <code class="codeph">TABLE</code> will not be allowed for the materialized view container table. The following error message will be thrown if it is issued.</p>
<pre dir="ltr">ORA-12098: cannot comment on the materialized view.
</pre>
<p>In the case of a prebuilt table, if it has an existing comment, the comment will be inherited by the materialized view after it has been created. The existing comment will be prefixed with <code class="codeph">&#39;(from table)&#39;</code>. For example, table <code class="codeph">sales_summary</code> was created to contain sales summary information. An existing comment <code class="codeph">&#39;Sales summary data&#39;</code> was associated with the table. A materialized view of the same name is created to use the prebuilt table as its container table. After the materialized view creation, the comment becomes <code class="codeph">&#39;(from table) Sales summary data&#39;</code>.</p>
<p>However, if the prebuilt table, <code class="codeph">sales_summary</code>, does not have any comment, the following comment is added: <code class="codeph">&#39;Sales summary data&#39;</code>. Then, if you drop the materialized view, the comment will be passed to the prebuilt table with the comment: <code class="codeph">&#39;(from materialized view) Sales summary data&#39;</code>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG9300"></a>
<div class="props_rev_3"><a id="GUID-4BCA1300-C03E-4C24-AD19-50EB9BBA8806"></a>
<h2 id="DWHSG-GUID-4BCA1300-C03E-4C24-AD19-50EB9BBA8806" class="sect2">Creating Materialized View Logs</h2>
<div>
<div class="section">
<p>Materialized view<a id="d14086e4409" class="indexterm-anchor"></a><a id="d14086e4411" class="indexterm-anchor"></a> logs are required if you want to use fast refresh, with the exception of partition change tracking refresh. That is, if a detail table supports partition change tracking for a materialized view, the materialized view log on that detail table is not required in order to do fast refresh on that materialized view. As a general rule, though, you should create materialized view logs if you want to use fast refresh. Materialized view logs are defined using a <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code> statement on the base table that is to be changed. They are not created on the materialized view unless there is another materialized view on top of that materialized view, which is the case with nested materialized views. For fast refresh of materialized views, the definition of the materialized view logs must normally specify the <code class="codeph">ROWID</code> clause. In addition, for aggregate materialized views, it must also contain every column in the table referenced in the materialized view, the <code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code> clause and the <code class="codeph">SEQUENCE</code> clause. You can typically achieve better fast refresh performance of local materialized views containing aggregates or joins by using a <code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code> clause.</p>
<p>An example of a materialized view log is shown as follows where one is created on the table <code class="codeph">sales</code>:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;
</pre>
<p>Alternatively, you could create a commit SCN-based materialized view log as follows:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold),
COMMIT SCN INCLUDING NEW VALUES;
</pre>
<p>Oracle recommends that the keyword <code class="codeph">SEQUENCE</code> be included in your materialized view log statement unless you are sure that you will never perform a mixed DML operation (a combination of <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> operations on multiple tables). The <code class="codeph">SEQUENCE</code> column is required in the materialized view log to support fast refresh with a combination of <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> statements on multiple tables. You can, however, add the <code class="codeph">SEQUENCE</code> number to the materialized view log after it has been created.</p>
<p>The boundary of a mixed DML operation is determined by whether the materialized view is <code class="codeph">ON</code> <code class="codeph">COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code>.</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>For <code class="codeph">ON</code> <code class="codeph">COMMIT</code>, the mixed DML statements occur within the same transaction because the refresh of the materialized view will occur upon commit of this transaction.</p>
</li>
<li>
<p>For <code class="codeph">ON</code> <code class="codeph">DEMAND</code>, the mixed DML statements occur between refreshes. The following example of a materialized view log illustrates where one is created on the table <code class="codeph">sales</code> that includes the <code class="codeph">SEQUENCE</code> keyword:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, 
 quantity_sold, amount_sold) INCLUDING NEW VALUES;
</pre></li>
</ul>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-03F7FB6A-A806-4F8F-A3E8-5C4D7F06E916">Using the FORCE Option With Materialized View Logs</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED">Purging Materialized View Logs</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG9301"></a>
<div class="props_rev_3"><a id="GUID-03F7FB6A-A806-4F8F-A3E8-5C4D7F06E916"></a>
<h3 id="DWHSG-GUID-03F7FB6A-A806-4F8F-A3E8-5C4D7F06E916" class="sect3">Using the FORCE Option With Materialized View Logs</h3>
<div>
<p>If you specify <code class="codeph">FORCE</code> and any items specified with the <code class="codeph">ADD</code> clause have already been specified for the materialized view log, Oracle does not return an error, but silently ignores the existing elements and adds to the materialized view log any items that do not already exist in the log. For example, if you used a filter column such as <code class="codeph">cust_id</code> and this column already existed, Oracle Database ignores the redundancy and does not return an error.</p>
</div>
</div>
<a id="DWHSG9302"></a>
<div class="props_rev_3"><a id="GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED"></a>
<h3 id="DWHSG-GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED" class="sect3">Purging Materialized View Logs</h3>
<div>
<div class="section">
<p>Purging materialized view logs can be done during the materialized view refresh process or deferred until later, thus improving refresh performance time. You can choose different options for when the purge will occur, using a <code class="codeph">PURGE</code> clause, as in the following:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales
PURGE START WITH sysdate NEXT sysdate+1
WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;
</pre>
<p>You can also query <code class="codeph">USER_MVIEW_LOGS</code> for purge information, as in the following:</p>
<pre dir="ltr">SELECT PURGE_DEFERRED, PURGE_INTERVAL, LAST_PURGE_DATE, LAST_PURGE_STATUS
FROM USER_MVIEW_LOGS
WHERE LOG_OWNER &#34;SH&#34; AND MASTER = &#39;SALES&#39;;
</pre>
<p>In addition to setting the purge when creating a materialized view log, you can also modify an existing materialized view log by issuing a statement resembling the following:</p>
<pre dir="ltr">ALTER MATERIALIZED VIEW LOG ON sales PURGE IMMEDIATE;
</pre>
<div class="infoboxnotealso" id="GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED__GUID-94DD02CD-2936-4AE5-A37F-81F872699936">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF01303" target="_blank" href="../SQLRF/statements_6003.htm#SQLRF01303"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information regarding materialized view log syntax</p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8215"></a>
<div class="props_rev_3"><a id="GUID-4DE39B8B-8452-4581-A841-6AF77019986D"></a>
<h2 id="DWHSG-GUID-4DE39B8B-8452-4581-A841-6AF77019986D" class="sect2">Registering Existing Materialized Views</h2>
<div>
<div class="section">
<p><a id="d14086e4649" class="indexterm-anchor"></a>Some data warehouses have implemented materialized views in ordinary user tables. Although this solution provides the performance benefits of materialized views, it does not:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Provide query rewrite to all SQL applications.</p>
</li>
<li>
<p>Enable materialized views defined in one application to be transparently accessed in another application.</p>
</li>
<li>
<p>Generally support fast parallel or fast materialized view refresh.</p>
</li>
</ul>
<p>Because of these limitations, and because existing materialized views can be extremely large and expensive to rebuild, you should register your existing materialized view tables whenever possible. You can register a user-defined materialized view with the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ... <code class="codeph">ON</code> <code class="codeph">PREBUILT</code> <code class="codeph">TABLE</code> statement. Once registered, the materialized view can be used for query rewrites or maintained by one of the refresh methods, or both.</p>
<p>The contents of the table must reflect the materialization of the defining query at the time you register it as a materialized view, and each column in the defining query must correspond to a column in the table that has a matching data type. However, you can specify <code class="codeph">WITH</code> <code class="codeph">REDUCED</code> <code class="codeph">PRECISION</code> to allow the precision of columns in the defining query to be different from that of the table columns.</p>
<p>The table and the materialized view must have the same name, but the table retains its identity as a table and can contain columns that are not referenced in the defining query of the materialized view. These extra columns are known as unmanaged columns. If rows are inserted during a refresh operation, each unmanaged column of the row is set to its default value. Therefore, the unmanaged columns cannot have <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints unless they also have default values.</p>
<p>Materialized views based on prebuilt tables are eligible for selection by query rewrite provided the parameter <code class="codeph">QUERY_REWRITE_INTEGRITY</code> is set to <code class="codeph">STALE_TOLERATED</code> or <code class="codeph">TRUSTED</code>.</p>
<div class="infoboxnotealso" id="GUID-4DE39B8B-8452-4581-A841-6AF77019986D__GUID-C92605F2-CB73-4E1E-9E08-4FBAA9AEC4D0">
<p class="notep1">See Also:</p>
<p><a href="qrbasic.htm#GUID-DB76286B-8557-446B-A6CC-BC987C378076">Basic Query Rewrite for Materialized Views</a> for details about integrity levels</p>
</div>
<p><a id="d14086e4723" class="indexterm-anchor"></a><a id="d14086e4727" class="indexterm-anchor"></a>When you drop a materialized view that was created on a prebuilt table, the table still exists&mdash;only the materialized view is dropped.</p>
<p>The following example illustrates the two steps required to register a user-defined table. First, the table is created, then the materialized view is defined using exactly the same name as the table. This materialized view <code class="codeph">sum_sales_tab_mv</code> is eligible for use in query rewrite.</p>
<pre dir="ltr">CREATE TABLE sum_sales_tab
PCTFREE 0  TABLESPACE demo
STORAGE (INITIAL 8M) AS
SELECT s.prod_id, SUM(amount_sold) AS dollar_sales,
       SUM(quantity_sold) AS unit_sales
FROM sales s GROUP BY s.prod_id;

CREATE MATERIALIZED VIEW sum_sales_tab_mv
ON PREBUILT TABLE WITHOUT REDUCED PRECISION
ENABLE QUERY REWRITE AS
SELECT s.prod_id, SUM(amount_sold) AS dollar_sales,
    SUM(quantity_sold) AS unit_sales
FROM sales s GROUP BY s.prod_id;
</pre>
<p>You could have compressed this table to save space.</p>
<p>In some cases, user-defined materialized views are refreshed on a schedule that is longer than the update cycle. For example, a monthly materialized view might be updated only at the end of each month, and the materialized view values always refer to complete time periods. Reports written directly against these materialized views implicitly select only data that is not in the current (incomplete) time period. If a user-defined materialized view already contains a time dimension:</p>
<ul style="list-style-type: disc;">
<li>
<p>It should be registered and then fast refreshed each update cycle.</p>
</li>
<li>
<p>You can create a view that selects the complete time period of interest.</p>
</li>
<li>
<p>The reports should be modified to refer to the view instead of referring directly to the user-defined materialized view.</p>
</li>
</ul>
<p>If the user-defined materialized view does not contain a time dimension, then you should create a new materialized view that does include the time dimension (if possible). Also, in this case, the view should aggregate over the time column in the new materialized view.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8216"></a>
<div class="props_rev_3"><a id="GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83"></a>
<h2 id="DWHSG-GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83" class="sect2">Choosing Indexes for Materialized Views</h2>
<div>
<div class="section">
<p>The two most common operations on a materialized view are query execution and fast refresh, and each operation has different performance requirements. Query execution might need to access any subset of the materialized view key columns, and might need to join and aggregate over a subset of those columns. Consequently, query execution usually performs best if a single-column bitmap index is defined on each materialized view key column.</p>
<p>In the case of materialized views containing only joins using fast refresh, Oracle recommends that indexes be created on the columns that contain the rowids to improve the performance of the refresh operation.</p>
<p>If a materialized view using aggregates is fast refreshable, then an index appropriate for the fast refresh procedure is created unless <code class="codeph">USING</code> <code class="codeph">NO</code> <code class="codeph">INDEX</code> is specified in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement.</p>
<p>If the materialized view is partitioned, then, after doing a partition maintenance operation on the materialized view, the indexes become unusable, and they need to be rebuilt for fast refresh to work.</p>
<p>If you create a materialized view with the prebuilt option, the <code class="codeph">I_snap$</code> index is not automatically created. This index significantly improves fast refresh performance, and you can create it manually by issuing a statement such as the following:</p>
<pre dir="ltr">CREATE UNIQUE INDEX &lt;OWNER&gt;.&#34;I_SNAP$_&lt;MVIEW_NAME&gt;&#34; ON &lt;OWNER&gt;.&lt;MVIEW_NAME&gt;
 (SYS_OP_MAP_NONNULL(&#34;LOG_DATE&#34;))
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DE
FAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE &lt;TABLESPACE_NAME&gt;;
</pre>
<div class="infoboxnotealso" id="GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83__GUID-B53F843C-E73E-4A7A-84DF-5F82CD036DA5">
<p class="notep1">See Also:</p>
<p><a class="olink TGSQL591" target="_blank" href="../TGSQL/tgsql_sqlaccess.htm#TGSQL591"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for information on using the SQL Access Advisor to determine what indexes are appropriate for your materialized view</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8217"></a>
<div class="props_rev_3"><a id="GUID-2932186A-CA03-47B7-A11A-FF30BD62AB57"></a>
<h2 id="DWHSG-GUID-2932186A-CA03-47B7-A11A-FF30BD62AB57" class="sect2">Dropping Materialized Views</h2>
<div>
<div class="section">
<p>Use the <code class="codeph">DROP</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement to drop a <a id="d14086e4851" class="indexterm-anchor"></a><a id="d14086e4855" class="indexterm-anchor"></a>materialized view. For example, consider the following statement:</p>
<pre dir="ltr">DROP MATERIALIZED VIEW sales_sum_mv;
</pre>
<p>This statement drops the materialized view <code class="codeph">sales_sum_mv</code>. If the materialized view was prebuilt on a table, then the table is not dropped, but it can no longer be maintained with the refresh mechanism or used by query rewrite. Alternatively, you can drop a materialized view using Oracle Enterprise Manager.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8218"></a>
<div class="props_rev_3"><a id="GUID-651B08EB-4D32-4A93-A260-A965C40AE136"></a>
<h2 id="DWHSG-GUID-651B08EB-4D32-4A93-A260-A965C40AE136" class="sect2">Analyzing Materialized View Capabilities</h2>
<div>
<div class="section">
<p>You can use the <code class="codeph">DBMS_MVIEW</code>.<code class="codeph">EXPLAIN_MVIEW</code> procedure to learn what is possible with a materialized view or potential materialized view. In particular, this procedure enables you to determine:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>If a materialized view is fast refreshable</p>
</li>
<li>
<p>What types of query rewrite you can perform with this materialized view</p>
</li>
<li>
<p>Whether partition change tracking refresh is possible</p>
</li>
</ul>
<p>Using this procedure is straightforward and described in <span class="q">&#34;<a href="basicmv.htm#GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0">Using the DBMS_MVIEW.EXPLAIN_MVIEW Procedure</a>&#34;</span>. You simply call <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code>, passing in as a single parameter the schema and materialized view name for an existing materialized view. Alternatively, you can specify the <code class="codeph">SELECT</code> string for a potential materialized view or the complete <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. The materialized view or potential materialized view is then analyzed and the results are written into either a table called <code class="codeph">MV_CAPABILITIES_TABLE</code>, which is the default, or to an array called <code class="codeph">MSG_ARRAY</code>.</p>
<p>Note that you must run the <code class="codeph">utlxmv.sql</code> script prior to calling <code class="codeph">EXPLAIN_MVIEW</code> except when you are placing the results in <code class="codeph">MSG_ARRAY</code>. The script is found in the <code class="codeph">admin</code> directory. It is to create the <code class="codeph">MV_CAPABILITIES_TABLE</code> in the current schema. An explanation of the various capabilities is in <a href="basicmv.htm#GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360" title="This table describes the values in the CAPABILITY_NAME column of the MV_CAPABILITIES_TABLE table.">Table 5-6</a>, and all the possible messages are listed in <a href="basicmv.htm#GUID-382EA476-95A5-4B2C-B708-79849C37DC57__G1014409" title="This table describes the semantics for some of the columns in the MV_CAPABILITIES_TABLE table.">Table 5-7</a>.</p>
</div>
<!-- class="section" --></div>
<a id="DWHSG8219"></a>
<div class="props_rev_3"><a id="GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0"></a>
<h3 id="DWHSG-GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0" class="sect3">Using the DBMS_MVIEW.EXPLAIN_MVIEW Procedure</h3>
<div>
<div class="section">
<p>The <code class="codeph">EXPLAIN_MVIEW</code> proc<a id="d14086e4989" class="indexterm-anchor"></a>edure has the following parameters:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">stmt_id</code></p>
<p>An optional parameter. A client-supplied unique identifier to associate output rows with specific invocations of <code class="codeph">EXPLAIN_MVIEW</code>.</p>
</li>
<li>
<p><code class="codeph">mv</code></p>
<p>The name of an existing materialized view or the query definition or the entire <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement of a potential materialized view you want to analyze.</p>
</li>
<li>
<p><code class="codeph">msg-array</code></p>
<p>The PL/SQL <code class="codeph">VARRAY</code> that receives the output.</p>
</li>
</ul>
<p><code class="codeph">EXPLAIN_MVIEW</code> analyzes the specified materialized view in terms of its refresh and rewrite capabilities and inserts its results (in the form of multiple rows) into <code class="codeph">MV_CAPABILITIES_TABLE</code> or <code class="codeph">MSG_ARRAY</code>.</p>
<div class="infoboxnotealso" id="GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0__GUID-99980C82-522E-4E67-83A2-7F421CF3BD62">
<p class="notep1">See Also:</p>
<p><a class="olink ARPLS027" target="_blank" href="../ARPLS/d_mview.htm#ARPLS027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for further information about the <code class="codeph">DBMS_MVIEW</code> package</p>
</div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-A3B09707-E5D5-4902-8181-B0D1FB2FC188">DBMS_MVIEW.EXPLAIN_MVIEW Declarations</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B">Using MV_CAPABILITIES_TABLE</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-34046E83-7E73-495D-B071-30033E54C616">MV_CAPABILITIES_TABLE.CAPABILITY_NAME Details</a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-382EA476-95A5-4B2C-B708-79849C37DC57">MV_CAPABILITIES_TABLE Column Details</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8220"></a>
<div class="props_rev_3"><a id="GUID-A3B09707-E5D5-4902-8181-B0D1FB2FC188"></a>
<h4 id="DWHSG-GUID-A3B09707-E5D5-4902-8181-B0D1FB2FC188" class="sect4">DBMS_MVIEW.EXPLAIN_MVIEW Declarations</h4>
<div>
<div class="section">
<p>The following <a id="d14086e5095" class="indexterm-anchor"></a>PL/SQL declarations that are made for you in the <code class="codeph">DBMS_MVIEW</code> package show the order and data types of these parameters for explaining an existing materialized view and a potential materialized view with output to a table and to a <code class="codeph">VARRAY</code>.</p>
<p>Explain an existing or potential materialized view with output to <code class="codeph">MV_CAPABILITIES_TABLE</code>:</p>
<pre dir="ltr">DBMS_MVIEW.EXPLAIN_MVIEW (mv           IN VARCHAR2,
                          stmt_id IN VARCHAR2:= NULL);
</pre>
<p>Explain an existing or potential materialized view with output to a <code class="codeph">VARRAY</code>:</p>
<pre dir="ltr">DBMS_MVIEW.EXPLAIN_MVIEW (mv          IN VARCHAR2,
                          msg_array   OUT SYS.ExplainMVArrayType);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8222"></a><a id="DWHSG8221"></a>
<div class="props_rev_3"><a id="GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B"></a>
<h4 id="DWHSG-GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B" class="sect4">Using MV_CAPABILITIES_TABLE</h4>
<div>
<div class="section">
<p>One of the simplest ways to use <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code> is <a id="d14086e5147" class="indexterm-anchor"></a>with the <code class="codeph">MV_CAPABILITIES_TABLE</code>, which has the following structure:</p>
<pre dir="ltr">CREATE TABLE MV_CAPABILITIES_TABLE 
(STATEMENT_ID      VARCHAR(30),   -- Client-supplied unique statement identifier
 MVOWNER           VARCHAR(30),   -- NULL for SELECT based EXPLAIN_MVIEW
 MVNAME            VARCHAR(30),   -- NULL for SELECT based EXPLAIN_MVIEW
 CAPABILITY_NAME   VARCHAR(30),   -- A descriptive name of the particular
                                  -- capability:
                                  -- REWRITE
                                  --   Can do at least full text match
                                  --   rewrite
                                  -- REWRITE_PARTIAL_TEXT_MATCH
                                  --   Can do at least full and partial
                                  --   text match rewrite
                                  -- REWRITE_GENERAL
                                  --   Can do all forms of rewrite
                                  -- REFRESH
                                  --   Can do at least complete refresh
                                  -- REFRESH_FROM_LOG_AFTER_INSERT
                                  --   Can do fast refresh from an mv log
                                  --   or change capture table at least
                                  --   when update operations are
                                  --   restricted to INSERT
                                  -- REFRESH_FROM_LOG_AFTER_ANY
                                  --   can do fast refresh from an mv log
                                  --   or change capture table after any
                                  --   combination of updates
                                  -- PCT
                                  --   Can do Enhanced Update Tracking on
                                  --   the table named in the RELATED_NAME
                                  --   column.  EUT is needed for fast
                                  --   refresh after partitioned
                                  --   maintenance operations on the table
                                  --   named in the RELATED_NAME column
                                  --   and to do non-stale tolerated
                                  --   rewrite when the mv is partially
                                  --   stale with respect to the table
                                  --   named in the RELATED_NAME column.
                                  --   EUT can also sometimes enable fast
                                  --   refresh of updates to the table
                                  --   named in the RELATED_NAME column
                                  --   when fast refresh from an mv log
                                  --   or change capture table is not
                                  --   possible.
                                  -- See <a href="basicmv.htm#GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360" title="This table describes the values in the CAPABILITY_NAME column of the MV_CAPABILITIES_TABLE table.">Table 5-6</a>
 POSSIBLE          CHARACTER(1),  -- T = capability is possible
                                  -- F = capability is not possible
 RELATED_TEXT      VARCHAR(2000), -- Owner.table.column, alias name, and so on
                                  -- related to this message. The specific 
                                  -- meaning of this column depends on the 
                                  -- NSGNO column. See the documentation for
                                  -- DBMS_MVIEW.EXPLAIN_MVIEW() for details.
 RELATED_NUM       NUMBER,        -- When there is a numeric value 
                                  -- associated with a row, it goes here.
 MSGNO             INTEGER,       -- When available, QSM message # explaining
                                  -- why disabled or more details when
                                  -- enabled.
 MSGTXT            VARCHAR(2000), -- Text associated with MSGNO.
 SEQ               NUMBER);       -- Useful in ORDER BY clause when 
                                  -- selecting from this table.
</pre>
<p>You can use the <code class="codeph">utlxmv.sql</code> script found in the <code class="codeph">admin</code> directory to create <code class="codeph">MV_CAPABILITIES_TABLE</code>.</p>
<div class="infoboxnotealso" id="GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B__GUID-D88801AE-16D1-4C06-A2B5-0DA46017B6F8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-64068234-BDB0-4C12-AE70-75571046A586">Refreshing Materialized Views</a> for further details about partition change tracking</p>
</li>
<li>
<p><a href="qradv.htm#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36">Advanced Query Rewrite for Materialized Views</a> for further details about partition change tracking</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B__GUID-DD2328B4-1CB9-4F6D-8ADF-5C6424676722">
<p class="titleinexample">Example 5-8 DBMS_MVIEW.EXPLAIN_MVIEW</p>
<p>First, create the materialized view. Alternatively, you can use <code class="codeph">EXPLAIN_MVIEW</code> on a potential materialized view using its <code class="codeph">SELECT</code> statement or the complete <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW cal_month_sales_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS
SELECT t.calendar_month_desc,  SUM(s.amount_sold) AS dollars
FROM sales s,  times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</pre>
<p>Then, you invoke <code class="codeph">EXPLAIN_MVIEW</code> with the materialized view to explain. You need to use the <code class="codeph">SEQ</code> column in an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause so the rows will display in a logical order. If a capability is not possible, <code class="codeph">N</code> will appear in the <code class="codeph">P</code> column and an explanation in the <code class="codeph">MSGTXT</code> column. If a capability is not possible for multiple reasons, a row is displayed for each reason.</p>
<pre dir="ltr">EXECUTE DBMS_MVIEW.EXPLAIN_MVIEW (&#39;SH.CAL_MONTH_SALES_MV&#39;);

SELECT capability_name,  possible, SUBSTR(related_text,1,8)
  AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
FROM MV_CAPABILITIES_TABLE
ORDER BY seq;

</pre>
<pre dir="ltr">CAPABILITY_NAME                 P    REL_TEXT     MSGTXT
---------------                 -    --------     ------
PCT                             N
REFRESH_COMPLETE                Y
REFRESH_FAST                    N
REWRITE                         Y 
PCT_TABLE                       N    SALES        no partition key or PMARKER in select list  
PCT_TABLE                       N    TIMES        relation is not a partitioned table 
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log must have new values  
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log must have ROWID 
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log does not have all necessary columns  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log must have new values  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log must have ROWID  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log does not have all necessary columns 
REFRESH_FAST_AFTER_ONETAB_DML   N    DOLLARS      SUM(expr) without COUNT(expr) 
REFRESH_FAST_AFTER_ONETAB_DML   N                 see the reason why
                                                  REFRESH_FAST_AFTER_INSERT is disabled
REFRESH_FAST_AFTER_ONETAB_DML   N                 COUNT(*) is not present in the select list 
REFRESH_FAST_AFTER_ONETAB_DML   N                 SUM(expr) without COUNT(expr)
REFRESH_FAST_AFTER_ANY_DML      N                 see the reason why 
                                                  REFRESH_FAST_AFTER_ONETAB_DML is disabled 
REFRESH_FAST_AFTER_ANY_DML      N    SH.TIMES     mv log must have sequence
REFRESH_FAST_AFTER_ANY_DML      N    SH.SALES     mv log must have sequence
REFRESH_PCT                     N                 PCT is not possible on any of the detail
                                                  tables in the materialized view
REWRITE_FULL_TEXT_MATCH         Y      
REWRITE_PARTIAL_TEXT_MATCH      Y  
REWRITE_GENERAL                 Y   
REWRITE_PCT                     N                 PCT is not possible on any detail tables
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8224"></a><a id="DWHSG8223"></a>
<div class="props_rev_3"><a id="GUID-34046E83-7E73-495D-B071-30033E54C616"></a>
<h4 id="DWHSG-GUID-34046E83-7E73-495D-B071-30033E54C616" class="sect4">MV_CAPABILITIES_TABLE.CAPABILITY_NAME Details</h4>
<div>
<div class="section">
<p><a href="basicmv.htm#GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360" title="This table describes the values in the CAPABILITY_NAME column of the MV_CAPABILITIES_TABLE table.">Table 5-6</a> lists explanations for values in the <code class="codeph">CAPABILITY_NAME</code> column.</p>
</div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360">
<p class="titleintable">Table 5-6 CAPABILITY_NAME Column Details</p>
<table class="cellalignment1533" title="CAPABILITY_NAME Column Details" summary="This table describes the values in the CAPABILITY_NAME column of the MV_CAPABILITIES_TABLE table.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1564" id="d14086e5275">CAPABILITY_NAME</th>
<th class="cellalignment1584" id="d14086e5278">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5283" headers="d14086e5275">
<p><code class="codeph">PCT</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5283 d14086e5278">
<p>If this capability is possible, partition change tracking is possible on at least one detail relation. If this capability is not possible, partition change tracking is not possible with any detail relation referenced by the materialized view.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5291" headers="d14086e5275">
<p><code class="codeph">REFRESH_COMPLETE</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5291 d14086e5278">
<p>If this capability is possible, complete refresh of the materialized view is possible.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5299" headers="d14086e5275">
<p><code class="codeph">REFRESH_FAST</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5299 d14086e5278">
<p>If this capability is possible, fast refresh is possible at least under certain circumstances.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5307" headers="d14086e5275">
<p><code class="codeph">REWRITE</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5307 d14086e5278">
<p>If this capability is possible, at least full text match query rewrite is possible. If this capability is not possible, no form of query rewrite is possible.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5315" headers="d14086e5275">
<p><code class="codeph">PCT_TABLE</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5315 d14086e5278">
<p>If this capability is possible, it is possible with respect to a particular partitioned table in the top level <code class="codeph">FROM</code> list. When possible, partition change tracking (PCT) applies to the partitioned table named in the <code class="codeph">RELATED_TEXT</code> column.</p>
<p>PCT is needed to support fast refresh after partition maintenance operations on the table named in the <code class="codeph">RELATED_TEXT</code> column.</p>
<p>PCT may also support fast refresh with regard to updates to the table named in the <code class="codeph">RELATED_TEXT</code> column when fast refresh from a materialized view log is not possible.</p>
<p>PCT is also needed to support query rewrite in the presence of partial staleness of the materialized view with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column.</p>
<p>When disabled, PCT does not apply to the table named in the <code class="codeph">RELATED_TEXT</code> column. In this case, fast refresh is not possible after partition maintenance operations on the table named in the <code class="codeph">RELATED_TEXT</code> column. In addition, PCT-based refresh of updates to the table named in the <code class="codeph">RELATED_TEXT</code> column is not possible. Finally, query rewrite cannot be supported in the presence of partial staleness of the materialized view with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5358" headers="d14086e5275">
<p><code class="codeph">PCT_TABLE_REWRITE</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5358 d14086e5278">
<p>If this capability is possible, it is possible with respect to a particular partitioned table in the top level <code class="codeph">FROM</code> list. When possible, PCT applies to the partitioned table named in the <code class="codeph">RELATED_TEXT</code> column.</p>
<p>This capability is needed to support query rewrite against this materialized view in partial stale state with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column.</p>
<p>When disabled, query rewrite cannot be supported if this materialized view is in partial stale state with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5382" headers="d14086e5275">
<p><code class="codeph">REFRESH_FAST_AFTER_INSERT</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5382 d14086e5278">
<p>If this capability is possible, fast refresh from a materialized view log is possible at least in the case where the updates are restricted to <code class="codeph">INSERT</code> operations; complete refresh is also possible. If this capability is not possible, no form of fast refresh from a materialized view log is possible.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5393" headers="d14086e5275">
<p><code class="codeph">REFRESH_FAST_AFTER_ONETAB_DML</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5393 d14086e5278">
<p>If this capability is possible, fast refresh from a materialized view log is possible regardless of the type of update operation, provided all update operations are performed on a single table. If this capability is not possible, fast refresh from a materialized view log may not be possible when the update operations are performed on multiple tables.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5401" headers="d14086e5275">
<p><code class="codeph">REFRESH_FAST_AFTER_ANY_DML</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5401 d14086e5278">
<p>If this capability is possible, fast refresh from a materialized view log is possible regardless of the type of update operation or the number of tables updated. If this capability is not possible, fast refresh from a materialized view log may not be possible when the update operations (other than <code class="codeph">INSERT</code>) affect multiple tables.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5412" headers="d14086e5275">
<p><code class="codeph">REFRESH_FAST_PCT</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5412 d14086e5278">
<p>If this capability is possible, fast refresh using PCT is possible. Generally, this means that refresh is possible after partition maintenance operations on those detail tables where PCT is indicated as possible.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5420" headers="d14086e5275">
<p><code class="codeph">REWRITE_FULL_TEXT_MATCH</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5420 d14086e5278">
<p>If this capability is possible, full text match query rewrite is possible. If this capability is not possible, full text match query rewrite is not possible.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5429" headers="d14086e5275">
<p><code class="codeph">REWRITE_PARTIAL_ TEXT_MATCH</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5429 d14086e5278">
<p>If this capability is possible, at least full and partial text match query rewrite are possible. If this capability is not possible, at least partial text match query rewrite and general query rewrite are not possible.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5437" headers="d14086e5275">
<p><code class="codeph">REWRITE_GENERAL</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5437 d14086e5278">
<p>If this capability is possible, all query rewrite capabilities are possible, including general query rewrite and full and partial text match query rewrite. If this capability is not possible, at least general query rewrite is not possible.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1567" id="d14086e5445" headers="d14086e5275">
<p><code class="codeph">REWRITE_PCT</code></p>
</td>
<td class="cellalignment1585" headers="d14086e5445 d14086e5278">
<p>If this capability is possible, query rewrite can use a partially stale materialized view even in <code class="codeph">QUERY_REWRITE_INTEGRITY</code> = <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> modes. When this capability is not possible, query rewrite can use a partially stale materialized view only in <code class="codeph">QUERY_REWRITE_INTEGRITY</code> = <code class="codeph">STALE_TOLERATED</code> mode.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="DWHSG8226"></a><a id="DWHSG8225"></a>
<div class="props_rev_3"><a id="GUID-382EA476-95A5-4B2C-B708-79849C37DC57"></a>
<h4 id="DWHSG-GUID-382EA476-95A5-4B2C-B708-79849C37DC57" class="sect4">MV_CAPABILITIES_TABLE Column Details</h4>
<div>
<div class="section">
<p><a href="basicmv.htm#GUID-382EA476-95A5-4B2C-B708-79849C37DC57__G1014409" title="This table describes the semantics for some of the columns in the MV_CAPABILITIES_TABLE table.">Table 5-7</a> lists the semantics for <code class="codeph">RELATED_TEXT</code> and <code class="codeph">RELATED_NUM</code> columns.</p>
</div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-382EA476-95A5-4B2C-B708-79849C37DC57__G1014409">
<p class="titleintable">Table 5-7 MV_CAPABILITIES_TABLE Column Details</p>
<table class="cellalignment1533" title="MV_CAPABILITIES_TABLE Column Details" summary="This table describes the semantics for some of the columns in the MV_CAPABILITIES_TABLE table.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1586" id="d14086e5513">MSGNO</th>
<th class="cellalignment1524" id="d14086e5516">MSGTXT</th>
<th class="cellalignment1564" id="d14086e5519">RELATED_NUM</th>
<th class="cellalignment1525" id="d14086e5522">RELATED_TEXT</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5527" headers="d14086e5513">
<p><code class="codeph">NULL</code></p>
</td>
<td class="cellalignment1527" headers="d14086e5527 d14086e5516">
<p><code class="codeph">NULL</code></p>
</td>
<td class="cellalignment1567" headers="d14086e5527 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5527 d14086e5522">
<p>For PCT capability only: <code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of the table upon which PCT is enabled</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5552" headers="d14086e5513">
<p>2066</p>
</td>
<td class="cellalignment1527" headers="d14086e5552 d14086e5516">
<p>This statement resulted in an Oracle error</p>
</td>
<td class="cellalignment1567" headers="d14086e5552 d14086e5519">
<p>Oracle error number that occurred</p>
</td>
<td class="cellalignment1528" headers="d14086e5552 d14086e5522">&nbsp;</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5564" headers="d14086e5513">
<p>2067</p>
</td>
<td class="cellalignment1527" headers="d14086e5564 d14086e5516">
<p>No partition key or <code class="codeph">PMARKER</code> or join dependent expression in <code class="codeph">SELECT</code> list</p>
</td>
<td class="cellalignment1567" headers="d14086e5564 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5564 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5592" headers="d14086e5513">
<p>2068</p>
</td>
<td class="cellalignment1527" headers="d14086e5592 d14086e5516">
<p>Relation is not partitioned</p>
</td>
<td class="cellalignment1567" headers="d14086e5592 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5592 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5614" headers="d14086e5513">
<p>2069</p>
</td>
<td class="cellalignment1527" headers="d14086e5614 d14086e5516">
<p>PCT not supported with multicolumn partition key</p>
</td>
<td class="cellalignment1567" headers="d14086e5614 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5614 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5636" headers="d14086e5513">
<p>2070</p>
</td>
<td class="cellalignment1527" headers="d14086e5636 d14086e5516">
<p>PCT not supported with this type of partitioning</p>
</td>
<td class="cellalignment1567" headers="d14086e5636 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5636 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5658" headers="d14086e5513">
<p>2071</p>
</td>
<td class="cellalignment1527" headers="d14086e5658 d14086e5516">
<p>Internal error: undefined PCT failure code</p>
</td>
<td class="cellalignment1567" headers="d14086e5658 d14086e5519">
<p>The unrecognized numeric PCT failure code</p>
</td>
<td class="cellalignment1528" headers="d14086e5658 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5681" headers="d14086e5513">
<p>2072</p>
</td>
<td class="cellalignment1527" headers="d14086e5681 d14086e5516">
<p>Requirements not satisfied for fast refresh of nested materialized view</p>
</td>
<td class="cellalignment1567" headers="d14086e5681 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5681 d14086e5522">&nbsp;</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5692" headers="d14086e5513">
<p>2077</p>
</td>
<td class="cellalignment1527" headers="d14086e5692 d14086e5516">
<p>Materialized view log is newer than last full refresh</p>
</td>
<td class="cellalignment1567" headers="d14086e5692 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5692 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5714" headers="d14086e5513">
<p>2078</p>
</td>
<td class="cellalignment1527" headers="d14086e5714 d14086e5516">
<p>Materialized view log must have new values</p>
</td>
<td class="cellalignment1567" headers="d14086e5714 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5714 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5736" headers="d14086e5513">
<p>2079</p>
</td>
<td class="cellalignment1527" headers="d14086e5736 d14086e5516">
<p>Materialized view log must have <code class="codeph">ROWID</code></p>
</td>
<td class="cellalignment1567" headers="d14086e5736 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5736 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5761" headers="d14086e5513">
<p>2080</p>
</td>
<td class="cellalignment1527" headers="d14086e5761 d14086e5516">
<p>Materialized view log must have primary key</p>
</td>
<td class="cellalignment1567" headers="d14086e5761 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5761 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5783" headers="d14086e5513">
<p>2081</p>
</td>
<td class="cellalignment1527" headers="d14086e5783 d14086e5516">
<p>Materialized view log does not have all necessary columns</p>
</td>
<td class="cellalignment1567" headers="d14086e5783 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5783 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5805" headers="d14086e5513">
<p>2082</p>
</td>
<td class="cellalignment1527" headers="d14086e5805 d14086e5516">
<p>Problem with materialized view log</p>
</td>
<td class="cellalignment1567" headers="d14086e5805 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5805 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5827" headers="d14086e5513">
<p>2099</p>
</td>
<td class="cellalignment1527" headers="d14086e5827 d14086e5516">
<p>Materialized view references a remote table or view in the <code class="codeph">FROM</code> list</p>
</td>
<td class="cellalignment1567" headers="d14086e5827 d14086e5519">
<p>Offset from the <code class="codeph">SELECT</code> keyword to the table or view in question</p>
</td>
<td class="cellalignment1528" headers="d14086e5827 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of the table or view in question</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5856" headers="d14086e5513">
<p>2126</p>
</td>
<td class="cellalignment1527" headers="d14086e5856 d14086e5516">
<p>Multiple master sites</p>
</td>
<td class="cellalignment1567" headers="d14086e5856 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5856 d14086e5522">
<p>Name of the first different node, or <code class="codeph">NULL</code> if the first different node is local</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5871" headers="d14086e5513">
<p>2129</p>
</td>
<td class="cellalignment1527" headers="d14086e5871 d14086e5516">
<p>Join or filter condition(s) are complex</p>
</td>
<td class="cellalignment1567" headers="d14086e5871 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5871 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of the table involved with the join or filter condition (or <code class="codeph">NULL</code> when not available)</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5896" headers="d14086e5513">
<p>2130</p>
</td>
<td class="cellalignment1527" headers="d14086e5896 d14086e5516">
<p>Expression not supported for fast refresh</p>
</td>
<td class="cellalignment1567" headers="d14086e5896 d14086e5519">
<p>Offset from the <code class="codeph">SELECT</code> keyword to the expression in question</p>
</td>
<td class="cellalignment1528" headers="d14086e5896 d14086e5522">
<p>The alias name in the <code class="codeph">SELECT</code> list of the expression in question</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5915" headers="d14086e5513">
<p>2150</p>
</td>
<td class="cellalignment1527" headers="d14086e5915 d14086e5516">
<p><code class="codeph">SELECT</code> lists must be identical across the <code class="codeph">UNION</code> operator</p>
</td>
<td class="cellalignment1567" headers="d14086e5915 d14086e5519">
<p>Offset from the <code class="codeph">SELECT</code> keyword to the first different select item in the <code class="codeph">SELECT</code> list</p>
</td>
<td class="cellalignment1528" headers="d14086e5915 d14086e5522">
<p>The alias name of the first different select item in the <code class="codeph">SELECT</code> list</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5942" headers="d14086e5513">
<p>2182</p>
</td>
<td class="cellalignment1527" headers="d14086e5942 d14086e5516">
<p>PCT is enabled through a join dependency</p>
</td>
<td class="cellalignment1567" headers="d14086e5942 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5942 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which <code class="codeph">PCT_TABLE_REWRITE</code> is not enabled</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5967" headers="d14086e5513">
<p>2183</p>
</td>
<td class="cellalignment1527" headers="d14086e5967 d14086e5516">
<p>Expression to enable PCT not in <code class="codeph">PARTITION</code> <code class="codeph">BY</code> of analytic function or model</p>
</td>
<td class="cellalignment1567" headers="d14086e5967 d14086e5519">
<p>The unrecognized numeric PCT failure code</p>
</td>
<td class="cellalignment1528" headers="d14086e5967 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not enabled</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e5996" headers="d14086e5513">
<p>2184</p>
</td>
<td class="cellalignment1527" headers="d14086e5996 d14086e5516">
<p>Expression to enable PCT cannot be rolled up</p>
</td>
<td class="cellalignment1567" headers="d14086e5996 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e5996 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not enabled</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e6019" headers="d14086e5513">
<p>2185</p>
</td>
<td class="cellalignment1527" headers="d14086e6019 d14086e5516">
<p>No partition key or <code class="codeph">PMARKER</code> in the <code class="codeph">SELECT</code> list</p>
</td>
<td class="cellalignment1567" headers="d14086e6019 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e6019 d14086e5522">
<p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which <code class="codeph">PCT_TABLE_REWRITE</code> is not enabled</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e6050" headers="d14086e5513">
<p>2186</p>
</td>
<td class="cellalignment1527" headers="d14086e6050 d14086e5516">
<p><code class="codeph">GROUP</code> <code class="codeph">OUTER</code> <code class="codeph">JOIN</code> is present</p>
</td>
<td class="cellalignment1567" headers="d14086e6050 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e6050 d14086e5522">&nbsp;</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1587" id="d14086e6069" headers="d14086e5513">
<p>2187</p>
</td>
<td class="cellalignment1527" headers="d14086e6069 d14086e5516">
<p>Materialized view on external table</p>
</td>
<td class="cellalignment1567" headers="d14086e6069 d14086e5519">&nbsp;</td>
<td class="cellalignment1528" headers="d14086e6069 d14086e5522">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1506">
<tr>
<td class="cellalignment1513">
<table class="cellalignment1511">
<tr>
<td class="cellalignment1510"><a href="part3.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1510"><a href="advmv.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1515">
<table class="cellalignment1509">
<tr>
<td class="cellalignment1510"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1510"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1510"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1510"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1510"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1510"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>