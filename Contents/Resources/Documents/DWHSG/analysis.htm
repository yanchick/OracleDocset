<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-6017"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/SQL%20for%20Analysis%20and%20Reporting"></a><title>SQL for Analysis and Reporting</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="dcterms.created" content="2017-06-07T18:07:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Warehousing Guide"/>
<meta name="dcterms.identifier" content="E41670-11"/>
<meta name="dcterms.isVersionOf" content="DWHSG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="part5.htm" title="Previous" type="text/html"/>
<link rel="Next" href="aggreg.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41670-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684"></a> <span id="PAGE" style="display:none;">26/32</span> <!-- End Header -->
<h1 id="DWHSG-GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684" class="sect1"><span class="enumeration_chapter">18</span> SQL for Analysis and Reporting</h1>
<div>
<p>The following topics provide information about analytical SQL features and techniques in Oracle. Although these topics are presented in terms of data warehousing, they are applicable to any activity needing analysis and reporting.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D">Overview of SQL for Analysis and Reporting</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-64CE26C0-43A0-4733-ADF6-7C0F186C6F64">Ranking_ Windowing_ and Reporting Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-7070D54B-AB82-4FDC-8A38-28D6F4CA5525">Advanced Aggregates for Analysis</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591">Pivoting Operations</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-01B5DD6F-C039-4223-B017-263F7788C4FA">Data Densification for Reporting</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-759F5F20-D45B-443F-9464-E71A4B70AF1B">Time Series Calculations on Densified Data</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-2F10D9C8-C6D6-47F2-9DDF-4146539655F3">Miscellaneous Analysis and Reporting Capabilities</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4">Limiting SQL Rows</a></p>
</li>
</ul>
</div>
<a id="DWHSG8660"></a><a id="DWHSG8661"></a><a id="DWHSG8662"></a><a id="DWHSG8659"></a>
<div class="props_rev_3"><a id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D"></a>
<h2 id="DWHSG-GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D" class="sect2">Overview of SQL for Analysis and Reporting</h2>
<div>
<p>Oracle Database provides a large family of analytic SQL functions. These analytic functions enable you to calculate:</p>
<ul style="list-style-type: disc;">
<li>
<p>Rankings and percentiles</p>
</li>
<li>
<p>Moving window calculations</p>
</li>
<li>
<p>Lag/lead analysis</p>
</li>
<li>
<p>First/last analysis</p>
</li>
<li>
<p>Linear regression statistics</p>
</li>
</ul>
<p>Ranking functions include cumulative distributions, percent rank, and N-tiles. Moving window calculations allow you to find moving and cumulative aggregations, such as sums and averages. Lag/lead analysis enables direct inter-row references so you can calculate period-to-period changes. First/last analysis enables you to find the first or last value in an ordered group.</p>
<p>Other SQL elements valuable for analysis and reporting include the <code class="codeph">CASE</code> expression and partitioned outer join. <code class="codeph">CASE</code> expressions provide if-then logic useful in many situations. Partitioned outer join is a variant of ANSI outer join syntax that allows users to selectively densify certain dimensions while keeping others sparse. This allows reporting tools to selectively densify dimensions, for example, the ones that appear in their cross-tabular reports while keeping others sparse.</p>
<p>To enhance performance, analytic functions can be parallelized: multiple processes can simultaneously execute all of these statements. These capabilities make calculations easier and more efficient, thereby enhancing database performance, scalability, and simplicity.</p>
<p>Analytic functions are classified as described in <a href="analysis.htm#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__i1014372">Analytic Functions and Their Uses&nbsp;</a>.</p>
<div class="tblformal" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__GUID-78CBF9F4-47A8-4D1F-BB4B-0078C78BFDAB">
<p class="titleintable">Table 18-1 <span class="italic" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__i1014372"><span class="bold">Analytic Functions and Their Uses&nbsp;</span></span></p>
<table class="cellalignment1516" title="Analytic Functions and Their Uses&nbsp;" summary="Analytic Functions and Their Uses">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1558" id="d59823e130">Type</th>
<th class="cellalignment1559" id="d59823e133">Used For</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e138" headers="d59823e130">
<p>Ranking</p>
</td>
<td class="cellalignment1561" headers="d59823e138 d59823e133">
<p>Calculating ranks, percentiles, and n-tiles of the values in a result set.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e145" headers="d59823e130">
<p>Windowing</p>
</td>
<td class="cellalignment1561" headers="d59823e145 d59823e133">
<p>Calculating cumulative and moving aggregates. Works with these functions: <code class="codeph">SUM</code>, <code class="codeph">AVG</code>, <code class="codeph">MIN</code>, <code class="codeph">MAX</code>, <code class="codeph">COUNT</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>, <code class="codeph">FIRST_VALUE</code>, <code class="codeph">LAST_VALUE</code>, and new statistical functions. Note that the <code class="codeph">DISTINCT</code> keyword is not supported in windowing functions except for <code class="codeph">MAX</code> and <code class="codeph">MIN</code>.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e190" headers="d59823e130">
<p>Reporting</p>
</td>
<td class="cellalignment1561" headers="d59823e190 d59823e133">
<p>Calculating shares, for example, market share. Works with these functions: <code class="codeph">SUM</code>, <code class="codeph">AVG</code>, <code class="codeph">MIN</code>, <code class="codeph">MAX</code>, <code class="codeph">COUNT</code> (with/without <code class="codeph">DISTINCT</code>), <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>, <code class="codeph">RATIO_TO_REPORT</code>, and new statistical functions. Note that the <code class="codeph">DISTINCT</code> keyword may be used in those reporting functions that support <code class="codeph">DISTINCT</code> in aggregate mode.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e231" headers="d59823e130">
<p><code class="codeph">LAG</code>/<code class="codeph">LEAD</code></p>
</td>
<td class="cellalignment1561" headers="d59823e231 d59823e133">
<p>Finding a value in a row a specified number of rows from a current row.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e242" headers="d59823e130">
<p><code class="codeph">FIRST</code>/<code class="codeph">LAST</code></p>
</td>
<td class="cellalignment1561" headers="d59823e242 d59823e133">
<p>First or last value in an ordered group.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e253" headers="d59823e130">
<p>Linear Regression</p>
</td>
<td class="cellalignment1561" headers="d59823e253 d59823e133">
<p>Calculating linear regression and other statistics (slope, intercept, and so on).</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e260" headers="d59823e130">
<p>Inverse Percentile</p>
</td>
<td class="cellalignment1561" headers="d59823e260 d59823e133">
<p>The value in a data set that corresponds to a specified percentile.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1560" id="d59823e267" headers="d59823e130">
<p>Hypothetical Rank and Distribution</p>
</td>
<td class="cellalignment1561" headers="d59823e267 d59823e133">
<p>The rank or percentile that a row would have if inserted into a specified data set.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>To perform these operations, the analytic functions add several new elements to SQL processing. These elements build on existing SQL to allow flexible and powerful calculation expressions. With just a few exceptions, the analytic functions have these additional elements. The processing flow is represented in <a href="analysis.htm#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__i1014377">Figure 18-1</a>.</p>
<div class="figure" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__i1014377">
<p class="titleinfigure">Figure 18-1 Processing Order</p>
<img width="464" height="72" src="img/GUID-0D38C35C-54A8-4A45-BB2C-6FCA3F529A26-default.gif" alt="Description of Figure 18-1 follows" title="Description of Figure 18-1 follows"/><br/>
<a href="img_text/GUID-0D38C35C-54A8-4A45-BB2C-6FCA3F529A26-print.htm">Description of &#34;Figure 18-1 Processing Order&#34;</a></div>
<!-- class="figure" -->
<p>The essential <a id="d59823e284" class="indexterm-anchor"></a>concepts used in analytic functions are:</p>
<ul style="list-style-type: disc;">
<li>
<p>Processing order</p>
<p>Query processing using analytic functions takes place in three stages. First, all joins, <code class="codeph">WHERE</code>, <code class="codeph">GROUP</code> <code class="codeph">BY</code> and <code class="codeph">HAVING</code> clauses are performed. Second, the result set is made available to the analytic functions, and all their calculations take place. Third, if the query has an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause at its end, the <code class="codeph">ORDER</code> <code class="codeph">BY</code> is processed to allow for precise output ordering. The processing order is shown in <a href="analysis.htm#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__i1014377">Figure 18-1</a>.</p>
</li>
<li>
<p>Result set partitions</p>
<p>The analytic functions allow users to divide query result sets into groups of rows called partitions. Note that the term <span class="bold">partitions</span> used with analytic functions is unrelated to the table partitions feature. Throughout this chapter, the term partitions refers to only the meaning related to analytic functions. Partitions are created after the groups defined with <code class="codeph">GROUP</code> <code class="codeph">BY</code> clauses, so they are available to any aggregate results such as sums and averages. Partition divisions may be based upon any desired columns or expressions. A query result set may be partitioned into just one partition holding all the rows, a few large partitions, or many small partitions holding just a few rows each.</p>
</li>
<li>
<p>Window</p>
<p>For each row in a partition, you can define a sliding window of data. This window determines the range of rows used to perform the calculations for the current row. Window sizes can be based on either a physical number of rows or a logical interval such as time. The window has a starting row and an ending row. Depending on its definition, the window may move at one or both ends. For instance, a window defined for a cumulative sum function would have its starting row fixed at the first row of its partition, and its ending row would slide from the starting point all the way to the last row of the partition. In contrast, a window defined for a moving average would have both its starting and end points slide so that they maintain a constant physical or logical range.</p>
<p>A window can be set as large as all the rows in a partition or just a sliding window of one row within a partition. When a window is near a border, the function returns results for only the available rows, rather than warning you that the results are not what you want.</p>
<p>When using window functions, the current row is included during calculations, so you should only specify (<span class="italic">n</span>-1) when you are dealing with <span class="italic">n</span> items.</p>
</li>
<li>
<p>Current row</p>
<p>Each calculation performed with an analytic function is based on a current row within a partition. The current row serves as the reference point determining the start and end of the window. For instance, a centered moving average calculation could be defined with a window that holds the current row, the six preceding rows, and the following six rows. This would create a sliding window of 13 rows, as shown in <a href="analysis.htm#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__i1006330">Figure 18-2</a>.</p>
</li>
</ul>
<div class="figure" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__i1006330">
<p class="titleinfigure">Figure 18-2 Sliding Window Example</p>
<img width="378" height="245" src="img/GUID-6F0AC36C-223A-4A1D-A145-3FF78E15199B-default.gif" alt="Description of Figure 18-2 follows" title="Description of Figure 18-2 follows"/><br/>
<a href="img_text/GUID-6F0AC36C-223A-4A1D-A145-3FF78E15199B-print.htm">Description of &#34;Figure 18-2 Sliding Window Example&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="DWHSG0201"></a>
<div class="props_rev_3"><a id="GUID-64CE26C0-43A0-4733-ADF6-7C0F186C6F64"></a>
<h2 id="DWHSG-GUID-64CE26C0-43A0-4733-ADF6-7C0F186C6F64" class="sect2">Ranking, Windowing, and Reporting Functions</h2>
<div>
<p>This section illustrates the basic analytic functions for ranking, windowing, and reporting. It contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-130370E5-9F75-42C5-9BC5-EEFF71C18F09">Ranking Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A">Windowing Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A">Reporting Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-4A7CC941-78D4-4A1C-98EC-DA548E1FD394">LAG/LEAD Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-B1E8AB97-FFF6-4C5A-BB3C-D54780536C86">FIRST_VALUE_ LAST_VALUE_ and NTH_VALUE Functions</a></p>
</li>
</ul>
</div>
<a id="DWHSG8663"></a>
<div class="props_rev_3"><a id="GUID-130370E5-9F75-42C5-9BC5-EEFF71C18F09"></a>
<h3 id="DWHSG-GUID-130370E5-9F75-42C5-9BC5-EEFF71C18F09" class="sect3">Ranking Functions</h3>
<div>
<p><a id="d59823e433" class="indexterm-anchor"></a><a id="d59823e437" class="indexterm-anchor"></a>A ranking function computes the rank of a record compared to other records in the data set based on the values of a set of measures. The types of ranking function are:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-1D8E3429-735B-409C-BD16-54004964D89B">RANK and DENSE_RANK Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-42E2699D-F7C5-4D99-8224-154F3A892633">Bottom N Ranking Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-D79F0C6D-74B6-4EC6-9612-4D3ACB6DED43">CUME_DIST Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-76DD07EA-4C7D-496C-8567-42781568AEE5">PERCENT_RANK Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-E1759E5F-4349-4092-BD4C-52238E400AF0">NTILE Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E">ROW_NUMBER Function</a></p>
</li>
</ul>
</div>
<a id="DWHSG8664"></a>
<div class="props_rev_3"><a id="GUID-1D8E3429-735B-409C-BD16-54004964D89B"></a>
<h4 id="DWHSG-GUID-1D8E3429-735B-409C-BD16-54004964D89B" class="sect4">RANK and DENSE_RANK Functions</h4>
<div>
<div class="section">
<p><a id="d59823e493" class="indexterm-anchor"></a><a id="d59823e495" class="indexterm-anchor"></a><a id="d59823e497" class="indexterm-anchor"></a><a id="d59823e501" class="indexterm-anchor"></a>The <code class="codeph">RANK</code> and <code class="codeph">DENSE_RANK</code> functions allow you to rank items in a group, for example, finding the top three products sold in California last year. There are two functions that perform ranking, as shown by the following syntax:</p>
<pre dir="ltr">RANK ( ) OVER ( [query_partition_clause] order_by_clause )
DENSE_RANK ( ) OVER ( [query_partition_clause] order_by_clause )
</pre>
<p>The difference between <code class="codeph">RANK</code> and <code class="codeph">DENSE_RANK</code> is that <code class="codeph">DENSE_RANK</code> leaves no gaps in ranking sequence when there are ties. That is, if you were ranking a competition using <code class="codeph">DENSE_RANK</code> and had three people tie for second place, you would say that all three were in second place and that the next person came in third. The <code class="codeph">RANK</code> function would also give three people in second place, but the next person would be in fifth place.</p>
<p>The following are some relevant points about <code class="codeph">RANK</code>:</p>
<ul style="list-style-type: disc;">
<li>
<p>Ascending is the default sort order, which you may want to change to descending.</p>
</li>
<li>
<p>The expressions in the optional <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause divide the query result set into groups within which the <code class="codeph">RANK</code> function operates. That is, <code class="codeph">RANK</code> gets reset whenever the group changes. In effect, the value expressions of the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause define the reset boundaries.</p>
</li>
<li>
<p>If the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause is missing, then ranks are computed over the entire query result set.</p>
</li>
<li>
<p>The <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause specifies the measures (&lt;<code class="codeph">value</code> <code class="codeph">expression</code>&gt;) on which ranking is done and defines the order in which rows are sorted in each group (or partition). Once the data is sorted within each partition, ranks are given to each row starting from 1.</p>
</li>
<li>
<p>The <code class="codeph">NULLS</code> <code class="codeph">FIRST</code> | <code class="codeph">NULLS</code> <code class="codeph">LAST</code> clause indicates the position of <code class="codeph">NULLs</code> in the ordered sequence, either first or last in the sequence. The order of the sequence would make <code class="codeph">NULLs</code> compare either high or low with respect to non-<code class="codeph">NULL</code> values. If the sequence were in ascending order, then <code class="codeph">NULLS</code> <code class="codeph">FIRST</code> implies that <code class="codeph">NULLs</code> are smaller than all other non-<code class="codeph">NULL</code> values and <code class="codeph">NULLS</code> <code class="codeph">LAST</code> implies they are larger than non-<code class="codeph">NULL</code> values. It is the opposite for descending order. See the example in <span class="q">&#34;<a href="analysis.htm#GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C">Examples: Treatment of NULLs in Ranking Functions</a>&#34;</span>.</p>
</li>
<li>
<p>If the <code class="codeph">NULLS</code> <code class="codeph">FIRST</code> | <code class="codeph">NULLS</code> <code class="codeph">LAST</code> clause is omitted, then the ordering of the null values depends on the <code class="codeph">ASC</code> or <code class="codeph">DESC</code> arguments. Null values are considered larger than any other values. If the ordering sequence is <code class="codeph">ASC</code>, then nulls will appear last; nulls will appear first otherwise. Nulls are considered equal to other nulls and, therefore, the order in which nulls are presented is non-deterministic.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8666"></a><a id="DWHSG8665"></a>
<div class="props_rev_3"><a id="GUID-35EB8A7E-04F3-4D0E-B550-B18CCEAB8590"></a>
<h5 id="DWHSG-GUID-35EB8A7E-04F3-4D0E-B550-B18CCEAB8590" class="sect5">Ranking Order in RANK and DENSE_RANK Functions</h5>
<div>
<div class="section">
<p>The following example shows how the <code class="codeph">[ASC | DESC]</code> option of RANK changes the ranking order.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-35EB8A7E-04F3-4D0E-B550-B18CCEAB8590__GUID-3C35A049-B98F-4BF0-86DA-C103988CB83F">
<p class="titleinexample">Example 18-1 Ranking Order</p>
<pre dir="ltr">SELECT channel_desc, TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$,
   RANK() OVER (ORDER BY SUM(amount_sold)) AS default_rank,
   RANK() OVER (ORDER BY SUM(amount_sold) DESC NULLS LAST) AS custom_rank
FROM sales, products, customers, times, channels, countries
WHERE sales.prod_id=products.prod_id AND sales.cust_id=customers.cust_id
  AND customers.country_id = countries.country_id AND sales.time_id=times.time_id
  AND sales.channel_id=channels.channel_id
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;)
  AND country_iso_code=&#39;US&#39;
GROUP BY channel_desc;

CHANNEL_DESC         SALES$         DEFAULT_RANK CUSTOM_RANK
-------------------- -------------- ------------ -----------
Direct Sales              1,320,497            3           1
Partners                    800,871            2           2
Internet                    261,278            1           3
</pre>
<p>While the data in this result is ordered on the measure <code class="codeph">SALES$</code>, in general, it is not guaranteed by the <code class="codeph">RANK</code> function that the data will be sorted on the measures. If you want the data to be sorted on <code class="codeph">SALES$</code> in your result, you must specify it explicitly with an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause, at the end of the <code class="codeph">SELECT</code> statement.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8668"></a><a id="DWHSG8667"></a>
<div class="props_rev_3"><a id="GUID-40784EB2-5A76-466A-A364-F19417DFBD7A"></a>
<h5 id="DWHSG-GUID-40784EB2-5A76-466A-A364-F19417DFBD7A" class="sect5">Ranking on Multiple Expressions</h5>
<div>
<div class="section">
<p>Ranking functions must resolve ties between values in the set. If the first expression cannot resolve ties, the second expression is used to resolve ties and so on. For example, here is a query ranking three of the sales channels over two months based on their dollar sales, breaking ties with the unit sales. (Note that the <code class="codeph">TRUNC</code> function is used here only to create tie values for this query.)</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-40784EB2-5A76-466A-A364-F19417DFBD7A__GUID-DD89B75F-DA9F-499E-9890-F415D288E662">
<p class="titleinexample">Example 18-2 Ranking On Multiple Expressions</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, TO_CHAR(TRUNC(SUM(amount_sold),-5),
  &#39;9,999,999,999&#39;) SALES$, TO_CHAR(SUM(quantity_sold), &#39;9,999,999,999&#39;) 
  SALES_Count, RANK() OVER (ORDER BY TRUNC(SUM(amount_sold), -5) 
  DESC, SUM(quantity_sold) DESC) AS col_rank
FROM sales, products, customers, times, channels
WHERE sales.prod_id=products.prod_id AND sales.cust_id=customers.cust_id
  AND sales.time_id=times.time_id AND sales.channel_id=channels.channel_id
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;)
  AND channels.channel_desc&lt;&gt;&#39;Tele Sales&#39;
GROUP BY channel_desc, calendar_month_desc;

CHANNEL_DESC         CALENDAR SALES$         SALES_COUNT     COL_RANK
-------------------- -------- -------------- -------------- ---------
Direct Sales         2000-10       1,200,000         12,584          1
Direct Sales         2000-09       1,200,000         11,995          2
Partners             2000-10         600,000          7,508          3
Partners             2000-09         600,000          6,165          4
Internet             2000-09         200,000          1,887          5
Internet             2000-10         200,000          1,450          6
</pre>
<p>The <code class="codeph">sales_count</code> column breaks the ties for three pairs of values.</p>
<p>If you only want to see the top five results for this query, you can add an <code class="codeph">ORDER</code> <code class="codeph">BY</code> <code class="codeph">COL_RANK</code> <code class="codeph">FETCH</code> <code class="codeph">FIRST</code> <code class="codeph">5</code> <code class="codeph">ROWS</code> <code class="codeph">ONLY</code> statement. See <span class="q">&#34;<a href="analysis.htm#GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4">Limiting SQL Rows</a>&#34;</span> for further information.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8670"></a><a id="DWHSG8669"></a>
<div class="props_rev_3"><a id="GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4"></a>
<h5 id="DWHSG-GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4" class="sect5">Example: Difference Between RANK and DENSE_RANK</h5>
<div>
<p>The difference between <code class="codeph">RANK</code> and <code class="codeph">DENSE_RANK</code> functions is illustrated in <a href="analysis.htm#GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4__BCFCJCEA">Example 18-3</a>.</p>
<div class="example" id="GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4__BCFCJCEA">
<p class="titleinexample">Example 18-3 RANK and DENSE_RANK</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc,
   TO_CHAR(TRUNC(SUM(amount_sold),-5), &#39;9,999,999,999&#39;) SALES$,
      RANK() OVER (ORDER BY TRUNC(SUM(amount_sold),-5) DESC) AS RANK,
DENSE_RANK() OVER (ORDER BY TRUNC(SUM(amount_sold),-5) DESC) AS DENSE_RANK
FROM sales, products, customers, times, channels
WHERE sales.prod_id=products.prod_id
  AND sales.cust_id=customers.cust_id
  AND sales.time_id=times.time_id AND sales.channel_id=channels.channel_id
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;)
  AND channels.channel_desc&lt;&gt;&#39;Tele Sales&#39;
GROUP BY channel_desc, calendar_month_desc;

CHANNEL_DESC         CALENDAR SALES$              RANK DENSE_RANK
-------------------- -------- -------------- --------- ----------
Direct Sales         2000-09       1,200,000         1          1
Direct Sales         2000-10       1,200,000         1          1
Partners             2000-09         600,000         3          2
Partners             2000-10         600,000         3          2
Internet             2000-09         200,000         5          3
Internet             2000-10         200,000         5          3
</pre>
<p>Note that, in the case of <code class="codeph">DENSE_RANK</code>, the largest rank value gives the number of distinct values in the data set.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8672"></a><a id="DWHSG8673"></a><a id="DWHSG8671"></a>
<div class="props_rev_3"><a id="GUID-D85A27E1-2515-4480-B7D1-883A144C3468"></a>
<h5 id="DWHSG-GUID-D85A27E1-2515-4480-B7D1-883A144C3468" class="sect5">Ranking Within Groups: Example</h5>
<div>
<div class="section">
<p>The <code class="codeph">RANK</code> function can be made to operate within groups, that is, the rank gets reset whenever the group changes. This is accomplished with the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause. The group expressions in the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> subclause divide the data set into groups within which <code class="codeph">RANK</code> operates. For example, to rank products within each channel by their dollar sales, you could issue the following statement.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-D85A27E1-2515-4480-B7D1-883A144C3468__GUID-21C56C7D-A2CB-403C-ACF5-E235D5783051">
<p class="titleinexample">Example 18-4 Per Group Ranking Example 1</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, TO_CHAR(SUM(amount_sold),
 &#39;9,999,999,999&#39;) SALES$, RANK() OVER (PARTITION BY channel_desc
  ORDER BY SUM(amount_sold) DESC) AS RANK_BY_CHANNEL
FROM sales, products, customers, times, channels
WHERE sales.prod_id=products.prod_id AND sales.cust_id=customers.cust_id
  AND sales.time_id=times.time_id AND sales.channel_id=channels.channel_id
  AND times.calendar_month_desc IN (&#39;2000-08&#39;, &#39;2000-09&#39;, &#39;2000-10&#39;, &#39;2000-11&#39;)
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;)
GROUP BY channel_desc, calendar_month_desc;

CHANNEL_DESC         CALENDAR SALES$         RANK_BY_CHANNEL
-------------------- -------- -------------- ---------------
Direct Sales         2000-08       1,236,104               1
Direct Sales         2000-10       1,225,584               2
Direct Sales         2000-09       1,217,808               3
Direct Sales         2000-11       1,115,239               4
Internet             2000-11         284,742               1
Internet             2000-10         239,236               2
Internet             2000-09         228,241               3
Internet             2000-08         215,107               4
 
8 rows selected.
</pre>
<p>A single query block can contain more than one ranking function, each partitioning the data into different groups (that is, reset on different boundaries). The groups can be mutually exclusive. The following query ranks products based on their dollar sales within each month (<code class="codeph">rank_of_product_per_region</code>) and within each channel (<code class="codeph">rank_of_product_total</code>).</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-D85A27E1-2515-4480-B7D1-883A144C3468__GUID-39EB856D-533D-497B-8006-FE7B21C46F54">
<p class="titleinexample">Example 18-5 Per Group Ranking Example 2</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, TO_CHAR(SUM(amount_sold),
  &#39;9,999,999,999&#39;) SALES$, RANK() OVER (PARTITION BY calendar_month_desc
  ORDER BY SUM(amount_sold) DESC) AS RANK_WITHIN_MONTH, RANK() OVER (PARTITION
 BY channel_desc ORDER BY SUM(amount_sold) DESC) AS RANK_WITHIN_CHANNEL 
FROM sales, products, customers, times, channels, countries
WHERE sales.prod_id=products.prod_id AND sales.cust_id=customers.cust_id
  AND customers.country_id = countries.country_id AND sales.time_id=times.time_id
  AND sales.channel_id=channels.channel_id
  AND times.calendar_month_desc IN (&#39;2000-08&#39;, &#39;2000-09&#39;, &#39;2000-10&#39;, &#39;2000-11&#39;)
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;)
GROUP BY channel_desc, calendar_month_desc;

CHANNEL_DESC  CALENDAR    SALES$     RANK_WITHIN_MONTH  RANK_WITHIN_CHANNEL
------------- --------    ---------  -----------------  -------------------
Direct Sales   2000-08    1,236,104                  1                    1
Internet       2000-08      215,107                  2                    4
Direct Sales   2000-09    1,217,808                  1                    3
Internet       2000-09      228,241                  2                    3
Direct Sales   2000-10    1,225,584                  1                    2
Internet       2000-10      239,236                  2                    2
Direct Sales   2000-11    1,115,239                  1                    4
Internet       2000-11      284,742                  2                    1
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8674"></a>
<div class="props_rev_3"><a id="GUID-610A2C96-DC26-4C5F-9F66-9B4537ED3F5E"></a>
<h5 id="DWHSG-GUID-610A2C96-DC26-4C5F-9F66-9B4537ED3F5E" class="sect5">Example: Per Cube and Rollup Group Ranking</h5>
<div>
<div class="section">
<p>Analytic functions, <code class="codeph">RANK</code> for example, can be reset based on the groupings provided by a <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, or <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> operator. It is useful to assign ranks to the groups created by <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, and <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> queries. See <a href="aggreg.htm#GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2">SQL for Aggregation in Data Warehouses</a> for further information about the <code class="codeph">GROUPING</code> function.</p>
<p>A sample <code class="codeph">CUBE</code> and <code class="codeph">ROLLUP</code> query is the following:</p>
<pre dir="ltr">SELECT channel_desc, country_iso_code, 
  TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;)
 SALES$, RANK() OVER (PARTITION BY GROUPING_ID(channel_desc, country_iso_code)
    ORDER BY SUM(amount_sold) DESC) AS RANK_PER_GROUP
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id
  AND sales.channel_id = channels.channel_id AND channels.channel_desc
   IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc=&#39;2000-09&#39;
   AND country_iso_code IN (&#39;GB&#39;, &#39;US&#39;, &#39;JP&#39;)
GROUP BY CUBE(channel_desc, country_iso_code);

CHANNEL_DESC         CO SALES$         RANK_PER_GROUP
-------------------- -- -------------- --------------
Direct Sales         GB      1,217,808              1
Direct Sales         JP      1,217,808              1
Direct Sales         US      1,217,808              1
Internet             GB        228,241              4
Internet             JP        228,241              4
Internet             US        228,241              4
Direct Sales                 3,653,423              1
Internet                       684,724              2
                     GB      1,446,049              1
                     JP      1,446,049              1
                     US      1,446,049              1
                             4,338,147              1
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8675"></a>
<div class="props_rev_3"><a id="GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C"></a>
<h5 id="DWHSG-GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C" class="sect5">Examples: Treatment of NULLs in Ranking Functions</h5>
<div>
<div class="section">
<p><code class="codeph">NULLs</code> are treated like normal values. Also, for rank computation, a <code class="codeph">NULL</code> value is assumed to be equal to another <code class="codeph">NULL</code> value. Depending on the <code class="codeph">ASC</code> | <code class="codeph">DESC</code> options provided for measures and the <code class="codeph">NULLS</code> <code class="codeph">FIRST</code> | <code class="codeph">NULLS</code> <code class="codeph">LAST</code> clause, <code class="codeph">NULLs</code> will either sort low or high and hence, are given ranks appropriately. The following example shows how <code class="codeph">NULLs</code> are ranked in different cases:</p>
<pre dir="ltr">SELECT  times.time_id time,  sold,
  RANK() OVER (ORDER BY (sold) DESC NULLS LAST) AS NLAST_DESC,
  RANK() OVER (ORDER BY (sold) DESC NULLS FIRST) AS NFIRST_DESC,
  RANK() OVER (ORDER BY (sold) ASC NULLS FIRST) AS NFIRST,
  RANK() OVER (ORDER BY (sold) ASC NULLS LAST) AS NLAST
FROM
  (
   SELECT time_id, SUM(sales.amount_sold)  sold
   FROM sales, products, customers, countries
   WHERE sales.prod_id=products.prod_id
    AND customers.country_id = countries.country_id 
    AND sales.cust_id=customers.cust_id 
    AND prod_name IN (&#39;Envoy Ambassador&#39;, &#39;Mouse Pad&#39;) AND country_iso_code =&#39;GB&#39;
   GROUP BY  time_id)
 v, times
WHERE v.time_id (+) = times.time_id 
  AND calendar_year=1999
  AND calendar_month_number=1
ORDER BY sold  DESC NULLS LAST;

TIME            SOLD NLAST_DESC NFIRST_DESC     NFIRST      NLAST
--------- ---------- ---------- ----------- ---------- ----------
25-JAN-99    3097.32          1          18         31         14
17-JAN-99    1791.77          2          19         30         13
30-JAN-99     127.69          3          20         29         12
28-JAN-99     120.34          4          21         28         11
23-JAN-99      86.12          5          22         27         10
20-JAN-99      79.07          6          23         26          9
13-JAN-99       56.1          7          24         25          8
07-JAN-99      42.97          8          25         24          7
08-JAN-99      33.81          9          26         23          6
10-JAN-99      22.76         10          27         21          4
02-JAN-99      22.76         10          27         21          4
26-JAN-99      19.84         12          29         20          3
16-JAN-99      11.27         13          30         19          2
14-JAN-99       9.52         14          31         18          1
09-JAN-99                    15           1          1         15
12-JAN-99                    15           1          1         15
31-JAN-99                    15           1          1         15
11-JAN-99                    15           1          1         15
19-JAN-99                    15           1          1         15
03-JAN-99                    15           1          1         15
15-JAN-99                    15           1          1         15
21-JAN-99                    15           1          1         15
24-JAN-99                    15           1          1         15
04-JAN-99                    15           1          1         15
06-JAN-99                    15           1          1         15
27-JAN-99                    15           1          1         15
18-JAN-99                    15           1          1         15
01-JAN-99                    15           1          1         15
22-JAN-99                    15           1          1         15
29-JAN-99                    15           1          1         15
05-JAN-99                    15           1          1         15
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8676"></a>
<div class="props_rev_3"><a id="GUID-42E2699D-F7C5-4D99-8224-154F3A892633"></a>
<h4 id="DWHSG-GUID-42E2699D-F7C5-4D99-8224-154F3A892633" class="sect4">Bottom N Ranking Functions</h4>
<div>
<div class="section">
<p>Bottom N is similar to top N except for the ordering sequence within the rank expression. Using the previous example, you can order <code class="codeph">SUM(s_amount)</code> ascending instead of descending.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8677"></a>
<div class="props_rev_3"><a id="GUID-D79F0C6D-74B6-4EC6-9612-4D3ACB6DED43"></a>
<h4 id="DWHSG-GUID-D79F0C6D-74B6-4EC6-9612-4D3ACB6DED43" class="sect4">CUME_DIST Function</h4>
<div>
<div class="section">
<p><a id="d59823e1065" class="indexterm-anchor"></a><a id="d59823e1067" class="indexterm-anchor"></a>The <code class="codeph">CUME_DIST</code> function (defined as the inverse of percentile in some statistical books) computes the position of a specified value relative to a set of values. The order can be ascending or descending. Ascending is the default. The range of values for <code class="codeph">CUME_DIST</code> is from greater than 0 to 1. To compute the <code class="codeph">CUME_DIST</code> of a value x in a set S of size N, you use the formula:</p>
<pre dir="ltr">CUME_DIST(x) =  number of values in S coming before 
   and including x in the specified order/ N
</pre>
<p>Its syntax is:</p>
<pre dir="ltr">CUME_DIST ( ) OVER ( [query_partition_clause] order_by_clause )
</pre>
<p>The semantics of various options in the <code class="codeph">CUME_DIST</code> function are similar to those in the <code class="codeph">RANK</code> function. The default order is ascending, implying that the lowest value gets the lowest <code class="codeph">CUME_DIST</code> (as all other values come later than this value in the order). <code class="codeph">NULLs</code> are treated the same as they are in the <code class="codeph">RANK</code> function. They are counted toward both the numerator and the denominator as they are treated like non-<code class="codeph">NULL</code> values. The following example finds cumulative distribution of sales by channel within each month:</p>
<pre dir="ltr">SELECT calendar_month_desc AS MONTH, channel_desc,
     TO_CHAR(SUM(amount_sold) , &#39;9,999,999,999&#39;) SALES$,
     CUME_DIST() OVER (PARTITION BY calendar_month_desc ORDER BY
         SUM(amount_sold) ) AS CUME_DIST_BY_CHANNEL
FROM sales, products, customers, times, channels
WHERE sales.prod_id=products.prod_id AND sales.cust_id=customers.cust_id
  AND sales.time_id=times.time_id AND sales.channel_id=channels.channel_id
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-07&#39;,&#39;2000-08&#39;)
GROUP BY calendar_month_desc, channel_desc;

MONTH    CHANNEL_DESC         SALES$         CUME_DIST_BY_CHANNEL
-------- -------------------- -------------- --------------------
2000-07  Internet                    140,423           .333333333
2000-07  Partners                    611,064           .666666667
2000-07  Direct Sales              1,145,275                    1
2000-08  Internet                    215,107           .333333333
2000-08  Partners                    661,045           .666666667
2000-08  Direct Sales              1,236,104                    1
2000-09  Internet                    228,241           .333333333
2000-09  Partners                    666,172           .666666667
2000-09  Direct Sales              1,217,808                    1
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8678"></a>
<div class="props_rev_3"><a id="GUID-76DD07EA-4C7D-496C-8567-42781568AEE5"></a>
<h4 id="DWHSG-GUID-76DD07EA-4C7D-496C-8567-42781568AEE5" class="sect4">PERCENT_RANK Function</h4>
<div>
<div class="section">
<p><code class="codeph">PERCENT_RANK</code> is similar to <code class="codeph">CUME_DIST</code>, but it uses rank values rather than row counts in its numerator. Therefore, it returns the percent rank of a value relative to a group of values. The function is available in many popular spreadsheets. <code class="codeph">PERCENT_RANK</code> of a row is calculated as:</p>
<pre dir="ltr">(rank of row in its partition - 1) / (number of rows in the partition - 1)
</pre>
<p><code class="codeph">PERCENT_RANK</code> returns values in the range zero to one. The row(s) with a rank of 1 will have a <code class="codeph">PERCENT_RANK</code> of zero. Its syntax is:</p>
<pre dir="ltr">PERCENT_RANK () OVER ([query_partition_clause] order_by_clause)
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8679"></a>
<div class="props_rev_3"><a id="GUID-E1759E5F-4349-4092-BD4C-52238E400AF0"></a>
<h4 id="DWHSG-GUID-E1759E5F-4349-4092-BD4C-52238E400AF0" class="sect4">NTILE Function</h4>
<div>
<div class="section">
<p><code class="codeph">NTILE</code> allows easy calculation of tertiles, quartiles, deciles and other common summary statistics. This function divides an ordered partition into a specified number of groups called <span class="bold">buckets</span> and assigns a bucket number to each row in the partition. <code class="codeph">NTILE</code> is a very useful calculation because it lets users divide a data set into fourths, thirds, and other groupings.</p>
<p>The buckets are calculated so that each bucket has exactly the same number of rows assigned to it or at most 1 row more than the others. For instance, if you have 100 rows in a partition and ask for an <code class="codeph">NTILE</code> function with four buckets, 25 rows will be assigned a value of 1, 25 rows will have value 2, and so on. These buckets are referred to as equiheight buckets.</p>
<p>If the number of rows in the partition does not divide evenly (without a remainder) into the number of buckets, then the number of rows assigned for each bucket will differ by one at most. The extra rows will be distributed one for each bucket starting from the lowest bucket number. For instance, if there are 103 rows in a partition which has an <code class="codeph">NTILE(5)</code> function, the first 21 rows will be in the first bucket, the next 21 in the second bucket, the next 21 in the third bucket, the next 20 in the fourth bucket and the final 20 in the fifth bucket.</p>
<p>The <code class="codeph">NTILE</code> function has the following syntax:</p>
<pre dir="ltr">NTILE (expr) OVER ([query_partition_clause] order_by_clause)
</pre>
<p>In this, the N in <code class="codeph">NTILE(N)</code> can be a constant (for example, 5) or an expression.</p>
<p>This function, like <code class="codeph">RANK</code> and <code class="codeph">CUME_DIST</code>, has a <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause for per group computation, an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause for specifying the measures and their sort order, and <code class="codeph">NULLS</code> <code class="codeph">FIRST</code> | <code class="codeph">NULLS</code> <code class="codeph">LAST</code> clause for the specific treatment of <code class="codeph">NULLs</code>. For example, the following is an example assigning each month&#39;s sales total into one of four buckets:</p>
<pre dir="ltr">SELECT calendar_month_desc AS MONTH , TO_CHAR(SUM(amount_sold),
 &#39;9,999,999,999&#39;)
 SALES$, NTILE(4) OVER (ORDER BY SUM(amount_sold)) AS TILE4
FROM sales, products, customers, times, channels
WHERE sales.prod_id=products.prod_id AND sales.cust_id=customers.cust_id
  AND sales.time_id=times.time_id AND sales.channel_id=channels.channel_id
  AND times.calendar_year=2000 AND prod_category= &#39;Electronics&#39;
GROUP BY calendar_month_desc;

MONTH    SALES$              TILE4
-------- -------------- ----------
2000-02         242,416          1
2000-01         257,286          1
2000-03         280,011          1
2000-06         315,951          2
2000-05         316,824          2
2000-04         318,106          2
2000-07         433,824          3
2000-08         477,833          3
2000-12         553,534          3
2000-10         652,225          4
2000-11         661,147          4
2000-09         691,449          4
</pre>
<p><code class="codeph">NTILE</code> <code class="codeph">ORDER</code> <code class="codeph">BY</code> statements must be fully specified to yield reproducible results. Equal values can get distributed across adjacent buckets. To ensure deterministic results, you must order on a unique key.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8681"></a><a id="DWHSG8680"></a>
<div class="props_rev_3"><a id="GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E"></a>
<h4 id="DWHSG-GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E" class="sect4">ROW_NUMBER Function</h4>
<div>
<div class="section">
<p><a id="d59823e1277" class="indexterm-anchor"></a><a id="d59823e1279" class="indexterm-anchor"></a>The <code class="codeph">ROW_NUMBER</code> function assigns a unique number (sequentially, starting from 1, as defined by <code class="codeph">ORDER</code> <code class="codeph">BY</code>) to each row within the partition. It has the following syntax:</p>
<pre dir="ltr">ROW_NUMBER ( ) OVER ( [query_partition_clause] order_by_clause )
</pre></div>
<!-- class="section" -->
<div class="example" id="GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E__GUID-39C2514C-3DDB-4ED9-802E-A48EE051C008">
<p class="titleinexample">Example 18-6 ROW_NUMBER</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc,
   TO_CHAR(TRUNC(SUM(amount_sold), -5), &#39;9,999,999,999&#39;) SALES$,
   ROW_NUMBER() OVER (ORDER BY TRUNC(SUM(amount_sold), -6) DESC) AS ROW_NUMBER 
FROM sales, products, customers, times, channels
WHERE sales.prod_id=products.prod_id AND sales.cust_id=customers.cust_id
  AND sales.time_id=times.time_id AND sales.channel_id=channels.channel_id
  AND times.calendar_month_desc IN (&#39;2001-09&#39;, &#39;2001-10&#39;)
GROUP BY channel_desc, calendar_month_desc;

CHANNEL_DESC         CALENDAR SALES$         ROW_NUMBER
-------------------- -------- -------------- ----------
Direct Sales         2001-10       1,000,000          1
Direct Sales         2001-09       1,100,000          2
Internet             2001-09         500,000          3
Partners             2001-09         600,000          4
Partners             2001-10         600,000          5
Internet             2001-10         700,000          6
</pre>
<p>Note that there are three pairs of tie values in these results. Like <code class="codeph">NTILE</code>, <code class="codeph">ROW_NUMBER</code> is a non-deterministic function, so each tied value could have its row number switched. To ensure deterministic results, you must order on a unique key. Inmost cases, that will require adding a new tie breaker column to the query and using it in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> specification.</p>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG0202"></a>
<div class="props_rev_3"><a id="GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A"></a>
<h3 id="DWHSG-GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A" class="sect3">Windowing Functions</h3>
<div>
<div class="section">
<p><a id="d59823e1336" class="indexterm-anchor"></a><a id="d59823e1340" class="indexterm-anchor"></a>Windowing functions can be used to compute cumulative, moving, and centered aggregates. They return a value for each row in the table, which depends on other rows in the corresponding window. With windowing aggregate functions, you can calculate moving and cumulative versions of <code class="codeph">SUM</code>, <code class="codeph">AVERAGE</code>, <code class="codeph">COUNT</code>, <code class="codeph">MAX</code>, <code class="codeph">MIN</code>, and many more functions. They can be used only in the <code class="codeph">SELECT</code> and <code class="codeph">ORDER</code> <code class="codeph">BY</code> clauses of the query. Windowing aggregate functions include the convenient <code class="codeph">FIRST_VALUE</code>, which returns the first value in the window; and <code class="codeph">LAST_VALUE</code>, which returns the last value in the window. These functions provide access to more than one row of a table without a self-join. The syntax of the windowing functions is:</p>
<pre dir="ltr">analytic_function([ arguments ])
   OVER (analytic_clause)

 where analytic_clause =
     [ query_partition_clause ]
     [ order_by_clause [ windowing_clause ] ]

and query_partition_clause =
    PARTITION BY
      { value_expr[, value_expr ]...
      }

 and windowing_clause =
     { ROWS | RANGE }
     { BETWEEN
       { UNBOUNDED PRECEDING
     | CURRENT ROW
     | value_expr { PRECEDING | FOLLOWING }
     } 
     AND
     { UNBOUNDED FOLLOWING
     | CURRENT ROW
     | value_expr { PRECEDING | FOLLOWING }
     }
   | { UNBOUNDED PRECEDING
     | CURRENT ROW
     | value_expr PRECEDING
     }
   }
</pre>
<p>Note that the <code class="codeph">DISTINCT</code> keyword is not supported in windowing functions except for <code class="codeph">MAX</code> and <code class="codeph">MIN</code>.</p>
<div class="infoboxnotealso" id="GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A__GUID-9F0A2D2B-E079-4A21-8026-53C1AA023739">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF20035" target="_blank" href="../SQLRF/functions003.htm#SQLRF20035"><span class="italic">Oracle Database SQL Language Reference</span></a> for further information regarding syntax and restrictions</p>
</div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-9560E5D5-DC77-4BAD-B880-4890651B9FCB">About Treatment of NULLs as Input to Window Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E">Windowing Functions with Logical Offset</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-DB530439-EC98-4F18-A08B-EA372D788CBE">Centered Aggregate Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B">Windowing Aggregate Functions in the Presence of Duplicates</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-D5B46A71-26DA-4E3A-B289-944DED263A62">Varying Window Size for Each Row</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2">Windowing Aggregate Functions with Physical Offsets</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8682"></a>
<div class="props_rev_3"><a id="GUID-9560E5D5-DC77-4BAD-B880-4890651B9FCB"></a>
<h4 id="DWHSG-GUID-9560E5D5-DC77-4BAD-B880-4890651B9FCB" class="sect4">About Treatment of NULLs as Input to Window Functions</h4>
<div>
<p>Window functions&#39; <code class="codeph">NULL</code> semantics match the <code class="codeph">NULL</code> semantics for SQL aggregate functions. Other semantics can be obtained by user-defined functions, or by using the <code class="codeph">DECODE</code> or a <code class="codeph">CASE</code> expression within the window function.</p>
</div>
</div>
<a id="DWHSG8684"></a><a id="DWHSG8685"></a><a id="DWHSG8683"></a>
<div class="props_rev_3"><a id="GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E"></a>
<h4 id="DWHSG-GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E" class="sect4">Windowing Functions with Logical Offset</h4>
<div>
<div class="section">
<p>A logical offset can be specified with constants such as <code class="codeph">RANGE 10 PRECEDING</code>, or an expression that evaluates to a constant, or by an interval specification like <code class="codeph">RANGE</code> <code class="codeph">INTERVAL</code> <code class="codeph">N</code> <code class="codeph">DAY</code>/<code class="codeph">MONTH</code>/<code class="codeph">YEAR</code> <code class="codeph">PRECEDING</code> or an expression that evaluates to an interval.</p>
<p>With logical offset, there can only be one expression in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> expression list in the function, with type compatible to <code class="codeph">NUMERIC</code> if offset is numeric, or <code class="codeph">DATE</code> if an interval is specified.</p>
<p>An analytic function that uses the <code class="codeph">RANGE</code> keyword can use multiple sort keys in its <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause if it specifies either of these two windows:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">RANGE</code> <code class="codeph">BETWEEN</code> <code class="codeph">UNBOUNDED</code> <code class="codeph">PRECEDING</code> <code class="codeph">AND</code> <code class="codeph">CURRENT</code> <code class="codeph">ROW</code>. The short form of this is <code class="codeph">RANGE</code> <code class="codeph">UNBOUNDED</code> <code class="codeph">PRECEDING</code>, which can also be used.</p>
</li>
<li>
<p><code class="codeph">RANGE</code> <code class="codeph">BETWEEN</code> <code class="codeph">CURRENT</code> <code class="codeph">ROW</code> <code class="codeph">AND</code> <code class="codeph">UNBOUNDED</code> <code class="codeph">FOLLOWING</code>.</p>
</li>
</ul>
<p>Window boundaries that do not meet these conditions can have only one sort key in the analytic function&#39;s <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E__GUID-4CB0EE02-AA9F-42D9-8F1B-2CD477496CD9">
<p class="titleinexample">Example 18-7 Cumulative Aggregate Function</p>
<p>The following is an example of cumulative <code class="codeph">amount_sold</code> by customer ID by quarter in 2000:</p>
<pre dir="ltr">SELECT c.cust_id, t.calendar_quarter_desc, TO_CHAR (SUM(amount_sold),
  &#39;9,999,999,999.99&#39;) AS Q_SALES, TO_CHAR(SUM(SUM(amount_sold))
OVER (PARTITION BY c.cust_id ORDER BY c.cust_id, t.calendar_quarter_desc
ROWS UNBOUNDED
PRECEDING), &#39;9,999,999,999.99&#39;) AS CUM_SALES
  FROM sales s, times t, customers c
  WHERE s.time_id=t.time_id AND s.cust_id=c.cust_id AND t.calendar_year=2000
    AND c.cust_id IN (2595, 9646, 11111)
  GROUP BY c.cust_id, t.calendar_quarter_desc
  ORDER BY c.cust_id, t.calendar_quarter_desc;

   CUST_ID CALENDA Q_SALES           CUM_SALES
---------- ------- ----------------- -----------------
      2595 2000-01            659.92            659.92
      2595 2000-02            224.79            884.71
      2595 2000-03            313.90          1,198.61
      2595 2000-04          6,015.08          7,213.69
      9646 2000-01          1,337.09          1,337.09
      9646 2000-02            185.67          1,522.76
      9646 2000-03            203.86          1,726.62
      9646 2000-04            458.29          2,184.91
     11111 2000-01             43.18             43.18
     11111 2000-02             33.33             76.51
     11111 2000-03            579.73            656.24
     11111 2000-04            307.58            963.82
</pre>
<p>In this example, the analytic function <code class="codeph">SUM</code> defines, for each row, a window that starts at the beginning of the partition (<code class="codeph">UNBOUNDED</code> <code class="codeph">PRECEDING</code>) and ends, by default, at the current row.</p>
<p>Nested <code class="codeph">SUM</code>s are needed in this example because you are performing a <code class="codeph">SUM</code> over a value that is itself a <code class="codeph">SUM</code>. Nested aggregations are used very often in analytic aggregate functions.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E__GUID-3AEC98E2-1872-4B74-A755-B6E1AFCB6AA1">
<p class="titleinexample">Example 18-8 Moving Aggregate Function</p>
<p>This example of a time-based window shows, for one customer, the moving average of sales for the current month and preceding two months:</p>
<pre dir="ltr">SELECT c.cust_id, t.calendar_month_desc, TO_CHAR (SUM(amount_sold), 
      &#39;9,999,999,999&#39;) AS SALES, TO_CHAR(AVG(SUM(amount_sold))
OVER (ORDER BY c.cust_id, t.calendar_month_desc ROWS 2 PRECEDING),
      &#39;9,999,999,999&#39;) AS MOVING_3_MONTH_AVG
FROM sales s, times t, customers c
WHERE s.time_id=t.time_id AND s.cust_id=c.cust_id
   AND t.calendar_year=1999 AND c.cust_id IN (6510)
GROUP BY c.cust_id, t.calendar_month_desc
ORDER BY c.cust_id, t.calendar_month_desc; 

   CUST_ID CALENDAR SALES          MOVING_3_MONTH
---------- -------- -------------- --------------
      6510 1999-04             125            125
      6510 1999-05           3,395          1,760
      6510 1999-06           4,080          2,533
      6510 1999-07           6,435          4,637
      6510 1999-08           5,105          5,207
      6510 1999-09           4,676          5,405
      6510 1999-10           5,109          4,963
      6510 1999-11             802          3,529
</pre>
<p>Note that the first two rows for the three month moving average calculation in the output data are based on a smaller interval size than specified because the window calculation cannot reach past the data retrieved by the query. You must consider the different window sizes found at the borders of result sets. In other words, you may need to modify the query to include exactly what you want.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8687"></a><a id="DWHSG8686"></a>
<div class="props_rev_3"><a id="GUID-DB530439-EC98-4F18-A08B-EA372D788CBE"></a>
<h4 id="DWHSG-GUID-DB530439-EC98-4F18-A08B-EA372D788CBE" class="sect4">Centered Aggregate Function</h4>
<div>
<div class="section">
<p>Calculating windowing aggregate functions centered around the current row is straightforward. This example computes for all customers a centered moving average of sales for one week in late December 1999. It finds an average of the sales total for the one day preceding the current row and one day following the current row including the current row as well.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-DB530439-EC98-4F18-A08B-EA372D788CBE__GUID-36104FDE-9CB2-431A-8C00-50C6AAFCCEF5">
<p class="titleinexample">Example 18-9 Centered Aggregate</p>
<pre dir="ltr">SELECT t.time_id, TO_CHAR (SUM(amount_sold), &#39;9,999,999,999&#39;)
AS SALES, TO_CHAR(AVG(SUM(amount_sold)) OVER
  (ORDER BY t.time_id
   RANGE BETWEEN INTERVAL &#39;1&#39; DAY PRECEDING AND
   INTERVAL &#39;1&#39; DAY FOLLOWING), &#39;9,999,999,999&#39;) AS CENTERED_3_DAY_AVG
   FROM sales s, times t
   WHERE s.time_id=t.time_id AND t.calendar_week_number IN (51)
     AND calendar_year=1999
   GROUP BY t.time_id
   ORDER BY t.time_id;

TIME_ID   SALES          CENTERED_3_DAY
--------- -------------- --------------
20-DEC-99        134,337        106,676
21-DEC-99         79,015        102,539
22-DEC-99         94,264         85,342
23-DEC-99         82,746         93,322
24-DEC-99        102,957         82,937
25-DEC-99         63,107         87,062
26-DEC-99         95,123         79,115
</pre>
<p>The starting and ending rows for each product&#39;s centered moving average calculation in the output data are based on just two days, because the window calculation cannot reach past the data retrieved by the query. As in the prior example, you must consider the different window sizes found at the borders of result sets: the query may need to be adjusted.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8689"></a><a id="DWHSG8688"></a>
<div class="props_rev_3"><a id="GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B"></a>
<h4 id="DWHSG-GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B" class="sect4">Windowing Aggregate Functions in the Presence of Duplicates</h4>
<div>
<div class="section">
<p>The following example illustrates how window aggregate functions compute values when there are duplicates, that is, when multiple rows are returned for a single ordering value. The query retrieves the quantity sold to several customers during a specified time range. (Although an inline view was used to define the base data set, it has no special significance and can be ignored.) The query defines a moving window that runs from the date of the current row to 10 days earlier.Note that the <code class="codeph">RANGE</code> keyword is used to define the windowing clause of this example. This means that the window can potentially hold many rows for each value in the range. In this case, there are three pairs of rows with duplicate date values.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B__GUID-AB01C7FE-431C-430F-9376-A5BFDB442CFE">
<p class="titleinexample">Example 18-10 Windowing Aggregate Functions with Logical Offsets</p>
<pre dir="ltr">SELECT time_id, daily_sum, SUM(daily_sum) OVER (ORDER BY time_id
RANGE BETWEEN INTERVAL &#39;10&#39; DAY PRECEDING AND CURRENT ROW)
AS current_group_sum
FROM (SELECT time_id, channel_id, SUM(s.quantity_sold)
AS daily_sum
FROM customers c, sales s, countries
WHERE c.cust_id=s.cust_id
  AND c.country_id = countries.country_id
  AND s.cust_id IN (638, 634, 753, 440 ) AND s.time_id BETWEEN &#39;01-MAY-00&#39;
  AND &#39;13-MAY-00&#39; GROUP BY time_id, channel_id);

TIME_ID    DAILY_SUM CURRENT_GROUP_SUM
--------- ---------- -----------------
06-MAY-00          7                 7   /* 7 */
10-MAY-00          1                 9   /* 7 + (1+1) */
10-MAY-00          1                 9   /* 7 + (1+1) */
11-MAY-00          2                15   /* 7 + (1+1) + (2+4) */
11-MAY-00          4                15   /* 7 + (1+1) + (2+4) */
12-MAY-00          1                16   /* 7 + (1+1) + (2+4) + 1 */
13-MAY-00          2                23   /* 7 + (1+1) + (2+4) + 1 + (5+2) */
13-MAY-00          5                23   /* 7 + (1+1) + (2+4) + 1 + (5+2) */
</pre>
<p>In the output of this example, all dates except May 6 and May 12 return two rows. Examine the commented numbers to the right of the output to see how the values are calculated. Note that each group in parentheses represents the values returned for a single day.</p>
<p>Note that this example applies only when you use the <code class="codeph">RANGE</code> keyword rather than the <code class="codeph">ROWS</code> keyword. It is also important to remember that with <code class="codeph">RANGE</code>, you can only use 1 <code class="codeph">ORDER</code> <code class="codeph">BY</code> expression in the analytic function&#39;s <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause. With the <code class="codeph">ROWS</code> keyword, you can use multiple order by expressions in the analytic function&#39;s <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8690"></a>
<div class="props_rev_3"><a id="GUID-D5B46A71-26DA-4E3A-B289-944DED263A62"></a>
<h4 id="DWHSG-GUID-D5B46A71-26DA-4E3A-B289-944DED263A62" class="sect4">Varying Window Size for Each Row</h4>
<div>
<div class="section">
<p>There are situations where it is useful to vary the size of a window for each row, based on a specified condition. For instance, you may want to make the window larger for certain dates and smaller for others. Assume that you want to calculate the moving average of stock price over three working days. If you have an equal number of rows for each day for all working days and no non-working days are stored, then you can use a physical window function. However, if the conditions noted are not met, you can still calculate a moving average by using an expression in the window size parameters.</p>
<p>Expressions in a window size specification can be made in several different sources. the expression could be a reference to a column in a table, such as a time table. It could also be a function that returns the appropriate boundary for the window based on values in the current row. The following statement for a hypothetical stock price database uses a user-defined function in its <code class="codeph">RANGE</code> clause to set window size:</p>
<pre dir="ltr">SELECT t_timekey, AVG(stock_price)
        OVER (ORDER BY t_timekey RANGE fn(t_timekey) PRECEDING) av_price
FROM stock, time WHERE st_timekey = t_timekey
ORDER BY t_timekey;
</pre>
<p>In this statement, <code class="codeph">t_timekey</code> is a date field. Here, <span class="italic">fn</span> could be a PL/SQL function with the following specification:</p>
<p><code class="codeph">fn(t_timekey)</code> returns</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>4 if <code class="codeph">t_timekey</code> is Monday, Tuesday</p>
</li>
<li>
<p>2 otherwise</p>
</li>
<li>
<p>If any of the previous days are holidays, it adjusts the count appropriately.</p>
</li>
</ul>
<p>Note that, when window is specified using a number in a window function with <code class="codeph">ORDER</code> <code class="codeph">BY</code> on a date column, then it is converted to mean the number of days. You could have also used the interval literal conversion function, as <code class="codeph">NUMTODSINTERVAL(fn(t_timekey), &#39;DAY&#39;)</code> instead of just <code class="codeph">fn(t_timekey)</code> to mean the same thing. You can also write a PL/SQL function that returns an <code class="codeph">INTERVAL</code> data type value.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8692"></a><a id="DWHSG8691"></a>
<div class="props_rev_3"><a id="GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2"></a>
<h4 id="DWHSG-GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2" class="sect4">Windowing Aggregate Functions with Physical Offsets</h4>
<div>
<div class="section">
<p>For windows expressed in rows, the ordering expressions should be unique to produce deterministic results. For example, the following query is not deterministic because <code class="codeph">time_id</code> is not unique in this result set.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2__GUID-AC76735B-6017-4C4E-AA59-791D20DC0215">
<p class="titleinexample">Example 18-11 Windowing Aggregate Functions With Physical Offsets</p>
<pre dir="ltr">SELECT t.time_id, TO_CHAR(amount_sold, &#39;9,999,999,999&#39;) AS INDIV_SALE,
       TO_CHAR(SUM(amount_sold) OVER (PARTITION BY t.time_id ORDER BY t.time_id
ROWS UNBOUNDED PRECEDING), &#39;9,999,999,999&#39;) AS CUM_SALES
FROM sales s, times t, customers c
WHERE s.time_id=t.time_id AND s.cust_id=c.cust_id
  AND t.time_id IN 
   (TO_DATE(&#39;11-DEC-1999&#39;), TO_DATE(&#39;12-DEC-1999&#39;)) 
  AND c.cust_id 
BETWEEN 6500 AND 6600
ORDER BY t.time_id;

TIME_ID   INDIV_SALE    CUM_SALES
--------- ----------    ---------
12-DEC-99         23           23
12-DEC-99          9           32
12-DEC-99         14           46
12-DEC-99         24           70
12-DEC-99         19           89
</pre>
<p>One way to handle this problem would be to add the <code class="codeph">prod_id</code> column to the result set and order on both <code class="codeph">time_id</code> and <code class="codeph">prod_id</code>.</p>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8693"></a><a id="DWHSG0203"></a>
<div class="props_rev_3"><a id="GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A"></a>
<h3 id="DWHSG-GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A" class="sect3">Reporting Functions</h3>
<div>
<p><a id="d59823e1883" class="indexterm-anchor"></a><a id="d59823e1885" class="indexterm-anchor"></a>After a query has been processed, aggregate values like the number of resulting rows or an average value in a column can be easily computed within a partition and made available to other reporting functions. Reporting aggregate functions return the same aggregate value for every row in a partition. Their behavior with respect to <code class="codeph">NULLs</code> is the same as the SQL aggregate functions. The syntax is:</p>
<pre dir="ltr">{SUM | AVG | MAX | MIN | COUNT | STDDEV | VARIANCE  ... } 
  ([ALL | DISTINCT] {<span class="italic">value expression1</span> [,...] | *})
   OVER ([PARTITION BY <span class="italic">value expression2</span>[,...]])
</pre>
<p>In addition, the following conditions apply:</p>
<ul style="list-style-type: disc;">
<li>
<p>An asterisk (*) is only allowed in <code class="codeph">COUNT(*)</code></p>
</li>
<li>
<p><code class="codeph">DISTINCT</code> is supported only if corresponding aggregate functions allow it.</p>
</li>
<li>
<p><span class="italic"><code class="codeph">value expression1</code></span> and <span class="italic"><code class="codeph">value expression2</code></span> can be any valid expression involving column references or aggregates.</p>
</li>
<li>
<p>The <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause defines the groups on which the windowing functions would be computed. If the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause is absent, then the function is computed over the whole query result set.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A__GUID-C88C8282-58FB-4D9C-AC63-33B2EAABEF71">
<p class="notep1">See Also:</p>
<p><a href="analysis.htm#GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7">RATIO_TO_REPORT Function</a></p>
</div>
<p>Reporting functions can appear only in the <code class="codeph">SELECT</code> clause or the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause. The major benefit of reporting functions is their ability to do multiple passes of data in a single query block and speed up query performance. Queries such as &#34;Count the number of salesmen with sales more than 10% of city sales&#34; do not require joins between separate query blocks.</p>
<p>For example, consider the question &#34;For each product category, find the region in which it had maximum sales&#34;. The equivalent SQL query using the <code class="codeph">MAX</code> reporting aggregate function would be:</p>
<pre dir="ltr">SELECT prod_category, country_region, sales
FROM (SELECT SUBSTR(p.prod_category,1,8) AS prod_category, co.country_region,
 SUM(amount_sold) AS sales,
MAX(SUM(amount_sold)) OVER (PARTITION BY prod_category) AS MAX_REG_SALES
FROM sales s, customers c, countries co, products p
WHERE s.cust_id=c.cust_id AND c.country_id=co.country_id
   AND s.prod_id =p.prod_id AND s.time_id = TO_DATE(&#39;11-OCT-2001&#39;)
GROUP BY prod_category, country_region)
WHERE sales = MAX_REG_SALES;
</pre>
<p>The inner query with the reporting aggregate function <code class="codeph">MAX(SUM(amount_sold))</code> returns:</p>
<pre dir="ltr">PROD_CAT COUNTRY_REGION            SALES MAX_REG_SALES
-------- -------------------- ---------- -------------
Electron Americas                 581.92        581.92
Hardware Americas                 925.93        925.93
Peripher Americas                3084.48       4290.38
Peripher Asia                    2616.51       4290.38
Peripher Europe                  4290.38       4290.38
Peripher Oceania                  940.43       4290.38
Software Americas                 4445.7        4445.7
Software Asia                    1408.19        4445.7
Software Europe                  3288.83        4445.7
Software Oceania                  890.25        4445.7
</pre>
<p>The full query results are:</p>
<pre dir="ltr">PROD_CAT COUNTRY_REGION            SALES
-------- -------------------- ----------
Electron Americas                 581.92
Hardware Americas                 925.93
Peripher Europe                  4290.38
Software Americas                 4445.7
</pre>
<div class="example" id="GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A__GUID-C64EE719-E3B7-4EEF-83C0-989BDD402B84">
<p class="titleinexample">Example 18-12 Reporting Aggregate Example</p>
<p>Reporting aggregates combined with nested queries enable you to answer complex queries efficiently. For example, what if you want to know the best selling products in your most significant product subcategories? The following is a query which finds the 5 top-selling products for each product subcategory that contributes more than 20% of the sales within its product category:</p>
<pre dir="ltr">SELECT SUBSTR(prod_category,1,8) AS CATEG, prod_subcategory, prod_id, SALES 
FROM (SELECT p.prod_category, p.prod_subcategory, p.prod_id,
      SUM(amount_sold) AS SALES,
      SUM(SUM(amount_sold)) OVER (PARTITION BY p.prod_category) AS CAT_SALES,
      SUM(SUM(amount_sold)) OVER 
         (PARTITION BY p.prod_subcategory) AS SUBCAT_SALES,
      RANK() OVER  (PARTITION BY p.prod_subcategory  
         ORDER BY SUM(amount_sold) ) AS RANK_IN_LINE
     FROM sales s, customers c, countries co, products p 
     WHERE s.cust_id=c.cust_id
       AND c.country_id=co.country_id AND  s.prod_id=p.prod_id
       AND s.time_id=to_DATE(&#39;11-OCT-2000&#39;)
     GROUP BY p.prod_category, p.prod_subcategory, p.prod_id
     ORDER BY prod_category, prod_subcategory) 
  WHERE SUBCAT_SALES&gt;0.2*CAT_SALES AND RANK_IN_LINE&lt;=5;
</pre></div>
<!-- class="example" --></div>
<a id="DWHSG8695"></a><a id="DWHSG8694"></a>
<div class="props_rev_3"><a id="GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7"></a>
<h4 id="DWHSG-GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7" class="sect4">RATIO_TO_REPORT Function</h4>
<div>
<div class="section">
<p><a id="d59823e2004" class="indexterm-anchor"></a><a id="d59823e2006" class="indexterm-anchor"></a>The <code class="codeph">RATIO_TO_REPORT</code> function computes the ratio of a value to the sum of a set of values. If the expression <code class="codeph">value</code> <code class="codeph">expression</code> evaluates to <code class="codeph">NULL</code>, <code class="codeph">RATIO_TO_REPORT</code> also evaluates to <code class="codeph">NULL</code>, but it is treated as zero for computing the sum of values for the denominator. Its syntax is:</p>
<pre dir="ltr">RATIO_TO_REPORT ( expr ) OVER ( [query_partition_clause] )
</pre>
<p>In this, the following applies:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">expr</code> can be any valid expression involving column references or aggregates.</p>
</li>
<li>
<p>The <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause defines the groups on which the <code class="codeph">RATIO_TO_REPORT</code> function is to be computed. If the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause is absent, then the function is computed over the whole query result set.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="example" id="GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7__GUID-4421F058-F21E-4714-941B-9E5C2D9B177E">
<p class="titleinexample">Example 18-13 RATIO_TO_REPORT</p>
<p>To calculate <code class="codeph">RATIO_TO_REPORT</code> of sales for each channel, you might use the following syntax:</p>
<pre dir="ltr">SELECT ch.channel_desc, TO_CHAR(SUM(amount_sold),&#39;9,999,999&#39;) AS SALES,
     TO_CHAR(SUM(SUM(amount_sold)) OVER (), &#39;9,999,999&#39;) AS TOTAL_SALES,
     TO_CHAR(RATIO_TO_REPORT(SUM(amount_sold)) OVER (), &#39;9.999&#39;)
     AS RATIO_TO_REPORT
FROM sales s, channels ch 
WHERE s.channel_id=ch.channel_id  AND s.time_id=to_DATE(&#39;11-OCT-2000&#39;)
GROUP BY ch.channel_desc;

CHANNEL_DESC         SALES      TOTAL_SALE RATIO_
-------------------- ---------- ---------- ------
Direct Sales             14,447     23,183   .623
Internet                    345     23,183   .015
Partners                  8,391     23,183   .362
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG0204"></a>
<div class="props_rev_3"><a id="GUID-4A7CC941-78D4-4A1C-98EC-DA548E1FD394"></a>
<h3 id="DWHSG-GUID-4A7CC941-78D4-4A1C-98EC-DA548E1FD394" class="sect3">LAG/LEAD Functions</h3>
<div>
<p><a id="d59823e2089" class="indexterm-anchor"></a><a id="d59823e2091" class="indexterm-anchor"></a>The <code class="codeph">LAG</code> and <code class="codeph">LEAD</code> functions are useful for comparing values when the relative positions of rows can be known reliably. They work by specifying the count of rows which separate the target row from the current row. Because the functions provide access to more than one row of a table at the same time without a self-join, they can enhance processing speed. The <code class="codeph">LAG</code> function provides access to a row at a given offset prior to the current position, and the <code class="codeph">LEAD</code> function provides access to a row at a given offset after the current position. <span class="q">&#34;<a href="analysis.htm#GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596">LAG/LEAD Syntax</a>&#34;</span> describes the syntax of these functions.</p>
<p>The <code class="codeph">LAG</code> and <code class="codeph">LEAD</code> functions can be thought of as being related to, and a simplification of, the <code class="codeph">NTH_VALUE</code> function. With <code class="codeph">LAG</code> and <code class="codeph">LEAD</code>, you can only retrieve values from a row at the specified physical offset. If this is insufficient, you can use <code class="codeph">NTH_VALUE</code>, which enables you to retrieve values from a row based on what is called a logical offset or relative position. You can use the <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> option with the <code class="codeph">NTH_VALUE</code> function to make it more useful, in the sense that you can specify conditions and filter out rows based on certain conditions. See <a href="analysis.htm#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189__BCFIBFFI">Example 18-17</a>, where rows with quantities less than eight are filtered out. This cannot be done with <code class="codeph">LAG</code> or <code class="codeph">LEAD</code>, as you would not know the offset to the row.</p>
<p>See <span class="q">&#34;<a href="analysis.htm#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189">NTH_VALUE Function</a>&#34;</span> and <a class="olink SQLRF30031" target="_blank" href="../SQLRF/functions126.htm#SQLRF30031"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
</div>
<a id="DWHSG8697"></a><a id="DWHSG8698"></a><a id="DWHSG8696"></a>
<div class="props_rev_3"><a id="GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596"></a>
<h4 id="DWHSG-GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596" class="sect4">LAG/LEAD Syntax</h4>
<div>
<div class="section">
<p>These functions have the following syntax:</p>
<pre dir="ltr">{LAG | LEAD} ( value_expr [, offset] [, default] ) [RESPECT NULLS|IGNORE NULLS]
   OVER ( [query_partition_clause] order_by_clause )
</pre>
<p><span class="italic"><code class="codeph">offset</code></span> is an optional parameter and defaults to 1. <span class="italic"><code class="codeph">default</code></span> is an optional parameter and is the value returned if <span class="italic"><code class="codeph">offset</code></span> falls outside the bounds of the table or partition. When <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> is specified, the value returned will be from a row at a specified lag or lead offset after ignoring rows with NULLs.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596__GUID-871C606E-C50E-4F91-8CCC-1CCE83C8FAA6">
<p class="titleinexample">Example 18-14 LAG/LEAD</p>
<p>This example illustrates a typical case of using <code class="codeph">LAG</code> and <code class="codeph">LEAD</code>:</p>
<pre dir="ltr">SELECT time_id, TO_CHAR(SUM(amount_sold),&#39;9,999,999&#39;) AS SALES, 
  TO_CHAR(LAG(SUM(amount_sold),1) OVER (ORDER BY time_id),&#39;9,999,999&#39;) AS LAG1,
  TO_CHAR(LEAD(SUM(amount_sold),1) OVER (ORDER BY time_id),&#39;9,999,999&#39;) AS LEAD1
FROM sales
WHERE time_id&gt;=TO_DATE(&#39;10-OCT-2000&#39;) AND time_id&lt;=TO_DATE(&#39;14-OCT-2000&#39;)
GROUP BY time_id;

TIME_ID   SALES      LAG1       LEAD1
--------- ---------- ---------- ----------
10-OCT-00    238,479                23,183
11-OCT-00     23,183    238,479     24,616
12-OCT-00     24,616     23,183     76,516
13-OCT-00     76,516     24,616     29,795
14-OCT-00     29,795     76,516
</pre></div>
<!-- class="example" -->
<div class="section">
<p>See <span class="q">&#34;<a href="analysis.htm#GUID-01B5DD6F-C039-4223-B017-263F7788C4FA">Data Densification for Reporting</a>&#34;</span> for information showing how to use the <code class="codeph">LAG</code>/<code class="codeph">LEAD</code> functions for doing period-to-period comparison queries on sparse data.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596__GUID-9B4F20D0-83E1-42BA-8EE9-9C6491921C0D">
<p class="titleinexample">Example 18-15 LAG/LEAD Using IGNORE NULLS</p>
<p>This example illustrates a typical case of using <code class="codeph">LAG</code> and <code class="codeph">LEAD</code> with the <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> option:</p>
<pre dir="ltr">SELECT prod_id, channel_id, SUM(quantity_sold) quantity,
 CASE WHEN SUM(quantity_sold) &lt; 5000 THEN SUM(amount_sold) ELSE NULL END amount,
 LAG(CASE WHEN SUM(quantity_sold) &lt; 5000 THEN SUM(amount_sold) ELSE NULL END)
 IGNORE NULLS OVER (PARTITION BY prod_id ORDER BY channel_id) lag
FROM sales
WHERE prod_id IN (18,127,138)
GROUP BY prod_id, channel_id;

 PROD_ID  CHANNEL_ID  QUANTITY   AMOUNT          LAG
--------  ----------  --------   -----------     ----------
      18           2      2888    4420923.94
      18           3      5615                   4420923.94
      18           4      1088    1545729.81     4420923.94
     127           2      4508     274088.08  
     127           3      9626                    274088.08
     127           4      1850     173682.67      274088.08
     138           2      1120      127390.3       
     138           3      3878     393111.15       127390.3
     138           4       543      71203.21      393111.15

9 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8699"></a>
<div class="props_rev_3"><a id="GUID-B1E8AB97-FFF6-4C5A-BB3C-D54780536C86"></a>
<h3 id="DWHSG-GUID-B1E8AB97-FFF6-4C5A-BB3C-D54780536C86" class="sect3">FIRST_VALUE, LAST_VALUE, and NTH_VALUE Functions</h3>
<div>
<p>This section illustrates the <code class="codeph">FIRST_VALUE</code>, <code class="codeph">LAST_VALUE</code>, and <code class="codeph">NTH_VALUE</code> functions that are described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9">FIRST_VALUE and LAST_VALUE Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189">NTH_VALUE Function</a></p>
</li>
</ul>
</div>
<a id="DWHSG8700"></a><a id="DWHSG02016"></a>
<div class="props_rev_3"><a id="GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9"></a>
<h4 id="DWHSG-GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9" class="sect4">FIRST_VALUE and LAST_VALUE Functions</h4>
<div>
<div class="section">
<p>The <code class="codeph">FIRST_VALUE</code> and <code class="codeph">LAST_VALUE</code> <a id="d59823e2329" class="indexterm-anchor"></a><a id="d59823e2331" class="indexterm-anchor"></a><a id="d59823e2333" class="indexterm-anchor"></a><a id="d59823e2337" class="indexterm-anchor"></a>functions allow you to select the first and last rows from a window. These rows are especially valuable because they are often used as the baselines in calculations. For instance, with a partition holding sales data ordered by day, you might ask &#34;How much was each day&#39;s sales compared to the first sales day (<code class="codeph">FIRST_VALUE</code>) of the period?&#34;</p>
<p>If the <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> option is used with <code class="codeph">FIRST_VALUE</code>, it returns the first non-null value in the set, or <code class="codeph">NULL</code> if all values are <code class="codeph">NULL</code>. If <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> is used with <code class="codeph">LAST_VALUE</code>, it returns the last non-null value in the set, or <code class="codeph">NULL</code> if all values are <code class="codeph">NULL</code>. The <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> option is particularly useful in populating an inventory table properly.</p>
<p>These functions have syntax as follows:</p>
<pre dir="ltr">FIRST_VALUE|LAST_VALUE ( &lt;expr&gt; ) [RESPECT NULLS|IGNORE NULLS] OVER (analytic clause );
</pre></div>
<!-- class="section" -->
<div class="example" id="GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9__GUID-4D7E3C21-F8EE-4CCE-88E3-474C66026470">
<p class="titleinexample">Example 18-16 FIRST_VALUE</p>
<p>This example illustrates using the <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> option with <code class="codeph">FIRST_VALUE</code>:</p>
<pre dir="ltr">SELECT prod_id, channel_id, time_id,
  CASE WHEN MIN(amount_sold) &gt; 9.5 
    THEN MIN(amount_sold) ELSE NULL END amount_sold, 
  FIRST_VALUE(CASE WHEN MIN(amount_sold) &gt; 9.5 
    THEN min(amount_sold) ELSE NULL END) 
    IGNORE NULLS OVER (PARTITION BY prod_id 
                      ORDER BY channel_id DESC, time_id 
                      ROWS BETWEEN UNBOUNDED PRECEDING 
                      AND UNBOUNDED FOLLOWING) nv FROM sales 
                      WHERE prod_id = 115 AND time_id BETWEEN &#39;18-DEC-01&#39; 
                      AND &#39;22-DEC-01&#39; GROUP BY prod_id, channel_id, time_id 
                      ORDER BY prod_id;

  PROD_ID CHANNEL_ID TIME_ID    AMOUNT_SOLD         NV
---------- ---------- --------- ----------- ----------
       115          4 18-DEC-01                   9.66
       115          4 19-DEC-01                   9.66
       115          4 20-DEC-01                   9.66
       115          4 22-DEC-01                   9.66
       115          3 18-DEC-01        9.66       9.66
       115          3 19-DEC-01        9.66       9.66
       115          3 20-DEC-01        9.66       9.66
       115          3 21-DEC-01        9.66       9.66
       115          3 22-DEC-01        9.66       9.66
       115          2 18-DEC-01        9.67       9.66
       115          2 19-DEC-01        9.67       9.66
       115          2 21-DEC-01        9.67       9.66
       115          2 22-DEC-01        9.67       9.66
 
13 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8701"></a><a id="DWHSG02017"></a>
<div class="props_rev_3"><a id="GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189"></a>
<h4 id="DWHSG-GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189" class="sect4">NTH_VALUE Function</h4>
<div>
<div class="section">
<p>The <code class="codeph">NTH_VALUE</code> function enabl<a id="d59823e2432" class="indexterm-anchor"></a><a id="d59823e2434" class="indexterm-anchor"></a>es you to find column values from an arbitrary row in the window. This could be used when, for example, you want to retrieve the 5th highest closing price for a company&#39;s shares during a year.</p>
<p>The <code class="codeph">LAG</code> and <code class="codeph">LEAD</code> functions can be thought of as being related to, and a simplification of, the <code class="codeph">NTH_VALUE</code> function. With <code class="codeph">LAG</code> and <code class="codeph">LEAD</code>, you can only retrieve values from a row at the specified physical offset. If this is insufficient, you can use <code class="codeph">NTH_VALUE</code>, which enables you to retrieve values from a row based on what is called a logical offset or relative position. You can use the <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> option with the <code class="codeph">NTH_VALUE</code>, <code class="codeph">FIRST_VALUE</code>, and <code class="codeph">LAST_VALUE</code> functions to make it more powerful, in the sense that you can specify conditions and filter out rows based on certain conditions. See <a href="analysis.htm#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189__BCFIBFFI">Example 18-17</a>, where rows with quantities less than eight are filtered out. This cannot be done with <code class="codeph">LAG</code> or <code class="codeph">LEAD</code>, as you would not know the offset to the row.</p>
<p>See <a class="olink SQLRF30031" target="_blank" href="../SQLRF/functions126.htm#SQLRF30031"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
<p>This function has syntax as follows:</p>
<pre dir="ltr">NTH_VALUE (&lt;expr&gt;, &lt;n expr&gt;) [FROM FIRST | FROM LAST]
[RESPECT NULLS | IGNORE NULLS] OVER (&lt;window specification&gt;)
</pre>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">expr</code> can be a column, constant, bind variable, or an expression involving them.</p>
</li>
<li>
<p><code class="codeph">n</code> can be a column, constant, bind variable, or an expression involving them.</p>
</li>
<li>
<p><code class="codeph">RESPECT</code> <code class="codeph">NULLS</code> is the default NULL handling mechanism. It determines whether null values of <code class="codeph">expr</code> are included in or eliminated from the calculation. The default is <code class="codeph">RESPECT</code> <code class="codeph">NULLS</code>.</p>
</li>
<li>
<p>The <code class="codeph">FROM</code> <code class="codeph">FIRST</code> and <code class="codeph">FROM</code> <code class="codeph">LAST</code> options determine whether the offset <code class="codeph">n</code> is from the first or last row. The default is <code class="codeph">FROM</code> <code class="codeph">FIRST</code>.</p>
</li>
<li>
<p><code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> enables you to skip NULLs in measure values.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="example" id="GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189__BCFIBFFI">
<p class="titleinexample">Example 18-17 NTH_VALUE</p>
<p>The following example returns the <code class="codeph">amount_sold</code> value of the second <code class="codeph">channel_id</code> in ascending order for each <code class="codeph">prod_id</code> in the range between 10 and 20:</p>
<pre dir="ltr">SELECT prod_id, channel_id, MIN(amount_sold), 
  NTH_VALUE(MIN(amount_sold), 2) OVER (PARTITION BY prod_id ORDER BY channel_id
  ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) NV 
FROM sales
WHERE prod_id BETWEEN 10 AND 20 GROUP BY prod_id, channel_id;

   PROD_ID CHANNEL_ID MIN(AMOUNT_SOLD)         NV
---------- ---------- ---------------- ----------
        13          2           907.34      906.2
        13          3            906.2      906.2
        13          4           842.21      906.2
        14          2          1015.94    1036.72
        14          3          1036.72    1036.72
        14          4           935.79    1036.72
        15          2           871.19     871.19
        15          3           871.19     871.19
        15          4           871.19     871.19
        16          2           266.84     266.84
        16          3           266.84     266.84
        16          4           266.84     266.84
        16          9            11.99     266.84
...
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="DWHSG02015"></a>
<div class="props_rev_3"><a id="GUID-7070D54B-AB82-4FDC-8A38-28D6F4CA5525"></a>
<h2 id="DWHSG-GUID-7070D54B-AB82-4FDC-8A38-28D6F4CA5525" class="sect2">Advanced Aggregates for Analysis</h2>
<div>
<p>This section illustrates the following advanced analytic aggregate functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D">LISTAGG Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-A0B6B93C-F8CB-4BEC-9069-C75C1797D027">FIRST/LAST Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-E93D95F0-867B-4387-8F31-0831D23953DB">Inverse Percentile Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-76DADC19-5E66-4857-99F7-509836BA44D5">Hypothetical Rank Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51">Linear Regression Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-399DBC4B-0CE6-49F7-87F2-5E74D83A1DB0">About Statistical Aggregates</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-04FC38D9-D651-4558-99D3-830255C958AF">About User-Defined Aggregates</a></p>
</li>
</ul>
</div>
<a id="DWHSG8702"></a>
<div class="props_rev_3"><a id="GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D"></a>
<h3 id="DWHSG-GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D" class="sect3">LISTAGG Function</h3>
<div>
<div class="section">
<p>The <code class="codeph">LISTAGG</code> function<a id="d59823e2657" class="indexterm-anchor"></a><a id="d59823e2659" class="indexterm-anchor"></a> orders data within each group based on the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause and then concatenates the values of the measure column. Its syntax is as follows:</p>
<pre dir="ltr">LISTAGG (&lt;expr&gt; [, &lt;delimiter&gt;) WITHIN GROUP (ORDER BY &lt;oby_expression_list&gt;)
</pre>
<p><code class="codeph">expr</code> can be a column, constant, bind variable, or an expression involving them.</p>
<p><code class="codeph">delimiter</code> can be a column, constant, bind variable, or an expression involving them.</p>
<p><code class="codeph">oby_expression_list</code> can be a list of expressions with optional ordering options to sort in ascending or descending order (<code class="codeph">ASC</code> or <code class="codeph">DESC</code>), and to control the sort order of NULLs (<code class="codeph">NULLS</code> <code class="codeph">FIRST</code> or <code class="codeph">NULLS</code> <code class="codeph">LAST</code>). <code class="codeph">ASCENDING</code> and <code class="codeph">NULLS</code> <code class="codeph">LAST</code> are the defaults.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-7198204A-6134-478D-B582-D3F1DCB7FF43">LISTAGG as Aggregate</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-B109E43C-63D9-4079-A24E-AB87DAED0262">LISTAGG as Reporting Aggregate</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8703"></a><a id="DWHSG8954"></a>
<div class="props_rev_3"><a id="GUID-7198204A-6134-478D-B582-D3F1DCB7FF43"></a>
<h4 id="DWHSG-GUID-7198204A-6134-478D-B582-D3F1DCB7FF43" class="sect4">LISTAGG as Aggregate</h4>
<div>
<p>You can use the <code class="codeph">LISTAGG</code> function as an aggregate.</p>
<div class="example" id="GUID-7198204A-6134-478D-B582-D3F1DCB7FF43__GUID-B9BF97CF-C816-408B-924F-5DCD113759F0">
<p class="titleinexample">Example 18-18 LISTAGG as Aggregate</p>
<p>The following example illustrates using <code class="codeph">LISTAGG</code> as an aggregate.</p>
<pre dir="ltr">SELECT prod_id, LISTAGG(cust_first_name||&#39; &#39;||cust_last_name, &#39;; &#39;) 
  WITHIN GROUP (ORDER BY amount_sold DESC) cust_list
FROM sales, customers
WHERE sales.cust_id = customers.cust_id AND cust_gender = &#39;M&#39; 
  AND cust_credit_limit = 15000 AND prod_id BETWEEN 15 AND 18 
  AND channel_id = 2 AND time_id &gt; &#39;01-JAN-01&#39;
GROUP BY prod_id;

PROD_ID  CUST_LIST
-------  -----------------------------------------------
     15  Hope Haarper; Roxanne Crocker; ... Mason Murray
     16  Manvil Austin; Bud Pinkston; ... Helga Nickols
     17  Opal Aaron; Thacher Rudder; ... Roxanne Crocker
     18  Boyd Lin; Bud Pinkston; ... Erik Ready
</pre>
<p>The output has been modified for readability.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8704"></a><a id="DWHSG8955"></a>
<div class="props_rev_3"><a id="GUID-B109E43C-63D9-4079-A24E-AB87DAED0262"></a>
<h4 id="DWHSG-GUID-B109E43C-63D9-4079-A24E-AB87DAED0262" class="sect4">LISTAGG as Reporting Aggregate</h4>
<div>
<p>You can use the <code class="codeph">LISTAGG</code> function as a reporting aggregate.</p>
<div class="example" id="GUID-B109E43C-63D9-4079-A24E-AB87DAED0262__GUID-37B1F930-6441-4068-B1E4-95706D1496FD">
<p class="titleinexample">Example 18-19 LISTAGG as Reporting Aggregate</p>
<p>This example illustrates using <code class="codeph">LISTAGG</code> as a reporting aggregate:</p>
<pre dir="ltr">connect sh/sh
set lines 120 pages 20000
column list format A40

SELECT time_id, prod_id, MIN(amount_sold), LISTAGG(min(amount_sold),&#39;;&#39;) 
WITHIN GROUP (ORDER BY prod_id) OVER (PARTITION BY time_id) cust_list 
FROM sales WHERE time_id &gt; &#39;20-DEC-01&#39; AND prod_id BETWEEN 120 AND 125 
GROUP BY prod_id, time_id;

TIME_ID   PROD_ID   MIN(AMOUNT_SOLD)  CUST_LIST
-------   -------   ----------------  -----------
21-DEC-01     120            51.36    51.36;10.81
21-DEC-01     121            10.81    51.36;10.81
22-DEC-01     120            51.36    51.36;10.81;20.23;56.12;17.79;15.67
22-DEC-01     121            10.81    51.36;10.81;20.23;56.12;17.79;15.67
22-DEC-01     122            20.23    51.36;10.81;20.23;56.12;17.79;15.67
22-DEC-01     123            56.12    51.36;10.81;20.23;56.12;17.79;15.67
22-DEC-01     124            17.79    51.36;10.81;20.23;56.12;17.79;15.67
22-DEC-01     125            15.67    51.36;10.81;20.23;56.12;17.79;15.67
...
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG0205"></a>
<div class="props_rev_3"><a id="GUID-A0B6B93C-F8CB-4BEC-9069-C75C1797D027"></a>
<h3 id="DWHSG-GUID-A0B6B93C-F8CB-4BEC-9069-C75C1797D027" class="sect3">FIRST/LAST Functions</h3>
<div>
<div class="section">
<p><a id="d59823e2821" class="indexterm-anchor"></a><a id="d59823e2823" class="indexterm-anchor"></a>The <code class="codeph">FIRST/LAST</code> aggregate functions allow you to rank a data set and work with its top-ranked or bottom-ranked rows. After finding the top or bottom ranked rows, an aggregate function is applied to any desired column. That is, <code class="codeph">FIRST</code>/<code class="codeph">LAST</code> lets you rank on column A but return the result of an aggregate applied on the first-ranked or last-ranked rows of column B. This is valuable because it avoids the need for a self-join or subquery, thus improving performance. These functions&#39; syntax begins with a regular aggregate function (<code class="codeph">MIN</code>, <code class="codeph">MAX</code>, <code class="codeph">SUM</code>, <code class="codeph">AVG</code>, <code class="codeph">COUNT</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>) that produces a single return value per group. To specify the ranking used, the <code class="codeph">FIRST</code>/<code class="codeph">LAST</code> functions add a new clause starting with the word <code class="codeph">KEEP</code>.</p>
<p>These functions have the following syntax:</p>
<pre dir="ltr">aggregate_function KEEP ( DENSE_RANK FIRST | LAST ORDER BY
  expr [ DESC | ASC ] [NULLS { FIRST | LAST }]
  [, expr [ DESC | ASC ] [NULLS { FIRST | LAST }]]...)
[OVER query_partitioning_clause]
</pre>
<p>Note that the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause can take multiple expressions.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-41554140-82EB-41C0-8FE1-D0C090715727">FIRST/LAST As Regular Aggregates</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E">FIRST/LAST As Reporting Aggregates</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8706"></a><a id="DWHSG8705"></a>
<div class="props_rev_3"><a id="GUID-41554140-82EB-41C0-8FE1-D0C090715727"></a>
<h4 id="DWHSG-GUID-41554140-82EB-41C0-8FE1-D0C090715727" class="sect4">FIRST/LAST As Regular Aggregates</h4>
<div>
<p>You can use the <code class="codeph">FIRST</code>/<code class="codeph">LAST</code> family of aggregates as regular aggregate functions.</p>
<div class="example" id="GUID-41554140-82EB-41C0-8FE1-D0C090715727__i1007076">
<p class="titleinexample">Example 18-20 FIRST/LAST Example 1</p>
<p>The following query lets us compare minimum price and list price of our products. For each product subcategory within the Men&#39;s clothing category, it returns the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>List price of the product with the lowest minimum price</p>
</li>
<li>
<p>Lowest minimum price</p>
</li>
<li>
<p>List price of the product with the highest minimum price</p>
</li>
<li>
<p>Highest minimum price</p>
</li>
</ul>
<pre dir="ltr">SELECT prod_subcategory, MIN(prod_list_price) 
  KEEP (DENSE_RANK FIRST ORDER BY (prod_min_price)) AS LP_OF_LO_MINP,
MIN(prod_min_price) AS LO_MINP,
MAX(prod_list_price) KEEP (DENSE_RANK LAST ORDER BY (prod_min_price))
 AS LP_OF_HI_MINP,
MAX(prod_min_price) AS HI_MINP
FROM products WHERE prod_category=&#39;Electronics&#39;
GROUP BY prod_subcategory;

PROD_SUBCATEGORY LP_OF_LO_MINP LO_MINP  LP_OF_HI_MINP  HI_MINP
---------------- ------------- -------  ------------- ----------
Game Consoles          299.99  299.99          299.99     299.99
Home Audio             499.99  499.99          599.99     599.99
Y Box Accessories        7.99    7.99           20.99      20.99
Y Box Games              7.99    7.99           29.99      29.99
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8708"></a><a id="DWHSG8707"></a>
<div class="props_rev_3"><a id="GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E"></a>
<h4 id="DWHSG-GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E" class="sect4">FIRST/LAST As Reporting Aggregates</h4>
<div>
<p>You can also use the <code class="codeph">FIRST</code>/<code class="codeph">LAST</code> family of aggregates as reporting aggregate functions. An example is calculating which months had the greatest and least increase in head count throughout the year. The syntax for these functions is similar to the syntax for any other reporting aggregate.</p>
<p>Consider the example in <a href="analysis.htm#GUID-41554140-82EB-41C0-8FE1-D0C090715727__i1007076">Example 18-20</a> for <code class="codeph">FIRST/LAST</code>. What if you wanted to find the list prices of individual products and compare them to the list prices of the products in their subcategory that had the highest and lowest minimum prices?</p>
<p>The following query lets us find that information for the Documentation subcategory by using <code class="codeph">FIRST/LAST</code> as reporting aggregates.</p>
<div class="example" id="GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E__GUID-F5C30676-A133-4E8D-9795-1E7006928695">
<p class="titleinexample">Example 18-21 FIRST/LAST Example 2</p>
<pre dir="ltr">SELECT prod_id, prod_list_price,
    MIN(prod_list_price) KEEP (DENSE_RANK FIRST ORDER BY (prod_min_price))
       OVER(PARTITION BY (prod_subcategory)) AS LP_OF_LO_MINP,
    MAX(prod_list_price) KEEP (DENSE_RANK LAST ORDER BY (prod_min_price))
       OVER(PARTITION BY (prod_subcategory)) AS LP_OF_HI_MINP
FROM products WHERE prod_subcategory = &#39;Documentation&#39;;

   PROD_ID PROD_LIST_PRICE LP_OF_LO_MINP LP_OF_HI_MINP
---------- --------------- ------------- -------------
        40           44.99         44.99         44.99
        41           44.99         44.99         44.99
        42           44.99         44.99         44.99
        43           44.99         44.99         44.99
        44           44.99         44.99         44.99
        45           44.99         44.99         44.99
</pre>
<p>Using the <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> functions as reporting aggregates makes it easy to include the results in calculations such as &#34;Salary as a percent of the highest salary.&#34;</p>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG0206"></a>
<div class="props_rev_3"><a id="GUID-E93D95F0-867B-4387-8F31-0831D23953DB"></a>
<h3 id="DWHSG-GUID-E93D95F0-867B-4387-8F31-0831D23953DB" class="sect3">Inverse Percentile Functions</h3>
<div>
<div class="section">
<p>Using the <code class="codeph">CUME_DIST</code> function, you can find the cumulative distribution (percentile) of a set of values. However, the inverse operation (finding what value computes to a certain percentile) is neither easy to do nor efficiently computed. To overcome this difficulty, the <code class="codeph">PERCENTILE_CONT</code> and <code class="codeph">PERCENTILE_DISC</code> functions were introduced. These can be used both as window reporting functions as well as normal aggregate functions.</p>
<p>These functions need a sort specification and a parameter that takes a percentile value between 0 and 1. The sort specification is handled by using an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause with one expression. When used as a normal aggregate function, it returns a single value for each ordered set.</p>
<p><code class="codeph">PERCENTILE_CONT</code>, which is a continuous function computed by interpolation, and <code class="codeph">PERCENTILE_DISC</code>, which is a step function that assumes discrete values. Like other aggregates, <code class="codeph">PERCENTILE_CONT</code> and <code class="codeph">PERCENTILE_DISC</code> operate on a group of rows in a grouped query, but with the following differences:</p>
<ul style="list-style-type: disc;">
<li>
<p>They require a parameter between 0 and 1 (inclusive). A parameter specified out of this range results in error. This parameter should be specified as an expression that evaluates to a constant.</p>
</li>
<li>
<p>They require a sort specification. This sort specification is an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause with a single expression. Multiple expressions are not allowed.</p>
</li>
</ul>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-D8F6C15D-6A66-468F-9496-78AFB40BBCD2">Normal Aggregate Syntax</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-5E107F21-385F-43A2-9DC2-98E8D95B42D1">Inverse Percentile Example Basis</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-464D983C-761D-428F-8AA5-587FDE7F5B54">As Reporting Aggregates</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-A5FA1D4D-1B5F-41CA-9384-649E4654523F">Restrictions on Inverse Percentile Functions</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8709"></a>
<div class="props_rev_3"><a id="GUID-D8F6C15D-6A66-468F-9496-78AFB40BBCD2"></a>
<h4 id="DWHSG-GUID-D8F6C15D-6A66-468F-9496-78AFB40BBCD2" class="sect4">Normal Aggregate Syntax</h4>
<div>
<div class="section">
<pre dir="ltr">[PERCENTILE_CONT | PERCENTILE_DISC]( <span class="italic">constant expression</span> ) 
    WITHIN GROUP ( ORDER BY <span class="italic">single order by expression</span>
[ASC|DESC] [NULLS FIRST| NULLS LAST])
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8710"></a>
<div class="props_rev_3"><a id="GUID-5E107F21-385F-43A2-9DC2-98E8D95B42D1"></a>
<h4 id="DWHSG-GUID-5E107F21-385F-43A2-9DC2-98E8D95B42D1" class="sect4">Inverse Percentile Example Basis</h4>
<div>
<p>Use the following query to return the 17 rows of data used in the examples of this section:</p>
<pre dir="ltr">SELECT cust_id, cust_credit_limit, CUME_DIST() 
   OVER (ORDER BY cust_credit_limit) AS CUME_DIST
FROM customers WHERE cust_city=&#39;Marshal&#39;;

   CUST_ID CUST_CREDIT_LIMIT  CUME_DIST
---------- ----------------- ----------
     28344              1500 .173913043
      8962              1500 .173913043
     36651              1500 .173913043
     32497              1500 .173913043
     15192              3000 .347826087
    102077              3000 .347826087
    102343              3000 .347826087
      8270              3000 .347826087
     21380              5000  .52173913
     13808              5000  .52173913
    101784              5000  .52173913
     30420              5000  .52173913
     10346              7000 .652173913
     31112              7000 .652173913
     35266              7000 .652173913
      3424              9000 .739130435
    100977              9000 .739130435
    103066             10000 .782608696
     35225             11000 .956521739
     14459             11000 .956521739
     17268             11000 .956521739
    100421             11000 .956521739
     41496             15000          1
</pre>
<p><code class="codeph">PERCENTILE_DISC</code>(<code class="codeph">x</code>) is computed by scanning up the <code class="codeph">CUME_DIST</code> values in each group till you find the first one greater than or equal to <code class="codeph">x</code>, where <code class="codeph">x</code> is the specified percentile value. For the example query where <code class="codeph">PERCENTILE_DISC(0.5)</code>, the result is 5,000, as the following illustrates:</p>
<pre dir="ltr">SELECT PERCENTILE_DISC(0.5) WITHIN GROUP
  (ORDER BY cust_credit_limit) AS perc_disc, PERCENTILE_CONT(0.5) WITHIN GROUP 
  (ORDER BY cust_credit_limit) AS perc_cont
 FROM customers WHERE cust_city=&#39;Marshal&#39;;

PERC_DISC   PERC_CONT
---------   ---------
     5000        5000
</pre>
<p>The result of <code class="codeph">PERCENTILE_CONT</code> is computed by linear interpolation between rows after ordering them. To compute <code class="codeph">PERCENTILE_CONT(x)</code>, you first compute the row number = <code class="codeph">RN</code>= (1+x*(n-1)), where <span class="italic">n</span> is the number of rows in the group and <span class="italic">x</span> is the specified percentile value. The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers <code class="codeph">CRN = CEIL(RN)</code> and <code class="codeph">FRN = FLOOR(RN)</code>.</p>
<p>The final result is: <code class="codeph">PERCENTILE_CONT(X)</code> = if (<code class="codeph">CRN = FRN = RN</code>), then (value of expression from row at <code class="codeph">RN</code>) else (<code class="codeph">CRN - RN</code>) * (value of expression for row at <code class="codeph">FRN</code>) + (<code class="codeph">RN -FRN</code>) * (value of expression for row at <code class="codeph">CRN</code>).</p>
<p>Consider the previous example query, where you compute <code class="codeph">PERCENTILE_CONT(0.5)</code>. Here <span class="italic">n</span> is 17. The row number <code class="codeph">RN</code> = (1 + 0.5*(n-1))= 9 for both groups. Putting this into the formula, (<code class="codeph">FRN=CRN=9</code>), you return the value from row 9 as the result.</p>
<p>Another example is, if you want to compute <code class="codeph">PERCENTILE_CONT</code><code class="codeph">(0.66)</code>. The computed row number <code class="codeph">RN</code>=(1 + 0.66*(<code class="codeph">n</code>-1))= (1 + 0.66*16)= 11.67. <code class="codeph">PERCENTILE_CONT</code>(0.66) = (12-11.67)*(value of row 11)+(11.67-11)*(value of row 12). These results are:</p>
<pre dir="ltr">SELECT PERCENTILE_DISC(0.66) WITHIN GROUP 
  (ORDER BY cust_credit_limit) AS perc_disc, PERCENTILE_CONT(0.66) WITHIN GROUP 
  (ORDER BY cust_credit_limit) AS perc_cont
FROM customers WHERE cust_city=&#39;Marshal&#39;;

 PERC_DISC  PERC_CONT
---------- ----------
      9000       8040
</pre>
<p>Inverse percentile aggregate functions can appear in the <code class="codeph">HAVING</code> clause of a query like other existing aggregate functions.</p>
</div>
</div>
<a id="DWHSG8711"></a>
<div class="props_rev_3"><a id="GUID-464D983C-761D-428F-8AA5-587FDE7F5B54"></a>
<h4 id="DWHSG-GUID-464D983C-761D-428F-8AA5-587FDE7F5B54" class="sect4">As Reporting Aggregates</h4>
<div>
<p>You can also use the aggregate functions <code class="codeph">PERCENTILE_CONT</code>, <code class="codeph">PERCENTILE_DISC</code> as reporting aggregate functions. When used as reporting aggregate functions, the syntax is similar to those of other reporting aggregates.</p>
<pre dir="ltr">[PERCENTILE_CONT | PERCENTILE_DISC](<span class="italic">constant expression</span>) 
WITHIN GROUP ( ORDER BY <span class="italic">single order by expression</span>
[ASC|DESC] [NULLS FIRST| NULLS LAST])
OVER ( [PARTITION BY <span class="italic">value expression</span> [,...]] )
</pre>
<p>This query performs the same computation (median credit limit for customers in this result set), but reports the result for every row in the result set, as shown in the following output:</p>
<pre dir="ltr">SELECT cust_id, cust_credit_limit, PERCENTILE_DISC(0.5) WITHIN GROUP
     (ORDER BY cust_credit_limit) OVER () AS perc_disc,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY cust_credit_limit) 
  OVER () AS perc_cont
FROM customers WHERE cust_city=&#39;Marshal&#39;;

   CUST_ID CUST_CREDIT_LIMIT  PERC_DISC  PERC_CONT
---------- ----------------- ---------- ----------
     28344              1500       5000       5000
      8962              1500       5000       5000
     36651              1500       5000       5000
     32497              1500       5000       5000
     15192              3000       5000       5000
    102077              3000       5000       5000
    102343              3000       5000       5000
      8270              3000       5000       5000
     21380              5000       5000       5000
     13808              5000       5000       5000
    101784              5000       5000       5000
     30420              5000       5000       5000
     10346              7000       5000       5000
     31112              7000       5000       5000
     35266              7000       5000       5000
      3424              9000       5000       5000
    100977              9000       5000       5000
    103066             10000       5000       5000
     35225             11000       5000       5000
     14459             11000       5000       5000
     17268             11000       5000       5000
    100421             11000       5000       5000
     41496             15000       5000       5000
</pre></div>
</div>
<a id="DWHSG8712"></a>
<div class="props_rev_3"><a id="GUID-A5FA1D4D-1B5F-41CA-9384-649E4654523F"></a>
<h4 id="DWHSG-GUID-A5FA1D4D-1B5F-41CA-9384-649E4654523F" class="sect4">Restrictions on Inverse Percentile Functions</h4>
<div>
<div class="section">
<p>For <code class="codeph">PERCENTILE_DISC</code>, the expression in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause can be of any data type that you can sort (numeric, string, date, and so on). However, the expression in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause must be a numeric or datetime type (including intervals) because linear interpolation is used to evaluate <code class="codeph">PERCENTILE_CONT</code>. If the expression is of type <code class="codeph">DATE</code>, the interpolated result is rounded to the smallest unit for the type. For a <code class="codeph">DATE</code> type, the interpolated value is rounded to the nearest second, for interval types to the nearest second (<code class="codeph">INTERVAL</code> <code class="codeph">DAY</code> <code class="codeph">TO</code> <code class="codeph">SECOND</code>) or to the month (<code class="codeph">INTERVAL</code> <code class="codeph">YEAR</code> <code class="codeph">TO</code> <code class="codeph">MONTH</code>).</p>
<p>Like other aggregates, the inverse percentile functions ignore <code class="codeph">NULLs</code> in evaluating the result. For example, when you want to find the median value in a set, Oracle Database ignores the <code class="codeph">NULLs</code> and finds the median among the non-null values. You can use the <code class="codeph">NULLS</code> <code class="codeph">FIRST</code>/<code class="codeph">NULLS</code> <code class="codeph">LAST</code> option in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause, but they will be ignored as <code class="codeph">NULLs</code> are ignored.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8713"></a><a id="DWHSG8714"></a><a id="DWHSG0207"></a>
<div class="props_rev_3"><a id="GUID-76DADC19-5E66-4857-99F7-509836BA44D5"></a>
<h3 id="DWHSG-GUID-76DADC19-5E66-4857-99F7-509836BA44D5" class="sect3">Hypothetical Rank Functions</h3>
<div>
<div class="section">
<p>These functions <a id="d59823e3418" class="indexterm-anchor"></a>provide functionality useful for what-if analysis. As an example, what would be the rank of a row, if the row was hypothetically inserted into a set of other rows?</p>
<p>This family of aggregates takes one or more arguments of a hypothetical row and an ordered group of rows, returning the <code class="codeph">RANK</code>, <code class="codeph">DENSE_RANK</code>, <code class="codeph">PERCENT_RANK</code> or <code class="codeph">CUME_DIST</code> of the row as if it was hypothetically inserted into the group.</p>
<pre dir="ltr">[RANK | DENSE_RANK | PERCENT_RANK | CUME_DIST]( <span class="italic">constant expression</span> [, ...] )
WITHIN GROUP ( ORDER BY <span class="italic">order by expression</span> [ASC|DESC] [NULLS FIRST|NULLS LAST][, ...] )
</pre>
<p>Here, <span class="italic"><code class="codeph">constant expression</code></span> refers to an expression that evaluates to a constant, and there may be more than one such expressions that are passed as arguments to the function. The <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause can contain one or more expressions that define the sorting order on which the ranking will be based. <code class="codeph">ASC</code>, <code class="codeph">DESC</code>, <code class="codeph">NULLS</code> <code class="codeph">FIRST</code>, <code class="codeph">NULLS</code> <code class="codeph">LAST</code> options will be available for each expression in the <code class="codeph">ORDER</code> <code class="codeph">BY</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-76DADC19-5E66-4857-99F7-509836BA44D5__GUID-7E70138E-5D8D-4BE2-BBFB-01ED1DDC026E">
<p class="titleinexample">Example 18-22 Hypothetical Rank and Distribution Example 1</p>
<p>Using the list price data from the <code class="codeph">products</code> table used throughout this section, you can calculate the <code class="codeph">RANK</code>, <code class="codeph">PERCENT_RANK</code> and <code class="codeph">CUME_DIST</code> for a hypothetical sweater with a price of $50 for how it fits within each of the sweater subcategories. The query and results are:</p>
<pre dir="ltr">SELECT cust_city,
  RANK(6000) WITHIN GROUP (ORDER BY CUST_CREDIT_LIMIT DESC) AS HRANK,
  TO_CHAR(PERCENT_RANK(6000) WITHIN GROUP
  (ORDER BY cust_credit_limit),&#39;9.999&#39;) AS HPERC_RANK,
  TO_CHAR(CUME_DIST (6000) WITHIN GROUP
  (ORDER BY cust_credit_limit),&#39;9.999&#39;) AS HCUME_DIST
FROM customers
WHERE cust_city LIKE &#39;Fo%&#39;
GROUP BY cust_city;

CUST_CITY                           HRANK HPERC_ HCUME_
------------------------------ ---------- ------ ------
Fondettes                              13   .455   .478
Fords Prairie                          18   .320   .346
Forest City                            47   .370   .378
Forest Heights                         38   .456   .464
Forestville                            58   .412   .418
Forrestcity                            51   .438   .444
Fort Klamath                           59   .356   .363
Fort William                           30   .500   .508
Foxborough                             52   .414   .420
</pre>
<p>Unlike the inverse percentile aggregates, the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause in the sort specification for hypothetical rank and distribution functions may take multiple expressions. The number of arguments and the expressions in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause should be the same and the arguments must be constant expressions of the same or compatible type to the corresponding <code class="codeph">ORDER</code> <code class="codeph">BY</code> expression. The following is an example using two arguments in several hypothetical ranking functions.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-76DADC19-5E66-4857-99F7-509836BA44D5__GUID-7B2C020A-84C3-4898-B527-E2F5692A717E">
<p class="titleinexample">Example 18-23 Hypothetical Rank and Distribution Example 2</p>
<pre dir="ltr">SELECT prod_subcategory,
  RANK(10,8) WITHIN GROUP (ORDER BY prod_list_price DESC,prod_min_price)
  AS HRANK, TO_CHAR(PERCENT_RANK(10,8) WITHIN GROUP
  (ORDER BY prod_list_price, prod_min_price),&#39;9.999&#39;) AS HPERC_RANK,
  TO_CHAR(CUME_DIST (10,8) WITHIN GROUP
  (ORDER BY prod_list_price, prod_min_price),&#39;9.999&#39;) AS HCUME_DIST
FROM products WHERE prod_subcategory LIKE &#39;Recordable%&#39;
GROUP BY prod_subcategory;

PROD_SUBCATEGORY          HRANK   HPERC_   HCUME_
--------------------      -----   ------   ------
Recordable CDs                4     .571     .625
Recordable DVD Discs          5     .200     .333
</pre>
<p>These functions can appear in the <code class="codeph">HAVING</code> clause of a query just like other aggregate functions. They cannot be used as either reporting aggregate functions or windowing aggregate functions.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG0208"></a>
<div class="props_rev_3"><a id="GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51"></a>
<h3 id="DWHSG-GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51" class="sect3">Linear Regression Functions</h3>
<div>
<p><a id="d59823e3554" class="indexterm-anchor"></a><a id="d59823e3558" class="indexterm-anchor"></a>The regression functions support the fitting of an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate functions or windowing or reporting functions.</p>
<p>The regression functions are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-BDDB54D1-42A7-4BD1-A61E-621C4184BBD0">REGR_COUNT Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-0C9A1E08-55A2-49BD-A9D6-4E88B9489070">REGR_AVGY and REGR_AVGX Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-74BB2242-09FC-45C7-8882-33789DD671F1">REGR_SLOPE and REGR_INTERCEPT Functions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-8B9FAFE5-4BE7-46B6-A26D-A953F3AED5D6">REGR_R2 Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-1A9FB0BB-F198-4688-A3BA-AF8FCDFDD43F">REGR_SXX_ REGR_SYY_ and REGR_SXY Functions</a></p>
</li>
</ul>
<p>Oracle applies the function to the set of (<code class="codeph">e1</code>, <code class="codeph">e2</code>) pairs after eliminating all pairs for which either of <code class="codeph">e1</code> or <code class="codeph">e2</code> is null. e1 is interpreted as a value of the dependent variable (a &#34;y value&#34;), and <code class="codeph">e2</code> is interpreted as a value of the independent variable (an &#34;x value&#34;). Both expressions must be numbers.</p>
<p>The regression functions are all computed simultaneously during a single pass through the data. They are frequently combined with the <code class="codeph">COVAR_POP</code>, <code class="codeph">COVAR_SAMP</code>, and <code class="codeph">CORR</code> functions.</p>
<div class="infoboxnotealso" id="GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51__GUID-D126A2D7-A814-4763-A66A-6B8FC0B9649E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-D660FE5C-2850-445E-8408-695C9E2963A7">Linear Regression Statistics Examples</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-1818A747-1C36-4FBD-BE49-481917EF9835">Sample Linear Regression Calculation</a></p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8715"></a>
<div class="props_rev_3"><a id="GUID-BDDB54D1-42A7-4BD1-A61E-621C4184BBD0"></a>
<h4 id="DWHSG-GUID-BDDB54D1-42A7-4BD1-A61E-621C4184BBD0" class="sect4">REGR_COUNT Function</h4>
<div>
<div class="section">
<p><code class="codeph">REGR_COUNT</code> returns the number of non-null number pairs used to fit the regression line. If applied to an empty set (or if there are no (<code class="codeph">e1</code>, <code class="codeph">e2</code>) pairs where neither of <code class="codeph">e1</code> or <code class="codeph">e2</code> is null), the function returns 0.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8716"></a>
<div class="props_rev_3"><a id="GUID-0C9A1E08-55A2-49BD-A9D6-4E88B9489070"></a>
<h4 id="DWHSG-GUID-0C9A1E08-55A2-49BD-A9D6-4E88B9489070" class="sect4">REGR_AVGY and REGR_AVGX Functions</h4>
<div>
<div class="section">
<p><code class="codeph">REGR_AVGY</code> and <code class="codeph">REGR_AVGX</code> compute the averages of the dependent variable and the independent variable of the regression line, respectively. <code class="codeph">REGR_AVGY</code> computes the average of its first argument (<code class="codeph">e1</code>) after eliminating (<code class="codeph">e1</code>, <code class="codeph">e2</code>) pairs where either of <code class="codeph">e1</code> or <code class="codeph">e2</code> is null. Similarly, <code class="codeph">REGR_AVGX</code> computes the average of its second argument (<code class="codeph">e2</code>) after null elimination. Both functions return <code class="codeph">NULL</code> if applied to an empty set.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8717"></a>
<div class="props_rev_3"><a id="GUID-74BB2242-09FC-45C7-8882-33789DD671F1"></a>
<h4 id="DWHSG-GUID-74BB2242-09FC-45C7-8882-33789DD671F1" class="sect4">REGR_SLOPE and REGR_INTERCEPT Functions</h4>
<div>
<div class="section">
<p><a id="d59823e3745" class="indexterm-anchor"></a><a id="d59823e3747" class="indexterm-anchor"></a><a id="d59823e3749" class="indexterm-anchor"></a><a id="d59823e3753" class="indexterm-anchor"></a>The <code class="codeph">REGR_SLOPE</code> function computes the slope of the regression line fitted to non-null (<code class="codeph">e1</code>, <code class="codeph">e2</code>) pairs.</p>
<p>The <code class="codeph">REGR_INTERCEPT</code> function computes the y-intercept of the regression line. <code class="codeph">REGR_INTERCEPT</code> returns <code class="codeph">NULL</code> whenever slope or the regression averages are <code class="codeph">NULL</code>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8718"></a>
<div class="props_rev_3"><a id="GUID-8B9FAFE5-4BE7-46B6-A26D-A953F3AED5D6"></a>
<h4 id="DWHSG-GUID-8B9FAFE5-4BE7-46B6-A26D-A953F3AED5D6" class="sect4">REGR_R2 Function</h4>
<div>
<div class="section">
<p><a id="d59823e3803" class="indexterm-anchor"></a>The <code class="codeph">REGR_R2</code> function computes the coefficient of determination (usually called &#34;R-squared&#34; or &#34;goodness of fit&#34;) for the regression line.</p>
<p><code class="codeph">REGR_R2</code> returns values between 0 and 1 when the regression line is defined (slope of the line is not null), and it returns <code class="codeph">NULL</code> otherwise. The closer the value is to 1, the better the regression line fits the data.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8719"></a>
<div class="props_rev_3"><a id="GUID-1A9FB0BB-F198-4688-A3BA-AF8FCDFDD43F"></a>
<h4 id="DWHSG-GUID-1A9FB0BB-F198-4688-A3BA-AF8FCDFDD43F" class="sect4">REGR_SXX, REGR_SYY, and REGR_SXY Functions</h4>
<div>
<div class="section">
<p><code class="codeph">REGR_SXX</code>, <code class="codeph">REGR_SYY</code> and <code class="codeph">REGR_SXY</code> functions are used in computing various diagnostic statistics for regression analysis. After eliminating (<code class="codeph">e1</code>, <code class="codeph">e2</code>) pairs where either of <code class="codeph">e1</code> or <code class="codeph">e2</code> is null, these functions make the following computations:</p>
<pre dir="ltr">REGR_SXX:    REGR_COUNT(e1,e2) * VAR_POP(e2)
REGR_SYY:    REGR_COUNT(e1,e2) * VAR_POP(e1) 
REGR_SXY:    REGR_COUNT(e1,e2) * COVAR_POP(e1, e2)
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8721"></a><a id="DWHSG8720"></a>
<div class="props_rev_3"><a id="GUID-D660FE5C-2850-445E-8408-695C9E2963A7"></a>
<h4 id="DWHSG-GUID-D660FE5C-2850-445E-8408-695C9E2963A7" class="sect4">Linear Regression Statistics Examples</h4>
<div>
<p>Some common diagnostic statistics that accompany linear regression analysis are given in <a href="analysis.htm#GUID-D660FE5C-2850-445E-8408-695C9E2963A7__g1016125" title="Common Diagnostic Statistics and Their Expressions">Table 18-2</a>. Note that Oracle enables you to calculate all of these.</p>
<div class="tblformalwide" id="GUID-D660FE5C-2850-445E-8408-695C9E2963A7__g1016125">
<p class="titleintable">Table 18-2 Common Diagnostic Statistics and Their Expressions&nbsp;</p>
<table class="cellalignment1533" title="Common Diagnostic Statistics and Their Expressions&nbsp;" summary="Common Diagnostic Statistics and Their Expressions">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1538" id="d59823e3901">Type of Statistic</th>
<th class="cellalignment1580" id="d59823e3904">Expression</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1539" id="d59823e3909" headers="d59823e3901">
<p>Adjusted R2</p>
</td>
<td class="cellalignment1581" headers="d59823e3909 d59823e3904">
<p><code class="codeph">1-((1 - REGR_R2)*((REGR_COUNT-1)/(REGR_COUNT-2)))</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1539" id="d59823e3917" headers="d59823e3901">
<p>Standard error</p>
</td>
<td class="cellalignment1581" headers="d59823e3917 d59823e3904">
<p><code class="codeph">SQRT((REGR_SYY-(POWER(REGR_SXY,2)/REGR_SXX))/(REGR_COUNT-2))</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1539" id="d59823e3925" headers="d59823e3901">
<p>Total sum of squares</p>
</td>
<td class="cellalignment1581" headers="d59823e3925 d59823e3904">
<p><code class="codeph">REGR_SYY</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1539" id="d59823e3933" headers="d59823e3901">
<p>Regression sum of squares</p>
</td>
<td class="cellalignment1581" headers="d59823e3933 d59823e3904">
<p><code class="codeph">POWER(REGR_SXY,2) / REGR_SXX</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1539" id="d59823e3941" headers="d59823e3901">
<p>Residual sum of squares</p>
</td>
<td class="cellalignment1581" headers="d59823e3941 d59823e3904">
<p><code class="codeph">REGR_SYY</code> - (<code class="codeph">POWER(REGR_SXY,2)/REGR_SXX)</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1539" id="d59823e3952" headers="d59823e3901">
<p>t statistic for slope</p>
</td>
<td class="cellalignment1581" headers="d59823e3952 d59823e3904">
<p><code class="codeph">REGR_SLOPE * SQRT(REGR_SXX)</code> / (Standard error)</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1539" id="d59823e3961" headers="d59823e3901">
<p>t statistic for y-intercept</p>
</td>
<td class="cellalignment1581" headers="d59823e3961 d59823e3904">
<p><code class="codeph">REGR_INTERCEPT</code> / ((Standard error) * <code class="codeph">SQRT((1/REGR_COUNT)+(POWER(REGR_AVGX,2)/REGR_SXX))</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="DWHSG8722"></a>
<div class="props_rev_3"><a id="GUID-1818A747-1C36-4FBD-BE49-481917EF9835"></a>
<h4 id="DWHSG-GUID-1818A747-1C36-4FBD-BE49-481917EF9835" class="sect4">Sample Linear Regression Calculation</h4>
<div>
<p>In this example, you compute an ordinary-least-squares regression line that expresses the quantity sold of a product as a linear function of the product&#39;s list price. The calculations are grouped by sales channel. The values <code class="codeph">SLOPE</code>, <code class="codeph">INTCPT</code>, <code class="codeph">RSQR</code> are slope, intercept, and coefficient of determination of the regression line, respectively. The (integer) value <code class="codeph">COUNT</code> is the number of products in each channel for whom both quantity sold and list price data are available.</p>
<pre dir="ltr">SELECT s.channel_id, REGR_SLOPE(s.quantity_sold, p.prod_list_price) SLOPE,
  REGR_INTERCEPT(s.quantity_sold, p.prod_list_price) INTCPT,
  REGR_R2(s.quantity_sold, p.prod_list_price) RSQR,
  REGR_COUNT(s.quantity_sold, p.prod_list_price) COUNT,
  REGR_AVGX(s.quantity_sold, p.prod_list_price) AVGLISTP,
  REGR_AVGY(s.quantity_sold, p.prod_list_price) AVGQSOLD
FROM sales s, products p WHERE s.prod_id=p.prod_id
  AND p.prod_category=&#39;Electronics&#39; AND s.time_id=to_DATE(&#39;10-OCT-2000&#39;)
GROUP BY s.channel_id;

CHANNEL_ID      SLOPE     INTCPT       RSQR      COUNT   AVGLISTP   AVGQSOLD
---------- ---------- ---------- ---------- ---------- ---------- ----------
         2          0          1          1         39 466.656667          1
         3          0          1          1         60     459.99          1
         4          0          1          1         19 526.305789          1
</pre></div>
</div>
</div>
<a id="DWHSG8723"></a>
<div class="props_rev_3"><a id="GUID-399DBC4B-0CE6-49F7-87F2-5E74D83A1DB0"></a>
<h3 id="DWHSG-GUID-399DBC4B-0CE6-49F7-87F2-5E74D83A1DB0" class="sect3">About Statistical Aggregates</h3>
<div>
<p>Oracle Database provides a set of SQL statistical functions and a statistics package, <code class="codeph">DBMS_STAT_FUNCS</code>. This section lists some of the new functions along with basic syntax.</p>
<p>See <a class="olink ARPLS006" target="_blank" href="../ARPLS/d_stat_f.htm#ARPLS006"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information about the <code class="codeph">DBMS_STAT_FUNCS</code> package and <a class="olink SQLRF00647" target="_blank" href="../SQLRF/functions080.htm#SQLRF00647"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax and semantics.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-43AE794B-06F5-407A-9E61-87BEFE58315A">Descriptive Statistics</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-BCF2AB78-069B-4560-8942-F8217CE6CAC0">Hypothesis Testing - Parametric Tests</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-A1A3BBD2-DDB3-49F9-A023-594F124D17BF">Crosstab Statistics</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-D75213DB-43C9-403C-947B-54083FB1C303">Hypothesis Testing - Non-Parametric Tests</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-7431A541-4F23-467A-9BB5-AD4D0930D950">Non-Parametric Correlation</a></p>
</li>
</ul>
</div>
<a id="DWHSG8724"></a>
<div class="props_rev_3"><a id="GUID-43AE794B-06F5-407A-9E61-87BEFE58315A"></a>
<h4 id="DWHSG-GUID-43AE794B-06F5-407A-9E61-87BEFE58315A" class="sect4">Descriptive Statistics</h4>
<div>
<div class="section">
<p>You can calculate the following descriptive statistics:</p>
<ul style="list-style-type: disc;">
<li>
<p>Median of a Data Set</p>
<pre dir="ltr">Median (expr) [OVER (query_partition_clause)]
</pre></li>
<li>
<p>Mode of a Data Set</p>
<pre dir="ltr">STATS_MODE (expr)
</pre></li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8725"></a>
<div class="props_rev_3"><a id="GUID-BCF2AB78-069B-4560-8942-F8217CE6CAC0"></a>
<h4 id="DWHSG-GUID-BCF2AB78-069B-4560-8942-F8217CE6CAC0" class="sect4">Hypothesis Testing - Parametric Tests</h4>
<div>
<div class="section">
<p>You can calculate the following descriptive statistics:</p>
<ul style="list-style-type: disc;">
<li>
<p>One-Sample T-Test</p>
<pre dir="ltr">STATS_T_TEST_ONE (expr1, expr2 (a constant) [, return_value])
</pre></li>
<li>
<p>Paired-Samples T-Test</p>
<pre dir="ltr">STATS_T_TEST_PAIRED (expr1, expr2 [, return_value])
</pre></li>
<li>
<p>Independent-Samples T-Test. Pooled Variances</p>
<pre dir="ltr">STATS_T_TEST_INDEP (expr1, expr2 [, return_value])
</pre></li>
<li>
<p>Independent-Samples T-Test, Unpooled Variances</p>
<pre dir="ltr">STATS_T_TEST_INDEPU (expr1, expr2 [, return_value])
</pre></li>
<li>
<p>The F-Test</p>
<pre dir="ltr">STATS_F_TEST (expr1, expr2 [, return_value])
</pre></li>
<li>
<p>One-Way ANOVA</p>
<pre dir="ltr">STATS_ONE_WAY_ANOVA (expr1, expr2 [, return_value])
</pre></li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8726"></a>
<div class="props_rev_3"><a id="GUID-A1A3BBD2-DDB3-49F9-A023-594F124D17BF"></a>
<h4 id="DWHSG-GUID-A1A3BBD2-DDB3-49F9-A023-594F124D17BF" class="sect4">Crosstab Statistics</h4>
<div>
<div class="section">
<p>You can calculate crosstab statistics using the following syntax:</p>
<pre dir="ltr">STATS_CROSSTAB (expr1, expr2 [, return_value])
</pre>
<p>Can return any one of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Observed value of chi-squared</p>
</li>
<li>
<p>Significance of observed chi-squared</p>
</li>
<li>
<p>Degree of freedom for chi-squared</p>
</li>
<li>
<p>Phi coefficient, Cramer&#39;s V statistic</p>
</li>
<li>
<p>Contingency coefficient</p>
</li>
<li>
<p>Cohen&#39;s Kappa</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8727"></a>
<div class="props_rev_3"><a id="GUID-D75213DB-43C9-403C-947B-54083FB1C303"></a>
<h4 id="DWHSG-GUID-D75213DB-43C9-403C-947B-54083FB1C303" class="sect4">Hypothesis Testing - Non-Parametric Tests</h4>
<div>
<div class="section">
<p>You can calculate hypothesis statistics using the following syntax:</p>
<pre dir="ltr">STATS_BINOMIAL_TEST (expr1, expr2, p [, return_value])
</pre>
<ul style="list-style-type: disc;">
<li>
<p>Binomial Test/Wilcoxon Signed Ranks Test</p>
<pre dir="ltr">STATS_WSR_TEST (expr1, expr2 [, return_value])
</pre></li>
<li>
<p>Mann-Whitney Test</p>
<pre dir="ltr">STATS_MW_TEST (expr1, expr2 [, return_value])
</pre></li>
<li>
<p>Kolmogorov-Smirnov Test</p>
<pre dir="ltr">STATS_KS_TEST (expr1, expr2 [, return_value])
</pre></li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8728"></a>
<div class="props_rev_3"><a id="GUID-7431A541-4F23-467A-9BB5-AD4D0930D950"></a>
<h4 id="DWHSG-GUID-7431A541-4F23-467A-9BB5-AD4D0930D950" class="sect4">Non-Parametric Correlation</h4>
<div>
<div class="section">
<p>You can calculate the following parametric statistics:</p>
<ul style="list-style-type: disc;">
<li>
<p>Spearman&#39;s rho Coefficient</p>
<pre dir="ltr">CORR_S (expr1, expr2 [, return_value])
</pre></li>
<li>
<p>Kendall&#39;s tau-b Coefficient</p>
<pre dir="ltr">CORR_K (expr1, expr2 [, return_value])
</pre></li>
</ul>
<p>In addition to the functions, this release has a PL/SQL package, <code class="codeph">DBMS_STAT_FUNCS</code>. It contains the descriptive statistical function <code class="codeph">SUMMARY</code> along with functions to support distribution fitting. The <code class="codeph">SUMMARY</code> function summarizes a numerical column of a table with a variety of descriptive statistics. The five distribution fitting functions support normal, uniform, Weibull, Poisson, and exponential distributions.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG02011"></a>
<div class="props_rev_3"><a id="GUID-04FC38D9-D651-4558-99D3-830255C958AF"></a>
<h3 id="DWHSG-GUID-04FC38D9-D651-4558-99D3-830255C958AF" class="sect3">About User-Defined Aggregates</h3>
<div>
<p>Oracle offers a facility for creating your own functions, called user-defined aggregate functions. These functions are written in programming languages such as PL/SQL, Java, and C, and can be used as analytic functions or aggregates in materialized views. See <a class="olink ADDCI2120" target="_blank" href="../ADDCI/aggr_functions.htm#ADDCI2120"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for further information regarding syntax and restrictions.</p>
<p>The advantages of these functions are:</p>
<ul style="list-style-type: disc;">
<li>
<p>Highly complex functions can be programmed using a fully procedural language.</p>
</li>
<li>
<p>Higher scalability than other techniques when user-defined functions are programmed for parallel processing.</p>
</li>
<li>
<p>Object data types can be processed.</p>
</li>
</ul>
<p>As a simple example of a user-defined aggregate function, consider the skew statistic. This calculation measures if a data set has a lopsided distribution about its mean. It will tell you if one tail of the distribution is significantly larger than the other. If you created a user-defined aggregate called <code class="codeph">udskew</code> and applied it to the credit limit data in the prior example, the SQL statement and results might look like this:</p>
<pre dir="ltr">SELECT USERDEF_SKEW(cust_credit_limit) FROM customers
WHERE cust_city=&#39;Marshal&#39;;

USERDEF_SKEW
============
0.583891
</pre>
<p>Before building user-defined aggregate functions, you should consider if your needs can be met in regular SQL. Many complex calculations are possible directly in SQL, particularly by using the <code class="codeph">CASE</code> expression.</p>
<p>Staying with regular SQL will enable simpler development, and many query operations are already well-parallelized in SQL. Even the earlier example, the skew statistic, can be created using standard, albeit lengthy, SQL.</p>
</div>
</div>
</div>
<a id="DWHSG0209"></a>
<div class="props_rev_3"><a id="GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591"></a>
<h2 id="DWHSG-GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591" class="sect2">Pivoting Operations</h2>
<div>
<div class="section">
<p>The d<a id="d59823e4373" class="indexterm-anchor"></a><a id="d59823e4375" class="indexterm-anchor"></a>ata returned by business intelligence queries is often most usable if presented in a crosstabular format. The <code class="codeph">pivot_clause</code> of the <code class="codeph">SELECT</code> statement lets you write crosstabulation queries that rotate rows into columns, aggregating data in the process of the rotation. Pivoting is a key technique in data warehouses. In it, you transform multiple rows of input into fewer and generally wider rows in the data warehouse. When pivoting, an aggregation operator is applied for each item in the pivot column value list. The pivot column cannot contain an arbitrary expression. If you need to pivot on an expression, then you should alias the expression in a view before the <code class="codeph">PIVOT</code> operation. The basic syntax is as follows:</p>
<pre dir="ltr">SELECT ....
FROM &lt;table-expr&gt;
   PIVOT
     (
      aggregate-function(&lt;column&gt;) AS &lt;alias&gt;
      FOR &lt;pivot-column&gt; IN (&lt;value1&gt;, &lt;value2&gt;,..., &lt;valuen&gt;)
        ) AS &lt;alias&gt;
WHERE .....
</pre>
<p>See <a class="olink SQLRF01702" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">pivot_clause</code> syntax.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1">Creating the View Used for Pivoting Examples</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-84C81897-0484-4F40-938B-D1D7F5EA4D97">Pivoting Example</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E">Pivoting on Multiple Columns</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206">Pivoting: Multiple Aggregates</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-3BBB2991-DC84-4BB1-B7DC-797F8817732C">Distinguishing PIVOT-Generated Nulls from Nulls in Source Data</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-C4AF4C41-55D1-402F-89C1-ED83C7986395">Wildcard and Subquery Pivoting with XML Operations</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<div class="props_rev_3"><a id="GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1"></a>
<h3 id="DWHSG-GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1" class="sect3">Creating the View Used for Pivoting Examples</h3>
<div>
<div class="section">
<p>The pivoting and unpivoting examples are based on the <code class="codeph">sales_view</code> view.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">
<p class="titleinexample">Example 18-24 Creating the SALES_VIEW View for Pivoting Examples</p>
<p>The following example creates the <code class="codeph">sales_view</code> view that is used as the basis to illustrate the use of pivoting.</p>
<pre dir="ltr">CREATE VIEW sales_view AS
SELECT
 prod_name product, country_name country, channel_id channel,
 SUBSTR(calendar_quarter_desc, 6,2) quarter,
 SUM(amount_sold) amount_sold, SUM(quantity_sold) quantity_sold 
FROM sales, times, customers, countries, products
WHERE sales.time_id = times.time_id AND
  sales.prod_id = products.prod_id AND
  sales.cust_id = customers.cust_id AND
  customers.country_id = countries.country_id
GROUP BY prod_name, country_name, channel_id,
 SUBSTR(calendar_quarter_desc, 6, 2);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8729"></a>
<div class="props_rev_3"><a id="GUID-84C81897-0484-4F40-938B-D1D7F5EA4D97"></a>
<h3 id="DWHSG-GUID-84C81897-0484-4F40-938B-D1D7F5EA4D97" class="sect3">Pivoting Example</h3>
<div>
<div class="section">
<p>The following statement illustrates a typical pivot on the <code class="codeph">channel</code> column of view <code class="codeph">sales_view</code> created as described in <a href="analysis.htm#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">Example 18-24</a>:</p>
<pre dir="ltr">SELECT * FROM
  (SELECT product, channel, amount_sold
   FROM sales_view
   ) S PIVOT (SUM(amount_sold)
   FOR CHANNEL IN (3 AS DIRECT_SALES, 4 AS INTERNET_SALES, 
                   5 AS CATALOG_SALES, 9 AS TELESALES))
ORDER BY product;

PRODUCT                  DIRECT&shy;_SALES  INTERNET_SALES  CATALOG_SALES  TELESALES
----------------------   ------------  --------------  -------------  ---------
...
Internal 6X CD-ROM          229512.97        26249.55
Internal 8X CD-ROM          286291.49        42809.44
Keyboard Wrist Rest         200959.84        38695.36                   1522.73
... 
</pre>
<p>Note that the output has created four new aliased columns, <code class="codeph">DIRECT_SALES</code>, <code class="codeph">INTERNET_SALES</code>, <code class="codeph">CATALOG_SALES</code>, and <code class="codeph">TELESALES</code>, one for each of the pivot values. The output is a sum. If no alias is provided, the column heading will be the values of the <code class="codeph">IN</code>-list.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8730"></a>
<div class="props_rev_3"><a id="GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E"></a>
<h3 id="DWHSG-GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E" class="sect3">Pivoting on Multiple Columns</h3>
<div>
<div class="section">
<p>You can pivot on more than one column. The following statement illustrates a typical multiple column pivot on the view <code class="codeph">sales_view</code> created as described in <a href="analysis.htm#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">Example 18-24</a>:</p>
<pre dir="ltr">SELECT *
FROM
     (SELECT product, channel, quarter, quantity_sold
      FROM sales_view
     ) PIVOT (SUM(quantity_sold)
                FOR (channel, quarter) IN
                  ((5, &#39;02&#39;) AS CATALOG_Q2,
                   (4, &#39;01&#39;) AS INTERNET_Q1,
                   (4, &#39;04&#39;) AS INTERNET_Q4,
                   (2, &#39;02&#39;) AS PARTNERS_Q2,
                   (9, &#39;03&#39;) AS TELE_Q3
                  )
                );

PRODUCT              CATALOG_Q2  INTERNET_Q1  INTERNET_Q4  PARTNERS_Q2   TELE_Q3
-------              ----------  -----------  -----------  -----------   -------
...
Bounce                                  347           632          954
...      
Smash Up Boxing                         129           280          560
...  
Comic Book Heroes                        47           155          275
...
</pre>
<p>Note that this example specifies a multi-column <code class="codeph">IN</code>-list with column headings designed to match the <code class="codeph">IN</code>-list members.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8731"></a>
<div class="props_rev_3"><a id="GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206"></a>
<h3 id="DWHSG-GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206" class="sect3">Pivoting: Multiple Aggregates</h3>
<div>
<div class="section">
<p>You can pivot with multiple aggregates, as shown in the following example that pivots on multiple aggregates from the <code class="codeph">sales_view</code> created in <a href="analysis.htm#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">Example 18-24</a>:</p>
<pre dir="ltr">SELECT *
FROM
     (SELECT product, channel, amount_sold, quantity_sold
      FROM sales_view
     ) PIVOT (SUM(amount_sold) AS sums,
              SUM(quantity_sold) AS sumq
              FOR channel IN (5, 4, 2, 9)
               )
ORDER BY product;
</pre>
<pre dir="ltr">PRODUCT                5_SUMS  5_SUMQ    4_SUMS   4_SUMQ      2_SUMS   2_SUMQ    9_SUMS   9_SUMQ
-------------          ------  ------    ------   ------      ------   ------    ------   ------
O/S Doc Set English                   142780.36     3081   381397.99     8044   6028.66      134
O/S Doc Set French                     55503.58     1192   132000.77     2782   
... 
 
</pre>
<p>Note that the query creates column headings by concatenating the pivot values, the underscore character (_), and the alias of the aggregate column. If the length of the generated column heading exceeds the maximum length of a column name, then an <code class="codeph">ORA-00918</code> error is returned. To avoid this error, use <code class="codeph">AS</code> <span class="italic"><code class="codeph">alias</code></span> to specify a shorter column alias for the pivot column heading, the aggregate value column name, or both. <span class="q">&#34;<a href="analysis.htm#GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E">Pivoting on Multiple Columns</a>&#34;</span> demonstrates using an alias for the pivot values.</p>
<div class="infoboxnotealso" id="GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206__GUID-6125A56E-0E36-4A6C-A15A-4AFCAA03AD02">
<p class="notep1">See Also:</p>
<p><span class="italic">Oracle Database SQL Language Reference</span> for information about the maximum length of column names</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8732"></a>
<div class="props_rev_3"><a id="GUID-3BBB2991-DC84-4BB1-B7DC-797F8817732C"></a>
<h3 id="DWHSG-GUID-3BBB2991-DC84-4BB1-B7DC-797F8817732C" class="sect3">Distinguishing PIVOT-Generated Nulls from Nulls in Source Data</h3>
<div>
<p>You can distinguish between null values that are generated from the use of <code class="codeph">PIVOT</code> and those that exist in the source data. The following example illustrates nulls that <code class="codeph">PIVOT</code> generates.</p>
<p>The following query returns rows with 5 columns, column <code class="codeph">prod_id</code>, and pivot resulting columns <code class="codeph">Q1</code>, <code class="codeph">Q1_COUNT_TOTAL</code>, <code class="codeph">Q2</code>, <code class="codeph">Q2_COUNT_TOTAL</code>. For each unique value of <code class="codeph">prod_id</code>, <code class="codeph">Q1_COUNT_TOTAL</code> returns the total number of rows whose <code class="codeph">qtr</code> value is <code class="codeph">Q1</code>, that is, and <code class="codeph">Q2_COUNT_TOTAL</code> returns the total number of rows whose <code class="codeph">qtr</code> value is <code class="codeph">Q2</code>.</p>
<p>Assume you have a table <code class="codeph">sales2</code> of the following structure:</p>
<pre dir="ltr">PROD_ID   QTR  AMOUNT_SOLD
-------   ---  -----------
100        Q1           10
100        Q1           20
100        Q2         NULL
200        Q1           50

SELECT *
FROM sales2
        PIVOT
         ( SUM(amount_sold), COUNT(*) AS count_total
           FOR qtr IN (&#39;Q1&#39;, &#39;Q2&#39;)
         );

PROD_ID    &#34;Q1&#34;   &#34;Q1_COUNT_TOTAL&#34;  &#34;Q2&#34;       &#34;Q2_COUNT_TOTAL&#34;
-------    ----   ----------------  ---------  ----------------
    100      20                  2   NULL &lt;1&gt;                 1
    200      50                  1   NULL &lt;2&gt;                 0
</pre>
<p>From the result, you know that for <code class="codeph">prod_id</code> 100, there are 2 sales rows for quarter <code class="codeph">Q1</code>, and 1 sales row for quarter <code class="codeph">Q2</code>; for <code class="codeph">prod_id</code> 200, there is 1 sales row for quarter <code class="codeph">Q1</code>, and no sales row for quarter <code class="codeph">Q2</code>.So, in <code class="codeph">Q2_COUNT_TOTAL</code>, you can identify that <code class="codeph">NULL&lt;1&gt;</code> comes from a row in the original table whose measure is of null value, while <code class="codeph">NULL&lt;2&gt;</code> is due to no row being present in the original table for <code class="codeph">prod_id</code> 200 in quarter <code class="codeph">Q2</code>.</p>
</div>
</div>
<a id="DWHSG8734"></a>
<div class="props_rev_3"><a id="GUID-C4AF4C41-55D1-402F-89C1-ED83C7986395"></a>
<h3 id="DWHSG-GUID-C4AF4C41-55D1-402F-89C1-ED83C7986395" class="sect3">Wildcard and Subquery Pivoting with XML Operations</h3>
<div>
<p>If you want to use a wildcard argument or subquery in your pivoting columns, you can do so with <code class="codeph">PIVOT</code> XML syntax. With <code class="codeph">PIVOT</code> XML, the output of the operation is properly formatted XML.</p>
<p>The following example illustrates using the wildcard keyword, <code class="codeph">ANY</code>. It outputs XML that includes all channel values in <code class="codeph">sales_view</code>:</p>
<pre dir="ltr">SELECT *
FROM
   (SELECT product, channel, quantity_sold
    FROM sales_view
    ) PIVOT XML(SUM(quantity_sold)
                FOR channel IN (ANY)
               );
</pre>
<p>See <a href="analysis.htm#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">Example 18-24</a> for the syntax that creates the view <code class="codeph">sales_view</code>.</p>
<p>Note that the keyword <code class="codeph">ANY</code> is available in <code class="codeph">PIVOT</code> operations only as part of an XML operation. This output includes data for cases where the channel exists in the data set. Also note that aggregation functions must specify a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause to return multiple values, yet the <code class="codeph">pivot_clause</code> does not contain an explicit <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. Instead, the <code class="codeph">pivot_clause</code> performs an implicit <code class="codeph">GROUP</code> <code class="codeph">BY</code>.</p>
<p>The following example illustrates using a subquery. It outputs XML that includes all channel values and the sales data corresponding to each channel:</p>
<pre dir="ltr">SELECT *
FROM
     (SELECT product, channel, quantity_sold
      FROM sales_view
     ) PIVOT XML(SUM(quantity_sold)
                FOR channel IN (SELECT DISTINCT channel_id FROM CHANNELS)
             );
</pre>
<p>The output densifies the data to include all possible channels for each product.</p>
</div>
</div>
</div>
<a id="DWHSG8733"></a>
<div class="props_rev_3"><a id="GUID-B0AC9284-DDC1-4EF7-84CD-A27DF7F8DD57"></a>
<h2 id="DWHSG-GUID-B0AC9284-DDC1-4EF7-84CD-A27DF7F8DD57" class="sect2">Unpivoting Operations</h2>
<div>
<div class="section">
<p>An unpivot does not reverse a <code class="codeph">PIVOT</code> operation. Instead, it rotates data from columns into rows. If you are working with pivoted data, an <code class="codeph">UNPIVOT</code> operation cannot reverse any aggregations that have been made by <code class="codeph">PIVOT</code> or any other means.</p>
<p>To illustrate unpivoting, first create a pivoted table that includes four columns, for quarters of the year. The following command creates a table based on the view <code class="codeph">sales_view</code> created as described in <a href="analysis.htm#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">Example 18-24</a>:</p>
<pre dir="ltr">CREATE TABLE pivotedTable AS
SELECT *
FROM (SELECT product, quarter, quantity_sold, amount_sold
      FROM sales_view)
    PIVOT
    (
       SUM(quantity_sold) AS sumq, SUM(amount_sold) AS suma
       FOR quarter IN (&#39;01&#39; AS Q1, &#39;02&#39; AS Q2, &#39;03&#39; AS Q3, &#39;04&#39; AS Q4));
</pre>
<p>The table&#39;s contents resemble the following:</p>
<pre dir="ltr">SELECT *
FROM pivotedTable
ORDER BY product;

PRODUCT         Q1_SUMQ  Q1_SUMA  Q2_SUMQ  Q2_SUMA   Q3_SUMQ  Q3_SUMA   Q4_SUMQ    Q4_SUMA
--------------- -------  -------  -------  --------  -------  --------  -------    ---------
1.44MB External   6098   58301.33    5112   49001.56    6050   56974.3     5848     55341.28
128MB Memory      1963  110763.63    2361  132123.12    3069  170710.4     2832    157736.6
17&#34; LCD           1492 1812786.94    1387 1672389.06    1591 1859987.66    1540   1844008.11
...
</pre>
<p>The following <code class="codeph">UNPIVOT</code> operation rotates the quarter columns into rows. For each product, there will be four rows, one for each quarter.</p>
<pre dir="ltr">SELECT product, DECODE(quarter, &#39;Q1_SUMQ&#39;, &#39;Q1&#39;, &#39;Q2_SUMQ&#39;, &#39;Q2&#39;, &#39;Q3_SUMQ&#39;, &#39;Q3&#39;,
   &#39;Q4_SUMQ&#39;, &#39;Q4&#39;) AS quarter, quantity_sold
FROM  pivotedTable
   UNPIVOT INCLUDE NULLS
       (quantity_sold
        FOR quarter IN (Q1_SUMQ, Q2_SUMQ, Q3_SUMQ, Q4_SUMQ))
ORDER BY product, quarter;

PRODUCT                          QU    QUANTITY_SOLD
-------                          --    -------------
1.44MB External 3.5&#34; Diskette    Q1             6098
1.44MB External 3.5&#34; Diskette    Q2             5112
1.44MB External 3.5&#34; Diskette    Q3             6050
1.44MB External 3.5&#34; Diskette    Q4             5848
128MB Memory Card                Q1             1963
128MB Memory Card                Q2             2361
128MB Memory Card                Q3             3069
128MB Memory Card                Q4             2832
...
</pre>
<p>Note the use of <code class="codeph">INCLUDE</code> <code class="codeph">NULLS</code> in this example. You can also use <code class="codeph">EXCLUDE</code> <code class="codeph">NULLS</code>, which is the default setting.</p>
<p>In addition, you can also unpivot using two columns, as in the following:</p>
<pre dir="ltr">SELECT product, quarter, quantity_sold, amount_sold
FROM  pivotedTable
   UNPIVOT INCLUDE NULLS
       (
        (quantity_sold, amount_sold)
        FOR quarter IN ((Q1_SUMQ, Q1_SUMA) AS &#39;Q1&#39;, (Q2_SUMQ, Q2_SUMA) AS &#39;Q2&#39;, (Q3_SUMQ, Q3_SUMA) AS &#39;Q3&#39;, (Q4_SUMQ, Q4_SUMA) AS &#39;Q4&#39;))
ORDER BY product, quarter;
 
PRODUCT                          QU   QUANTITY_SOLD   AMOUNT_SOLD
-----------------------------    --   -------------   ------------
1.44MB External 3.5&#34; Diskette    Q1            6098       58301.33
1.44MB External 3.5&#34; Diskette    Q2            5112       49001.56
1.44MB External 3.5&#34; Diskette    Q3            6050       56974.3
1.44MB External 3.5&#34; Diskette    Q4            5848       55341.28
128MB Memory Card                Q1            1963      110763.63
128MB Memory Card                Q2            2361      132123.12
128MB Memory Card                Q3            3069      170710.4
128MB Memory Card                Q4            2832      157736.6
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG02013"></a>
<div class="props_rev_3"><a id="GUID-01B5DD6F-C039-4223-B017-263F7788C4FA"></a>
<h2 id="DWHSG-GUID-01B5DD6F-C039-4223-B017-263F7788C4FA" class="sect2">Data Densification for Reporting</h2>
<div>
<p>Data is <a id="d59823e4901" class="indexterm-anchor"></a><a id="d59823e4903" class="indexterm-anchor"></a><a id="d59823e4905" class="indexterm-anchor"></a>normally stored in sparse form. That is, if no value exists for a given combination of dimension values, no row exists in the fact table. However, you may want to view the data in dense form, with rows for all combination of dimension values displayed even when no fact data exist for them. For example, if a product did not sell during a particular time period, you may still want to see the product for that time period with zero sales value next to it. Moreover, time series calculations can be performed most easily when data is dense along the time dimension. This is because dense data will fill a consistent number of rows for each period, which in turn makes it simple to use the analytic windowing functions with physical offsets. Data densification is the process of converting sparse data into dense form.</p>
<p>To overcome the problem of sparsity, you can use a partitioned outer join to fill the gaps in a time series or any other dimension. Such a join extends the conventional outer join syntax by applying the outer join to each logical partition defined in a query. Oracle logically partitions the rows in your query based on the expression you specify in the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause. The result of a partitioned outer join is a <code class="codeph">UNION</code> of the outer joins of each of the partitions in the logically partitioned table with the table on the other side of the join.</p>
<p>Note that you can use this type of join to fill the gaps in any dimension, not just the time dimension. Most of the examples here focus on the time dimension because it is the dimension most frequently used as a basis for comparisons.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-F0ADB2FE-730D-42D7-9FE4-9C80206E1F96">About Partition Join Syntax</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE">Sample of Sparse Data</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-A0114A13-F31D-4B41-8069-AB85A72957FC">Filling Gaps in Data</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD">Filling Gaps in Two Dimensions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70">Filling Gaps in an Inventory Table</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-1778791F-C3CF-485D-8EEC-D861316828B7">Computing Data Values to Fill Gaps</a></p>
</li>
</ul>
</div>
<a id="DWHSG8735"></a>
<div class="props_rev_3"><a id="GUID-F0ADB2FE-730D-42D7-9FE4-9C80206E1F96"></a>
<h3 id="DWHSG-GUID-F0ADB2FE-730D-42D7-9FE4-9C80206E1F96" class="sect3">About Partition Join Syntax</h3>
<div>
<p>The syntax for partitioned outer join extends the SQL <code class="codeph">JOIN</code> clause with the phrase <code class="codeph">PARTITION</code> <code class="codeph">BY</code> followed by an expression list. The expressions in the list specify the group to which the outer join is applied. The following are the two forms of syntax normally used for partitioned outer join:</p>
<pre dir="ltr">SELECT .....
FROM table_reference
PARTITION BY (expr [, expr ]... )
RIGHT OUTER JOIN table_reference

SELECT .....
FROM table_reference
LEFT OUTER JOIN table_reference
PARTITION BY {expr [,expr ]...)
</pre>
<p>Note that <code class="codeph">FULL</code> <code class="codeph">OUTER</code> <code class="codeph">JOIN</code> is not supported with a partitioned outer join.</p>
</div>
</div>
<a id="DWHSG8736"></a>
<div class="props_rev_3"><a id="GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE"></a>
<h3 id="DWHSG-GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE" class="sect3">Sample of Sparse Data</h3>
<div>
<p>A typi<a id="d59823e5022" class="indexterm-anchor"></a><a id="d59823e5026" class="indexterm-anchor"></a>cal situation with a sparse dimension is shown in the following example, which computes the weekly sales and year-to-date sales for the product Bounce for weeks 20-30 in 2000 and 2001:</p>
<pre dir="ltr">SELECT SUBSTR(p.Prod_Name,1,15) Product_Name, t.Calendar_Year Year,
 t.Calendar_Week_Number Week, SUM(Amount_Sold) Sales
FROM Sales s, Times t, Products p
WHERE s.Time_id = t.Time_id AND s.Prod_id = p.Prod_id AND
 p.Prod_name IN (&#39;Bounce&#39;) AND t.Calendar_Year IN (2000,2001) AND
 t.Calendar_Week_Number BETWEEN 20 AND 30
GROUP BY p.Prod_Name, t.Calendar_Year, t.Calendar_Week_Number;

PRODUCT_NAME          YEAR       WEEK      SALES
--------------- ---------- ---------- ----------
Bounce                2000         20        801
Bounce                2000         21    4062.24
Bounce                2000         22    2043.16
Bounce                2000         23    2731.14
Bounce                2000         24    4419.36
Bounce                2000         27    2297.29
Bounce                2000         28    1443.13
Bounce                2000         29    1927.38
Bounce                2000         30    1927.38
Bounce                2001         20    1483.3
Bounce                2001         21    4184.49
Bounce                2001         22    2609.19
Bounce                2001         23    1416.95
Bounce                2001         24    3149.62
Bounce                2001         25    2645.98
Bounce                2001         27    2125.12
Bounce                2001         29    2467.92
Bounce                2001         30    2620.17
</pre>
<p>In this example, you would expect 22 rows of data (11 weeks each from 2 years) if the data were dense. However, you get only 18 rows because weeks 25 and 26 are missing in 2000, and weeks 26 and 28 in 2001.</p>
</div>
</div>
<a id="DWHSG8737"></a>
<div class="props_rev_3"><a id="GUID-A0114A13-F31D-4B41-8069-AB85A72957FC"></a>
<h3 id="DWHSG-GUID-A0114A13-F31D-4B41-8069-AB85A72957FC" class="sect3">Filling Gaps in Data</h3>
<div>
<div class="section">
<p>You can take the sparse data of the query shown in <a href="analysis.htm#GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE">Sample of Sparse Data</a> and do a partitioned outer join with a dense set of time data. In the following query, you alias the original query as <code class="codeph">v</code> and you select data from the <code class="codeph">times</code> table, which you alias as <code class="codeph">t</code>. Here you retrieve 22 rows because there are no gaps in the series. The four added rows each have 0 as their Sales value set to 0 by using the <code class="codeph">NVL</code> function.</p>
<pre dir="ltr">SELECT Product_Name, t.Year, t.Week, NVL(Sales,0) dense_sales
FROM
 (SELECT SUBSTR(p.Prod_Name,1,15) Product_Name,
  t.Calendar_Year Year, t.Calendar_Week_Number Week, SUM(Amount_Sold) Sales
  FROM Sales s, Times t, Products p
  WHERE s.Time_id = t.Time_id AND s.Prod_id = p.Prod_id AND
   p.Prod_name IN (&#39;Bounce&#39;) AND t.Calendar_Year IN (2000,2001) AND
   t.Calendar_Week_Number BETWEEN 20 AND 30
  GROUP BY p.Prod_Name, t.Calendar_Year, t.Calendar_Week_Number) v
PARTITION BY (v.Product_Name)
RIGHT OUTER JOIN
 (SELECT DISTINCT Calendar_Week_Number Week, Calendar_Year Year
  FROM Times
  WHERE Calendar_Year IN (2000, 2001)
  AND Calendar_Week_Number BETWEEN 20 AND 30) t
ON (v.week = t.week AND v.Year = t.Year)
ORDER BY t.year, t.week;
</pre>
<pre dir="ltr">PRODUCT_NAME          YEAR       WEEK DENSE_SALES
--------------- ---------- ---------- -----------
Bounce                2000         20         801
Bounce                2000         21     4062.24
Bounce                2000         22     2043.16
Bounce                2000         23     2731.14
Bounce                2000         24     4419.36
Bounce                2000         25           0
Bounce                2000         26           0
Bounce                2000         27     2297.29
Bounce                2000         28     1443.13
Bounce                2000         29     1927.38
Bounce                2000         30     1927.38
Bounce                2001         20      1483.3
Bounce                2001         21     4184.49
Bounce                2001         22     2609.19
Bounce                2001         23     1416.95
Bounce                2001         24     3149.62
Bounce                2001         25     2645.98
Bounce                2001         26           0
Bounce                2001         27     2125.12
Bounce                2001         28           0
Bounce                2001         29     2467.92
Bounce                2001         30     2620.17
</pre>
<p>Note that in this query, a <code class="codeph">WHERE</code> condition was placed for weeks between 20 and 30 in the inline view for the time dimension. This was introduced to keep the result set small.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8738"></a>
<div class="props_rev_3"><a id="GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD"></a>
<h3 id="DWHSG-GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD" class="sect3">Filling Gaps in Two Dimensions</h3>
<div>
<div class="section">
<p>N-dimensional data is typically displayed as a dense 2-dimensional cross tab of (n - 2) page dimensions. This requires that all dimension values for the two dimensions appearing in the cross tab be filled in. The following is another example where the partitioned outer join capability can be used for filling the gaps on two dimensions:</p>
<pre dir="ltr">WITH v1 AS
 (SELECT p.prod_id, country_id, calendar_year,
    SUM(quantity_sold) units, SUM(amount_sold) sales
  FROM sales s, products p, customers c, times t
  WHERE s.prod_id in (147, 148) AND t.time_id = s.time_id AND
    c.cust_id = s.cust_id AND p.prod_id = s.prod_id
  GROUP BY p.prod_id, country_id, calendar_year),
v2 AS                                  --countries to use for densifications
  (SELECT DISTINCT country_id 
  FROM customers
  WHERE country_id IN (52782, 52785, 52786, 52787, 52788)),
v3 AS                                   --years to use for densifications
  (SELECT DISTINCT calendar_year FROM times)
SELECT v4.prod_id, v4.country_id, v3.calendar_year, units, sales
FROM 
  (SELECT prod_id, v2.country_id, calendar_year, units, sales
   FROM v1 PARTITION BY (prod_id) 
   RIGHT OUTER JOIN v2                  --densifies on country
   ON (v1.country_id = v2.country_id)) v4 
PARTITION BY (prod_id,country_id)
RIGHT OUTER JOIN v3                     --densifies on year
ON (v4.calendar_year = v3.calendar_year)
ORDER BY 1, 2, 3;
</pre>
<p>In this query, the <code class="codeph">WITH</code> subquery factoring clause <code class="codeph">v1</code> summarizes sales data at the product, country, and year level. This result is sparse but users may want to see all the country, year combinations for each product. To achieve this, you take each partition of <code class="codeph">v1</code> based on product values and outer join it on the country dimension first. This will give us all values of country for each product. You then take that result and partition it on product and country values and then outer join it on time dimension. This will give us all time values for each product and country combination.</p>
<pre dir="ltr">   PROD_ID COUNTRY_ID CALENDAR_YEAR      UNITS      SALES
---------- ---------- ------------- ---------- ----------
       147      52782          1998
       147      52782          1999         29     209.82
       147      52782          2000         71     594.36
       147      52782          2001        345    2754.42
       147      52782          2002
       147      52785          1998          1       7.99
       147      52785          1999
       147      52785          2000
       147      52785          2001
       147      52785          2002
       147      52786          1998          1       7.99
       147      52786          1999
       147      52786          2000          2      15.98
       147      52786          2001
       147      52786          2002
       147      52787          1998
       147      52787          1999
       147      52787          2000
       147      52787          2001
       147      52787          2002
       147      52788          1998
       147      52788          1999
       147      52788          2000          1       7.99
       147      52788          2001
       147      52788          2002
       148      52782          1998        139    4046.67
       148      52782          1999        228    5362.57
       148      52782          2000        251    5629.47
       148      52782          2001        308    7138.98
       148      52782          2002
       148      52785          1998
       148      52785          1999
       148      52785          2000
       148      52785          2001
       148      52785          2002
       148      52786          1998
       148      52786          1999
       148      52786          2000
       148      52786          2001
       148      52786          2002
       148      52787          1998
       148      52787          1999
       148      52787          2000
       148      52787          2001
       148      52787          2002
       148      52788          1998          4     117.23
       148      52788          1999
       148      52788          2000
       148      52788          2001
       148      52788          2002
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8739"></a>
<div class="props_rev_3"><a id="GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70"></a>
<h3 id="DWHSG-GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70" class="sect3">Filling Gaps in an Inventory Table</h3>
<div>
<div class="section">
<p>An inventory table typically tracks quantity of units available for various products. This table is sparse: it only stores a row for a product when there is an event. For a sales table, the event is a sale, and for the inventory table, the event is a change in quantity available for a product. For example, consider the following inventory table:</p>
<pre dir="ltr">CREATE TABLE invent_table (
product VARCHAR2(10),
time_id DATE,
quant NUMBER);

INSERT INTO invent_table VALUES
 (&#39;bottle&#39;, TO_DATE(&#39;01/04/01&#39;, &#39;DD/MM/YY&#39;), 10);
INSERT INTO invent_table VALUES
 (&#39;bottle&#39;, TO_DATE(&#39;06/04/01&#39;, &#39;DD/MM/YY&#39;), 8);
INSERT INTO invent_table VALUES
 (&#39;can&#39;, TO_DATE(&#39;01/04/01&#39;, &#39;DD/MM/YY&#39;), 15);
INSERT INTO invent_table VALUES
 (&#39;can&#39;, TO_DATE(&#39;04/04/01&#39;, &#39;DD/MM/YY&#39;), 11);
</pre>
<p>The inventory table now has the following rows:</p>
<pre dir="ltr">PRODUCT    TIME_ID   QUANT
---------- --------- -----
bottle     01-APR-01    10
bottle     06-APR-01     8
can        01-APR-01    15
can        04-APR-01    11
</pre>
<p>For reporting purposes, users may want to see this inventory data differently. For example, they may want to see all values of time for each product. This can be accomplished using partitioned outer join. In addition, for the newly inserted rows of missing time periods, users may want to see the values for quantity of units column to be carried over from the most recent existing time period. The latter can be accomplished using analytic window function <code class="codeph">LAST_VALUE</code> value. Here is the query and the desired output:</p>
<pre dir="ltr">WITH v1 AS
 (SELECT time_id
  FROM times
  WHERE times.time_id BETWEEN
   TO_DATE(&#39;01/04/01&#39;, &#39;DD/MM/YY&#39;)
   AND TO_DATE(&#39;07/04/01&#39;, &#39;DD/MM/YY&#39;))
SELECT product, time_id, quant quantity,
  LAST_VALUE(quant IGNORE NULLS)
    OVER (PARTITION BY product ORDER BY time_id)
    repeated_quantity
FROM 
 (SELECT product, v1.time_id, quant
  FROM invent_table PARTITION BY (product)
  RIGHT OUTER JOIN v1
  ON (v1.time_id = invent_table.time_id))
ORDER BY 1, 2;
</pre>
<p>The inner query computes a partitioned outer join on time within each product. The inner query densifies the data on the time dimension (meaning the time dimension will now have a row for each day of the week). However, the measure column <code class="codeph">quantity</code> will have nulls for the newly added rows (see the output in the column <code class="codeph">quantity</code> in the following results.</p>
<p>The outer query uses the analytic function <code class="codeph">LAST_VALUE</code>. Applying this function partitions the data by product and orders the data on the time dimension column (<code class="codeph">time_id</code>). For each row, the function finds the last non-null value in the window due to the option <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>, which you can use with both <code class="codeph">LAST_VALUE</code> and <code class="codeph">FIRST_VALUE</code>. You see the desired output in the column <code class="codeph">repeated_quantity</code> in the following output:</p>
<pre dir="ltr">PRODUCT    TIME_ID   QUANTITY REPEATED_QUANTITY
---------- --------- -------- -----------------
bottle     01-APR-01       10                10
bottle     02-APR-01                         10
bottle     03-APR-01                         10
bottle     04-APR-01                         10
bottle     05-APR-01                         10
bottle     06-APR-01        8                 8
bottle     07-APR-01                          8
can        01-APR-01       15                15
can        02-APR-01                         15
can        03-APR-01                         15
can        04-APR-01       11                11
can        05-APR-01                         11
can        06-APR-01                         11
can        07-APR-01                         11
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8740"></a>
<div class="props_rev_3"><a id="GUID-1778791F-C3CF-485D-8EEC-D861316828B7"></a>
<h3 id="DWHSG-GUID-1778791F-C3CF-485D-8EEC-D861316828B7" class="sect3">Computing Data Values to Fill Gaps</h3>
<div>
<div class="section">
<p>Examples<a id="d59823e5216" class="indexterm-anchor"></a> in sections <a href="analysis.htm#GUID-A0114A13-F31D-4B41-8069-AB85A72957FC">Filling Gaps in Data</a>, <a href="analysis.htm#GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD">Filling Gaps in Two Dimensions</a>, and <a href="analysis.htm#GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70">Filling Gaps in an Inventory Table</a> illustrate how to use partitioned outer join to fill gaps in one or more dimensions. However, the result sets produced by partitioned outer join have null values for columns that are not included in the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> list. Typically, these are measure columns. Users can make use of analytic SQL functions to replace those null values with a non-null value.</p>
<p>For example, the following query computes monthly totals for products 64MB Memory card and DVD-R Discs (product IDs 122 and 136) for the year 2000. It uses partitioned outer join to densify data for all months. For the missing months, it then uses the analytic SQL function <code class="codeph">AVG</code> to compute the sales and units to be the average of the months when the product was sold.</p>
<p>If working in SQL*Plus, the following two commands wraps the column headings for greater readability of results:</p>
<pre dir="ltr">col computed_units  heading  &#39;Computed|_units&#39;
col computed_sales  heading  &#39;Computed|_sales&#39;

WITH V AS
 (SELECT substr(p.prod_name,1,12) prod_name, calendar_month_desc,
     SUM(quantity_sold) units, SUM(amount_sold) sales
   FROM sales s, products p, times t
   WHERE s.prod_id IN (122,136) AND calendar_year = 2000
     AND t.time_id = s.time_id
     AND p.prod_id = s.prod_id
   GROUP BY p.prod_name, calendar_month_desc)
SELECT v.prod_name, calendar_month_desc, units, sales,
  NVL(units, AVG(units) OVER (PARTITION BY v.prod_name)) computed_units,
  NVL(sales, AVG(sales) OVER (PARTITION BY v.prod_name)) computed_sales
FROM 
  (SELECT DISTINCT calendar_month_desc
   FROM times
   WHERE calendar_year = 2000) t
   LEFT OUTER JOIN V
   PARTITION BY (prod_name)
   USING (calendar_month_desc);
                                              computed   computed
PROD_NAME    CALENDAR      UNITS      SALES     _units     _sales
------------ -------- ---------- ---------- ---------- ----------
64MB Memory  2000-01         112    4129.72        112    4129.72
64MB Memory  2000-02         190       7049        190       7049
64MB Memory  2000-03          47    1724.98         47    1724.98
64MB Memory  2000-04          20      739.4         20      739.4
64MB Memory  2000-05          47    1738.24         47    1738.24
64MB Memory  2000-06          20      739.4         20      739.4
64MB Memory  2000-07                        72.6666667    2686.79
64MB Memory  2000-08                        72.6666667    2686.79
64MB Memory  2000-09                        72.6666667    2686.79
64MB Memory  2000-10                        72.6666667    2686.79
64MB Memory  2000-11                        72.6666667    2686.79
64MB Memory  2000-12                        72.6666667    2686.79
DVD-R Discs, 2000-01         167     3683.5        167     3683.5
DVD-R Discs, 2000-02         152    3362.24        152    3362.24
DVD-R Discs, 2000-03         188    4148.02        188    4148.02
DVD-R Discs, 2000-04         144    3170.09        144    3170.09
DVD-R Discs, 2000-05         189    4164.87        189    4164.87
DVD-R Discs, 2000-06         145    3192.21        145    3192.21
DVD-R Discs, 2000-07                            124.25    2737.71
DVD-R Discs, 2000-08                            124.25    2737.71
DVD-R Discs, 2000-09           1      18.91          1      18.91
DVD-R Discs, 2000-10                            124.25    2737.71
DVD-R Discs, 2000-11                            124.25    2737.71
DVD-R Discs, 2000-12           8     161.84          8     161.84
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8741"></a>
<div class="props_rev_3"><a id="GUID-759F5F20-D45B-443F-9464-E71A4B70AF1B"></a>
<h2 id="DWHSG-GUID-759F5F20-D45B-443F-9464-E71A4B70AF1B" class="sect2">Time Series Calculations on Densified Data</h2>
<div>
<p>Densificatio<a id="d59823e5271" class="indexterm-anchor"></a><a id="d59823e5275" class="indexterm-anchor"></a>n is not just for reporting purpose. It also enables certain types of calculations, especially, time series calculations. Time series calculations are easier when data is dense along the time dimension. Dense data has a consistent number of rows for each time periods which in turn make it simple to use analytic window functions with physical offsets.</p>
<p>To illustrate, let us first take the example on <span class="q">&#34;<a href="analysis.htm#GUID-A0114A13-F31D-4B41-8069-AB85A72957FC">Filling Gaps in Data</a>&#34;</span>, and let&#39;s add an analytic function to that query. In the following enhanced version, you calculate weekly year-to-date sales alongside the weekly sales. The <code class="codeph">NULL</code> values that the partitioned outer join inserts in making the time series dense are handled in the usual way: the <code class="codeph">SUM</code> function treats them as 0&#39;s.</p>
<pre dir="ltr">SELECT Product_Name, t.Year, t.Week, NVL(Sales,0) Current_sales,
 SUM(Sales) 
   OVER (PARTITION BY Product_Name, t.year ORDER BY t.week) Cumulative_sales
FROM 
 (SELECT SUBSTR(p.Prod_Name,1,15) Product_Name, t.Calendar_Year Year,
   t.Calendar_Week_Number Week, SUM(Amount_Sold) Sales
  FROM Sales s, Times t, Products p
  WHERE s.Time_id = t.Time_id AND
   s.Prod_id = p.Prod_id AND p.Prod_name IN (&#39;Bounce&#39;) AND
   t.Calendar_Year IN (2000,2001) AND
   t.Calendar_Week_Number BETWEEN 20 AND 30
  GROUP BY p.Prod_Name, t.Calendar_Year, t.Calendar_Week_Number) v
PARTITION BY (v.Product_Name)
RIGHT OUTER JOIN
(SELECT DISTINCT
 Calendar_Week_Number Week, Calendar_Year Year
 FROM Times
 WHERE Calendar_Year in (2000, 2001)
 AND Calendar_Week_Number BETWEEN 20 AND 30) t
ON (v.week = t.week AND v.Year = t.Year)
ORDER BY t.year, t.week;

PRODUCT_NAME          YEAR       WEEK CURRENT_SALES CUMULATIVE_SALES
--------------- ---------- ---------- ------------- ----------------
Bounce                2000         20           801              801
Bounce                2000         21       4062.24          4863.24
Bounce                2000         22       2043.16           6906.4
Bounce                2000         23       2731.14          9637.54
Bounce                2000         24       4419.36          14056.9
Bounce                2000         25             0          14056.9
Bounce                2000         26             0          14056.9
Bounce                2000         27       2297.29         16354.19
Bounce                2000         28       1443.13         17797.32
Bounce                2000         29       1927.38          19724.7
Bounce                2000         30       1927.38         21652.08
Bounce                2001         20        1483.3           1483.3
Bounce                2001         21       4184.49          5667.79
Bounce                2001         22       2609.19          8276.98
Bounce                2001         23       1416.95          9693.93
Bounce                2001         24       3149.62         12843.55
Bounce                2001         25       2645.98         15489.53
Bounce                2001         26             0         15489.53
Bounce                2001         27       2125.12         17614.65
Bounce                2001         28             0         17614.65
Bounce                2001         29       2467.92         20082.57
Bounce                2001         30       2620.17         22702.74
</pre>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-E32F35FA-1188-45EC-805D-3D934806911A">Period-to-Period Comparison for One Time Level: Example</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC">Period-to-Period Comparison for Multiple Time Levels: Example</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-8BED5B1F-C20F-4215-B4A0-28DD1564CC3B">Creating a Custom Member in a Dimension: Example</a></p>
</li>
</ul>
</div>
<a id="DWHSG8742"></a>
<div class="props_rev_3"><a id="GUID-E32F35FA-1188-45EC-805D-3D934806911A"></a>
<h3 id="DWHSG-GUID-E32F35FA-1188-45EC-805D-3D934806911A" class="sect3">Period-to-Period Comparison for One Time Level: Example</h3>
<div>
<p>How do you use this feature to compare values across time periods? Specifically, how do you calculate a year-over-year sales comparison at the week level? The following query returns on the same row, for each product, the year-to-date sales for each week of 2001 with that of 2000.</p>
<p>Note that in this example you start with a <code class="codeph">WITH</code> clause. This improves readability of the query and lets us focus on the partitioned outer join. If working in SQL*Plus, the following command wraps the column headings for greater readability of results:</p>
<pre dir="ltr">col Weekly_ytd_sales_prior_year  heading  &#39;Weekly_ytd|_sales_|prior_year&#39;

WITH v AS
  (SELECT SUBSTR(p.Prod_Name,1,6) Prod, t.Calendar_Year Year,
     t.Calendar_Week_Number Week, SUM(Amount_Sold) Sales
   FROM Sales s, Times t, Products p
   WHERE s.Time_id = t.Time_id AND
     s.Prod_id = p.Prod_id AND p.Prod_name in (&#39;Y Box&#39;) AND
     t.Calendar_Year in (2000,2001) AND 
     t.Calendar_Week_Number BETWEEN 30 AND 40
   GROUP BY p.Prod_Name, t.Calendar_Year, t.Calendar_Week_Number)
SELECT Prod , Year, Week, Sales,
  Weekly_ytd_sales, Weekly_ytd_sales_prior_year
FROM 
  (SELECT Prod, Year, Week, Sales, Weekly_ytd_sales,
     LAG(Weekly_ytd_sales, 1) OVER 
       (PARTITION BY Prod , Week ORDER BY Year) Weekly_ytd_sales_prior_year
   FROM 
     (SELECT v.Prod  Prod , t.Year Year, t.Week Week,
        NVL(v.Sales,0) Sales, SUM(NVL(v.Sales,0)) OVER
          (PARTITION BY v.Prod , t.Year ORDER BY t.week) weekly_ytd_sales
      FROM v
      PARTITION BY (v.Prod )
      RIGHT OUTER JOIN
        (SELECT DISTINCT Calendar_Week_Number Week, Calendar_Year Year
         FROM Times
         WHERE Calendar_Year IN (2000, 2001)) t
      ON (v.week = t.week AND v.Year = t.Year)
     ) dense_sales
  ) year_over_year_sales
WHERE Year = 2001 AND Week BETWEEN 30 AND 40
ORDER BY 1, 2, 3;
                                                         Weekly_ytd
                                                            _sales_
PROD         YEAR       WEEK      SALES WEEKLY_YTD_SALES prior_year
------ ---------- ---------- ---------- ---------------- ----------
Y Box        2001         30    7877.45          7877.45          0
Y Box        2001         31   13082.46         20959.91    1537.35
Y Box        2001         32   11569.02         32528.93    9531.57
Y Box        2001         33   38081.97          70610.9   39048.69
Y Box        2001         34   33109.65        103720.55   69100.79
Y Box        2001         35          0        103720.55   71265.35
Y Box        2001         36     4169.3        107889.85   81156.29
Y Box        2001         37   24616.85         132506.7   95433.09
Y Box        2001         38   37739.65        170246.35  107726.96
Y Box        2001         39     284.95         170531.3   118817.4
Y Box        2001         40   10868.44        181399.74  120969.69
</pre>
<p>In the <code class="codeph">FROM</code> clause of the inline view <code class="codeph">dense_sales</code>, you use a partitioned outer join of aggregate view <code class="codeph">v</code> and time view <code class="codeph">t</code> to fill gaps in the sales data along the time dimension. The output of the partitioned outer join is then processed by the analytic function <code class="codeph">SUM ... OVER</code> to compute the weekly year-to-date sales (the <code class="codeph">weekly_ytd_sales</code> column). Thus, the view <code class="codeph">dense_sales</code> computes the year-to-date sales data for each week, including those missing in the aggregate view s. The inline view <code class="codeph">year_over_year_sales</code> then computes the year ago weekly year-to-date sales using the <code class="codeph">LAG</code> function. The <code class="codeph">LAG</code> function labeled <code class="codeph">weekly_ytd_sales_prior_year</code> specifies a <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause that pairs rows for the same week of years 2000 and 2001 into a single partition. You then pass an offset of 1 to the <code class="codeph">LAG</code> function to get the weekly year to date sales for the prior year.The outermost query block selects data from <code class="codeph">year_over_year_sales</code> with the condition <code class="codeph">yr = 2001</code>, and thus the query returns, for each product, its weekly year-to-date sales in the specified weeks of years 2001 and 2000.</p>
</div>
</div>
<a id="DWHSG8743"></a>
<div class="props_rev_3"><a id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC"></a>
<h3 id="DWHSG-GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC" class="sect3">Period-to-Period Comparison for Multiple Time Levels: Example</h3>
<div>
<p>While the prior example shows us a way to create comparisons for a single time level, it would be even more useful to handle multiple time levels in a single query. For example, you could compare sales versus the prior period at the year, quarter, month and day levels. How can you create a query which performs a year-over-year comparison of year-to-date sales for all levels of our time hierarchy?</p>
<p>You will take several steps to perform this task. The goal is a single query with comparisons at the day, week, month, quarter, and year level. The steps are as follows:</p>
<ol>
<li>
<p>Create a view called <code class="codeph">cube_prod_time</code>, which holds a hierarchical cube of sales aggregated across <code class="codeph">times</code> and <code class="codeph">products</code>.</p>
<p>See <span class="q">&#34;<a href="analysis.htm#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDHGDJC">Create the Hierarchical Cube View</a>&#34;</span>.</p>
</li>
<li>
<p>Create a view of the time dimension to use as an edge of the cube. The time edge, which holds a complete set of dates, will be partitioned outer joined to the sparse data in the view <code class="codeph">cube_prod_time</code>.</p>
<p>See <span class="q">&#34;<a href="analysis.htm#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDFDIGG">Create the View edge_time, which is a Complete Set of Date Values</a>&#34;</span>.</p>
</li>
<li>
<p>Finally, for maximum performance, create a materialized view, <code class="codeph">mv_prod_time</code>, built using the same definition as <code class="codeph">cube_prod_time</code>.</p>
<p>See <span class="q">&#34;<a href="analysis.htm#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDEHJHE">Create the Materialized View mv_prod_time to Support Faster Performance</a>&#34;</span>.</p>
</li>
<li>
<p>Create the comparison query.</p>
<p>See <span class="q">&#34;<a href="analysis.htm#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDIAIEB">Create the Comparison Query</a>&#34;</span>.</p>
</li>
</ol>
<p>For more information regarding hierarchical cubes, see <a href="aggreg.htm#GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2">SQL for Aggregation in Data Warehouses</a>. The materialized view is defined in the following section.</p>
<div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDHGDJC">
<p class="subhead3">Create the Hierarchical Cube View</p>
<p>The materialized view shown in the following may already exist in your system; if not, create it now. If you must generate it, note that you limit the query to just two products to keep processing time short:</p>
<pre dir="ltr">CREATE OR REPLACE VIEW cube_prod_time AS
SELECT 
  (CASE
     WHEN ((GROUPING(calendar_year)=0 ) 
       AND (GROUPING(calendar_quarter_desc)=1 ))
       THEN (TO_CHAR(calendar_year) || &#39;_0&#39;)
     WHEN ((GROUPING(calendar_quarter_desc)=0 )
       AND (GROUPING(calendar_month_desc)=1 ))
       THEN (TO_CHAR(calendar_quarter_desc) || &#39;_1&#39;)
     WHEN ((GROUPING(calendar_month_desc)=0 )
       AND (GROUPING(t.time_id)=1 ))
       THEN (TO_CHAR(calendar_month_desc) || &#39;_2&#39;)
     ELSE (TO_CHAR(t.time_id) || &#39;_3&#39;)
  END) Hierarchical_Time,
  calendar_year year, calendar_quarter_desc quarter,
  calendar_month_desc month, t.time_id day,
  prod_category cat, prod_subcategory subcat, p.prod_id prod,
  GROUPING_ID(prod_category, prod_subcategory, p.prod_id,
    calendar_year, calendar_quarter_desc, calendar_month_desc,t.time_id) gid,
  GROUPING_ID(prod_category, prod_subcategory, p.prod_id) gid_p,
  GROUPING_ID(calendar_year, calendar_quarter_desc,
    calendar_month_desc, t.time_id) gid_t,
  SUM(amount_sold) s_sold, COUNT(amount_sold) c_sold, COUNT(*) cnt
FROM SALES s, TIMES t, PRODUCTS p
WHERE s.time_id = t.time_id AND
  p.prod_name IN (&#39;Bounce&#39;, &#39;Y Box&#39;) AND s.prod_id = p.prod_id
GROUP BY
  ROLLUP(calendar_year, calendar_quarter_desc, calendar_month_desc, t.time_id),
  ROLLUP(prod_category, prod_subcategory, p.prod_id);
</pre>
<p>Because this view is limited to two products, it returns just over 2200 rows. Note that the column <code class="codeph">Hierarchical_Time</code> contains string representations of time from all levels of the time hierarchy. The <code class="codeph">CASE</code> expression used for the <code class="codeph">Hierarchical_Time</code> column appends a marker (_0, _1, ...) to each date string to denote the time level of the value. A _0 represents the year level, _1 is quarters, _2 is months, and _3 is day. Note that the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause is a concatenated <code class="codeph">ROLLUP</code> which specifies the rollup hierarchy for the time and product dimensions. The <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause is what determines the hierarchical cube contents.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDFDIGG">
<p class="subhead3">Create the View edge_time, which is a Complete Set of Date Values</p>
<p><code class="codeph">edge_time</code> is the source for filling time gaps in the hierarchical cube using a partitioned outer join. The column <code class="codeph">Hierarchical_Time</code> in <code class="codeph">edge_time</code> will be used in a partitioned join with the <code class="codeph">Hierarchical_Time</code> column in the view <code class="codeph">cube_prod_time</code>. The following statement defines <code class="codeph">edge_time</code>:</p>
<pre dir="ltr">CREATE OR REPLACE VIEW edge_time AS
SELECT 
  (CASE
     WHEN ((GROUPING(calendar_year)=0 )
       AND (GROUPING(calendar_quarter_desc)=1 ))
       THEN (TO_CHAR(calendar_year) || &#39;_0&#39;)
     WHEN ((GROUPING(calendar_quarter_desc)=0 )
       AND (GROUPING(calendar_month_desc)=1 ))
       THEN (TO_CHAR(calendar_quarter_desc) || &#39;_1&#39;)
     WHEN ((GROUPING(calendar_month_desc)=0 )
       AND (GROUPING(time_id)=1 ))
       THEN (TO_CHAR(calendar_month_desc) || &#39;_2&#39;)
     ELSE (TO_CHAR(time_id) || &#39;_3&#39;)
   END) Hierarchical_Time,
   calendar_year yr, calendar_quarter_number qtr_num,
   calendar_quarter_desc qtr, calendar_month_number mon_num,
   calendar_month_desc mon, time_id - TRUNC(time_id, &#39;YEAR&#39;) + 1 day_num,
   time_id day,
GROUPING_ID(calendar_year, calendar_quarter_desc,
  calendar_month_desc, time_id) gid_t
FROM TIMES
GROUP BY ROLLUP
 (calendar_year, (calendar_quarter_desc, calendar_quarter_number),
 (calendar_month_desc, calendar_month_number), time_id);
</pre></div>
<!-- class="section" -->
<div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDEHJHE">
<p class="subhead3">Create the Materialized View mv_prod_time to Support Faster Performance</p>
<p>The materialized view definition is a duplicate of the view <code class="codeph">cube_prod_time</code> defined earlier. Because it is a duplicate query, references to <code class="codeph">cube_prod_time</code> will be rewritten to use the <code class="codeph">mv_prod_time</code> materialized view. The following materialized may already exist in your system; if not, create it now. If you must generate it, note that you limit the query to just two products to keep processing time short.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW mv_prod_time
REFRESH COMPLETE ON DEMAND AS
SELECT 
  (CASE
     WHEN ((GROUPING(calendar_year)=0 )
       AND (GROUPING(calendar_quarter_desc)=1 ))
       THEN (TO_CHAR(calendar_year) || &#39;_0&#39;)
     WHEN ((GROUPING(calendar_quarter_desc)=0 )
       AND (GROUPING(calendar_month_desc)=1 ))
       THEN (TO_CHAR(calendar_quarter_desc) || &#39;_1&#39;)
     WHEN ((GROUPING(calendar_month_desc)=0 )
       AND (GROUPING(t.time_id)=1 ))
       THEN (TO_CHAR(calendar_month_desc) || &#39;_2&#39;)
     ELSE (TO_CHAR(t.time_id) || &#39;_3&#39;)
  END) Hierarchical_Time,
  calendar_year year, calendar_quarter_desc quarter,
  calendar_month_desc month, t.time_id day,
  prod_category cat, prod_subcategory subcat, p.prod_id prod,
  GROUPING_ID(prod_category, prod_subcategory, p.prod_id,
    calendar_year, calendar_quarter_desc, calendar_month_desc,t.time_id) gid,
  GROUPING_ID(prod_category, prod_subcategory, p.prod_id) gid_p,
  GROUPING_ID(calendar_year, calendar_quarter_desc,
    calendar_month_desc, t.time_id) gid_t,
  SUM(amount_sold) s_sold, COUNT(amount_sold) c_sold, COUNT(*) cnt
FROM SALES s, TIMES t, PRODUCTS p
WHERE s.time_id = t.time_id AND
  p.prod_name IN (&#39;Bounce&#39;, &#39;Y Box&#39;) AND s.prod_id = p.prod_id
GROUP BY
  ROLLUP(calendar_year, calendar_quarter_desc, calendar_month_desc, t.time_id),
  ROLLUP(prod_category, prod_subcategory, p.prod_id);
</pre></div>
<!-- class="section" -->
<div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDIAIEB">
<p class="subhead3">Create the Comparison Query</p>
<p>You have now set the stage for our comparison query. You can obtain period-to-period comparison calculations at all time levels. It requires applying analytic functions to a hierarchical cube with dense data along the time dimension.</p>
<p>Some of the calculations you can achieve for each time level are:</p>
<ul style="list-style-type: disc;">
<li>
<p>Sum of sales for prior period at all levels of time.</p>
</li>
<li>
<p>Variance in sales over prior period.</p>
</li>
<li>
<p>Sum of sales in the same period a year ago at all levels of time.</p>
</li>
<li>
<p>Variance in sales over the same period last year.</p>
</li>
</ul>
<p>The following example performs all four of these calculations. It uses a partitioned outer join of the views <code class="codeph">cube_prod_time</code> and <code class="codeph">edge_time</code> to create an inline view of dense data called <code class="codeph">dense_cube_prod_time</code>. The query then uses the <code class="codeph">LAG</code> function in the same way as the prior single-level example. The outer <code class="codeph">WHERE</code> clause specifies time at three levels: the days of August 2001, the entire month, and the entire third quarter of 2001. Note that the last two rows of the results contain the month level and quarter level aggregations.Note that to make the results easier to read if you are using SQL*Plus, the column headings should be adjusted with the following commands. The commands will fold the column headings to reduce line length:</p>
<pre dir="ltr">col sales_prior_period heading &#39;sales_prior|_period&#39;
col variance_prior_period heading &#39;variance|_prior|_period&#39;
col sales_same_period_prior_year heading &#39;sales_same|_period_prior|_year&#39;
col variance_same_period_p_year heading &#39;variance|_same_period|_prior_year&#39;
</pre>
<p>Here is the query comparing current sales to prior and year ago sales:</p>
<pre dir="ltr">SELECT SUBSTR(prod,1,4) prod, SUBSTR(Hierarchical_Time,1,12) ht, 
  sales, sales_prior_period, 
  sales - sales_prior_period variance_prior_period,
  sales_same_period_prior_year,
  sales - sales_same_period_prior_year variance_same_period_p_year
FROM
 (SELECT cat, subcat, prod, gid_p, gid_t, 
    Hierarchical_Time, yr, qtr, mon, day, sales,
    LAG(sales, 1) OVER (PARTITION BY gid_p, cat, subcat, prod,
      gid_t ORDER BY yr, qtr, mon, day)
      sales_prior_period,
    LAG(sales, 1) OVER (PARTITION BY gid_p, cat, subcat, prod,
      gid_t, qtr_num, mon_num, day_num ORDER BY yr)
      sales_same_period_prior_year
  FROM 
   (SELECT c.gid, c.cat, c.subcat, c.prod, c.gid_p,
      t.gid_t, t.yr, t.qtr, t.qtr_num, t.mon, t.mon_num,
      t.day, t.day_num, t.Hierarchical_Time, NVL(s_sold,0) sales
    FROM cube_prod_time c
    PARTITION BY (gid_p, cat, subcat, prod)
    RIGHT OUTER JOIN edge_time t
    ON ( c.gid_t = t.gid_t AND 
      c.Hierarchical_Time = t.Hierarchical_Time)
   ) dense_cube_prod_time
 )                        --side by side current and prior year sales
WHERE prod IN (139) AND gid_p=0 AND    --1 product and product level data
  ( (mon IN (&#39;2001-08&#39; ) AND gid_t IN (0, 1)) OR --day and month data
  (qtr IN (&#39;2001-03&#39; ) AND gid_t IN (3)))        --quarter level data
ORDER BY day;

                                           variance    sales_same     variance
                             sales_prior     _prior _period_prior _same_period
PROD HT                SALES     _period    _period         _year  _prior_year
---- ------------ ---------- ----------- ---------- ------------- ------------
139  01-AUG-01_3           0           0          0             0            0
139  02-AUG-01_3     1347.53           0    1347.53             0      1347.53
139  03-AUG-01_3           0     1347.53   -1347.53         42.36       -42.36
139  04-AUG-01_3       57.83           0      57.83        995.75      -937.92
139  05-AUG-01_3           0       57.83     -57.83             0            0
139  06-AUG-01_3           0           0          0             0            0
139  07-AUG-01_3      134.81           0     134.81        880.27      -745.46
139  08-AUG-01_3     1289.89      134.81    1155.08             0      1289.89
139  09-AUG-01_3           0     1289.89   -1289.89             0            0
139  10-AUG-01_3           0           0          0             0            0
139  11-AUG-01_3           0           0          0             0            0
139  12-AUG-01_3           0           0          0             0            0
139  13-AUG-01_3           0           0          0             0            0
139  14-AUG-01_3           0           0          0             0            0
139  15-AUG-01_3       38.49           0      38.49       1104.55     -1066.06
139  16-AUG-01_3           0       38.49     -38.49             0            0
139  17-AUG-01_3       77.17           0      77.17       1052.03      -974.86
139  18-AUG-01_3     2467.54       77.17    2390.37             0      2467.54
139  19-AUG-01_3           0     2467.54   -2467.54        127.08      -127.08
139  20-AUG-01_3           0           0          0             0            0
139  21-AUG-01_3           0           0          0             0            0
139  22-AUG-01_3           0           0          0             0            0
139  23-AUG-01_3     1371.43           0    1371.43             0      1371.43
139  24-AUG-01_3      153.96     1371.43   -1217.47        2091.3     -1937.34
139  25-AUG-01_3           0      153.96    -153.96             0            0
139  26-AUG-01_3           0           0          0             0            0
139  27-AUG-01_3     1235.48           0    1235.48             0      1235.48
139  28-AUG-01_3       173.3     1235.48   -1062.18       2075.64     -1902.34
139  29-AUG-01_3           0       173.3     -173.3             0            0
139  30-AUG-01_3           0           0          0             0            0
139  31-AUG-01_3           0           0          0             0            0
139  2001-08_2       8347.43     7213.21    1134.22       8368.98       -21.55
139  2001-03_1       24356.8    28862.14   -4505.34      24168.99       187.81
</pre>
<p>The first <code class="codeph">LAG</code> function (<code class="codeph">sales_prior_period</code>) partitions the data on <code class="codeph">gid_p</code>, <code class="codeph">cat</code>, <code class="codeph">subcat</code>, <code class="codeph">prod</code>, <code class="codeph">gid_t</code> and orders the rows on all the time dimension columns. It gets the sales value of the prior period by passing an offset of 1. The second <code class="codeph">LAG</code> function (<code class="codeph">sales_same_period_prior_year</code>) partitions the data on additional columns <code class="codeph">qtr_num</code>, <code class="codeph">mon_num</code>, and <code class="codeph">day_num</code> and orders it on <code class="codeph">yr</code> so that, with an offset of 1, it can compute the year ago sales for the same period. The outermost <code class="codeph">SELECT</code> clause computes the variances.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8744"></a>
<div class="props_rev_3"><a id="GUID-8BED5B1F-C20F-4215-B4A0-28DD1564CC3B"></a>
<h3 id="DWHSG-GUID-8BED5B1F-C20F-4215-B4A0-28DD1564CC3B" class="sect3">Creating a Custom Member in a Dimension: Example</h3>
<div>
<div class="section">
<p>In many analytical SQL tasks, it is helpful to define custom members in a dimension. For instance, you might define a specialized time period for analyses. You can use a partitioned outer join to temporarily add a member to a dimension. Note that the new SQL <code class="codeph">MODEL</code> clause is suitable for creating more complex scenarios involving new members in dimensions. See <a href="sqlmodel.htm#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a> for more information on this topic.</p>
<p>As an example of a task, what if you want to define a new member for the <code class="codeph">time</code> dimension? You want to create a 13th member of the Month level in the <code class="codeph">time</code> dimension. This 13th month is defined as the summation of the sales for each product in the first month of each quarter of year 2001.</p>
<p>The solution has two steps. Note that you will build this solution using the views and tables created in the prior example. Two steps are required. First, create a view with the new member added to the appropriate dimension. The view uses a <code class="codeph">UNION</code> <code class="codeph">ALL</code> operation to add the new member. To query using the custom member, use a <code class="codeph">CASE</code> expression and a partitioned outer join.</p>
<p>Our new member for the <code class="codeph">time</code> dimension is created with the following view:</p>
<pre dir="ltr">CREATE OR REPLACE VIEW time_c AS
(SELECT * FROM edge_time
UNION ALL
SELECT &#39;2001-13_2&#39;, 2001, 5, &#39;2001-05&#39;, 13, &#39;2001-13&#39;, null, null,
8 -- &lt;gid_of_mon&gt;
FROM DUAL);
</pre>
<p>In this statement, the view <code class="codeph">time_c</code> is defined by performing a <code class="codeph">UNION</code> <code class="codeph">ALL</code> of the <code class="codeph">edge_time</code> view (defined in the prior example) and the user-defined 13th month. The <code class="codeph">gid_t</code> value of 8 was chosen to differentiate the custom member from the standard members. The <code class="codeph">UNION</code> <code class="codeph">ALL</code> specifies the attributes for a 13th month member by doing a <code class="codeph">SELECT</code> from the <code class="codeph">DUAL</code> table. Note that the grouping id, column <code class="codeph">gid_t</code>, is set to 8, and the quarter number is set to 5.</p>
<p>Then, the second step is to use an inline view of the query to perform a partitioned outer join of <code class="codeph">cube_prod_time</code> with <code class="codeph">time_c</code>. This step creates sales data for the 13th month at each level of product aggregation. In the main query, the analytic function <code class="codeph">SUM</code> is used with a <code class="codeph">CASE</code> expression to compute the 13th month, which is defined as the summation of the first month&#39;s sales of each quarter.</p>
<pre dir="ltr">SELECT * FROM  (SELECT SUBSTR(cat,1,12) cat, SUBSTR(subcat,1,12) subcat,
     prod, mon, mon_num,
     SUM(CASE WHEN mon_num IN (1, 4, 7, 10)
           THEN s_sold 
           ELSE NULL 
         END)
       OVER (PARTITION BY gid_p, prod, subcat, cat, yr) sales_month_13
   FROM
     (SELECT c.gid, c.prod, c.subcat, c.cat, gid_p,
        t.gid_t, t.day, t.mon, t.mon_num,
        t.qtr, t.yr, NVL(s_sold,0) s_sold
      FROM cube_prod_time c
      PARTITION BY (gid_p, prod, subcat, cat)
      RIGHT OUTER JOIN time_c t
      ON (c.gid_t = t.gid_t AND 
        c.Hierarchical_Time = t.Hierarchical_Time)
     )
  )
WHERE mon_num=13;

CAT          SUBCAT             PROD MON         MON_NUM SALES_MONTH_13
------------ ------------ ---------- -------- ---------- --------------
Electronics  Game Console         16 2001-13          13      762334.34
Electronics  Y Box Games         139 2001-13          13       75650.22
Electronics  Game Console            2001-13          13      762334.34
Electronics  Y Box Games             2001-13          13       75650.22
Electronics                          2001-13          13      837984.56
                                     2001-13          13      837984.56
</pre>
<p>The <code class="codeph">SUM</code> function uses a <code class="codeph">CASE</code> to limit the data to months 1, 4, 7, and 10 within each year. Due to the tiny data set, with just 2 products, the rollup values of the results are necessarily repetitions of lower level aggregations. For more realistic set of rollup values, you can include more products from the Game Console and Y Box Games subcategories in the underlying materialized view.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8745"></a>
<div class="props_rev_3"><a id="GUID-2F10D9C8-C6D6-47F2-9DDF-4146539655F3"></a>
<h2 id="DWHSG-GUID-2F10D9C8-C6D6-47F2-9DDF-4146539655F3" class="sect2">Miscellaneous Analysis and Reporting Capabilities</h2>
<div>
<p>This section illustrates the following additional analytic capabilities:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="analysis.htm#GUID-91A27A23-A5E0-4CF7-8669-019146D22A4D">WIDTH_BUCKET Function</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E">Linear Algebra</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-C3160877-BF50-41B2-8E8D-6643108EE866">CASE Expressions</a></p>
</li>
<li>
<p><a href="analysis.htm#GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D">Frequent Itemsets in SQL Analytics</a></p>
</li>
</ul>
</div>
<a id="DWHSG02010"></a>
<div class="props_rev_3"><a id="GUID-91A27A23-A5E0-4CF7-8669-019146D22A4D"></a>
<h3 id="DWHSG-GUID-91A27A23-A5E0-4CF7-8669-019146D22A4D" class="sect3">WIDTH_BUCKET Function</h3>
<div>
<div class="section">
<p>For<a id="d59823e5820" class="indexterm-anchor"></a><a id="d59823e5822" class="indexterm-anchor"></a> a given expression, the <code class="codeph">WIDTH_BUCKET</code> function returns the bucket number that the result of this expression will be assigned after it is evaluated. <span class="q">&#34;<a href="analysis.htm#GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523">WIDTH_BUCKET Syntax</a>&#34;</span> describes the <code class="codeph">WIDTH_BUCKET</code> syntax.</p>
<p>You can generate equiwidth histograms with this function. Equiwidth histograms divide data sets into buckets whose interval size (highest value to lowest value) is equal. The number of rows held by each bucket will vary. A related function, <code class="codeph">NTILE</code>, creates equiheight buckets.</p>
<p>Equiwidth histograms can be generated only for numeric, date or datetime types. So the first three parameters should be all numeric expressions or all date expressions. Other types of expressions are not allowed. If the first parameter is <code class="codeph">NULL</code>, the result is <code class="codeph">NULL</code>. If the second or the third parameter is <code class="codeph">NULL</code>, an error message is returned, as a <code class="codeph">NULL</code> value cannot denote any end point (or any point) for a range in a date or numeric value dimension. The last parameter (number of buckets) should be a numeric expression that evaluates to a positive integer value; 0, <code class="codeph">NULL</code>, or a negative value will result in an error.</p>
<p>Buckets are numbered from 0 to (<code class="codeph">n</code>+1). Bucket 0 holds the count of values less than the minimum. Bucket(<code class="codeph">n</code>+1) holds the count of values greater than or equal to the maximum specified value.</p>
</div>
<!-- class="section" --></div>
<a id="DWHSG8747"></a><a id="DWHSG8748"></a><a id="DWHSG8746"></a>
<div class="props_rev_3"><a id="GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523"></a>
<h4 id="DWHSG-GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523" class="sect4">WIDTH_BUCKET Syntax</h4>
<div>
<div class="section">
<p>The <code class="codeph">WIDTH_BUCKET</code> takes four expressions as parameters. The first parameter is the expression that the equiwidth histogram is for. The second and third parameters are expressions that denote the end points of the acceptable range for the first parameter. The fourth parameter denotes the number of buckets.</p>
<pre dir="ltr">WIDTH_BUCKET(expression, minval expression, maxval expression, num buckets)
</pre>
<p>Consider the following data from table <code class="codeph">customers</code>, that shows the credit limits of 17 customers. This data is gathered in the query shown in <a href="analysis.htm#GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__i1007460">Example 18-25</a>.</p>
<pre dir="ltr">CUST_ID    CUST_CREDIT_LIMIT
---------  -----------------
    10346               7000
    35266               7000
    41496              15000
    35225              11000
     3424               9000
    28344               1500
    31112               7000
     8962               1500
    15192               3000
    21380               5000
    36651               1500
    30420               5000
     8270               3000
    17268              11000
    14459              11000
    13808               5000
    32497               1500
   100977               9000
   102077               3000
   103066              10000
   101784               5000
   100421              11000
   102343               3000
</pre>
<p>In the table <code class="codeph">customers</code>, the column <code class="codeph">cust_credit_limit</code> contains values between 1500 and 15000, and you can assign the values to four equiwidth buckets, numbered from 1 to 4, by using <code class="codeph">WIDTH_BUCKET (cust_credit_limit, 0, 20000, 4)</code>. Ideally each bucket is a closed-open interval of the real number line, for example, bucket number 2 is assigned to scores between 5000.0000 and 9999.9999..., sometimes denoted [5000, 10000) to indicate that 5,000 is included in the interval and 10,000 is excluded. To accommodate values outside the range [0, 20,000), values less than 0 are assigned to a designated underflow bucket which is numbered 0, and values greater than or equal to 20,000 are assigned to a designated overflow bucket which is numbered 5 (num buckets + 1 in general). See <a href="analysis.htm#GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__i1007452">Figure 18-3</a> for a graphical illustration of how the buckets are assigned.</p>
<div class="figure" id="GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__i1007452">
<p class="titleinfigure">Figure 18-3 Bucket Assignments</p>
<img width="470" height="91" src="img/GUID-240F4BB8-77F6-4E4A-8EC0-3E011B7AC4D6-default.gif" alt="Description of Figure 18-3 follows" title="Description of Figure 18-3 follows"/><br/>
<a href="img_text/GUID-240F4BB8-77F6-4E4A-8EC0-3E011B7AC4D6-print.htm">Description of &#34;Figure 18-3 Bucket Assignments&#34;</a></div>
<!-- class="figure" -->
<p>You can specify the bounds in the reverse order, for example, <code class="codeph">WIDTH_BUCKET</code> (<code class="codeph">cust_credit_limit</code>, <code class="codeph">20000</code>, <code class="codeph">0</code>, <code class="codeph">4</code>). When the bounds are reversed, the buckets will be open-closed intervals. In this example, bucket number 1 is (<code class="codeph">15000,20000</code>], bucket number 2 is (<code class="codeph">10000,15000</code>], and bucket number 4, is (<code class="codeph">0</code><code class="codeph">,5000</code>]. The overflow bucket will be numbered 0 (<code class="codeph">20000</code>, +<code class="codeph">infinity</code>), and the underflow bucket will be numbered 5 (-<code class="codeph">infinity</code>, <code class="codeph">0</code>].</p>
<p>It is an error if the bucket count parameter is 0 or negative.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__i1007460">
<p class="titleinexample">Example 18-25 WIDTH_BUCKET</p>
<p>The followin<a id="d59823e5974" class="indexterm-anchor"></a><a id="d59823e5976" class="indexterm-anchor"></a>g query shows the bucket numbers for the credit limits in the customers table for both cases where the boundaries are specified in regular or reverse order. You use a range of 0 to 20,000.</p>
<pre dir="ltr">SELECT cust_id, cust_credit_limit,
 WIDTH_BUCKET(cust_credit_limit,0,20000,4) AS WIDTH_BUCKET_UP,
 WIDTH_BUCKET(cust_credit_limit,20000, 0, 4) AS WIDTH_BUCKET_DOWN
FROM customers WHERE cust_city = &#39;Marshal&#39;;

   CUST_ID CUST_CREDIT_LIMIT WIDTH_BUCKET_UP WIDTH_BUCKET_DOWN
---------- ----------------- --------------- -----------------
     10346              7000               2                 3
     35266              7000               2                 3
     41496             15000               4                 2
     35225             11000               3                 2
      3424              9000               2                 3
     28344              1500               1                 4
     31112              7000               2                 3
      8962              1500               1                 4
     15192              3000               1                 4
     21380              5000               2                 4
     36651              1500               1                 4
     30420              5000               2                 4
      8270              3000               1                 4
     17268             11000               3                 2
     14459             11000               3                 2
     13808              5000               2                 4
     32497              1500               1                 4
    100977              9000               2                 3
    102077              3000               1                 4
    103066             10000               3                 3
    101784              5000               2                 4
    100421             11000               3                 2
    102343              3000               1                 4
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8749"></a><a id="DWHSG02014"></a>
<div class="props_rev_3"><a id="GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E"></a>
<h3 id="DWHSG-GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E" class="sect3">Linear Algebra</h3>
<div>
<p>Linear algebra is a branch of mathematics with a wide range of practical applications. Many areas have tasks that can be expressed using linear algebra, and here are some examples from several fields: statistics (multiple linear regression and principle components analysis), data mining (clustering and classification), bioinformatics (analysis of microarray data), operations research (supply chain and other optimization problems), econometrics (analysis of consumer demand data), and finance (asset allocation problems). Various libraries for linear algebra are freely available for anyone to use. Oracle&#39;s <code class="codeph">UTL_NLA</code> package exposes matrix PL/SQL data types and wrapper PL/SQL subprograms for two of the most popular and robust of these libraries, BLAS and LAPACK.</p>
<p>Linear algebra depends on matrix manipulation. Performing matrix manipulation in PL/SQL in the past required inventing a matrix representation based on PL/SQL&#39;s native data types and then writing matrix manipulation routines from scratch. This required substantial programming effort and the performance of the resulting implementation was limited. If developers chose to send data to external packages for processing rather than create their own routines, data transfer back and forth could be time consuming. Using the <code class="codeph">UTL_NLA</code> package lets data stay within Oracle, removes the programming effort, and delivers a fast implementation.</p>
<div class="infoboxnotealso" id="GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E__GUID-68F30956-1AC9-4DA4-B187-744DC1A99C32">
<p class="notep1">See Also:</p>
<p><a class="olink ARPLS224" target="_blank" href="../ARPLS/u_nla.htm#ARPLS224"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for further information regarding the use of the <code class="codeph">UTL_NLA</code> package and linear algebra</p>
</div>
<div class="example" id="GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E__GUID-F45C8C56-4CF1-4A28-AB28-2C5940AA8DDA">
<p class="titleinexample">Example 18-26 Linear Algebra</p>
<p>Here is an example of how Oracle&#39;s linear algebra support could be used for business analysis. It invokes a multiple linear regression application built using the <code class="codeph">UTL_NLA</code> package. The multiple regression application is implemented in an object called <code class="codeph">OLS_Regression</code>. Note that sample files for the OLS Regression object can be found in <code class="codeph">$ORACLE_HOME/plsql/demo</code>.</p>
<p>Consider the scenario of a retailer analyzing the effectiveness of its marketing program. Each of its stores allocates its marketing budget over the following possible programs: media advertisements (<code class="codeph">media</code>), promotions (<code class="codeph">promo</code>), discount coupons (<code class="codeph">disct</code>), and direct mailers (<code class="codeph">dmail</code>). The regression analysis builds a linear relationship between the amount of sales that an average store has in a given year (<code class="codeph">sales</code>) and the spending on the four components of the marketing program. Suppose that the marketing data is stored in the following table:</p>
<pre dir="ltr">sales_marketing_data (
  /* Store information*/
  store_no   NUMBER,
  year       NUMBER,
  /* Sales revenue (in dollars)*/
  sales      NUMBER,   /* sales amount*/
  /* Marketing expenses (in dollars)*/
  media      NUMBER,   /*media advertisements*/
  promo      NUMBER,   /*promotions*/
  disct      NUMBER,   /*dicount coupons*/
  dmail      NUMBER,   /*direct mailers*/
</pre>
<p>Then you can build the following sales-marketing linear model using coefficients:</p>
<pre dir="ltr">Sales Revenue = a  + b Media Advisements
                   + c Promotions
                   + d Discount Coupons
                   + e Direct Mailer
</pre>
<p>This model can be implemented as the following view, which refers to the OLS regression object:</p>
<pre dir="ltr">CREATE OR REPLACE VIEW sales_marketing_model (year, ols)
   AS SELECT year,
        OLS_Regression( 
        /* mean_y =&gt; */
        AVG(sales),
        /* variance_y =&gt; */
        var_pop(sales),
        /* MV mean vector =&gt; */
        UTL_NLA_ARRAY_DBL (AVG(media),AVG(promo),
                           AVG(disct),AVG(dmail)),
        /* VCM variance covariance matrix =&gt; */
        UTL_NLA_ARRAY_DBL (var_pop(media),covar_pop(media,promo),
                           covar_pop(media,disct),covar_pop(media,dmail),
                           var_pop(promo),covar_pop(promo,disct),
                           covar_pop(promo,dmail),var_pop(disct),
                           covar_pop(disct,dmail),var_pop(dmail)),
        /* CV covariance vector =&gt; */
  UTL_NLA_ARRAY_DBL (covar_pop(sales,media),covar_pop(sales,promo),
                           covar_pop(sales,disct),covar_pop(sales,dmail)))
 FROM sales_marketing_data
 GROUP BY year;
</pre>
<p>Using this view, a marketing program manager can perform an analysis such as &#34;Is this sales-marketing model reasonable for year 2004 data? That is, is the multiple-correlation greater than some acceptable value, say, 0.9?&#34; The SQL for such a query might be as follows:</p>
<pre dir="ltr">SELECT model.ols.getCorrelation(1)
       AS &#34;Applicability of Linear Model&#34;
FROM sales_marketing_model model
WHERE year = 2004;
</pre>
<p>You could also solve questions such as &#34;What is the expected base-line sales revenue of a store without any marketing programs in 2003?&#34; or &#34;Which component of the marketing program was the most effective in 2004? That is, a dollar increase in which program produced the greatest expected increase in sales?&#34;</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8750"></a><a id="DWHSG8751"></a><a id="DWHSG02012"></a>
<div class="props_rev_3"><a id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866"></a>
<h3 id="DWHSG-GUID-C3160877-BF50-41B2-8E8D-6643108EE866" class="sect3">CASE Expressions</h3>
<div>
<div class="section">
<p><a id="d59823e6096" class="indexterm-anchor"></a>Oracle now supports simple and searched <code class="codeph">CASE</code> statements. <code class="codeph">CASE</code> statements are similar in purpose to the <code class="codeph">DECODE</code> statement, but they offer more flexibility and logical power. They are also easier to read than traditional <code class="codeph">DECODE</code> statements, and offer better performance as well. They are commonly used when breaking categories into buckets like age (for example, 20-29, 30-39, and so on).</p>
<p>The syntax for simple <code class="codeph">CASE</code> statements is:</p>
<pre dir="ltr">CASE expr WHEN comparison_expr THEN return_expr
 [, WHEN comparison_expr THEN return_expr]... [ELSE else_expr] END
</pre>
<p>Simple <code class="codeph">CASE</code> expressions test if the <code class="codeph">expr</code> value equals the <code class="codeph">comparison_expr</code>.</p>
<p>The syntax for searched <code class="codeph">CASE</code> statements is:</p>
<pre dir="ltr">CASE WHEN condition THEN return_expr [, WHEN condition THEN return_expr]
   ... ELSE else_expr] END
</pre>
<p>You can use any kind of condition in a searched <code class="codeph">CASE</code> expression, not just an equality test.</p>
<p>You can specify only 65,535 arguments and each <code class="codeph">WHEN</code> ... <code class="codeph">THEN</code> pair counts as two arguments. To avoid exceeding this limit, you can nest <code class="codeph">CASE</code> expressions so that the <code class="codeph">return_expr</code> itself is a <code class="codeph">CASE</code> expression.</p>
<div class="infoboxnotealso" id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866__GUID-D93DA578-8726-4149-94EA-6B400089F7C0">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="analysis.htm#GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C">Creating Histograms Using CASE Statement</a>&#34;</span> for information about using <code class="codeph">CASE</code> to create histograms</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866__GUID-B29C4700-0629-4862-BCE5-D83F7FC100FF">
<p class="titleinexample">Example 18-27 CASE</p>
<p>Suppose you wanted to find the average salary of all employees in the company. If an employee&#39;s salary is less than $2000, you want the query to use $2000 instead. Without a <code class="codeph">CASE</code> statement, you might choose to write this query as follows:</p>
<pre dir="ltr">SELECT AVG(foo(e.salary)) FROM employees e;
</pre>
<p>Note that this runs against the <code class="codeph">hr</code> sample schema. In this, <code class="codeph">foo</code> is a function that returns its input if the input is greater than 2000, and returns 2000 otherwise. The query has performance implications because it needs to invoke a function for each row. Writing custom functions can also add to the development load.</p>
<p>Using <code class="codeph">CASE</code> expressions in the database without PL/SQL, this query can be rewritten as:</p>
<pre dir="ltr">SELECT AVG(CASE when e.salary &gt; 2000 THEN e.salary ELSE 2000 end) 
  AS avg_sal_2k_floor
FROM employees e;
</pre>
<p>Using a <code class="codeph">CASE</code> expression lets you avoid developing custom functions and can also perform faster.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866__GUID-2A4830C6-A96B-4043-A849-BBAE07F10F2E">
<p class="titleinexample">Example 18-28 CASE for Aggregating Independent Subsets</p>
<p>Using <code class="codeph">CASE</code> inside aggregate functions is a convenient way to perform aggregates on multiple subsets of data when a plain <code class="codeph">GROUP</code> <code class="codeph">BY</code> will not suffice. For instance, the preceding example could have included multiple <code class="codeph">AVG</code> columns in its <code class="codeph">SELECT</code> list, each with its own <code class="codeph">CASE</code> expression. You might have had a query find the average salary for all employees in the salary ranges 0-2000 and 2000-5000. It would look like:</p>
<pre dir="ltr">SELECT AVG(CASE WHEN e.sal BETWEEN 0 AND 2000 THEN e.sal ELSE null END) avg2000,
    AVG(CASE WHEN e.sal BETWEEN 2001 AND 5000 THEN e.sal ELSE null END) avg5000
 FROM emps e;
</pre>
<p>Although this query places the aggregates of independent subsets data into separate columns, by adding a <code class="codeph">CASE</code> expression to the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause you can display the aggregates as the rows of a single column. The next section shows the flexibility of this approach with two approaches to creating histograms with <code class="codeph">CASE</code>.</p>
</div>
<!-- class="example" --></div>
<a id="DWHSG8753"></a><a id="DWHSG8754"></a><a id="DWHSG8752"></a>
<div class="props_rev_3"><a id="GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C"></a>
<h4 id="DWHSG-GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C" class="sect4">Creating Histograms Using CASE Statement</h4>
<div>
<div class="section">
<p><a id="d59823e6262" class="indexterm-anchor"></a>You can use the <code class="codeph">CASE</code> statement when you want to obtain histograms with user-defined buckets (both in number of buckets and width of each bucket). The following are two examples of histograms created with <code class="codeph">CASE</code> statements. In the first example, the histogram totals are shown in multiple columns and a single row is returned. In the second example, the histogram is shown with a label column and a single column for totals, and multiple rows are returned.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C__GUID-7B021397-0A55-44AA-8028-DBA13EE68185">
<p class="titleinexample">Example 18-29 Histogram Example 1</p>
<pre dir="ltr">SELECT SUM(CASE WHEN cust_credit_limit BETWEEN  0 AND 3999 THEN 1 ELSE 0 END)
  AS &#34;0-3999&#34;,
SUM(CASE WHEN cust_credit_limit BETWEEN  4000 AND 7999 THEN 1 ELSE 0 END)
  AS &#34;4000-7999&#34;,
SUM(CASE WHEN cust_credit_limit BETWEEN  8000 AND 11999 THEN 1 ELSE 0 END)
  AS &#34;8000-11999&#34;,
SUM(CASE WHEN cust_credit_limit BETWEEN  12000 AND 16000 THEN 1 ELSE 0 END)
  AS &#34;12000-16000&#34;
FROM customers WHERE cust_city = &#39;Marshal&#39;;

    0-3999  4000-7999 8000-11999 12000-16000
---------- ---------- ---------- -----------
         8          7          7           1
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C__GUID-980C277D-EE49-4759-B1F9-5F2F901ACF3A">
<p class="titleinexample">Example 18-30 Histogram Example 2</p>
<pre dir="ltr">SELECT (CASE WHEN cust_credit_limit BETWEEN  0 AND 3999 THEN  &#39; 0 - 3999&#39;
   WHEN cust_credit_limit BETWEEN  4000 AND 7999 THEN &#39; 4000 - 7999&#39;
   WHEN cust_credit_limit BETWEEN  8000 AND 11999 THEN  &#39; 8000 - 11999&#39;
   WHEN cust_credit_limit BETWEEN  12000 AND 16000 THEN &#39;12000 - 16000&#39; END)
  AS BUCKET, COUNT(*) AS Count_in_Group
FROM customers WHERE cust_city = &#39;Marshal&#39; GROUP BY
 (CASE WHEN cust_credit_limit BETWEEN  0 AND 3999 THEN &#39; 0 - 3999&#39;
 WHEN cust_credit_limit BETWEEN  4000 AND 7999 THEN &#39; 4000 - 7999&#39;
 WHEN cust_credit_limit BETWEEN  8000 AND 11999 THEN  &#39; 8000 - 11999&#39;
 WHEN cust_credit_limit BETWEEN  12000 AND 16000 THEN &#39;12000 - 16000&#39; END);

BUCKET        COUNT_IN_GROUP
------------- --------------
 0 - 3999                  8
 4000 - 7999               7
 8000 - 11999              7
12000 - 16000              1
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8755"></a>
<div class="props_rev_3"><a id="GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D"></a>
<h3 id="DWHSG-GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D" class="sect3">Frequent Itemsets in SQL Analytics</h3>
<div>
<div class="section">
<p>Instead <a id="d59823e6306" class="indexterm-anchor"></a><a id="d59823e6308" class="indexterm-anchor"></a>of counting how often a given event occurs (for example, how often someone has purchased milk at the grocery), you may find it useful to count how often multiple events occur together (for example, how often someone has purchased both milk and cereal together at the grocery store). You can count these multiple events using what is called a frequent itemset, which is, as the name implies, a set of items. Some examples of itemsets could be all of the products that a given customer purchased in a single trip to the grocery store (commonly called a market basket), the web pages that a user accessed in a single session, or the financial services that a given customer utilizes.</p>
<p>The practical motivation for using a frequent itemset is to find those itemsets that occur most often. If you analyze a grocery store&#39;s point-of-sale data, you might, for example, discover that milk and bananas are the most commonly bought pair of items. Frequent itemsets have thus been used in business intelligence environments for many years, with the most common one being for market basket analysis in the retail industry. Frequent itemset calculations are integrated with the database, operating on top of relational tables and accessed through SQL. This integration provides the following key benefits:</p>
<ul style="list-style-type: disc;">
<li>
<p>Applications that previously relied on frequent itemset operations now benefit from significantly improved performance as well as simpler implementation.</p>
</li>
<li>
<p>SQL-based applications that did not previously use frequent itemsets can now be easily extended to take advantage of this functionality.</p>
</li>
</ul>
<p>Frequent itemsets analysis is performed with the PL/SQL package <code class="codeph">DBMS_FREQUENT_ITEMSETS</code>. See <a class="olink ARPLS007" target="_blank" href="../ARPLS/d_frqist.htm#ARPLS007"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information. In addition, there is an example of frequent itemset usage in <span class="q">&#34;<a href="advbi.htm#GUID-2741CAB6-DFFB-4079-AAE3-583F6B756434">Business Intelligence Query Example 4: Frequent Itemsets</a>&#34;</span>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG9189"></a><a id="DWHSG9190"></a><a id="DWHSG9188"></a>
<div class="props_rev_3"><a id="GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4"></a>
<h2 id="DWHSG-GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4" class="sect2">Limiting SQL Rows</h2>
<div>
<p>You can limit the rows returned from SQL queries by either a specific number of rows or a percentage<a id="d59823e6362" class="indexterm-anchor"></a><a id="d59823e6364" class="indexterm-anchor"></a><a id="d59823e6366" class="indexterm-anchor"></a> of rows. In some cases, you may need the query results to be ordered before the number of rows returned is limited. A query which first sorts its rows and then limits the number of rows returned is often called a Top-N query, and it offers a straightforward way of creating reports or just a simple view of basic questions, such as &#34;Who are the ten highest-paid employees?&#34; It is also useful for user interfaces that provide the first few rows of a data set for browsing. When you issue a Top-N query, you may also want to specify an offset: the offset excludes the leading rows of the query result set. The query then returns the specified number or percent of rows starting with the first row after the offset. An offset enables you to modify typical questions, so that the question about highest-paid employees might skip the top ten employees and return only those from eleventh to twentieth place in the salary rankings. In a similar manner, you could query the employees by salary, skip the top ten employees and then return the top 10% of the remaining employees.</p>
<p>Queries that limit the rows returned have been possible using the <code class="codeph">ROW_NUMBER</code> window function, the <code class="codeph">ROWNUM</code> pseudocolumn, and other techniques for some time, but can now be written more simply with the ANSI SQL standard syntax of <span class="italic">row_limiting_clause</span>. When using this clause, you can ensure a deterministic sort order, as needed for Top-N queries, by including an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause in the query. The <span class="italic"><code class="codeph">row_limiting_clause</code></span> clause appears as the last part of a <code class="codeph">SELECT</code>, after the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause, and it starts with either the keyword <code class="codeph">FETCH</code> or <code class="codeph">OFFSET</code>. Its basic syntax is as follows:</p>
<pre dir="ltr">[ OFFSET offset { ROW | ROWS } ]
[ FETCH { FIRST | NEXT } [ { rowcount | percent PERCENT } ]
    { ROW | ROWS } { ONLY | WITH TIES } ]
</pre>
<p>This syntax is illustrated in the following sections.</p>
<div class="section">
<p class="subhead2">OFFSET</p>
</div>
<!-- class="section" -->
<div class="section">
<p>This specifies the number of rows to skip before row limiting begins. <span class="italic"><code class="codeph">offset</code></span> must be a number. If you specify a negative number, then offset is treated as 0. If you specify <code class="codeph">NULL</code>, or a number greater than or equal to the number of rows returned by the query, then 0 rows are returned. If <span class="italic"><code class="codeph">offset</code></span> includes a fraction, then the fractional portion is truncated. If you do not specify this clause, then <span class="italic"><code class="codeph">offset</code></span> is 0 and row limiting begins with the first row. To improve readability, Oracle offers the option of using either <code class="codeph">ROW</code> or <code class="codeph">ROWS</code> - both are equivalent.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">FETCH</p>
</div>
<!-- class="section" -->
<div class="section">
<p>This specifies the number of rows or percentage of rows to return. If you do not specify this clause, then all rows are returned, beginning at the <span class="italic"><code class="codeph">offset</code></span> + 1 row. If you use the <code class="codeph">WITH</code> <code class="codeph">TIES</code> keywords, your query will also include all rows that match the sort key of the last qualified row.</p>
<p>To illustrate how you can limit the number of rows returned in a query, consider the following statement:</p>
<pre dir="ltr">SELECT employee_id, last_name
FROM employees
ORDER BY employee_id
FETCH FIRST 5 ROWS ONLY;

EMPLOYEE_ID LAST_NAME
----------- ----------
        100 King
        101 Kochhar
        102 De Haan
        103 Hunold
        104 Ernst
</pre>
<p>In this statement, the first 5 employees with the lowest <code class="codeph">employee_id</code> values are returned.</p>
<p>To return the next set of 5 employees, add an <code class="codeph">OFFSET</code> to the statement:</p>
<pre dir="ltr">SELECT employee_id, last_name
FROM employees
ORDER BY employee_id
OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY;

EMPLOYEE_ID LAST_NAME
----------- ----------
        105 Austin
        106 Pataballa
        107 Lorentz
        108 Greenberg
        109 Faviet
</pre>
<p>In this statement, <code class="codeph">FETCH</code> <code class="codeph">FIRST</code> and <code class="codeph">FETCH</code> <code class="codeph">NEXT</code> are equivalent, but <code class="codeph">FETCH</code> <code class="codeph">NEXT</code> is clearer when <code class="codeph">OFFSET</code> is used.</p>
<p>The offset can be a larger value, such as 10, as in the following statement:</p>
<pre dir="ltr">SELECT employee_id, last_name
FROM employees
ORDER BY employee_id
OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;

EMPLOYEE_ID LAST_NAME
----------- ----------
        110 Chen
        111 Sciarra
        112 Urman
        113 Popp
        114 Raphaely
</pre>
<p>You can choose to return values by percentage instead of a fixed number. To illustrate this, the following statement returns the 5 percent of employees with the lowest salaries:</p>
<pre dir="ltr">SELECT employee_id, last_name, salary
FROM employees
ORDER BY salary
FETCH FIRST 5 PERCENT ROWS ONLY;

EMPLOYEE_ID LAST_NAME             SALARY
----------- --------------------- ------
        132 Olson                   2100
        128 Markle                  2200
        136 Philtanker              2200
        127 Landry                  2400
        135 Gee                     2400
        119 Colmenares              2500
</pre>
<p>In this result set, 5% is six rows. This is important if you use <code class="codeph">OFFSET</code>, because the percentage calculation is based on the entire result set before the offset is applied. An example of using <code class="codeph">OFFSET</code> is the following statement:</p>
<pre dir="ltr">SELECT employee_id, last_name, salary
FROM employees
ORDER BY salary, employee_id
OFFSET 6 ROWS FETCH FIRST 5 PERCENT ROWS ONLY;

EMPLOYEE_ID LAST_NAME             SALARY
----------- --------------------- ------
        131 Marlow                  2500
        140 Patel                   2500
        144 Vargas                  2500
        182 Sullivan                2500
        191 Perkins                 2500
        118 Himuro                  2500
</pre>
<p>This statement still returns six rows, but starts with the seventh row of the result set. The additional <code class="codeph">employee_id</code> added to the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause was to guarantee a deterministic sort.</p>
<p>You have the option of returning tie values by using <code class="codeph">WITH</code> <code class="codeph">TIES</code>. This would return the 5 percent with the lowest salaries, plus all additional employees with the same salary as the last row fetched:</p>
<pre dir="ltr">SELECT employee_id, last_name, salary
FROM employees
ORDER BY salary
FETCH FIRST 5 PERCENT ROWS WITH TIES;

EMPLOYEE_ID LAST_NAME             SALARY
----------- --------------------- ------
        132 Olson                   2100
        128 Markle                  2200
        136 Philtanker              2200
        127 Landry                  2400
        135 Gee                     2400
        119 Colmenares              2500
        131 Marlow                  2500
        140 Patel                   2500
        144 Vargas                  2500
        182 Sullivan                2500
        191 Perkins                 2500
</pre>
<p>You could issue the same query, but skip the first 5 values with the following statement:</p>
<pre dir="ltr">SELECT employee_id, last_name, salary
FROM employees
ORDER BY salary
OFFSET 5 ROWS FETCH FIRST 5 PERCENT ROWS WITH TIES;

EMPLOYEE_ID LAST_NAME             SALARY
----------- --------------------- ------
        119 Colmenares              2500
        131 Marlow                  2500
        140 Patel                   2500
        144 Vargas                  2500
        182 Sullivan                2500
        191 Perkins                 2500
</pre></div>
<!-- class="section" --></div>
<a id="DWHSG9191"></a>
<div class="props_rev_3"><a id="GUID-27A245ED-676B-4FC1-827B-B58020E234AA"></a>
<h3 id="DWHSG-GUID-27A245ED-676B-4FC1-827B-B58020E234AA" class="sect3">SQL Row Limiting Restrictions and Considerations</h3>
<div>
<div class="section">
<p>The <span class="italic"><code class="codeph">row_limiting_clause</code></span> clause is subject to the following restrictions:</p>
<ul style="list-style-type: disc;">
<li>
<p>You cannot specify this clause with the <span class="italic"><code class="codeph">for_update_clause</code></span>.</p>
</li>
<li>
<p>If you specify this clause, then the select list cannot contain the sequence pseudocolumns <code class="codeph">CURRVAL</code> or <code class="codeph">NEXTVAL</code>.</p>
</li>
<li>
<p>Materialized views are not eligible for an incremental refresh if the defining query contains this clause.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-27A245ED-676B-4FC1-827B-B58020E234AA__GUID-98BF1BE4-0869-4AE5-A7D3-B94AB01827DB">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF55644" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF55644"><span class="italic">Oracle Database SQL Language Reference</span></a> for further information regarding syntax and restrictions</p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1506">
<tr>
<td class="cellalignment1513">
<table class="cellalignment1511">
<tr>
<td class="cellalignment1510"><a href="part5.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1510"><a href="aggreg.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1515">
<table class="cellalignment1509">
<tr>
<td class="cellalignment1510"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1510"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1510"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1510"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1510"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1510"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>