<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-6085"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Refreshing%20Materialized%20Views"></a><title>Refreshing Materialized Views</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="DBMS_MVIEW package, manual refresh, with DBMS_MVIEW package"/>
<meta name="dcterms.created" content="2017-06-07T18:07:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Warehousing Guide"/>
<meta name="dcterms.identifier" content="E41670-11"/>
<meta name="dcterms.isVersionOf" content="DWHSG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="advmv.htm" title="Previous" type="text/html"/>
<link rel="Next" href="sync.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41670-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-64068234-BDB0-4C12-AE70-75571046A586"></a> <span id="PAGE" style="display:none;">13/32</span> <!-- End Header -->
<h1 id="DWHSG-GUID-64068234-BDB0-4C12-AE70-75571046A586" class="sect1"><span class="enumeration_chapter">7</span> Refreshing Materialized Views</h1>
<div>
<p>This chapter discusses how to refresh materialized views, which is a key element in maintaining good performance and consistent data when working with materialized views in a data warehousing environment.</p>
<p>This chapter includes the following sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213">About Refreshing Materialized Views</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-7EA0FBD1-DCBD-4EBD-A131-59EE6ACC97B6">Using Materialized Views with Partitioned Tables</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-4679957A-71E5-439E-BD8B-A0331F0631F2">Using Partitioning to Improve Data Warehouse Refresh</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-2F0765F5-DDDA-4667-9629-6834A805CB13">Optimizing DML Operations During Refresh</a></p>
</li>
</ul>
</div>
<a id="DWHSG03003"></a>
<div class="props_rev_3"><a id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213"></a>
<h2 id="DWHSG-GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213" class="sect2">About Refreshing Materialized Views</h2>
<div>
<p><a id="d26360e63" class="indexterm-anchor"></a><a id="d26360e67" class="indexterm-anchor"></a>The database maintains data in materialized views by refreshing them after changes to the base tables.</p>
<p>Performing a refresh operation requires temporary space to rebuild the indexes and can require additional space for performing the refresh operation itself. Some sites might prefer not to refresh all of their materialized views at the same time: as soon as some underlying detail data has been updated, all materialized views using this data become stale. Therefore, if you defer refreshing your materialized views, you can either rely on your chosen rewrite integrity level to determine whether or not a stale materialized view can be used for query rewrite, or you can temporarily disable query rewrite with an <code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> <code class="codeph">SET</code> <code class="codeph">QUERY_REWRITE_ENABLED = FALSE</code> statement. After refreshing the materialized views, you can re-enable query rewrite as the default for all sessions in the current database instance by specifying <code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> <code class="codeph">SET</code> <code class="codeph">QUERY_REWRITE_ENABLED</code> as <code class="codeph">TRUE</code>. Refreshing a materialized view automatically updates all of its indexes. In the case of full refresh, this requires temporary sort space to rebuild all indexes during refresh. This is because the full refresh truncates or deletes the table before inserting the new full data volume. If insufficient temporary space is available to rebuild the indexes, then you must explicitly drop each index or mark it <code class="codeph">UNUSABLE</code> prior to performing the refresh operation.</p>
<div class="section">
<p class="subhead2">About Types of Refresh for Materialized Views</p>
<p>The refresh method can be incremental or a complete refresh. There are two incremental refresh methods, known as log-based refresh and partition change tracking (PCT) refresh. The incremental refresh is commonly called <code class="codeph">FAST</code> refresh as it usually performs faster than the complete refresh.</p>
<p>A complete refresh occurs when the materialized view is initially created when it is defined as <code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code>, unless the materialized view references a prebuilt table or is defined as <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code>. Users can perform a complete refresh at any time after the materialized view is created. The complete refresh involves executing the query that defines the materialized view. This process can be slow, especially if the database must read and process huge amounts of data.</p>
<p>An incremental refresh eliminates the need to rebuild materialized views from scratch. Thus, processing only the changes can result in a very fast refresh time. Materialized views can be refreshed either on demand or at regular time intervals. Alternatively, materialized views in the same database as their base tables can be refreshed whenever a transaction commits its changes to the base tables.</p>
<p>For materialized views that use the log-based fast refresh method, a materialized view log and/or a direct loader log keep a record of changes to the base tables. A materialized view log is a schema object that records changes to a base table so that a materialized view defined on the base table can be refreshed incrementally. Each materialized view log is associated with a single base table. The materialized view log resides in the same database and schema as its base table.</p>
<p>The PCT refresh method can be used if the modified base tables are partitioned and the modified base table partitions can be used to identify the affected partitions or portions of data in the materialized view. When there have been some partition maintenance operations on the base tables, this is the only incremental refresh method that can be used. The PCT refresh removes all data in the affected materialized view partitions or affected portions of data and recomputes them from scratch.</p>
<div class="infoboxnotealso" id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213__GUID-829B5682-600D-4412-A9C8-9006358DF5CC">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-A32EE00B-B369-44C3-AB5D-07403C0A44CD">About Complete Refresh for Materialized Views</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-4FD1E4C6-B82F-4B13-880C-80187FA22AAF">About Fast Refresh for Materialized Views</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD">About Partition Change Tracking (PCT) Refresh for Materialized Views</a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2"><span class="bold">About Refresh Modes for Materialized Views</span></p>
<p>When <a id="d26360e156" class="indexterm-anchor"></a>creating a materialized view, you have the option of specifying whether the refresh occurs <code class="codeph">ON</code> <code class="codeph">DEMAND</code> or <code class="codeph">ON</code> <code class="codeph">COMMIT</code>.</p>
<p>If you anticipate performing insert, update or delete operations on tables referenced by a materialized view concurrently with the refresh of that materialized view, and that materialized view includes joins and aggregation, Oracle recommends you use <code class="codeph">ON</code> <code class="codeph">COMMIT</code> fast refresh rather than <code class="codeph">ON</code> <code class="codeph">DEMAND</code> fast refresh.</p>
<p>In the case of <code class="codeph">ON</code> <code class="codeph">COMMIT</code>, the materialized view is changed every time a transaction commits, thus ensuring that the materialized view always contains the latest data. Alternatively, you can control the time when refresh of the materialized views occurs by specifying <code class="codeph">ON</code> <code class="codeph">DEMAND</code>. In the case of <code class="codeph">ON</code> <code class="codeph">DEMAND</code> materialized views, the refresh can be performed with refresh methods provided in either the <code class="codeph">DBMS_SYNC_REFRESH</code> or the <code class="codeph">DBMS_MVIEW</code> packages:</p>
<ul style="list-style-type: disc;">
<li>
<p>The <code class="codeph">DBMS_SYNC_REFRESH</code> package contains the APIs for synchronous refresh, a new refresh method introduced in Oracle Database 12<span class="italic">c</span>, Release 1. For details, see <a href="sync.htm#GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889">Synchronous Refresh</a>.</p>
</li>
<li>
<p>The <code class="codeph">DBMS_MVIEW</code> package contains the APIs whose usage is described in this chapter. There are three basic types of refresh operations: complete refresh, fast refresh, and partition change tracking (PCT) refresh. These basic types have been enhanced in Oracle Database 12<span class="italic">c</span>, Release 1 with a new refresh option called out-of-place refresh.</p>
</li>
</ul>
<p>The <code class="codeph">DBMS_MVIEW</code> package contains three APIs for performing refresh operations:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">DBMS_MVIEW.REFRESH</code></p>
<p>Refresh one or more materialized views.</p>
</li>
<li>
<p><code class="codeph">DBMS_MVIEW.REFRESH_ALL_MVIEWS</code></p>
<p>Refresh all materialized views.</p>
</li>
<li>
<p><code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT</code></p>
<p>Refresh all materialized views that depend on a specified master table or materialized view or list of master tables or materialized views.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213__GUID-2B7C6E77-4D31-4A6E-92BA-713F7E6F2FD1">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-587D67C7-CD96-44CA-8B3B-597C39247F31">About ON COMMIT Refresh for Materialized Views</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-6EEA28AC-503B-4526-AD56-85378B547971">About Manual Refresh Using the DBMS_MVIEW Package</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-EB813C4E-FEE4-4E4C-AAB8-9A34F8EB8D3C">Refreshing Specific Materialized Views with REFRESH</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-A927CEA3-D02D-4871-955D-86E965BC03C4">Refreshing All Materialized Views with REFRESH_ALL_MVIEWS</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-2A3AE420-9B99-4F52-A1E3-8F56B7563B2B">Refreshing Dependent Materialized Views with REFRESH_DEPENDENT</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD">When Fast Refresh is Possible</a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2"><span class="bold">How to Refresh Materialized Views?</span></p>
<p>For each of these refresh options, you have two techniques for how the refresh is performed, namely in-place refresh and out-of-place refresh. The in-place refresh executes the refresh statements directly on the materialized view. The out-of-place refresh creates one or more outside tables and executes the refresh statements on the outside tables and then switches the materialized view or affected materialized view partitions with the outside tables. Both in-place refresh and out-of-place refresh achieve good performance in certain refresh scenarios. However, the out-of-place refresh enables high materialized view availability during refresh, especially when refresh statements take a long time to finish.</p>
<p>Also adopting the out-of-place mechanism, a new refresh method called synchronous refresh is introduced in Oracle Database 12<span class="italic">c</span>, Release 1. It targets the common usage scenario in the data warehouse where both fact tables and their materialized views are partitioned in the same way or their partitions are related by a functional dependency.</p>
<p>The refresh approach enables you to keep a set of tables and the materialized views defined on them to be always in sync. In this refresh method, the user does not directly modify the contents of the base tables but must use the APIs provided by the synchronous refresh package that will apply these changes to the base tables and materialized views at the same time to ensure their consistency. The synchronous refresh method is well-suited for data warehouses, where the loading of incremental data is tightly controlled and occurs at periodic intervals.</p>
<div class="infoboxnotealso" id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213__GUID-E94EF20D-ADDB-4A2E-93A0-324C4BFDF413">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-51191C38-D52F-4A4D-B6FF-E631965AD69A">About the Out-of-Place Refresh Option</a></p>
</li>
<li>
<p><a class="olink OLAUG700" target="_blank" href="../OLAUG/admin.htm#OLAUG700"><span class="italic">Oracle OLAP User&#39;s Guide</span></a> for information regarding the refresh of cube organized materialized views</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="DWHSG8360"></a>
<div class="props_rev_3"><a id="GUID-A32EE00B-B369-44C3-AB5D-07403C0A44CD"></a>
<h3 id="DWHSG-GUID-A32EE00B-B369-44C3-AB5D-07403C0A44CD" class="sect3">About Complete Refresh for Materialized Views</h3>
<div>
<p><a id="d26360e342" class="indexterm-anchor"></a>A complete refresh occurs when the materialized view is initially defined as <code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code>, unless the materialized view references a prebuilt table. For materialized views using <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code>, a complete refresh must be requested before it can be used for the first time. A complete refresh may be requested at any time during the life of any materialized view. The refresh involves reading the detail tables to compute the results for the materialized view. This can be a very time-consuming process, especially if there are huge amounts of data to be read and processed. Therefore, you should always consider the time required to process a complete refresh before requesting it.</p>
<p>There are, however, cases when the only refresh method available for an already built materialized view is complete refresh because the materialized view does not satisfy the conditions specified in the following section for a fast refresh.</p>
</div>
</div>
<a id="DWHSG8361"></a>
<div class="props_rev_3"><a id="GUID-4FD1E4C6-B82F-4B13-880C-80187FA22AAF"></a>
<h3 id="DWHSG-GUID-4FD1E4C6-B82F-4B13-880C-80187FA22AAF" class="sect3">About Fast Refresh for Materialized Views</h3>
<div>
<p><a id="d26360e380" class="indexterm-anchor"></a>Most data warehouses have periodic incremental updates to their detail data. As described in <span class="q">&#34;<a href="basicmv.htm#GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27">About Materialized View Schema Design</a>&#34;</span>, you can use the SQL*Loader or any bulk load utility to perform incremental loads of detail data. Fast refresh of your materialized views is usually efficient, because instead of having to recompute the entire materialized view, the changes are applied to the existing data. Thus, processing only the changes can result in a very fast refresh time.</p>
</div>
</div>
<a id="DWHSG8362"></a>
<div class="props_rev_3"><a id="GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD"></a>
<h3 id="DWHSG-GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD" class="sect3">About Partition Change Tracking (PCT) Refresh for Materialized Views</h3>
<div>
<p>Whe<a id="d26360e411" class="indexterm-anchor"></a><a id="d26360e415" class="indexterm-anchor"></a>n there have been some partition maintenance operations on the detail tables, this is the only method of fast refresh that can be used. PCT-based refresh on a materialized view is enabled only if all the conditions described in <span class="q">&#34;<a href="advmv.htm#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a>&#34;</span> are satisfied.</p>
<p>In the absence of partition maintenance operations on detail tables, when you request a <code class="codeph">FAST</code> method (<code class="codeph">method =&gt; &#39;F&#39;</code>) of refresh through procedures in <code class="codeph">DBMS_MVIEW</code> package, Oracle uses a heuristic rule to try log-based rule fast refresh before choosing PCT refresh. Similarly, when you request a <code class="codeph">FORCE</code> method (<code class="codeph">method =&gt; &#39;?&#39;</code>), Oracle chooses the refresh method based on the following attempt order: log-based fast refresh, PCT refresh, and complete refresh. Alternatively, you can request the PCT method (<code class="codeph">method =&gt; &#39;P&#39;</code>), and Oracle uses the PCT method provided all PCT requirements are satisfied.</p>
<p>Oracle can use <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> on a materialized view if it satisfies the conditions in <span class="q">&#34;<a href="advmv.htm#GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA">Benefits of Partitioning a Materialized View</a>&#34;</span> and hence, make the PCT refresh process more efficient.</p>
<div class="infoboxnotealso" id="GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD__GUID-44E9C54C-91AF-45C6-9BEB-C337016E382C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="advmv.htm#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a>&#34;</span> for more information regarding partition change tracking</p>
</li>
</ul>
</div>
</div>
</div>
<div class="props_rev_3"><a id="GUID-51191C38-D52F-4A4D-B6FF-E631965AD69A"></a>
<h3 id="DWHSG-GUID-51191C38-D52F-4A4D-B6FF-E631965AD69A" class="sect3">About the Out-of-Place Refresh Option</h3>
<div>
<p>Beginning with Oracle Datab<a id="d26360e489" class="indexterm-anchor"></a><a id="d26360e493" class="indexterm-anchor"></a>ase 12<span class="italic">c</span> Release 1, a new refresh option is available to improve materialized view refresh performance and availability. This refresh option is called out-of-place refresh because it uses outside tables during refresh as opposed to the existing &#34;in-place&#34; refresh that directly applies changes to the materialized view container table. The out-of-place refresh option works with all existing refresh methods, such as <code class="codeph">FAST</code> (<code class="codeph">&#39;F&#39;</code>), <code class="codeph">COMPLETE</code> (&#39;<code class="codeph">C&#39;</code>), <code class="codeph">PCT</code> (<code class="codeph">&#39;P&#39;</code>), and <code class="codeph">FORCE</code> (<code class="codeph">&#39;?&#39;</code>). Out-of-place refresh is particularly effective when handling situations with large amounts of data changes, where conventional DML statements do not scale well. It also enables you to achieve a very high degree of availability because the materialized views that are being refreshed can be used for direct access and query rewrite during the execution of refresh statements. In addition, it helps to avoid potential problems such as materialized view container tables becoming fragmented over time or intermediate refresh results being seen.</p>
<p>In out-of-place refresh, the entire or affected portions of a materialized view are computed into one or more outside tables. For partitioned materialized views, if partition level change tracking is possible, and there are local indexes defined on the materialized view, the out-of-place method also builds the same local indexes on the outside tables. This refresh process is completed by either switching between the materialized view and the outside table or partition exchange between the affected partitions and the outside tables. Note that query rewrite is not supported during the switching or partition exchange operation. During refresh, the outside table is populated by direct load, which is efficient.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-0A1E1DC3-0881-4DF9-A388-5FF7A553D540">Types of Out-of-Place Refresh</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-9B26B82B-AAA4-4270-9966-86B75CDE31F6">Restrictions and Considerations with Out-of-Place Refresh</a></p>
</li>
</ul>
</div>
<a id="DWHSG9416"></a>
<div class="props_rev_3"><a id="GUID-0A1E1DC3-0881-4DF9-A388-5FF7A553D540"></a>
<h4 id="DWHSG-GUID-0A1E1DC3-0881-4DF9-A388-5FF7A553D540" class="sect4">Types of Out-of-Place Refresh</h4>
<div>
<p>There are three types of out-of-place refresh:</p>
<ul style="list-style-type: disc;">
<li>
<p>out-of-place fast refresh</p>
<p>This offers better availability than in-place fast refresh. It also offers better performance when changes affect a large part of the materialized view.</p>
</li>
<li>
<p>out-of-place PCT refresh</p>
<p>This offers better availability than in-place PCT refresh. There are two different approaches for partitioned and non-partitioned materialized views. If truncation and direct load are not feasible, you should use out-of-place refresh when the changes are relatively large. If truncation and direct load are feasible, in-place refresh is preferable in terms of performance. In terms of availability, out-of-place refresh is always preferable.</p>
</li>
<li>
<p>out-of-place complete refresh</p>
<p>This offers better availability than in-place complete refresh.</p>
</li>
</ul>
<p>Using the refresh interface in the <code class="codeph">DBMS_MVIEW</code> package, with <code class="codeph">method</code> <code class="codeph">=</code> <code class="codeph">?</code> and <code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code>, out-of-place fast refresh are attempted first, then out-of-place PCT refresh, and finally out-of-place complete refresh. An example is the following:</p>
<pre dir="ltr">DBMS_MVIEW.REFRESH(&#39;CAL_MONTH_SALES_MV&#39;, method =&gt; &#39;?&#39;, 
   atomic_refresh =&gt; FALSE, out_of_place =&gt; TRUE);
</pre></div>
</div>
<a id="DWHSG9082"></a>
<div class="props_rev_3"><a id="GUID-9B26B82B-AAA4-4270-9966-86B75CDE31F6"></a>
<h4 id="DWHSG-GUID-9B26B82B-AAA4-4270-9966-86B75CDE31F6" class="sect4">Restrictions and Considerations with Out-of-Place Refresh</h4>
<div>
<div class="section">
<p>Out-of-place refresh has all the restrictions that apply when using the corresponding in-place refresh. In addition, it has the following restrictions:</p>
<ul style="list-style-type: disc;">
<li>
<p>Only materialized join views and materialized aggregate views are allowed</p>
</li>
<li>
<p>No <code class="codeph">ON</code> <code class="codeph">COMMIT</code> refresh is permitted</p>
</li>
<li>
<p>No remote materialized views, cube materialized views, object materialized views are permitted</p>
</li>
<li>
<p>No <code class="codeph">LOB</code> columns are permitted</p>
</li>
<li>
<p>Not permitted if materialized view logs, triggers, or constraints (except <code class="codeph">NOT</code> <code class="codeph">NULL</code>) are defined on the materialized view</p>
</li>
<li>
<p>Not permitted if the materialized view contains the <code class="codeph">CLUSTERING</code> clause</p>
</li>
<li>
<p>Not applied to complete refresh within a <code class="codeph">CREATE</code> or <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> session or an <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> session</p>
</li>
<li>
<p>Atomic mode is not permitted. If you specify <code class="codeph">atomic_refresh</code> as <code class="codeph">TRUE</code> and <code class="codeph">out_of_place</code> as <code class="codeph">TRUE</code>, an error is displayed</p>
</li>
</ul>
<p>For out-of-place PCT refresh, there is the following restriction:</p>
<ul style="list-style-type: disc;">
<li>
<p>No <code class="codeph">UNION</code> <code class="codeph">ALL</code> or grouping sets are permitted</p>
</li>
</ul>
<p>For out-of-place fast refresh, there are the following restrictions:</p>
<ul style="list-style-type: disc;">
<li>
<p>No <code class="codeph">UNION</code> <code class="codeph">ALL</code>, grouping sets or outer joins are permitted</p>
</li>
<li>
<p>Not allowed for materialized join views when more than one base table is modified with mixed DML statements</p>
</li>
</ul>
<p>Out-of-place refresh requires additional storage for the outside table and the indexes for the duration of the refresh. Thus, you must have enough available tablespace or auto extend turned on.</p>
<p>The partition exchange in out-of-place PCT refresh impacts the global index on the materialized view. Therefore, if there are global indexes defined on the materialized view container table, Oracle disables the global indexes before doing the partition exchange and rebuild the global indexes after the partition exchange. This rebuilding is additional overhead.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8363"></a>
<div class="props_rev_3"><a id="GUID-587D67C7-CD96-44CA-8B3B-597C39247F31"></a>
<h3 id="DWHSG-GUID-587D67C7-CD96-44CA-8B3B-597C39247F31" class="sect3">About ON COMMIT Refresh for Materialized Views</h3>
<div>
<p>A materialized view can be refreshed automatically using the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> method. Therefore, whenever a transaction commits which has updated the tables on which a materialized view is defined, those changes are automatically reflected in the materialized view. The advantage of using this approach is you never have to remember to refresh the materialized view. The only disadvantage is the time required to complete the commit will be slightly longer because of the extra processing involved. However, in a data warehouse, this should not be an issue because there is unlikely to be concurrent processes trying to update the same table.</p>
</div>
</div>
<a id="DWHSG8365"></a><a id="DWHSG8364"></a>
<div class="props_rev_3"><a id="GUID-6EEA28AC-503B-4526-AD56-85378B547971"></a>
<h3 id="DWHSG-GUID-6EEA28AC-503B-4526-AD56-85378B547971" class="sect3">About Manual Refresh Using the DBMS_MVIEW Package</h3>
<div>
<p>When a materialized view is refreshed <code class="codeph">ON</code> <code class="codeph">DEMAND</code>, one of four refresh methods can be specified as shown in the following table. You can define a default option during the creation of the materialized view. <a href="refresh.htm#GUID-6EEA28AC-503B-4526-AD56-85378B547971__I1008349" title="This table describes the various ON DEMAND refresh methods for materialized view.">Table 7-1</a> details the refresh options.</p>
<div class="tblformal" id="GUID-6EEA28AC-503B-4526-AD56-85378B547971__I1008349">
<p class="titleintable">Table 7-1 ON DEMAND Refresh Methods</p>
<table class="cellalignment1516" title="ON DEMAND Refresh Methods" summary="This table describes the various ON DEMAND refresh methods for materialized view.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1544" id="d26360e813">Refresh Method</th>
<th class="cellalignment1544" id="d26360e816">Parameter</th>
<th class="cellalignment1545" id="d26360e819">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1546" id="d26360e824" headers="d26360e813">
<p><code class="codeph">COMPLETE</code></p>
</td>
<td class="cellalignment1546" headers="d26360e824 d26360e816">
<p><code class="codeph">C</code></p>
</td>
<td class="cellalignment1547" headers="d26360e824 d26360e819">
<p>Refreshes by recalculating the defining query of the materialized view.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1546" id="d26360e836" headers="d26360e813">
<p><code class="codeph">FAST</code></p>
</td>
<td class="cellalignment1546" headers="d26360e836 d26360e816">
<p><code class="codeph">F</code></p>
</td>
<td class="cellalignment1547" headers="d26360e836 d26360e819">
<p>Refreshes by incrementally applying changes to the materialized view.</p>
<p>For local materialized views, it chooses the refresh method which is estimated by optimizer to be most efficient. The refresh methods considered are log-based <code class="codeph">FAST</code> and <code class="codeph">FAST_PCT</code>.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1546" id="d26360e856" headers="d26360e813">
<p><code class="codeph">FAST_PCT</code></p>
</td>
<td class="cellalignment1546" headers="d26360e856 d26360e816">
<p><code class="codeph">P</code></p>
</td>
<td class="cellalignment1547" headers="d26360e856 d26360e819">
<p>Refreshes by recomputing the rows in the materialized view affected by changed partitions in the detail tables.</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1546" id="d26360e868" headers="d26360e813">
<p><code class="codeph">FORCE</code></p>
</td>
<td class="cellalignment1546" headers="d26360e868 d26360e816">
<p><code class="codeph">?</code></p>
</td>
<td class="cellalignment1547" headers="d26360e868 d26360e819">
<p>Attempts a fast refresh. If that is not possible, it does a complete refresh.</p>
<p>For local materialized views, it chooses the refresh method which is estimated by optimizer to be most efficient. The refresh methods considered are log based <code class="codeph">FAST</code>, <code class="codeph">FAST_PCT</code>, and <code class="codeph">COMPLETE</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a id="d26360e891" class="indexterm-anchor"></a>Three refresh procedures are available in the <code class="codeph">DBMS_MVIEW</code> package for performing <code class="codeph">ON</code> <code class="codeph">DEMAND</code> refresh. Each has its own unique set of parameters.</p>
<div class="infoboxnotealso" id="GUID-6EEA28AC-503B-4526-AD56-85378B547971__GUID-842C6F74-F828-411A-B860-F7E617DB5663">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink REPLN003" target="_blank" href="../REPLN/repmview.htm#REPLN003"><span class="italic">Oracle Database Advanced Replication</span></a> for information showing how to use it in a replication environment</p>
</li>
<li>
<p><a class="olink ARPLS027" target="_blank" href="../ARPLS/d_mview.htm#ARPLS027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information about the <code class="codeph">DBMS_MVIEW</code> package</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8366"></a>
<div class="props_rev_3"><a id="GUID-EB813C4E-FEE4-4E4C-AAB8-9A34F8EB8D3C"></a>
<h3 id="DWHSG-GUID-EB813C4E-FEE4-4E4C-AAB8-9A34F8EB8D3C" class="sect3">Refreshing Specific Materialized Views with REFRESH</h3>
<div>
<div class="section">
<p>Use the <code class="codeph">DBMS_MVIEW.REFRESH</code> procedure to refresh one or more materialized views. Some parameters are used only for replication, so they are not mentioned here. The required parameters to use this procedure are:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The comma-delimited list of materialized views to refresh</p>
</li>
<li>
<p>The refresh method: <code class="codeph">F</code>-Fast, <code class="codeph">P</code>-Fast_PCT, <code class="codeph">?</code>-Force, <code class="codeph">C</code>-Complete</p>
</li>
<li>
<p>The rollback segment to use</p>
</li>
<li>
<p>Refresh after errors (<code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>)</p>
<p>A Boolean parameter. If set to <code class="codeph">TRUE</code>, the <code class="codeph">number_of_failures</code> output parameter is set to the number of refreshes that failed, and a generic error message indicates that failures occurred. The alert log for the instance gives details of refresh errors. If set to <code class="codeph">FALSE</code>, the default, then refresh stops after it encounters the first error, and any remaining materialized views in the list are not refreshed.</p>
</li>
<li>
<p>The following four parameters are used by the replication process. For warehouse refresh, set them to <code class="codeph">FALSE, 0,0,0</code>.</p>
</li>
<li>
<p>Atomic refresh (<code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>)</p>
<p>If set to <code class="codeph">TRUE</code>, then all refreshes are done in one transaction. If set to <code class="codeph">FALSE</code>, then each of the materialized views is refreshed non-atomically in separate transactions. If set to <code class="codeph">FALSE</code>, Oracle can optimize refresh by using parallel DML and truncate DDL on a materialized views. When a materialized view is refreshed in atomic mode, it is eligible for query rewrite if the rewrite integrity mode is set to <code class="codeph">stale_tolerated</code>. Atomic refresh cannot be guaranteed when refresh is performed on nested views.</p>
</li>
<li>
<p>Whether to use out-of-place refresh</p>
<p>This parameter works with all existing refresh methods (<code class="codeph">F</code>, <code class="codeph">P</code>, <code class="codeph">C</code>, <code class="codeph">?</code>). So, for example, if you specify <code class="codeph">F</code> and <code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code>, then an out-of-place fast refresh is attempted. Similarly, if you specify <code class="codeph">P</code> and <code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code>, then out-of-place PCT refresh is attempted.</p>
</li>
</ul>
<p>For example, to perform a fast refresh on the materialized view <code class="codeph">cal_month_sales_mv</code>, the <code class="codeph">DBMS_MVIEW</code> package would be called as follows:</p>
<pre dir="ltr">DBMS_MVIEW.REFRESH(&#39;CAL_MONTH_SALES_MV&#39;, &#39;F&#39;, &#39;&#39;, TRUE, FALSE, 0,0,0, 
   FALSE, FALSE);
</pre>
<p>Multiple materialized views can be refreshed at the same time, and they do not all have to use the same refresh method. To give them different refresh methods, specify multiple method codes in the same order as the list of materialized views (without commas). For example, the following specifies that <code class="codeph">cal_month_sales_mv</code> be completely refreshed and <code class="codeph">fweek_pscat_sales_mv</code> receive a fast refresh:</p>
<pre dir="ltr">DBMS_MVIEW.REFRESH(&#39;CAL_MONTH_SALES_MV, FWEEK_PSCAT_SALES_MV&#39;, &#39;CF&#39;, &#39;&#39;, 
  TRUE, FALSE, 0,0,0, FALSE, FALSE);
</pre>
<p>If the refresh method is not specified, the default refresh method as specified in the materialized view definition is used.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8367"></a>
<div class="props_rev_3"><a id="GUID-A927CEA3-D02D-4871-955D-86E965BC03C4"></a>
<h3 id="DWHSG-GUID-A927CEA3-D02D-4871-955D-86E965BC03C4" class="sect3">Refreshing All Materialized Views with REFRESH_ALL_MVIEWS</h3>
<div>
<div class="section">
<p><a id="d26360e1109" class="indexterm-anchor"></a>An alternative to specifying the materialized views to refresh is to use the procedure <code class="codeph">DBMS_MVIEW.REFRESH_ALL_MVIEWS</code>. This procedure refreshes all materialized views. If any of the materialized views fails to refresh, then the number of failures is reported.</p>
<p>The parameters for this procedure are:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The number of failures (this is an <code class="codeph">OUT</code> variable)</p>
</li>
<li>
<p>The refresh method: <code class="codeph">F</code>-Fast, <code class="codeph">P</code>-Fast_PCT, <code class="codeph">?</code>-Force, <code class="codeph">C</code>-Complete</p>
</li>
<li>
<p>Refresh after errors (<code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>)</p>
<p>A Boolean parameter. If set to <code class="codeph">TRUE</code>, the <code class="codeph">number_of_failures</code> output parameter is set to the number of refreshes that failed, and a generic error message indicates that failures occurred. The alert log for the instance gives details of refresh errors. If set to <code class="codeph">FALSE</code>, the default, then refresh stops after it encounters the first error, and any remaining materialized views in the list is not refreshed.</p>
</li>
<li>
<p>Atomic refresh (<code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>)</p>
<p>If set to <code class="codeph">TRUE</code>, then all refreshes are done in one transaction. If set to <code class="codeph">FALSE</code>, then each of the materialized views is refreshed non-atomically in separate transactions. If set to <code class="codeph">FALSE</code>, Oracle can optimize refresh by using parallel DML and truncate DDL on a materialized views. When a materialized view is refreshed in atomic mode, it is eligible for query rewrite if the rewrite integrity mode is set to <code class="codeph">stale_tolerated</code>. Atomic refresh cannot be guaranteed when refresh is performed on nested views.</p>
</li>
<li>
<p>Whether to use out-of-place refresh</p>
<p>This parameter works with all existing refresh method (<code class="codeph">F</code>, <code class="codeph">P</code>, <code class="codeph">C</code>, <code class="codeph">?</code>). So, for example, if you specify <code class="codeph">F</code> and <code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code>, then an out-of-place fast refresh is attempted. Similarly, if you specify <code class="codeph">P</code> and <code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code>, then out-of-place PCT refresh is attempted.</p>
</li>
</ul>
<p>An example of refreshing all materialized views is the following:</p>
<pre dir="ltr">DBMS_MVIEW.REFRESH_ALL_MVIEWS(failures,&#39;C&#39;,&#39;&#39;, TRUE, FALSE, FALSE);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8368"></a>
<div class="props_rev_3"><a id="GUID-2A3AE420-9B99-4F52-A1E3-8F56B7563B2B"></a>
<h3 id="DWHSG-GUID-2A3AE420-9B99-4F52-A1E3-8F56B7563B2B" class="sect3">Refreshing Dependent Materialized Views with REFRESH_DEPENDENT</h3>
<div>
<div class="section">
<p><a id="d26360e1255" class="indexterm-anchor"></a>The third procedure, <code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT</code>, refreshes only those materialized views that depend on a specific table or list of tables. For example, suppose the changes have been received for the <code class="codeph">orders</code> table but not for <code class="codeph">customer</code> payments. The refresh dependent procedure can be called to refresh only those materialized views that reference the <code class="codeph">orders</code> table.</p>
<p>The parameters for this procedure are:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The number of failures (this is an <code class="codeph">OUT</code> variable)</p>
</li>
<li>
<p>The dependent table</p>
</li>
<li>
<p>The refresh method: <code class="codeph">F</code>-Fast, <code class="codeph">P</code>-Fast_PCT, <code class="codeph">?</code>-Force, <code class="codeph">C</code>-Complete</p>
</li>
<li>
<p>The rollback segment to use</p>
</li>
<li>
<p>Refresh after errors (<code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>)</p>
<p>A Boolean parameter. If set to <code class="codeph">TRUE</code>, the <code class="codeph">number_of_failures</code> output parameter is set to the number of refreshes that failed, and a generic error message indicates that failures occurred. The alert log for the instance gives details of refresh errors. If set to <code class="codeph">FALSE</code>, the default, then refresh stops after it encounters the first error, and any remaining materialized views in the list are not refreshed.</p>
</li>
<li>
<p>Atomic refresh (<code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>)</p>
<p>If set to <code class="codeph">TRUE</code>, then all refreshes are done in one transaction. If set to <code class="codeph">FALSE</code>, then each of the materialized views is refreshed non-atomically in separate transactions. If set to <code class="codeph">FALSE</code>, Oracle can optimize refresh by using parallel DML and truncate DDL on a materialized views. When a materialized view is refreshed in atomic mode, it is eligible for query rewrite if the rewrite integrity mode is set to <code class="codeph">stale_tolerated</code>. Atomic refresh cannot be guaranteed when refresh is performed on nested views.</p>
</li>
<li>
<p>Whether it is nested or not</p>
<p>If set to <code class="codeph">TRUE</code>, refresh all the dependent materialized views of the specified set of tables based on a dependency order to ensure the materialized views are truly fresh with respect to the underlying base tables.</p>
</li>
<li>
<p>Whether to use out-of-place refresh</p>
<p>This parameter works with all existing refresh methods (<code class="codeph">F</code>, <code class="codeph">P</code>, <code class="codeph">C</code>, <code class="codeph">?</code>). So, for example, if you specify <code class="codeph">F</code> and <code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code>, then an out-of-place fast refresh is attempted. Similarly, if you specify <code class="codeph">P</code> and <code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code>, then out-of-place PCT refresh is attempted.</p>
</li>
</ul>
<p>To perform a full refresh on all materialized views that reference the <code class="codeph">customers</code> table, specify:</p>
<pre dir="ltr">DBMS_MVIEW.REFRESH_DEPENDENT(failures, &#39;CUSTOMERS&#39;, &#39;C&#39;, &#39;&#39;, FALSE, FALSE, FALSE);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8369"></a>
<div class="props_rev_3"><a id="GUID-EEB31BA4-AD51-4A90-8FB0-2238F5A41817"></a>
<h3 id="DWHSG-GUID-EEB31BA4-AD51-4A90-8FB0-2238F5A41817" class="sect3">About Using Job Queues for Refresh</h3>
<div>
<p>Job queues can be used to refresh multiple materialized views in parallel. If queues are not available, fast refresh sequentially refreshes each view in the foreground process. To make queues available, you must set the <code class="codeph">JOB_QUEUE_PROCESSES</code> parameter. This parameter defines the number of background job queue processes and determines how many materialized views can be refreshed concurrently. Oracle tries to balance the number of concurrent refreshes with the degree of parallelism of each refresh. The order in which the materialized views are refreshed is determined by dependencies imposed by nested materialized views and potential for efficient refresh by using query rewrite against other materialized views (See <span class="q">&#34;<a href="refresh.htm#GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A">Scheduling Refresh of Materialized Views</a>&#34;</span> for details). This parameter is only effective when <code class="codeph">atomic_refresh</code> is set to <code class="codeph">FALSE</code>.</p>
<p><a id="d26360e1441" class="indexterm-anchor"></a>If the process that is executing <code class="codeph">DBMS_MVIEW.REFRESH</code> is interrupted or the instance is shut down, any refresh jobs that were executing in job queue processes are requeued and continue running. To remove these jobs, use the <code class="codeph">DBMS_JOB.REMOVE</code> procedure.</p>
<div class="infoboxnotealso" id="GUID-EEB31BA4-AD51-4A90-8FB0-2238F5A41817__GUID-1AA9BC52-C060-47B9-B209-0937DC57042A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ARPLS019" target="_blank" href="../ARPLS/d_job.htm#ARPLS019"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information about the <code class="codeph">DBMS_JOB</code> package</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8370"></a>
<div class="props_rev_3"><a id="GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD"></a>
<h3 id="DWHSG-GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD" class="sect3">When Fast Refresh is Possible</h3>
<div>
<p>Not all materialized views may be fast refreshable. Therefore, use the package <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code> to determine what refresh methods are available for a materialized view.</p>
<p>If you are not sure how to make a materialized view fast refreshable, you can use the <code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code> procedure, which provides a script containing the statements required to create a fast refreshable materialized view.</p>
<div class="infoboxnotealso" id="GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD__GUID-F772E6CB-AF35-44B0-A649-977DE149F2E8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink TGSQL591" target="_blank" href="../TGSQL/tgsql_sqlaccess.htm#TGSQL591"><span class="italic">Oracle Database SQL Tuning Guide</span></a></p>
</li>
<li>
<p><a href="basicmv.htm#GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF">Basic Materialized Views</a> for further information about the <code class="codeph">DBMS_MVIEW</code> package</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8371"></a>
<div class="props_rev_3"><a id="GUID-D13F84CB-04D1-490F-80FB-AC0E95E0DB60"></a>
<h3 id="DWHSG-GUID-D13F84CB-04D1-490F-80FB-AC0E95E0DB60" class="sect3">Recommended Initialization Parameters for Parallelism</h3>
<div>
<p>The following initialization parameters need to be set properly for parallelism to be effective:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">PARALLEL_MAX_SERVERS</code> should be set high enough to take care of parallelism. You must consider the number of slaves needed for the refresh statement. For example, with a degree of parallelism of eight, you need 16 slave processes.</p>
</li>
<li>
<p><code class="codeph">PGA_AGGREGATE_TARGET</code> should be set for the instance to manage the memory usage for sorts and joins automatically. If the memory parameters are set manually, <code class="codeph">SORT_AREA_SIZE</code> should be less than <code class="codeph">HASH_AREA_SIZE</code>.</p>
</li>
<li>
<p><code class="codeph">OPTIMIZER_MODE</code> should equal <code class="codeph">all_rows</code>.</p>
</li>
</ul>
<p>Remember to analyze all tables and indexes for better optimization.</p>
<div class="infoboxnotealso" id="GUID-D13F84CB-04D1-490F-80FB-AC0E95E0DB60__GUID-4C72F524-0B9F-44EA-87AA-49BE57CCCD40">
<p class="notep1">See Also:</p>
<p><a class="olink VLDBG010" target="_blank" href="../VLDBG/GUID-3E2AE088-2505-465E-A8B2-AC38813EA355.htm#VLDBG010"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a></p>
</div>
</div>
</div>
<a id="DWHSG8372"></a>
<div class="props_rev_3"><a id="GUID-85E2F8EC-2497-42F4-AB84-E3A99FD22EE2"></a>
<h3 id="DWHSG-GUID-85E2F8EC-2497-42F4-AB84-E3A99FD22EE2" class="sect3">Monitoring a Refresh</h3>
<div>
<div class="section">
<p><a id="d26360e1589" class="indexterm-anchor"></a><a id="d26360e1593" class="indexterm-anchor"></a>While a job is running, you can query the <code class="codeph">V$SESSION_LONGOPS</code> view to tell you the progress of each materialized view being refreshed.</p>
<pre dir="ltr">SELECT * FROM V$SESSION_LONGOPS;
</pre>
<p>To look at the progress of which jobs are on which queue, use:</p>
<pre dir="ltr">SELECT * FROM DBA_JOBS_RUNNING;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8373"></a>
<div class="props_rev_3"><a id="GUID-A5F676C6-68D5-4E85-B0CC-DE0DAFE2BD4B"></a>
<h3 id="DWHSG-GUID-A5F676C6-68D5-4E85-B0CC-DE0DAFE2BD4B" class="sect3">Checking the Status of a Materialized View</h3>
<div>
<div class="section">
<p>Three <a id="d26360e1630" class="indexterm-anchor"></a>views are provided for checking the status of a materialized view: <code class="codeph">DBA_MVIEWS</code>, <code class="codeph">ALL_MVIEWS</code>, and <code class="codeph">USER_MVIEWS</code>. To check if a materialized view is fresh or stale, issue the following statement:</p>
<pre dir="ltr">SELECT MVIEW_NAME, STALENESS, LAST_REFRESH_TYPE, COMPILE_STATE 
FROM USER_MVIEWS ORDER BY MVIEW_NAME;

MVIEW_NAME            STALENESS      LAST_REF       COMPILE_STATE
----------            ---------      --------       -------------
CUST_MTH_SALES_MV     NEEDS_COMPILE  FAST           NEEDS_COMPILE
PROD_YR_SALES_MV      FRESH          FAST           VALID
</pre>
<p>If the <code class="codeph">compile_state</code> column shows <code class="codeph">NEEDS</code> <code class="codeph">COMPILE</code>, the other displayed column values cannot be trusted as reflecting the true status. To revalidate the materialized view, issue the following statement:</p>
<pre dir="ltr">ALTER MATERIALIZED VIEW [materialized_view_name] COMPILE;
</pre>
<p>Then reissue the <code class="codeph">SELECT</code> statement.</p>
</div>
<!-- class="section" --></div>
<a id="DWHSG8375"></a><a id="DWHSG8374"></a>
<div class="props_rev_3"><a id="GUID-5B145F5C-C368-450D-8768-22D138A2ED39"></a>
<h4 id="DWHSG-GUID-5B145F5C-C368-450D-8768-22D138A2ED39" class="sect4">Viewing Partition Freshness</h4>
<div>
<div class="section">
<p>Several views are available that enable you to verify the status of base table partitions and determine which ranges of materialized view data are fresh and which are stale. The views are as follows:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">*_USER_MVIEWS</code></p>
<p>To determine partition change tracking (PCT) information for the materialized view.</p>
</li>
<li>
<p><code class="codeph">*_USER_MVIEW_DETAIL_RELATIONS</code></p>
<p>To display partition information for the detail table a materialized view is based on.</p>
</li>
<li>
<p><code class="codeph">*_USER_MVIEW_DETAIL_PARTITION</code></p>
<p>To determine which partitions are fresh.</p>
</li>
<li>
<p><code class="codeph">*_USER_MVIEW_DETAIL_SUBPARTITION</code></p>
<p>To determine which subpartitions are fresh.</p>
</li>
</ul>
<p>The use of these views is illustrated in the following examples. <a href="refresh.htm#GUID-5B145F5C-C368-450D-8768-22D138A2ED39__CACFEBFE">Figure 7-1</a> illustrates a range-list partitioned table and a materialized view based on it. The partitions are P1, P2, P3, and P4, while the subpartitions are SP1, SP2, and SP3.</p>
<div class="figure" id="GUID-5B145F5C-C368-450D-8768-22D138A2ED39__CACFEBFE">
<p class="titleinfigure">Figure 7-1 Determining PCT Freshness</p>
<img width="365" height="162" src="img/GUID-5E5F9C7B-E793-4A44-8349-8B692BD1BA52-default.gif" alt="Description of Figure 7-1 follows" title="Description of Figure 7-1 follows"/><br/>
<a href="img_text/GUID-5E5F9C7B-E793-4A44-8349-8B692BD1BA52-print.htm">Description of &#34;Figure 7-1 Determining PCT Freshness&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-5B145F5C-C368-450D-8768-22D138A2ED39__GUID-7845953F-8BD8-4514-B8EF-7BCE4456DDBF">
<p class="notep1">See Also:</p>
<p><a href="refresh.htm#GUID-96A66E25-4845-45EB-AD82-940E7E693BF5">Examples of Using Views to Determine Freshness</a></p>
</div>
</div>
<!-- class="section" --></div>
<a id="DWHSG8377"></a><a id="DWHSG8378"></a><a id="DWHSG8379"></a><a id="DWHSG8380"></a><a id="DWHSG8376"></a>
<div class="props_rev_3"><a id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5"></a>
<h5 id="DWHSG-GUID-96A66E25-4845-45EB-AD82-940E7E693BF5" class="sect5">Examples of Using Views to Determine Freshness</h5>
<div>
<div class="section">
<p>This section illustrates examples of determining the PCT and freshness information for materialized views and their detail tables.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-520866E2-8E42-4E08-BFC9-DD2EC6B46DC1">
<p class="titleinexample">Example 7-1 Verifying the PCT Status of a Materialized View</p>
<p>Query <code class="codeph">USER_MVIEWS</code> to access PCT information about the materialized view, as shown in the following:</p>
<pre dir="ltr">SELECT MVIEW_NAME, NUM_PCT_TABLES, NUM_FRESH_PCT_REGIONS,
   NUM_STALE_PCT_REGIONS
FROM USER_MVIEWS
WHERE MVIEW_NAME = MV1;

MVIEW_NAME NUM_PCT_TABLES NUM_FRESH_PCT_REGIONS NUM_STALE_PCT_REGIONS
---------- -------------- --------------------- ---------------------
       MV1              1                     9                     3
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-3D7406D5-B321-42A2-96B5-005D9A53E404">
<p class="titleinexample">Example 7-2 Verifying the PCT Status in a Materialized View&#39;s Detail Table</p>
<p>Query <code class="codeph">USER_MVIEW_DETAIL_RELATIONS</code> to access PCT detail table information, as shown in the following:</p>
<pre dir="ltr">SELECT MVIEW_NAME, DETAILOBJ_NAME, DETAILOBJ_PCT,
   NUM_FRESH_PCT_PARTITIONS, NUM_STALE_PCT_PARTITIONS
FROM USER_MVIEW_DETAIL_RELATIONS
WHERE MVIEW_NAME = MV1;
</pre>
<pre dir="ltr">MVIEW_NAME  DETAILOBJ_NAME  DETAIL_OBJ_PCT  NUM_FRESH_PCT_PARTITIONS  NUM_STALE_PCT_PARTITIONS
----------  --------------  --------------  ------------------------  ------------------------
        MV1             T1               Y                         3                         1
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-8DFF7D1A-3990-48A3-B24A-F28140C8D32A">
<p class="titleinexample">Example 7-3 Verifying Which Partitions are Fresh</p>
<p>Query <code class="codeph">USER_MVIEW_DETAIL_PARTITION</code> to access PCT freshness information for partitions, as shown in the following:</p>
<pre dir="ltr">SELECT MVIEW_NAME,DETAILOBJ_NAME,DETAIL_PARTITION_NAME,
   DETAIL_PARTITION_POSITION,FRESHNESS
FROM USER_MVIEW_DETAIL_PARTITION
WHERE MVIEW_NAME = MV1;
</pre>
<pre dir="ltr">MVIEW_NAME  DETAILOBJ_NAME  DETAIL_PARTITION_NAME  DETAIL_PARTITION_POSITION  FRESHNESS
----------  --------------  ---------------------  -------------------------  ---------
       MV1               T1                    P1                          1      FRESH
       MV1               T1                    P2                          2      FRESH
       MV1               T1                    P3                          3      STALE
       MV1               T1                    P4                          4      FRESH
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-BCE1BEED-5962-4500-A038-2F46B83CA31D">
<p class="titleinexample">Example 7-4 Verifying Which Subpartitions are Fresh</p>
<p>Query <code class="codeph">USER_MVIEW_DETAIL_SUBPARTITION</code> to access PCT freshness information for subpartitions, as shown in the following:</p>
<pre dir="ltr">SELECT MVIEW_NAME,DETAILOBJ_NAME,DETAIL_PARTITION_NAME, DETAIL_SUBPARTITION_NAME,
    DETAIL_SUBPARTITION_POSITION,FRESHNESS
FROM USER_MVIEW_DETAIL_SUBPARTITION
WHERE MVIEW_NAME = MV1;
</pre>
<pre dir="ltr">MVIEW_NAME DETAILOBJ DETAIL_PARTITION DETAIL_SUBPARTITION_NAME DETAIL_SUBPARTITION_POS FRESHNESS
---------- --------- ---------------- ------------------------ ----------------------- ---------
       MV1        T1               P1                      SP1                       1     FRESH
       MV1        T1               P1                      SP2                       1     FRESH
       MV1        T1               P1                      SP3                       1     FRESH
       MV1        T1               P2                      SP1                       1     FRESH
       MV1        T1               P2                      SP2                       1     FRESH
       MV1        T1               P2                      SP3                       1     FRESH
       MV1        T1               P3                      SP1                       1     STALE
       MV1        T1               P3                      SP2                       1     STALE
       MV1        T1               P3                      SP3                       1     STALE
       MV1        T1               P4                      SP1                       1     FRESH
       MV1        T1               P4                      SP2                       1     FRESH
       MV1        T1               P4                      SP3                       1     FRESH
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="DWHSG8381"></a>
<div class="props_rev_3"><a id="GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A"></a>
<h3 id="DWHSG-GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A" class="sect3">Scheduling Refresh of Materialized Views</h3>
<div>
<div class="section">
<p>Very<a id="d26360e1825" class="indexterm-anchor"></a> often you have multiple materialized views in the database. Some of these can be computed by rewriting against others. This is very common in data warehousing environment where you may have nested materialized views or materialized views at different levels of some hierarchy.</p>
<p>In such cases, you should create the materialized views as <code class="codeph">BUILD DEFERRED</code>, and then issue one of the refresh procedures in <code class="codeph">DBMS_MVIEW</code> package to refresh all the materialized views. Oracle Database computes the dependencies and refreshes the materialized views in the right order. Consider the example of a complete hierarchical cube described in <span class="q">&#34;<a href="aggreg.htm#GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0">Examples of Hierarchical Cube Materialized Views</a>&#34;</span>. Suppose all the materialized views have been created as <code class="codeph">BUILD DEFERRED</code>. Creating the materialized views as <code class="codeph">BUILD DEFERRED</code> only creates the metadata for all the materialized views. And, then, you can just call one of the refresh procedures in <code class="codeph">DBMS_MVIEW</code> package to refresh all the materialized views in the right order:</p>
<pre dir="ltr">DECLARE numerrs PLS_INTEGER;
BEGIN DBMS_MVIEW.REFRESH_DEPENDENT (
   number_of_failures =&gt; numerrs, list=&gt;&#39;SALES&#39;, method =&gt; &#39;C&#39;);
DBMS_OUTPUT.PUT_LINE(&#39;There were &#39; || numerrs || &#39; errors during refresh&#39;);
END;
/
</pre>
<p>The procedure refreshes the materialized views in the order of their dependencies (first <code class="codeph">sales_hierarchical_mon_cube_mv</code>, followed by <code class="codeph">sales_hierarchical_qtr_cube_mv</code>, then, <code class="codeph">sales_hierarchical_yr_cube_mv</code> and finally, <code class="codeph">sales_hierarchical_all_cube_mv</code>). Each of these materialized views gets rewritten against the one prior to it in the list).</p>
<p>The same kind of rewrite can also be used while doing PCT refresh. PCT refresh recomputes rows in a materialized view corresponding to changed rows in the detail tables. And, if there are other fresh materialized views available at the time of refresh, it can go directly against them as opposed to going against the detail tables.</p>
<p>Hence, it is always beneficial to pass a list of materialized views to any of the refresh procedures in <code class="codeph">DBMS_MVIEW</code> package (irrespective of the method specified) and let the procedure figure out the order of doing refresh on materialized views.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG9417"></a>
<div class="props_rev_3"><a id="GUID-E4E896C7-8173-4A36-A43F-188158981EB7"></a>
<h2 id="DWHSG-GUID-E4E896C7-8173-4A36-A43F-188158981EB7" class="sect2">Tips for Refreshing Materialized Views</h2>
<div>
<p>This section contains the following topics with tips on refreshing materialized views:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-BB945209-8D69-4FC7-844E-35C9ED7C8A80">Tips for Refreshing Materialized Views with Aggregates</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-8ACD48DC-9F21-4B30-9A07-7A81B8515199">Tips for Refreshing Materialized Views Without Aggregates</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-3EA0A375-94F7-44D5-B0F6-6D2E20923A64">Tips for Refreshing Nested Materialized Views</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-848922D5-4C3A-4297-A9D2-30BCD92D9046">Tips for Fast Refresh with UNION ALL</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-5CBF17CF-0253-4A7B-826C-95A9CF2B659E">Tips for Fast Refresh with Commit SCN-Based Materialized View Logs</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-E7F088E2-B9ED-482B-919B-D4AF315F2761">Tips After Refreshing Materialized Views</a></p>
</li>
</ul>
</div>
<a id="DWHSG8382"></a>
<div class="props_rev_3"><a id="GUID-BB945209-8D69-4FC7-844E-35C9ED7C8A80"></a>
<h3 id="DWHSG-GUID-BB945209-8D69-4FC7-844E-35C9ED7C8A80" class="sect3">Tips for Refreshing Materialized Views with Aggregates</h3>
<div>
<p>Following are some guidelines for using the refresh mechanism for materialized views with aggregates.</p>
<ul style="list-style-type: disc;">
<li>
<p>For fast refresh, create materialized view logs on all detail tables involved in a materialized view with the <code class="codeph">ROWID</code>, <code class="codeph">SEQUENCE</code> and <code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code> clauses.</p>
<p>Include all columns from the table likely to be used in materialized views in the materialized view logs.</p>
<p>Fast refresh may be possible even if the <code class="codeph">SEQUENCE</code> option is omitted from the materialized view log. If it can be determined that only inserts or deletes will occur on all the detail tables, then the materialized view log does not require the <code class="codeph">SEQUENCE</code> clause. However, if updates to multiple tables are likely or required or if the specific update scenarios are unknown, make sure the <code class="codeph">SEQUENCE</code> clause is included.</p>
</li>
<li>
<p>Use Oracle&#39;s bulk loader utility or direct-path <code class="codeph">INSERT</code> (<code class="codeph">INSERT</code> with the <code class="codeph">APPEND</code> hint for loads). Starting in Oracle Database 12<span class="italic">c</span>, the database automatically gathers table statistics as part of a bulk-load operation (CTAS and IAS) similar to how statistics are gathered when an index is created. By gathering statistics during the data load, you avoid additional scan operations and provide the necessary statistics as soon as the data becomes available to the users. Note that, in the case of an IAS statement, statistics are only gathered if the table the data is being inserted into is empty.</p>
<p>This is a lot more efficient than conventional insert. During loading, disable all constraints and re-enable when finished loading. Note that materialized view logs are required regardless of whether you use direct load or conventional DML.</p>
<p>Try to optimize the sequence of conventional mixed DML operations, direct-path <code class="codeph">INSERT</code> and the fast refresh of materialized views. You can use fast refresh with a mixture of conventional DML and direct loads. Fast refresh can perform significant optimizations if it finds that only direct loads have occurred, as illustrated in the following:</p>
<ol>
<li>
<p>Direct-path <code class="codeph">INSERT</code> (SQL*Loader or <code class="codeph">INSERT /*+ APPEND */</code>) into the detail table</p>
</li>
<li>
<p>Refresh materialized view</p>
</li>
<li>
<p>Conventional mixed DML</p>
</li>
<li>
<p>Refresh materialized view</p>
</li>
</ol>
<p>You can use fast refresh with conventional mixed DML (<code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">DELETE</code>) to the detail tables. However, fast refresh is able to perform significant optimizations in its processing if it detects that only inserts or deletes have been done to the tables, such as:</p>
<ul style="list-style-type: disc;">
<li>
<p>DML <code class="codeph">INSERT</code> or <code class="codeph">DELETE</code> to the detail table</p>
</li>
<li>
<p>Refresh materialized views</p>
</li>
<li>
<p>DML update to the detail table</p>
</li>
<li>
<p>Refresh materialized view</p>
</li>
</ul>
<p>Even more optimal is the separation of <code class="codeph">INSERT</code> and <code class="codeph">DELETE</code>.</p>
<p>If possible, refresh should be performed after each type of data change (as shown earlier) rather than issuing only one refresh at the end. If that is not possible, restrict the conventional DML to the table to inserts only, to get much better refresh performance. Avoid mixing deletes and direct loads.</p>
<p>Furthermore, for refresh <code class="codeph">ON</code> <code class="codeph">COMMIT</code>, Oracle keeps track of the type of DML done in the committed transaction. Therefore, do not perform direct-path <code class="codeph">INSERT</code> and DML to other tables in the same transaction, as Oracle may not be able to optimize the refresh phase.</p>
<p>For <code class="codeph">ON</code> <code class="codeph">COMMIT</code> materialized views, where refreshes automatically occur at the end of each transaction, it may not be possible to isolate the DML statements, in which case keeping the transactions short will help. However, if you plan to make numerous modifications to the detail table, it may be better to perform them in one transaction, so that refresh of the materialized view is performed just once at commit time rather than after each update.</p>
</li>
<li>
<p>Oracle recommends partitioning the tables because it enables you to use:</p>
<ul style="list-style-type: disc;">
<li>
<p>Parallel DML</p>
<p>For large loads or refresh, enabling parallel DML helps shorten the length of time for the operation.</p>
</li>
<li>
<p>Partition change tracking (PCT) fast refresh</p>
<p>You can refresh your materialized views fast after partition maintenance operations on the detail tables. <span class="q">&#34;<a href="advmv.htm#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a>&#34;</span> for details on enabling PCT for materialized views.</p>
</li>
</ul>
</li>
<li>
<p>Partitioning the materialized view also helps refresh performance as refresh can update the materialized view using parallel DML. For example, assume that the detail tables and materialized view are partitioned and have a parallel clause. The following sequence would enable Oracle to parallelize the refresh of the materialized view.</p>
<ol>
<li>
<p>Bulk load into the detail table.</p>
</li>
<li>
<p>Enable parallel DML with an <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">ENABLE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code> statement.</p>
</li>
<li>
<p>Refresh the materialized view.</p>
</li>
</ol>
</li>
<li>
<p>For refresh using <code class="codeph">DBMS_MVIEW.REFRESH</code>, set the parameter <code class="codeph">atomic_refresh</code> to <code class="codeph">FALSE</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p>For <code class="codeph">COMPLETE</code> refresh, this causes a <code class="codeph">TRUNCATE</code> to delete existing rows in the materialized view, which is faster than a delete.</p>
</li>
<li>
<p>For <code class="codeph">PCT</code> refresh, if the materialized view is partitioned appropriately, this uses <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> to delete rows in the affected partitions of the materialized view, which is faster than a delete.</p>
</li>
<li>
<p>For <code class="codeph">FAST</code> or <code class="codeph">FORCE</code> refresh, if <code class="codeph">COMPLETE</code> or PCT refresh is chosen, this is able to use the <code class="codeph">TRUNCATE</code> optimizations described earlier.</p>
</li>
</ul>
</li>
<li>
<p>When using <code class="codeph">DBMS_MVIEW.REFRESH</code> with <code class="codeph">JOB_QUEUES</code>, remember to set <code class="codeph">atomic</code> to <code class="codeph">FALSE</code>. Otherwise, <code class="codeph">JOB_QUEUES</code> is not used. Set the number of job queue processes greater than the number of processors.</p>
<p>If job queues are enabled and there are many materialized views to refresh, it is faster to refresh all of them in a single command than to call them individually.</p>
</li>
<li>
<p>Use <code class="codeph">REFRESH</code> <code class="codeph">FORCE</code> to ensure refreshing a materialized view so that it can definitely be used for query rewrite. The best refresh method is chosen. If a fast refresh cannot be done, a complete refresh is performed.</p>
</li>
<li>
<p>Refresh all the materialized views in a single procedure call. This gives Oracle an opportunity to schedule refresh of all the materialized views in the right order taking into account dependencies imposed by nested materialized views and potential for efficient refresh by using query rewrite against other materialized views.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8383"></a>
<div class="props_rev_3"><a id="GUID-8ACD48DC-9F21-4B30-9A07-7A81B8515199"></a>
<h3 id="DWHSG-GUID-8ACD48DC-9F21-4B30-9A07-7A81B8515199" class="sect3">Tips for Refreshing Materialized Views Without Aggregates</h3>
<div>
<p>If a materialized view contains joins but no aggregates, then having an index on each of the join column rowids in the detail table enhances refresh performance greatly, because this type of materialized view tends to be much larger than materialized views containing aggregates. For example, consider the following materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW detail_fact_mv BUILD IMMEDIATE AS
SELECT s.rowid &#34;sales_rid&#34;, t.rowid &#34;times_rid&#34;, c.rowid &#34;cust_rid&#34;,
   c.cust_state_province, t.week_ending_day, s.amount_sold
FROM sales s, times t, customers c 
WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id;
 
</pre>
<p>Indexes should be created on columns <code class="codeph">sales_rid</code>, <code class="codeph">times_rid</code> and <code class="codeph">cust_rid</code>. Partitioning is highly recommended, as is enabling parallel DML in the session before invoking refresh, because it greatly enhances refresh performance.</p>
<p>This type of materialized view can also be fast refreshed if DML is performed on the detail table. It is recommended that the same procedure be applied to this type of materialized view as for a single table aggregate. That is, perform one type of change (direct-path <code class="codeph">INSERT</code> or DML) and then refresh the materialized view. This is because Oracle Database can perform significant optimizations if it detects that only one type of change has been done.</p>
<p>Also, Oracle recommends that the refresh be invoked after each table is loaded, rather than load all the tables and then perform the refresh.</p>
<p>For refresh <code class="codeph">ON</code> <code class="codeph">COMMIT</code>, Oracle keeps track of the type of DML done in the committed transaction. Oracle therefore recommends that you do not perform direct-path and conventional DML to other tables in the same transaction because Oracle may not be able to optimize the refresh phase. For example, the following is not recommended:</p>
<ol>
<li>
<p>Direct load new data into the fact table</p>
</li>
<li>
<p>DML into the store table</p>
</li>
<li>
<p>Commit</p>
</li>
</ol>
<p>Also, try not to mix different types of conventional DML statements if possible. This would again prevent using various optimizations during fast refresh. For example, try to avoid the following:</p>
<ol>
<li>
<p>Insert into the fact table</p>
</li>
<li>
<p>Delete from the fact table</p>
</li>
<li>
<p>Commit</p>
</li>
</ol>
<p>If many updates are needed, try to group them all into one transaction because refresh is performed just once at commit time, rather than after each update.</p>
<p>In a data warehousing environment, assuming that the materialized view has a parallel clause, the following sequence of steps is recommended:</p>
<ol>
<li>
<p>Bulk load into the fact table</p>
</li>
<li>
<p>Enable parallel DML</p>
</li>
<li>
<p>An <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">ENABLE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code> statement</p>
</li>
<li>
<p>Refresh the materialized view</p>
</li>
</ol>
</div>
</div>
<a id="DWHSG8384"></a>
<div class="props_rev_3"><a id="GUID-3EA0A375-94F7-44D5-B0F6-6D2E20923A64"></a>
<h3 id="DWHSG-GUID-3EA0A375-94F7-44D5-B0F6-6D2E20923A64" class="sect3">Tips for Refreshing Nested Materialized Views</h3>
<div>
<p><a id="d26360e2338" class="indexterm-anchor"></a><a id="d26360e2342" class="indexterm-anchor"></a>All underlying objects are treated as ordinary tables when refreshing materialized views. If the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> refresh option is specified, then all the materialized views are refreshed in the appropriate order at commit time. In other words, Oracle builds a partially ordered set of materialized views and refreshes them such that, after the successful completion of the refresh, all the materialized views are fresh. The status of the materialized views can be checked by querying the appropriate <code class="codeph">USER_</code>, <code class="codeph">DBA_</code>, or <code class="codeph">ALL_MVIEWS</code> view.</p>
<p>If any of the materialized views are defined as <code class="codeph">ON</code> <code class="codeph">DEMAND</code> refresh (irrespective of whether the refresh method is <code class="codeph">FAST</code>, <code class="codeph">FORCE</code>, or <code class="codeph">COMPLETE</code>), you must refresh them in the correct order (taking into account the dependencies between the materialized views) because the nested materialized view are refreshed with respect to the current contents of the other materialized views (whether fresh or not). This can be achieved by invoking the refresh procedure against the materialized view at the top of the nested hierarchy and specifying the <code class="codeph">nested</code> parameter as <code class="codeph">TRUE</code>.</p>
<p>If a refresh fails during commit time, the list of materialized views that has not been refreshed is written to the alert log, and you must manually refresh them along with all their dependent materialized views.</p>
<p>Use the same <code class="codeph">DBMS_MVIEW</code> procedures on nested materialized views that you use on regular materialized views.</p>
<p>These procedures have the following behavior when used with nested materialized views:</p>
<ul style="list-style-type: disc;">
<li>
<p>If <code class="codeph">REFRESH</code> is applied to a materialized view <code class="codeph">my_mv</code> that is built on other materialized views, then <code class="codeph">my_mv</code> is refreshed with respect to the current contents of the other materialized views (that is, the other materialized views are not made fresh first) unless you specify <code class="codeph">nested =&gt; TRUE</code>.</p>
</li>
<li>
<p>If <code class="codeph">REFRESH_DEPENDENT</code> is applied to materialized view <code class="codeph">my_mv</code>, then only materialized views that directly depend on <code class="codeph">my_mv</code> are refreshed (that is, a materialized view that depends on a materialized view that depends on <code class="codeph">my_mv</code> will not be refreshed) unless you specify <code class="codeph">nested =&gt; TRUE</code>.</p>
</li>
<li>
<p>If <code class="codeph">REFRESH_ALL_MVIEWS</code> is used, the order in which the materialized views are refreshed is guaranteed to respect the dependencies between nested materialized views.</p>
</li>
<li>
<p><code class="codeph">GET_MV_DEPENDENCIES</code> provides a list of the immediate (or direct) materialized view dependencies for an object.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8385"></a>
<div class="props_rev_3"><a id="GUID-848922D5-4C3A-4297-A9D2-30BCD92D9046"></a>
<h3 id="DWHSG-GUID-848922D5-4C3A-4297-A9D2-30BCD92D9046" class="sect3">Tips for Fast Refresh with UNION ALL</h3>
<div>
<p>You can use fast<a id="d26360e2463" class="indexterm-anchor"></a><a id="d26360e2467" class="indexterm-anchor"></a> refresh for materialized views that use the <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator by providing a maintenance column in the definition of the materialized view. For example, a materialized view with a <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator can be made fast refreshable as follows:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW fast_rf_union_all_mv AS
SELECT x.rowid AS r1, y.rowid AS r2, a, b, c, 1 AS marker
FROM x, y WHERE x.a = y.b 
UNION ALL 
SELECT p.rowid, r.rowid, a, c, d, 2 AS marker
FROM p, r WHERE p.a = r.y;
</pre>
<p>The form of a maintenance marker column, column <code class="codeph">MARKER</code> in the example, must be <code class="codeph">numeric_or_string_literal</code> <code class="codeph">AS</code> <code class="codeph">column_alias</code>, where each <code class="codeph">UNION</code> <code class="codeph">ALL</code> member has a distinct value for <code class="codeph">numeric_or_string_literal</code>.</p>
</div>
</div>
<a id="DWHSG0319"></a>
<div class="props_rev_3"><a id="GUID-5CBF17CF-0253-4A7B-826C-95A9CF2B659E"></a>
<h3 id="DWHSG-GUID-5CBF17CF-0253-4A7B-826C-95A9CF2B659E" class="sect3">Tips for Fast Refresh with Commit SCN-Based Materialized View Logs</h3>
<div>
<p>You can often improve fast refresh performance by ensuring that your materialized view logs on the base table contain a <code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code> clause, often significantly. By optimizing materialized view log processing <code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code>, the fast refresh process can save time. The following example illustrates how to use this clause:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold),
COMMIT SCN INCLUDING NEW VALUES;
</pre>
<p>The materialized view refresh automatically uses the commit SCN-based materialized view log to save refresh time.</p>
<p>Note that only new materialized view logs can take advantage of <code class="codeph">COMMIT</code> <code class="codeph">SCN</code>. Existing materialized view logs cannot be altered to add <code class="codeph">COMMIT</code> <code class="codeph">SCN</code> unless they are dropped and recreated.</p>
<p>When a materialized view is created on both base tables with timestamp-based materialized view logs and base tables with commit SCN-based materialized view logs, an error (ORA-32414) is raised stating that materialized view logs are not compatible with each other for fast refresh.</p>
</div>
</div>
<a id="DWHSG8386"></a>
<div class="props_rev_3"><a id="GUID-E7F088E2-B9ED-482B-919B-D4AF315F2761"></a>
<h3 id="DWHSG-GUID-E7F088E2-B9ED-482B-919B-D4AF315F2761" class="sect3">Tips After Refreshing Materialized Views</h3>
<div>
<p>After you have performed a load or incremental load and rebuilt the detail table indexes, you must re-enable integrity constraints (if any) and refresh the materialized views and materialized view indexes that are derived from that detail data. In a data warehouse environment, referential integrity constraints are normally enabled with the <code class="codeph">NOVALIDATE</code> or <code class="codeph">RELY</code> options. An important decision to make before performing a refresh operation is whether the refresh needs to be recoverable. Because materialized view data is redundant and can always be reconstructed from the detail tables, it might be preferable to disable logging on the materialized view. To disable logging and run incremental refresh non-recoverably, use the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ... <code class="codeph">NOLOGGING</code> statement prior to refreshing.</p>
<p>If the materialized view is being refreshed using the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> method, then, following refresh operations, consult the alert log <code class="codeph">alert_</code><span class="italic">SID</span><code class="codeph">.log</code> and the trace file <code class="codeph">ora_</code><span class="italic">SID</span><code class="codeph">_number.trc</code> to check that no errors have occurred.</p>
</div>
</div>
</div>
<a id="DWHSG03009"></a>
<div class="props_rev_3"><a id="GUID-7EA0FBD1-DCBD-4EBD-A131-59EE6ACC97B6"></a>
<h2 id="DWHSG-GUID-7EA0FBD1-DCBD-4EBD-A131-59EE6ACC97B6" class="sect2">Using Materialized Views with Partitioned Tables</h2>
<div>
<div class="section">
<p>A major maintenance <a id="d26360e2660" class="indexterm-anchor"></a><a id="d26360e2664" class="indexterm-anchor"></a>component of a data warehouse is synchronizing (refreshing) the materialized views when the detail data changes. Partitioning the underlying detail tables can reduce the amount of time taken to perform the refresh task. This is possible because partitioning enables refresh to use parallel DML to update the materialized view. Also, it enables the use of partition change tracking.</p>
<p><span class="q">&#34;<a href="refresh.htm#GUID-26E584E9-86BB-4752-9202-5D58D31172A9">Materialized View Fast Refresh with Partition Change Tracking</a>&#34;</span> provides additional information about PCT refresh.</p>
</div>
<!-- class="section" --></div>
<a id="DWHSG8387"></a>
<div class="props_rev_3"><a id="GUID-26E584E9-86BB-4752-9202-5D58D31172A9"></a>
<h3 id="DWHSG-GUID-26E584E9-86BB-4752-9202-5D58D31172A9" class="sect3">Materialized View Fast Refresh with Partition Change Tracking</h3>
<div>
<p>In a data warehous<a id="d26360e2697" class="indexterm-anchor"></a>e, changes to the detail tables can often entail partition maintenance operations, such as <code class="codeph">DROP</code>, <code class="codeph">EXCHANGE</code>, <code class="codeph">MERGE</code>, and <code class="codeph">ADD</code> <code class="codeph">PARTITION</code>. To maintain the materialized view after such operations used to require manual maintenance (see also <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code>) or complete refresh. You now have the option of using an addition to fast refresh known as partition change tracking (PCT) refresh.</p>
<p>For PCT to be available, the detail tables must be partitioned. The partitioning of the materialized view itself has no bearing on this feature. If PCT refresh is possible, it occurs automatically and no user intervention is required in order for it to occur. See <span class="q">&#34;<a href="advmv.htm#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a>&#34;</span> for PCT requirements.</p>
<p>The following examples illustrate the use of this feature:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT Fast Refresh for Materialized Views: Scenario 1</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950">PCT Fast Refresh for Materialized Views: Scenario 2</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-B4682FA1-52C4-4847-9843-8CA3D6AD258D">PCT Fast Refresh for Materialized Views: Scenario 3</a></p>
</li>
</ul>
</div>
<a id="DWHSG8388"></a>
<div class="props_rev_3"><a id="GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976"></a>
<h4 id="DWHSG-GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976" class="sect4">PCT Fast Refresh for Materialized Views: Scenario 1</h4>
<div>
<div class="section">
<p>In this scenario, assume <code class="codeph">sales</code> is a partitioned table using the <code class="codeph">time_id</code> column and <code class="codeph">products</code> is partitioned by the <code class="codeph">prod_category</code> column. The table <code class="codeph">times</code> is not a partitioned table.</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create the materialized view. The following materialized view satisfies requirements for PCT.</span>
<div>
<pre dir="ltr">CREATE MATERIALIZED VIEW cust_mth_sales_mv
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.time_id, s.prod_id, SUM(s.quantity_sold), SUM(s.amount_sold),
       p.prod_name, t.calendar_month_name, COUNT(*),
       COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY t.calendar_month_name, s.prod_id, p.prod_name, s.time_id;
</pre></div>
</li>
<li class="stepexpand"><span>Run the <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code> procedure to determine which tables allow PCT refresh.</span>
<div>
<pre dir="ltr">MVNAME              CAPABILITY_NAME   POSSIBLE  RELATED_TEXT  MSGTXT
-----------------   ---------------   --------  ------------  ----------------
CUST_MTH_SALES_MV   PCT               Y         SALES
CUST_MTH_SALES_MV   PCT_TABLE         Y         SALES
CUST_MTH_SALES_MV   PCT_TABLE         N         PRODUCTS      no partition key
                                                              or PMARKER
                                                              in SELECT list
CUST_MTH_SALES_MV   PCT_TABLE         N         TIMES         relation is not
                                                              partitionedtable
</pre>
<p>As can be seen from the partial sample output from <code class="codeph">EXPLAIN_MVIEW</code>, any partition maintenance operation performed on the <code class="codeph">sales</code> table allows PCT fast refresh. However, PCT is not possible after partition maintenance operations or updates to the <code class="codeph">products</code> table as there is insufficient information contained in <code class="codeph">cust_mth_sales_mv</code> for PCT refresh to be possible. Note that the <code class="codeph">times</code> table is not partitioned and hence can never allow for PCT refresh. Oracle Database applies PCT refresh if it can determine that the materialized view has sufficient information to support PCT for all the updated tables. You can verify which partitions are fresh and stale with views such as <code class="codeph">DBA_MVIEWS</code> and <code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code>.</p>
<p>See <span class="q">&#34;<a href="basicmv.htm#GUID-651B08EB-4D32-4A93-A260-A965C40AE136">Analyzing Materialized View Capabilities</a>&#34;</span> for information on how to use this procedure and also some details regarding PCT-related views.</p>
</div>
</li>
<li class="stepexpand"><span>Suppose at some later point, a <code class="codeph">SPLIT</code> operation of one partition in the sales table becomes necessary.</span>
<div>
<pre dir="ltr">ALTER TABLE SALES
SPLIT PARTITION month3 AT (TO_DATE(&#39;05-02-1998&#39;, &#39;DD-MM-YYYY&#39;))
INTO (PARTITION month3_1 TABLESPACE summ,
      PARTITION month3 TABLESPACE summ);
 
</pre></div>
</li>
<li class="stepexpand"><span>Insert some data into the <code class="codeph">sales</code> table.</span></li>
<li class="stepexpand"><span>Fast refresh <code class="codeph">cust_mth_sales_mv</code> using the <code class="codeph">DBMS_MVIEW.REFRESH</code> procedure.</span>
<div>
<pre dir="ltr">EXECUTE DBMS_MVIEW.REFRESH(&#39;CUST_MTH_SALES_MV&#39;, &#39;F&#39;,
   &#39;&#39;,TRUE,FALSE,0,0,0,FALSE);
</pre></div>
</li>
</ol>
<div class="section">
<p>Fast refresh automatically performs a PCT refresh as it is the only fast refresh possible in this scenario. However, fast refresh will not occur if a partition maintenance operation occurs when any update has taken place to a table on which PCT is not enabled. This is shown in <span class="q">&#34;<a href="refresh.htm#GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950">PCT Fast Refresh for Materialized Views: Scenario 2</a>&#34;</span>.</p>
<p><span class="q">&#34;<a href="refresh.htm#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT Fast Refresh for Materialized Views: Scenario 1</a>&#34;</span> would also be appropriate if the materialized view was created using the <code class="codeph">PMARKER</code> clause as illustrated in the following:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW cust_sales_marker_mv
BUILD IMMEDIATE
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT DBMS_MVIEW.PMARKER(s.rowid) s_marker, SUM(s.quantity_sold),
  SUM(s.amount_sold), p.prod_name, t.calendar_month_name, COUNT(*),
  COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY DBMS_MVIEW.PMARKER(s.rowid),
         p.prod_name, t.calendar_month_name;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8389"></a>
<div class="props_rev_3"><a id="GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950"></a>
<h4 id="DWHSG-GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950" class="sect4">PCT Fast Refresh for Materialized Views: Scenario 2</h4>
<div>
<div class="section">
<p>In this scenario, the first three steps are the same as in <span class="q">&#34;<a href="refresh.htm#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT Fast Refresh for Materialized Views: Scenario 1</a>&#34;</span>. Then, the <code class="codeph">SPLIT</code> partition operation to the <code class="codeph">sales</code> table is performed, but before the materialized view refresh occurs, records are inserted into the <code class="codeph">times</code> table.</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>The same as in <span class="q">&#34;<a href="refresh.htm#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT Fast Refresh for Materialized Views: Scenario 1</a>&#34;</span>.</span></li>
<li class="stepexpand"><span>The same as in <span class="q">&#34;<a href="refresh.htm#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT Fast Refresh for Materialized Views: Scenario 1</a>&#34;</span>.</span></li>
<li class="stepexpand"><span>The same as in <span class="q">&#34;<a href="refresh.htm#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT Fast Refresh for Materialized Views: Scenario 1</a>&#34;</span>.</span></li>
<li class="stepexpand"><span>After issuing the same <code class="codeph">SPLIT</code> operation, as shown in <span class="q">&#34;<a href="refresh.htm#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT Fast Refresh for Materialized Views: Scenario 1</a>&#34;</span>, some data is inserted into the <code class="codeph">times</code> table.</span>
<div>
<pre dir="ltr">ALTER TABLE SALES
SPLIT PARTITION month3 AT (TO_DATE(&#39;05-02-1998&#39;, &#39;DD-MM-YYYY&#39;))
INTO (PARTIITION month3_1 TABLESPACE summ,
      PARTITION month3 TABLESPACE summ);
</pre></div>
</li>
<li class="stepexpand"><span>Refresh <code class="codeph">cust_mth_sales_mv</code>.</span>
<div>
<pre dir="ltr">EXECUTE DBMS_MVIEW.REFRESH(&#39;CUST_MTH_SALES_MV&#39;, &#39;F&#39;,
    &#39;&#39;, TRUE, FALSE, 0, 0, 0, FALSE, FALSE);
ORA-12052: cannot fast refresh materialized view SH.CUST_MTH_SALES_MV
</pre></div>
</li>
</ol>
<div class="section">
<p>The materialized view is not fast refreshable because DML has occurred to a table on which PCT fast refresh is not possible. To avoid this occurring, Oracle recommends performing a fast refresh immediately after any partition maintenance operation on detail tables for which partition tracking fast refresh is available.</p>
<p>If the situation in <span class="q">&#34;<a href="refresh.htm#GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950">PCT Fast Refresh for Materialized Views: Scenario 2</a>&#34;</span> occurs, there are two possibilities; perform a complete refresh or switch to the <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> option outlined in the following, if suitable. However, it should be noted that <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> and partition change tracking fast refresh are not compatible. Once the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">cust_mth_sales_mv</code> <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> statement has been issued, PCT refresh is no longer be applied to this materialized view, until a complete refresh is done. Moreover, you should not use <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> unless you have taken manual action to ensure that the materialized view is indeed fresh.</p>
<p>A common situation in a data warehouse is the use of rolling windows of data. In this case, the detail table and the materialized view may contain say the last 12 months of data. Every month, new data for a month is added to the table and the oldest month is deleted (or maybe archived). PCT refresh provides a very efficient mechanism to maintain the materialized view in this case.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8390"></a>
<div class="props_rev_3"><a id="GUID-B4682FA1-52C4-4847-9843-8CA3D6AD258D"></a>
<h4 id="DWHSG-GUID-B4682FA1-52C4-4847-9843-8CA3D6AD258D" class="sect4">PCT Fast Refresh for Materialized Views: Scenario 3</h4>
<div>
<ol>
<li class="stepexpand"><span>The new data is usually added to the detail table by adding a new partition and exchanging it with a table containing the new data.</span>
<div>
<pre dir="ltr">ALTER TABLE sales ADD PARTITION month_new ...
ALTER TABLE sales EXCHANGE PARTITION month_new month_new_table
  
</pre></div>
</li>
<li class="stepexpand"><span>Next, the oldest partition is dropped or truncated.</span>
<div>
<pre dir="ltr">ALTER TABLE sales DROP PARTITION month_oldest;
</pre></div>
</li>
<li class="stepexpand"><span>Now, if the materialized view satisfies all conditions for PCT refresh.</span>
<div>
<pre dir="ltr">EXECUTE DBMS_MVIEW.REFRESH(&#39;CUST_MTH_SALES_MV&#39;, &#39;F&#39;, &#39;&#39;, TRUE, FALSE, 0, 0, 0, FALSE, FALSE);
</pre></div>
</li>
</ol>
<div class="section">
<p>Fast refresh will automatically detect that PCT is available and perform a PCT refresh.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<a id="DWHSG03001"></a>
<div class="props_rev_3"><a id="GUID-4679957A-71E5-439E-BD8B-A0331F0631F2"></a>
<h2 id="DWHSG-GUID-4679957A-71E5-439E-BD8B-A0331F0631F2" class="sect2">Using Partitioning to Improve Data Warehouse Refresh</h2>
<div>
<div class="section">
<p><a href="glossary.htm#GUID-A85C01AD-53F8-409B-A648-60DC2E8CE0ED"><span class="xrefglossterm">ETL</span></a> (Extraction, Transformation and Loading) is done on a scheduled basis to reflect changes made to the original source system. During this step, you physically insert the new, clean data into the production data warehouse schema, and take all of the other steps necessary (such as building indexes, validating constraints, taking backups) to make this new data available to the end users. Once all of this data has been loaded into the data warehouse, the materialized views have to be updated to reflect the latest data.</p>
<p><a id="d26360e3086" class="indexterm-anchor"></a>The partitioning scheme of the data warehouse is often crucial in determining the efficiency of refresh operations in the data warehouse load process. In fact, the load process is often the primary consideration in choosing the partitioning scheme of data warehouse tables and indexes.</p>
<p>The partitioning scheme of the largest data warehouse tables (for example, the fact table in a star schema) should be based upon the loading paradigm of the data warehouse.</p>
<p>Most data warehouses are loaded with new data on a regular schedule. For example, every night, week, or month, new data is brought into the data warehouse. The data being loaded at the end of the week or month typically corresponds to the transactions for the week or month. In this very common scenario, the data warehouse is being loaded by time. This suggests that the data warehouse tables should be partitioned on a date column. In our data warehouse example, suppose the new data is loaded into the <code class="codeph">sales</code> table every month. Furthermore, the <code class="codeph">sales</code> table has been partitioned by month. These steps show how the load process proceeds to add the data for a new month (January 2001) to the table <code class="codeph">sales</code>.</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Place the new data into a separate table, <code class="codeph">sales_01_2001</code>. This data can be directly loaded into <code class="codeph">sales_01_2001</code> from outside the data warehouse, or this data can be the result of previous data transformation operations that have already occurred in the data warehouse. <code class="codeph">sales_01_2001</code> has the exact same columns, data types, and so forth, as the <code class="codeph">sales</code> table. Gather statistics on the <code class="codeph">sales_01_2001</code> table.</span></li>
<li class="stepexpand"><span>Create indexes and add constraints on <code class="codeph">sales_01_2001</code>. Again, the indexes and constraints on <code class="codeph">sales_01_2001</code> should be identical to the indexes and constraints on <code class="codeph">sales</code>. Indexes can be built in parallel and should use the <code class="codeph">NOLOGGING</code> and the <code class="codeph">COMPUTE</code> <code class="codeph">STATISTICS</code> options. For example:</span>
<div>
<pre dir="ltr">CREATE BITMAP INDEX sales_01_2001_customer_id_bix
  ON sales_01_2001(customer_id)
      TABLESPACE sales_idx NOLOGGING PARALLEL 8 COMPUTE STATISTICS;
</pre>
<p>Apply all constraints to the <code class="codeph">sales_01_2001</code> table that are present on the <code class="codeph">sales</code> table. This includes referential integrity constraints. A typical constraint would be:</p>
<pre dir="ltr">ALTER TABLE sales_01_2001 ADD CONSTRAINT sales_customer_id
      REFERENCES customer(customer_id) ENABLE NOVALIDATE;
</pre>
<p>If the partitioned table <code class="codeph">sales</code> has a primary or unique key that is enforced with a global index structure, ensure that the constraint on <code class="codeph">sales_pk_jan01</code> is validated without the creation of an index structure, as in the following:</p>
<pre dir="ltr">ALTER TABLE sales_01_2001 ADD CONSTRAINT sales_pk_jan01
PRIMARY KEY (sales_transaction_id) DISABLE VALIDATE;
</pre>
<p>The creation of the constraint with <code class="codeph">ENABLE</code> clause would cause the creation of a unique index, which does not match a local index structure of the partitioned table. You must not have any index structure built on the nonpartitioned table to be exchanged for existing global indexes of the partitioned table. The exchange command would fail.</p>
</div>
</li>
<li class="stepexpand"><span>Add the <code class="codeph">sales_01_2001</code> table to the <code class="codeph">sales</code> table.</span>
<div>
<p>In order to add this new data to the <code class="codeph">sales</code> table, you must do two things. First, you must add a new partition to the <code class="codeph">sales</code> table. You use an <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ... <code class="codeph">ADD</code> <code class="codeph">PARTITION</code> statement. This adds an empty partition to the <code class="codeph">sales</code> table:</p>
<pre dir="ltr">ALTER TABLE sales ADD PARTITION sales_01_2001 
VALUES LESS THAN (TO_DATE(&#39;01-FEB-2001&#39;, &#39;DD-MON-YYYY&#39;));
</pre>
<p>Then, you can add our newly created table to this partition using the <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> operation. This exchanges the new, empty partition with the newly loaded table.</p>
<pre dir="ltr">ALTER TABLE sales EXCHANGE PARTITION sales_01_2001 WITH TABLE sales_01_2001 
INCLUDING INDEXES WITHOUT VALIDATION UPDATE GLOBAL INDEXES;
  
</pre>
<p>The <code class="codeph">EXCHANGE</code> operation preserves the indexes and constraints that were already present on the <code class="codeph">sales_01_2001</code> table. For unique constraints (such as the unique constraint on <code class="codeph">sales_transaction_id</code>), you can use the <code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code> clause, as shown previously. This automatically maintains your global index structures as part of the partition maintenance operation and keep them accessible throughout the whole process. If there were only foreign-key constraints, the exchange operation would be instantaneous.</p>
<p>Note that, if you use synchronous refresh, instead of performing Step 3, you must register the <code class="codeph">sales_01_2001</code> table using the <code class="codeph">DBMS_SYNC_REFRESH.REGISTER_PARTITION_OPERATION</code> package. See <a href="sync.htm#GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889">Synchronous Refresh</a> for more information.</p>
</div>
</li>
</ol>
<div class="section">
<p>The benefits of this partitioning technique are significant. First, the new data is loaded with minimal resource utilization. The new data is loaded into an entirely separate table, and the index processing and constraint processing are applied only to the new partition. If the <code class="codeph">sales</code> table was 50 GB and had 12 partitions, then a new month&#39;s worth of data contains approximately four GB. Only the new month&#39;s worth of data must be indexed. None of the indexes on the remaining 46 GB of data must be modified at all. This partitioning scheme additionally ensures that the load processing time is directly proportional to the amount of new data being loaded, not to the total size of the <code class="codeph">sales</code> table.</p>
<p>Second, the new data is loaded with minimal impact on concurrent queries. All of the operations associated with data loading are occurring on a separate <code class="codeph">sales_01_2001</code> table. Therefore, none of the existing data or indexes of the <code class="codeph">sales</code> table is affected during this data refresh process. The <code class="codeph">sales</code> table and its indexes remain entirely untouched throughout this refresh process.</p>
<p>Third, in case of the existence of any global indexes, those are incrementally maintained as part of the exchange command. This maintenance does not affect the availability of the existing global index structures.</p>
<p>The exchange operation can be viewed as a publishing mechanism. Until the data warehouse administrator exchanges the <code class="codeph">sales_01_2001</code> table into the <code class="codeph">sales</code> table, end users cannot see the new data. Once the exchange has occurred, then any end user query accessing the <code class="codeph">sales</code> table is immediately able to see the <code class="codeph">sales_01_2001</code> data.</p>
<p>Partitioning is useful not only for adding new data but also for removing and archiving data. Many data warehouses maintain a rolling window of data. For example, the data warehouse stores the most recent 36 months of <code class="codeph">sales</code> data. Just as a new partition can be added to the <code class="codeph">sales</code> table (as described earlier), an old partition can be quickly (and independently) removed from the <code class="codeph">sales</code> table. These two benefits (reduced resources utilization and minimal end-user impact) are just as pertinent to removing a partition as they are to adding a partition.</p>
<p>Removing data from a partitioned table does not necessarily mean that the old data is physically deleted from the database. There are two alternatives for removing old data from a partitioned table. First, you can physically delete all data from the database by dropping the partition containing the old data, thus freeing the allocated space:</p>
<pre dir="ltr">ALTER TABLE sales DROP PARTITION sales_01_1998;
</pre>
<p>Also, you can exchange the old partition with an empty table of the same structure; this empty table is created equivalent to steps 1 and 2 described in the load process. Assuming the new empty table stub is named <code class="codeph">sales_archive_01_1998</code>, the following SQL statement empties partition <code class="codeph">sales_01_1998</code>:</p>
<pre dir="ltr">ALTER TABLE sales EXCHANGE PARTITION sales_01_1998 
WITH TABLE sales_archive_01_1998 INCLUDING INDEXES WITHOUT VALIDATION 
UPDATE GLOBAL INDEXES;
</pre>
<p>Note that the old data is still existent as the exchanged, nonpartitioned table <code class="codeph">sales_archive_01_1998</code>.</p>
<p>If the partitioned table was setup in a way that every partition is stored in a separate tablespace, you can archive (or transport) this table using Oracle Database&#39;s transportable tablespace framework before dropping the actual data (the tablespace). See <span class="q">&#34;<a href="transport.htm#GUID-B3C1F5D9-21CD-41DB-BEC9-986016E6A5AA">Transportation Using Transportable Tablespaces</a>&#34;</span> for further details regarding transportable tablespaces.</p>
<p>In some situations, you might not want to drop the old data immediately, but keep it as part of the partitioned table; although the data is no longer of main interest, there are still potential queries accessing this old, read-only data. You can use Oracle&#39;s data compression to minimize the space usage of the old data. You also assume that at least one compressed partition is already part of the partitioned table.</p>
<div class="infoboxnotealso" id="GUID-4679957A-71E5-439E-BD8B-A0331F0631F2__GUID-EDDEEB4D-EFEE-4ED0-B5AD-F93F48D94293">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN13948" target="_blank" href="../ADMIN/tables.htm#ADMIN13948"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information regarding table compression</p>
</li>
<li>
<p><a class="olink VLDBG004" target="_blank" href="../VLDBG/GUID-FA29787B-8700-49EA-B80D-54D667CF2752.htm#VLDBG004"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information regarding partitioning and table compression</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="DWHSG8344"></a>
<div class="props_rev_3"><a id="GUID-19F3E938-9783-419F-8B70-DABEC4B40FAF"></a>
<h3 id="DWHSG-GUID-19F3E938-9783-419F-8B70-DABEC4B40FAF" class="sect3">Data Warehouse Refresh Scenarios</h3>
<div>
<div class="section">
<p>A typical scenario might not only need to compress old data, but also to merge several old partitions to reflect the granularity for a later backup of several merged partitions. Let us assume that a backup (partition) granularity is on a quarterly base for any quarter, where the oldest month is more than 36 months behind the most recent month. In this case, you are therefore compressing and merging <code class="codeph">sales_01_1998</code>, <code class="codeph">sales_02_1998</code>, and <code class="codeph">sales_03_1998</code> into a new, compressed partition <code class="codeph">sales_q1_1998</code>.</p>
<ol>
<li>
<p>Create the new merged partition in parallel in another tablespace. The partition is compressed as part of the <code class="codeph">MERGE</code> operation:</p>
<pre dir="ltr">ALTER TABLE sales MERGE PARTITIONS sales_01_1998, sales_02_1998, sales_03_1998
 INTO PARTITION sales_q1_1998 TABLESPACE archive_q1_1998 
COMPRESS UPDATE GLOBAL INDEXES PARALLEL 4;
</pre></li>
<li>
<p>The partition <code class="codeph">MERGE</code> operation invalidates the local indexes for the new merged partition. You therefore have to rebuild them:</p>
<pre dir="ltr">ALTER TABLE sales MODIFY PARTITION sales_q1_1998 
REBUILD UNUSABLE LOCAL INDEXES;
</pre></li>
</ol>
<p>Alternatively, you can choose to create the new compressed table outside the partitioned table and exchange it back. The performance and the temporary space consumption is identical for both methods:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create an intermediate table to hold the new merged information. The following statement inherits all <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints from the original table by default:</span>
<div>
<pre dir="ltr">CREATE TABLE sales_q1_1998_out TABLESPACE archive_q1_1998 
NOLOGGING COMPRESS PARALLEL 4 AS SELECT * FROM sales
WHERE time_id &gt;=  TO_DATE(&#39;01-JAN-1998&#39;,&#39;dd-mon-yyyy&#39;)
  AND time_id &lt; TO_DATE(&#39;01-APR-1998&#39;,&#39;dd-mon-yyyy&#39;);
</pre></div>
</li>
<li class="stepexpand"><span>Create the equivalent index structure for table <code class="codeph">sales_q1_1998_out</code> than for the existing table <code class="codeph">sales</code>.</span></li>
<li class="stepexpand"><span>Prepare the existing table sales for the exchange with the new compressed table <code class="codeph">sales_q1_1998_out</code>. Because the table to be exchanged contains data actually covered in three partitions, you have to create one matching partition, having the range boundaries you are looking for. You simply have to drop two of the existing partitions. Note that you have to drop the lower two partitions <code class="codeph">sales_01_1998</code> and <code class="codeph">sales_02_1998</code>; the lower boundary of a range partition is always defined by the upper (exclusive) boundary of the previous partition:</span>
<div>
<pre dir="ltr">ALTER TABLE sales DROP PARTITION sales_01_1998;
ALTER TABLE sales DROP PARTITION sales_02_1998;
 
</pre></div>
</li>
<li class="stepexpand"><span>You can now exchange table <code class="codeph">sales_q1_1998_out</code> with partition <code class="codeph">sales_03_1998</code>. Unlike what the name of the partition suggests, its boundaries cover Q1-1998.</span>
<div>
<pre dir="ltr">ALTER TABLE sales EXCHANGE PARTITION sales_03_1998 
WITH TABLE sales_q1_1998_out INCLUDING INDEXES WITHOUT VALIDATION 
UPDATE GLOBAL INDEXES;
</pre></div>
</li>
</ol>
<div class="section">
<p>Both methods apply to slightly different business scenarios: Using the <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code> approach invalidates the local index structures for the affected partition, but it keeps all data accessible all the time. Any attempt to access the affected partition through one of the unusable index structures raises an error. The limited availability time is approximately the time for re-creating the local bitmap index structures. In most cases, this can be neglected, because this part of the partitioned table should not be accessed too often.</p>
<p>The CTAS approach, however, minimizes unavailability of any index structures close to zero, but there is a specific time window, where the partitioned table does not have all the data, because you dropped two partitions. The limited availability time is approximately the time for exchanging the table. Depending on the existence and number of global indexes, this time window varies. Without any existing global indexes, this time window is a matter of a fraction to few seconds.</p>
<p>These examples are a simplification of the data warehouse rolling window load scenario. Real-world data warehouse refresh characteristics are always more complex. However, the advantages of this rolling window approach are not diminished in more complex scenarios.</p>
<p>Note that before you add single or multiple compressed partitions to a partitioned table for the first time, all local bitmap indexes must be either dropped or marked unusable. After the first compressed partition is added, no additional actions are necessary for all subsequent operations involving compressed partitions. It is irrelevant how the compressed partitions are added to the partitioned table.</p>
<div class="infoboxnotealso" id="GUID-19F3E938-9783-419F-8B70-DABEC4B40FAF__GUID-67814316-CFFC-431B-82C7-B21AA7E11768">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink VLDBG004" target="_blank" href="../VLDBG/GUID-FA29787B-8700-49EA-B80D-54D667CF2752.htm#VLDBG004"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information regarding partitioning and table compression</p>
</li>
<li>
<p><a class="olink ADMIN13948" target="_blank" href="../ADMIN/tables.htm#ADMIN13948"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for further details about partitioning and table compression.</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8345"></a>
<div class="props_rev_3"><a id="GUID-3D827265-D3BD-4BE4-BD5B-A2943AB5C0C7"></a>
<h3 id="DWHSG-GUID-3D827265-D3BD-4BE4-BD5B-A2943AB5C0C7" class="sect3">Scenarios for Using Partitioning for Refreshing Data Warehouses</h3>
<div>
<p>This section describes the following two typical scenarios where partitioning is used with refresh:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-5B57F621-2E5B-4B32-9B04-77FEAAB4F9BB">Partitioning for Refreshing Data Warehouses: Scenario 1</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4">Partitioning for Refreshing Data Warehouses: Scenario 2</a></p>
</li>
</ul>
</div>
<a id="DWHSG8346"></a>
<div class="props_rev_3"><a id="GUID-5B57F621-2E5B-4B32-9B04-77FEAAB4F9BB"></a>
<h4 id="DWHSG-GUID-5B57F621-2E5B-4B32-9B04-77FEAAB4F9BB" class="sect4">Partitioning for Refreshing Data Warehouses: Scenario 1</h4>
<div>
<div class="section">
<p>Data is loaded daily. However, the data warehouse contains two years of data, so that partitioning by day might not be desired.</p>
<p>The solution is to partition by week or month (as appropriate). Use <code class="codeph">INSERT</code> to add the new data to an existing partition. The <code class="codeph">INSERT</code> operation only affects a single partition, so the benefits described previously remain intact. The <code class="codeph">INSERT</code> operation could occur while the partition remains a part of the table. Inserts into a single partition can be parallelized:</p>
<pre dir="ltr">INSERT /*+ APPEND*/ INTO sales PARTITION (sales_01_2001) 
SELECT * FROM new_sales;
</pre>
<p>The indexes of this <code class="codeph">sales</code> partition is maintained in parallel as well. An alternative is to use the <code class="codeph">EXCHANGE</code> operation. You can do this by exchanging the <code class="codeph">sales_01_2001</code> partition of the <code class="codeph">sales</code> table and then using an <code class="codeph">INSERT</code> operation. You might prefer this technique when dropping and rebuilding indexes is more efficient than maintaining them.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8347"></a>
<div class="props_rev_3"><a id="GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4"></a>
<h4 id="DWHSG-GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4" class="sect4">Partitioning for Refreshing Data Warehouses: Scenario 2</h4>
<div>
<div class="section">
<p>New data feeds, although consisting primarily of data for the most recent day, week, and month, also contain some data from previous time periods.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Solution 1</p>
<p>Use parallel SQL operations (such as <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> ... <code class="codeph">AS</code> <code class="codeph">SELECT</code>) to separate the new data from the data in previous time periods. Process the old data separately using other techniques.</p>
<p>New data feeds are not solely time based. You can also feed new data into a data warehouse with data from multiple operational systems on a business need basis. For example, the sales data from direct channels may come into the data warehouse separately from the data from indirect channels. For business reasons, it may furthermore make sense to keep the direct and indirect data in separate partitions.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Solution 2</p>
<p>Oracle supports composite range-list partitioning. The primary partitioning strategy of the sales table could be range partitioning based on <code class="codeph">time_id</code> as shown in the example. However, the subpartitioning is a list based on the channel attribute. Each subpartition can now be loaded independently of each other (for each distinct channel) and added in a rolling window operation as discussed before. The partitioning strategy addresses the business needs in the most optimal manner.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<a id="DWHSG03002"></a>
<div class="props_rev_3"><a id="GUID-2F0765F5-DDDA-4667-9629-6834A805CB13"></a>
<h2 id="DWHSG-GUID-2F0765F5-DDDA-4667-9629-6834A805CB13" class="sect2">Optimizing DML Operations During Refresh</h2>
<div>
<p>You can optimize DML performance through the following techniques:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="refresh.htm#GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E">Implementing an Efficient MERGE Operation</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-2ABAAD60-8354-4302-9D7E-CB802001105E">Maintaining Referential Integrity in Data Warehouses</a></p>
</li>
<li>
<p><a href="refresh.htm#GUID-599B0FB2-2053-43BF-9887-CA0A96F2FBF9">Purging Data from Data Warehouses</a></p>
</li>
</ul>
</div>
<a id="DWHSG8351"></a><a id="DWHSG8352"></a><a id="DWHSG8353"></a><a id="DWHSG8354"></a><a id="DWHSG8355"></a><a id="DWHSG8356"></a><a id="DWHSG8357"></a><a id="DWHSG8350"></a>
<div class="props_rev_3"><a id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E"></a>
<h3 id="DWHSG-GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E" class="sect3">Implementing an Efficient MERGE Operation</h3>
<div>
<div class="section">
<p><a id="d26360e3681" class="indexterm-anchor"></a>Commonly, the data that is extracted from a source system is not simply a list of new records that needs to be inserted into the data warehouse. Instead, this new data set is a combination of new records as well as modified records. For example, suppose that most of data extracted from the OLTP systems will be new sales transactions. These records are inserted into the warehouse&#39;s <code class="codeph">sales</code> table, but some records may reflect modifications of previous transactions, such as returned merchandise or transactions that were incomplete or incorrect when initially loaded into the data warehouse. These records require updates to the <code class="codeph">sales</code> table.</p>
<p>As a typical scenario, suppose that there is a table called <code class="codeph">new_sales</code> that contains both inserts and updates that are applied to the <code class="codeph">sales</code> table. When designing the entire data warehouse load process, it was determined that the <code class="codeph">new_sales</code> table would contain records with the following semantics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>If a given <code class="codeph">sales_transaction_id</code> of a record in <code class="codeph">new_sales</code> already exists in <code class="codeph">sales</code>, then update the <code class="codeph">sales</code> table by adding the <code class="codeph">sales_dollar_amount</code> and <code class="codeph">sales_quantity_sold</code> values from the <code class="codeph">new_sales</code> table to the existing row in the <code class="codeph">sales</code> table.</p>
</li>
<li>
<p>Otherwise, insert the entire new record from the <code class="codeph">new_sales</code> table into the <code class="codeph">sales</code> table.</p>
</li>
</ul>
<p>This <code class="codeph">UPDATE-ELSE-INSERT</code> operation is often called a merge. A merge can be executed using one SQL statement.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-877052F7-6E9A-4884-8180-B57CA21B40BA">
<p class="titleinexample">Example 7-5 MERGE Operation</p>
<pre dir="ltr">MERGE INTO sales s USING new_sales n
ON (s.sales_transaction_id = n.sales_transaction_id)
WHEN MATCHED THEN
UPDATE SET s.sales_quantity_sold = s.sales_quantity_sold + n.sales_quantity_sold,
 s.sales_dollar_amount = s.sales_dollar_amount + n.sales_dollar_amount
WHEN NOT MATCHED THEN INSERT (sales_transaction_id, sales_quantity_sold, 
sales_dollar_amount)
VALUES (n.sales_transcation_id, n.sales_quantity_sold, n.sales_dollar_amount);
</pre>
<p>In addition to using the <code class="codeph">MERGE</code> statement for unconditional <code class="codeph">UPDATE</code> <code class="codeph">ELSE</code> <code class="codeph">INSERT</code> functionality into a target table, you can also use it to:</p>
<ul style="list-style-type: disc;">
<li>
<p>Perform an <code class="codeph">UPDATE</code> only or <code class="codeph">INSERT</code> only statement.</p>
</li>
<li>
<p>Apply additional <code class="codeph">WHERE</code> conditions for the <code class="codeph">UPDATE</code> or <code class="codeph">INSERT</code> portion of the <code class="codeph">MERGE</code> statement.</p>
</li>
<li>
<p>The <code class="codeph">UPDATE</code> operation can even delete rows if a specific condition yields true.</p>
</li>
</ul>
</div>
<!-- class="example" -->
<div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-48F4E58F-DE47-4522-A994-6E9F5E8C33A0">
<p class="titleinexample">Example 7-6 Omitting the INSERT Clause</p>
<p>In some data warehouse applications, it is not allowed to add new rows to historical information, but only to update them. It may also happen that you do not want to update but only insert new information. The following example demonstrates <code class="codeph">INSERT</code>-only with <code class="codeph">UPDATE</code>-only functionality:</p>
<pre dir="ltr">MERGE USING Product_Changes S     -- Source/Delta table
INTO Products D1                  -- Destination table 1
ON (D1.PROD_ID = S.PROD_ID)       -- Search/Join condition
WHEN MATCHED THEN UPDATE          -- update if join
SET D1.PROD_STATUS = S.PROD_NEW_STATUS
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-EF74A6A4-74DB-4337-B784-E84B3797DE4B">
<p class="titleinexample">Example 7-7 Omitting the UPDATE Clause</p>
<p>The following statement illustrates an example of omitting an <code class="codeph">UPDATE</code>:</p>
<pre dir="ltr">MERGE USING New_Product S           -- Source/Delta table
INTO Products D2                    -- Destination table 2
ON (D2.PROD_ID = S.PROD_ID)         -- Search/Join condition
WHEN NOT MATCHED THEN               -- insert if no join
INSERT (PROD_ID, PROD_STATUS) VALUES (S.PROD_ID, S.PROD_NEW_STATUS)
</pre>
<p>When the <code class="codeph">INSERT</code> clause is omitted, Oracle Database performs a regular join of the source and the target tables. When the <code class="codeph">UPDATE</code> clause is omitted, Oracle Database performs an antijoin of the source and the target tables. This makes the join between the source and target table more efficient.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-AD1164D9-1C1B-4714-9140-F00656530AEF">
<p class="titleinexample">Example 7-8 Skipping the UPDATE Clause</p>
<p>In some situations, you may want to skip the <code class="codeph">UPDATE</code> operation when merging a given row into the table. In this case, you can use an optional <code class="codeph">WHERE</code> clause in the <code class="codeph">UPDATE</code> clause of the <code class="codeph">MERGE</code>. As a result, the <code class="codeph">UPDATE</code> operation only executes when a given condition is true. The following statement illustrates an example of skipping the <code class="codeph">UPDATE</code> operation:</p>
<pre dir="ltr">MERGE 
USING Product_Changes S                      -- Source/Delta table 
INTO Products P                              -- Destination table 1 
ON (P.PROD_ID = S.PROD_ID)                   -- Search/Join condition 
WHEN MATCHED THEN 
UPDATE                                       -- update if join 
SET P.PROD_LIST_PRICE = S.PROD_NEW_PRICE 
WHERE P.PROD_STATUS &lt;&gt; &#34;OBSOLETE&#34;            -- Conditional UPDATE
</pre>
<p>This shows how the <code class="codeph">UPDATE</code> operation would be skipped if the condition <code class="codeph">P.PROD_STATUS &lt;&gt; &#34;OBSOLETE&#34;</code> is not true. The condition predicate can refer to both the target and the source table.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-5D5F8EC6-E080-41AB-BD5A-F22FCFDFCA80">
<p class="titleinexample">Example 7-9 Conditional Inserts with MERGE Statements</p>
<p>You may want to skip the <code class="codeph">INSERT</code> operation when merging a given row into the table. So an optional <code class="codeph">WHERE</code> clause is added to the <code class="codeph">INSERT</code> clause of the <code class="codeph">MERGE</code>. As a result, the <code class="codeph">INSERT</code> operation only executes when a given condition is true. The following statement offers an example:</p>
<pre dir="ltr">MERGE USING Product_Changes S                      -- Source/Delta table
INTO Products P                                    -- Destination table 1
ON (P.PROD_ID = S.PROD_ID)                         -- Search/Join condition
WHEN MATCHED THEN UPDATE                           -- update if join
SET P.PROD_LIST_PRICE = S.PROD_NEW_PRICE
WHERE P.PROD_STATUS &lt;&gt; &#34;OBSOLETE&#34;                  -- Conditional
WHEN NOT MATCHED THEN
INSERT (PROD_ID, PROD_STATUS, PROD_LIST_PRICE)     -- insert if not join
VALUES (S.PROD_ID, S.PROD_NEW_STATUS, S.PROD_NEW_PRICE)
WHERE S.PROD_STATUS &lt;&gt; &#34;OBSOLETE&#34;;                 -- Conditional INSERT
</pre>
<p>This example shows that the <code class="codeph">INSERT</code> operation would be skipped if the condition <code class="codeph">S.PROD_STATUS &lt;&gt; &#34;OBSOLETE&#34;</code> is not true, and <code class="codeph">INSERT</code> only occurs if the condition is true. The condition predicate can refer to the source table only. The condition predicate can only refer to the source table.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-E1672702-D63D-4C6F-93BE-BD73C531371D">
<p class="titleinexample">Example 7-10 Using the DELETE Clause with MERGE Statements</p>
<p>You may want to cleanse tables while populating or updating them. To do this, you may want to consider using the <code class="codeph">DELETE</code> clause in a <code class="codeph">MERGE</code> statement, as in the following example:</p>
<pre dir="ltr">MERGE USING Product_Changes S
INTO Products D ON (D.PROD_ID = S.PROD_ID)
WHEN MATCHED THEN
UPDATE SET D.PROD_LIST_PRICE =S.PROD_NEW_PRICE, D.PROD_STATUS = S.PROD_NEWSTATUS
DELETE WHERE (D.PROD_STATUS = &#34;OBSOLETE&#34;)
WHEN NOT MATCHED THEN
INSERT (PROD_ID, PROD_LIST_PRICE, PROD_STATUS)
VALUES (S.PROD_ID, S.PROD_NEW_PRICE, S.PROD_NEW_STATUS);
</pre>
<p>Thus when a row is updated in <code class="codeph">products</code>, Oracle checks the delete condition <code class="codeph">D.PROD_STATUS = &#34;OBSOLETE&#34;</code>, and deletes the row if the condition yields true.</p>
<p>The <code class="codeph">DELETE</code> operation is not as same as that of a complete <code class="codeph">DELETE</code> statement. Only the rows from the destination of the <code class="codeph">MERGE</code> can be deleted. The only rows that are affected by the <code class="codeph">DELETE</code> are the ones that are updated by this <code class="codeph">MERGE</code> statement. Thus, although a given row of the destination table meets the delete condition, if it does not join under the <code class="codeph">ON</code> clause condition, it is not deleted.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-22086C31-067A-4352-B21B-B28B55F628CC">
<p class="titleinexample">Example 7-11 Unconditional Inserts with MERGE Statements</p>
<p>You may want to insert all of the source rows into a table. In this case, the join between the source and target table can be avoided. By identifying special constant join conditions that always result to <code class="codeph">FALSE</code>, for example, 1=0, such <code class="codeph">MERGE</code> statements are optimized and the join condition are suppressed.</p>
<pre dir="ltr">MERGE USING New_Product S       -- Source/Delta table 
INTO Products P                 -- Destination table 1 
ON (1 = 0)                      -- Search/Join condition 
WHEN NOT MATCHED THEN           -- insert if no join 
INSERT (PROD_ID, PROD_STATUS) VALUES (S.PROD_ID, S.PROD_NEW_STATUS)
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8358"></a>
<div class="props_rev_3"><a id="GUID-2ABAAD60-8354-4302-9D7E-CB802001105E"></a>
<h3 id="DWHSG-GUID-2ABAAD60-8354-4302-9D7E-CB802001105E" class="sect3">Maintaining Referential Integrity in Data Warehouses</h3>
<div>
<div class="section">
<p>In some data warehousing environments, you might want to insert new data into tables in order to guarantee referential integrity. For example, a data warehouse may derive <code class="codeph">sales</code> from an operational system that retrieves data directly from cash registers. <code class="codeph">sales</code> is refreshed nightly. However, the data for the <code class="codeph">product</code> dimension table may be derived from a separate operational system. The <code class="codeph">product</code> dimension table may only be refreshed once for each week, because the <code class="codeph">product</code> table changes relatively slowly. If a new product was introduced on Monday, then it is possible for that product&#39;s <code class="codeph">product_id</code> to appear in the <code class="codeph">sales</code> data of the data warehouse before that <code class="codeph">product_id</code> has been inserted into the data warehouses <code class="codeph">product</code> table.</p>
<p>Although the sales transactions of the new product may be valid, this sales data do not satisfy the referential integrity constraint between the <code class="codeph">product</code> dimension table and the <code class="codeph">sales</code> fact table. Rather than disallow the new sales transactions, you might choose to insert the sales transactions into the <code class="codeph">sales</code> table. However, you might also wish to maintain the referential integrity relationship between the <code class="codeph">sales</code> and <code class="codeph">product</code> tables. This can be accomplished by inserting new rows into the <code class="codeph">product</code> table as placeholders for the unknown products.</p>
<p>As in previous examples, assume that the new data for the <code class="codeph">sales</code> table is staged in a separate table, <code class="codeph">new_sales</code>. Using a single <code class="codeph">INSERT</code> statement (which can be parallelized), the <code class="codeph">product</code> table can be altered to reflect the new products:</p>
<pre dir="ltr">INSERT INTO product
  (SELECT sales_product_id, &#39;Unknown Product Name&#39;, NULL, NULL ...
   FROM new_sales WHERE sales_product_id NOT IN
  (SELECT product_id FROM product));
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8359"></a>
<div class="props_rev_3"><a id="GUID-599B0FB2-2053-43BF-9887-CA0A96F2FBF9"></a>
<h3 id="DWHSG-GUID-599B0FB2-2053-43BF-9887-CA0A96F2FBF9" class="sect3">Purging Data from Data Warehouses</h3>
<div>
<div class="section">
<p><a id="d26360e4059" class="indexterm-anchor"></a><a id="d26360e4061" class="indexterm-anchor"></a>Occasionally, it is necessary<a id="d26360e4066" class="indexterm-anchor"></a> to remove large amounts of data from a data warehouse. A very common scenario is the rolling window discussed previously, in which older data is rolled out of the data warehouse to make room for new data.</p>
<p>However, sometimes other data might need to be removed from a data warehouse. Suppose that a retail company has previously sold products from <code class="codeph">XYZ</code> <code class="codeph">Software</code>, and that <code class="codeph">XYZ</code> <code class="codeph">Software</code> has subsequently gone out of business. The business users of the warehouse may decide that they are no longer interested in seeing any data related to <code class="codeph">XYZ</code> <code class="codeph">Software</code>, so this data should be deleted.</p>
<p>One approach to removing a large volume of data is to use parallel delete as shown in the following statement:</p>
<pre dir="ltr">DELETE FROM sales WHERE sales_product_id IN (SELECT product_id 
   FROM product WHERE product_category = &#39;XYZ Software&#39;);
</pre>
<p>This SQL statement spawns one parallel process for each partition. This approach is much more efficient than a series of <code class="codeph">DELETE</code> statements, and none of the data in the <code class="codeph">sales</code> table needs to be moved. However, this approach also has some disadvantages. When removing a large percentage of rows, the <code class="codeph">DELETE</code> statement leaves many empty row-slots in the existing partitions. If new data is being loaded using a rolling window technique (or is being loaded using direct-path <code class="codeph">INSERT</code> or load), then this storage space is not reclaimed. Moreover, even though the <code class="codeph">DELETE</code> statement is parallelized, there might be more efficient methods. An alternative method is to re-create the entire <code class="codeph">sales</code> table, keeping the data for all product categories except <code class="codeph">XYZ</code> <code class="codeph">Software</code>.</p>
<pre dir="ltr">CREATE TABLE sales2 AS SELECT * FROM sales, product
WHERE sales.sales_product_id = product.product_id 
AND product_category &lt;&gt; &#39;XYZ Software&#39;
NOLOGGING PARALLEL (DEGREE 8)
#PARTITION ... ; #create indexes, constraints, and so on
DROP TABLE SALES;
RENAME SALES2 TO SALES;
</pre>
<p>This approach may be more efficient than a parallel delete. However, it is also costly in terms of the amount of disk space, because the <code class="codeph">sales</code> table must effectively be instantiated twice.</p>
<p>An alternative method to utilize less space is to re-create the <code class="codeph">sales</code> table one partition at a time:</p>
<pre dir="ltr">CREATE TABLE sales_temp AS SELECT * FROM sales WHERE 1=0;
INSERT INTO sales_temp
SELECT * FROM sales PARTITION (sales_99jan), product
WHERE sales.sales_product_id = product.product_id
AND product_category &lt;&gt; &#39;XYZ Software&#39;;
&lt;create appropriate indexes and constraints on sales_temp&gt;
ALTER TABLE sales EXCHANGE PARTITION sales_99jan WITH TABLE sales_temp;
</pre>
<p>Continue this process for each partition in the <code class="codeph">sales</code> table.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1506">
<tr>
<td class="cellalignment1513">
<table class="cellalignment1511">
<tr>
<td class="cellalignment1510"><a href="advmv.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1510"><a href="sync.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1515">
<table class="cellalignment1509">
<tr>
<td class="cellalignment1510"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1510"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1510"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1510"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1510"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1510"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>