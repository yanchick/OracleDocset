<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-6020"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Data%20Warehousing%20Logical%20Design"></a><title>Data Warehousing Logical Design</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="Third Normal Form, 3NF, schemas, In-Memory Column Store, using, using, vector joins, VECOTR GROUP BY aggregation, scenarios"/>
<meta name="dcterms.created" content="2017-06-07T18:07:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Warehousing Guide"/>
<meta name="dcterms.identifier" content="E41670-11"/>
<meta name="dcterms.isVersionOf" content="DWHSG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="concept.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch3physdes.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41670-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3"></a> <span id="PAGE" style="display:none;">7/32</span> <!-- End Header -->
<h1 id="DWHSG-GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3" class="sect1"><span class="enumeration_chapter">2</span> Data Warehousing Logical Design</h1>
<div>
<p>This chapter <a id="d6646e19" class="indexterm-anchor"></a><a id="d6646e23" class="indexterm-anchor"></a>explains how to create a logical design for a data warehousing environment and includes the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ch2logdes.htm#GUID-48D381BE-15FD-4C92-B486-6071BEBD7801">Logical Versus Physical Design in Data Warehouses</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C">Creating a Logical Design</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822">About Third Normal Form Schemas</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF">About Star Schemas</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997">About the Oracle In-Memory Column Store</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-BD54F705-627B-4460-AB83-AFA992D8798C">Automatic Big Table Caching to Improve the Performance of In-Memory Parallel Queries</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-C0C57677-E420-432C-9E1F-271011F0C775">About In-Memory Aggregation</a></p>
</li>
</ul>
</div>
<a id="DWHSG9226"></a>
<div class="props_rev_3"><a id="GUID-48D381BE-15FD-4C92-B486-6071BEBD7801"></a>
<h2 id="DWHSG-GUID-48D381BE-15FD-4C92-B486-6071BEBD7801" class="sect2">Logical Versus Physical Design in Data Warehouses</h2>
<div>
<p>Your organization has decided to build an enterprise data warehouse. You have defined the business requirements and agreed upon the scope of your business goals, and created a conceptual design. Now you need to translate your requirements into a system deliverable. To do so, you create the logical and physical design for the data warehouse. You then define:</p>
<ul style="list-style-type: disc;">
<li>
<p>The specific data content</p>
</li>
<li>
<p>Relationships within and between groups of data</p>
</li>
<li>
<p>The system environment supporting your data warehouse</p>
</li>
<li>
<p>The data transformations required</p>
</li>
<li>
<p>The frequency with which data is refreshed</p>
</li>
</ul>
<p>The logical design is more conceptual and abstract than the physical design. In the logical design, you look at the logical relationships among the objects. In the physical design, you look at the most effective way of storing and retrieving the objects as well as handling them from a transportation and backup/recovery perspective.</p>
<p>Orient your design toward the needs of the end users. End users typically want to perform analysis and look at aggregated data, rather than at individual transactions. However, end users might not know what they need until they see it. In addition, a well-planned design allows for growth and changes as the needs of users change and evolve.</p>
<p>By beginning with the logical design, you focus on the information requirements and save the implementation details for later.</p>
</div>
</div>
<a id="DWHSG9227"></a>
<div class="props_rev_3"><a id="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C"></a>
<h2 id="DWHSG-GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C" class="sect2">Creating a Logical Design</h2>
<div>
<p>A logical design is conceptual and abstract. You do not deal with the physical implementation details yet. You deal only with defining the types of information that you need.</p>
<p>One technique you can use to model your organization&#39;s logical information requirements is entity-relationship modeling. Entity-relationship modeling involves identifying the things of importance (entities), the properties of these things (attributes), and how they are related to one another (relationships).</p>
<p>The process of logical design involves arranging data into a series of logical relationships called entities and attributes. <a id="d6646e134" class="indexterm-anchor"></a>An entity represents a chunk of information. In relational databases, an entity often maps to a table. <a id="d6646e137" class="indexterm-anchor"></a>An attribute is a component of an entity that helps define the uniqueness of the entity. In relational databases, an attribute maps to a column.</p>
<p>To ensure that your data is consistent, you must use unique<a id="d6646e142" class="indexterm-anchor"></a> identifiers. A unique identifier is something you add to tables so that you can differentiate between the same item when it appears in different places. In a physical design, this is usually a primary key.</p>
<p>Entity-relationship modeling is purely logical and applies to both OLTP and data warehousing systems. It is also applicable to the various common physical schema modeling techniques found in data warehousing environments, namely normalized (3NF) schemas in Enterprise Data Warehousing environments, star or snowflake schemas in data marts, or hybrid schemas with components of both of these classical modeling techniques.</p>
<div class="infoboxnotealso" id="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C__GUID-CE0A1E37-859E-4388-8B99-887DD4ED3237">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ODIDG" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ODIDG"><span class="italic">Oracle Fusion Middleware Developer&#39;s Guide for Oracle Data Integrator</span></a> for more details regarding ODI</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG9290"></a>
<div class="props_rev_3"><a id="GUID-3507EE0E-F92E-4781-8341-549791A3EE7D"></a>
<h3 id="DWHSG-GUID-3507EE0E-F92E-4781-8341-549791A3EE7D" class="sect3">What is a Schema?</h3>
<div>
<p>A schema<a id="d6646e180" class="indexterm-anchor"></a><a id="d6646e184" class="indexterm-anchor"></a> is a collection of database objects, including tables, views, indexes, and synonyms. You can arrange schema objects in the schema models designed for data warehousing in a variety of ways. Most data warehouses use a dimensional model.</p>
<p>The model of your source data and the requirements of your users help you design the data warehouse schema. You can sometimes get the source model from your company&#39;s enterprise data model and reverse-engineer the logical data model for the data warehouse from this. The physical implementation of the logical data warehouse model may require some changes to adapt it to your system parameters&mdash;size of computer, number of users, storage capacity, type of network, and software. A key part of designing the schema is whether to use a third normal form, star, or snowflake schema, and these are discussed later.</p>
</div>
</div>
</div>
<a id="DWHSG9230"></a><a id="DWHSG9229"></a>
<div class="props_rev_3"><a id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822"></a>
<h2 id="DWHSG-GUID-FD474327-4F5C-4D7E-AC7B-91739F229822" class="sect2">About Third Normal Form Schemas</h2>
<div>
<p>Third Normal Form design seeks to minimize data redundancy and avoid anomalies in data insertion, updates and deletion. 3NF design has a long heritage in online transaction processing (OLTP) systems. OLTP systems must maximize performance and accuracy when inserting, updating and deleting data. Transactions must be handled as quickly as possible or the business may be unable to handle the flow of events, perhaps losing sales or incurring other costs. Therefore, 3NF designs avoid redundant data manipulation and minimize table locks, both of which can slow inserts, updates and deletes. 3NF designs also works well to abstract the data from specific application needs. If new types of data are added to the environment, you can extend the data model with relative ease and minimal impact to existing applications. Likewise, if you have completely new types of analyses to perform in your data warehouse, a well-designed 3NF schema will be able to handle them without requiring redesigned data structures.</p>
<p>3NF designs have great flexibility, but it comes at a cost. 3NF databases use very many tables and this requires complex queries with many joins. For full scale enterprise models built in 3NF form, over one thousand tables are commonly encountered in the schema. With the kinds of queries involved in data warehousing, which will often need access to many rows from many tables, this design imposes understanding and performance penalties. It can be complex for query builders, whether they are humans or business intelligence tools and applications, to choose and join the tables needed for a given piece of data when there are very large numbers of tables available. Even when the tables are readily chosen by the query generator, the 3NF schema often requires that a large number of tables be used in a single query. More tables in a query mean more potential data access paths, which makes the database query optimizer&#39;s job harder. The end result can be slow query performance.</p>
<p>The issue of slow query performance in a 3NF system is not necessarily limited to the core queries used to create reports and analyses. It can also show up in the simpler task of users browsing subsets of data to understand the contents. Similarly, the complexity of a 3NF schema may impact generating the pick-lists of data used to constrain queries and reports. Although these may seem relatively minor issues, speedy response time for such processes makes a big impact on user satisfaction.</p>
<p><a href="ch2logdes.htm#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__BABIFDDG">Figure 2-1</a> presents a tiny fragment of a 3NF Schema. Note how order information is broken into order and order items to avoid redundant data storage. The &#34;crow&#39;s feet&#34; markings on the relationship between tables indicate one-to-many relationships among the entities. Thus, one order may have multiple order items, a single customer may have many orders, and a single product may be found in many order items. Although this diagram shows a very small case, you can see that minimizing data redundancy can lead to many tables in the schema.</p>
<div class="figure" id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__BABIFDDG">
<p class="titleinfigure">Figure 2-1 Fragment of a Third Normal Form Schema</p>
<img width="326" height="135" src="img/GUID-F610C76D-BB65-4330-AB17-26F38E9338C8-default.gif" alt="Description of Figure 2-1 follows" title="Description of Figure 2-1 follows"/><br/>
<a href="img_text/GUID-F610C76D-BB65-4330-AB17-26F38E9338C8-print.htm">Description of &#34;Figure 2-1 Fragment of a Third Normal Form Schema&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__GUID-B3F28A2E-2AB2-48B8-9338-948A9A223EE9">
<p class="notep1">See Also:</p>
<p><a href="ch2logdes.htm#GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578">Design Concepts for 3NF Schemas</a></p>
</div>
</div>
<a id="DWHSG9231"></a>
<div class="props_rev_3"><a id="GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80"></a>
<h3 id="DWHSG-GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80" class="sect3">About Normalization</h3>
<div>
<p>Normalization is a data design process that has a high level goal of keeping each fact in just one place to avoid data redundancy and insert, update, and delete anomalies. There are multiple levels of normalization, and this section describes the first three of them. Considering how fundamental the term third normal form (3NF) term is, it only makes sense to see how 3NF is reached.</p>
<p>Consider a situation where you are tracking sales. The core entity you track is sales orders, where each sales order contains details about each item purchased (referred to as a line item): its name, price, quantity, and so on. The order also holds the name and address of the customer and more. Some orders have many different line items, and some orders have just one.</p>
<p>In first normal form (1NF), there are no repeating groups of data and no duplicate rows. Every intersection of a row and column (a field) contains just one value, and there are no groups of columns that contain the same facts. To avoid duplicate rows, there is a primary key. For sales orders, in first normal form, multiple line items of each sales order in a single field of the table are not displayed. Also, there will not be multiple columns showing line items.</p>
<p>Then comes second normal form (2NF), where the design is in first normal form and every non-key column is dependent on the complete primary key. Thus, the line items are broken out into a table of sales order line items where each row represents one line item of one order. You can look at the line item table and see that the names of the items sold are not dependent on the primary key of the line items table: the sales item is its own entity. Therefore, you move the sales item to its own table showing the item name. Prices charged for each item can vary by order (for instance, due to discounts) so these remain in the line items table. In the case of sales order, the name and address of the customer is not dependent on the primary key of the sales order: customer is its own entity. Thus, you move the customer name and address columns out into their own table of customer information.</p>
<p>Next is third normal form, where the goal is to ensure that there are no dependencies on non-key attributes. So the goal is to take columns that do not directly relate to the subject of the row (the primary key), and put them in their own table. So details about customers, such as customer name or customer city, should be put in a separate table, and then a customer foreign key added into the orders table.</p>
<p>Another example of how a 2NF table differs from a 3NF table would be a table of the winners of tennis tournaments that contained columns of tournament, year, winner, and winner&#39;s date of birth. In this case, the winner&#39;s date of birth is vulnerable to inconsistencies, as the same person could be shown with different dates of birth in different records. The way to avoid this potential problem is to break the table into one for tournament winners, and another for the player dates of birth.</p>
</div>
</div>
<a id="DWHSG9311"></a>
<div class="props_rev_3"><a id="GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578"></a>
<h3 id="DWHSG-GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578" class="sect3">Design Concepts for 3NF Schemas</h3>
<div>
<p>The following section discusses some basic concepts when modeling for a data warehousing environment using a 3NF schema approach. The intent is not to discuss the theoretical foundation for 3NF modeling (or even higher levels of normalization), but to highlight some key components relevant for data warehousing.</p>
<p>Some key 3NF schema design concepts that are relevant to data warehousing are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ch2logdes.htm#GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2">Identifying Candidate Primary Keys</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-AD7D5938-1B52-44A6-815E-D73834303871">Foreign Key Relationships and Referential Integrity Constraints</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-75BD1411-C19C-436B-8FB9-47F3708272D9">Denormalization</a></p>
</li>
</ul>
</div>
<a id="DWHSG9312"></a>
<div class="props_rev_3"><a id="GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2"></a>
<h4 id="DWHSG-GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2" class="sect4">Identifying Candidate Primary Keys</h4>
<div>
<p>A primary key is an attribute that uniquely identifies a specific record in a table. Primary keys can be identified through single or multiple columns. It is normally preferred to achieve unique identification through as little columns as possible - ideally one or two - and to either use a column that is most likely not going to be updated or even changed in bulk. If your data model does not lead to a simple unique identification through its attributes, you would require too many attributes to uniquely identify a single records, or the data is prone to changes, the usage of a surrogate key is highly recommended.</p>
<p>Specifically, 3NF schemas rely on proper and simple unique identification since queries tend to have many table joins and all columns necessary to uniquely identify a record are needed as join condition to avoid row duplication through the join.</p>
</div>
</div>
<a id="DWHSG9313"></a>
<div class="props_rev_3"><a id="GUID-AD7D5938-1B52-44A6-815E-D73834303871"></a>
<h4 id="DWHSG-GUID-AD7D5938-1B52-44A6-815E-D73834303871" class="sect4">Foreign Key Relationships and Referential Integrity Constraints</h4>
<div>
<p>3NF schemas in data warehousing environments often resemble the data model of its OLTP source systems, in which the logical consistency between data entities is expressed and enforced through primary key - foreign key relationships, also known as parent-child relationship. A foreign key resolves a 1-to-many relationship in relational system and ensures logical consistency: for example, you cannot have an order line item without an order header, or an employee working for a non-existent department.</p>
<p>While such referential are always enforced in OLTP system, data warehousing systems often implement them as declarative, non-enforced conditions, relying on the ETL process to ensure data consistency. Whenever possible, foreign keys and referential integrity constraints should be defined as non-enforced conditions, since it enables better query optimization and cardinality estimates.</p>
</div>
</div>
<a id="DWHSG9314"></a>
<div class="props_rev_3"><a id="GUID-75BD1411-C19C-436B-8FB9-47F3708272D9"></a>
<h4 id="DWHSG-GUID-75BD1411-C19C-436B-8FB9-47F3708272D9" class="sect4">Denormalization</h4>
<div>
<p>Proper normalized modelling tends to decompose logical entities - such as a customer. a product, or an order - into many physical tables, making even the retrieval of perceived simple information requiring to join many tables. While this is not a problem from a query processing perspective, it can put some unnecessary burden on both the application developer (for writing code) as well as the database (for joining information that is always used together). It is not uncommon to see some sensible level of denormalization in 3NF data warehousing models, in a logical form as views or in a physical form through slightly denormalized tables.</p>
<p>Care has to be taken with the physical denormalization to preserve the subject-neutral shape and therefore the flexibility of the physical implementation of the 3NF schema.</p>
</div>
</div>
</div>
</div>
<a id="DWHSG9233"></a>
<div class="props_rev_3"><a id="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF"></a>
<h2 id="DWHSG-GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF" class="sect2">About Star Schemas</h2>
<div>
<p>Star schemas are often found in data warehousing systems with embedded logical or physical data marts. The term star schema is another way of referring to a &#34;dimensional modeling&#34; approach to defining your data model. Most descriptions of dimensional modeling use terminology drawn from the work of Ralph Kimball, the pioneering consultant and writer in this field. Dimensional modeling creates multiple star schemas, each based on a business process such as sales tracking or shipments. Each star schema can be considered a data mart, and perhaps as few as 20 data marts can cover the business intelligence needs of an enterprise. Compared to 3NF designs, the number of tables involved in dimensional modeling is a tiny fraction. Many star schemas will have under a dozen tables. The star schemas are knit together through conformed dimensions and conformed facts. Thus, users are able to get data from multiple star schemas with minimal effort.</p>
<p>The goal for star schemas is structural simplicity and high performance data retrieval. Because most queries in the modern era are generated by reporting tools and applications, it&#39;s vital to make the query generation convenient and reliable for the tools and application. In fact, many business intelligence tools and applications are designed with the expectation that a star schema representation will be available to them.</p>
<p>Discussions of star schemas are less abstracted from the physical database than 3NF descriptions. This is due to the pragmatic emphasis of dimensional modeling on the needs of business intelligence users.</p>
<p>Note how different the dimensional modeling style is from the 3NF approach that minimizes data redundancy and the risks of update/inset/delete anomalies. The star schema accepts data redundancy (denormalization) in its dimension tables for the sake of easy user understanding and better data retrieval performance. A common criticism of star schemas is that they limit analysis flexibility compared to 3NF designs. However, a well designed dimensional model can be extended to enable new types of analysis, and star schemas have been successful for many years at the largest enterprises.</p>
<p>As noted earlier, the modern approach to data warehousing does not pit star schemas and 3NF against each other. Rather, both techniques are used, with a foundation layer of 3NF - the Enterprise Data Warehouse of 3NF, acting as the bedrock data, and star schemas as a central part of an access and performance optimization layer.</p>
<div class="section">
<div class="infoboxnotealso" id="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF__GUID-D40EA285-8F0E-4476-82F8-E1B2CE618747">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ch2logdes.htm#GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F">About Facts and Dimensions in Star Schemas</a></p>
</li>
<li><a href="ch2logdes.htm#GUID-787CD3B1-0131-47F4-A904-4F7221A29448">Design Concepts in Star Schemas</a></li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="DWHSG9235"></a><a id="DWHSG9234"></a>
<div class="props_rev_3"><a id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F"></a>
<h3 id="DWHSG-GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F" class="sect3">About Facts and Dimensions in Star Schemas</h3>
<div>
<p>Star schemas divide data into facts and dimensions. Facts are the measurements of some event such as a sale and are typically numbers. Dimensions are the categories you use to identify facts, such as date, location, and product.</p>
<p>The name &#34;star schema&#34; comes from the fact that the diagrams of the schemas typically show a<a id="d6646e448" class="indexterm-anchor"></a> central fact table with lines joining it to the dimension tables, so the graphic impression is similar to a star. <a href="ch2logdes.htm#GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__BABEBJEF">Figure 2-2</a> is a simple example with sales as the fact table and products, times, customers, and channels as the dimension table.</p>
<div class="figure" id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__BABEBJEF">
<p class="titleinfigure">Figure 2-2 Star Schema</p>
<img width="377" height="178" src="img/GUID-9765F3F2-B121-473E-91DF-388F40A56E14-default.gif" alt="Description of Figure 2-2 follows" title="Description of Figure 2-2 follows"/><br/>
<a href="img_text/GUID-9765F3F2-B121-473E-91DF-388F40A56E14-print.htm">Description of &#34;Figure 2-2 Star Schema&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__GUID-F5436257-7D99-45BF-9ECE-7F2640293B25">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ch2logdes.htm#GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE">About Fact Tables in Data Warehouses</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1">About Dimension Tables in Data Warehouses</a></p>
</li>
</ul>
</div>
</div>
<a id="DWHSG9236"></a>
<div class="props_rev_3"><a id="GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE"></a>
<h4 id="DWHSG-GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE" class="sect4">About Fact Tables in Data Warehouses</h4>
<div>
<p>Fact tables have measurement data. They have many rows but typically not many columns. Fact tables for a large enterprise can easily hold billions of rows. For many star schemas, the fact table will represent well over 90 percent of the total storage space. A fact table has a composite key made up of the primary keys of the dimension tables of the schema.</p>
<p>A fact table contains either detail-level facts or facts that have been aggregated. Fact tables that contain aggregated facts are often called summary tables. A fact table usually contains facts with the same level of aggregation. Though most facts are additive, they can also be semi-additive or non-additive. Additive facts can be aggregated by simple arithmetical addition. A common example of this is sales. Non-additive facts cannot be added at all. An example of this is averages. Semi-additive facts can be aggregated along some of the dimensions and not along others. An example of this is inventory levels stored in physical warehouses, where you may be able to add across a dimension of warehouse sites, but you cannot aggregate across time.</p>
<p>In terms of adding rows to data in a fact table, there are three main approaches:</p>
<ul style="list-style-type: disc;">
<li>
<p>Transaction-based</p>
<p>Shows a row for the finest level detail in a transaction. A row is entered only if a transaction has occurred for a given combination of dimension values. This is the most common type of fact table.</p>
</li>
<li>
<p>Periodic Snapshot</p>
<p>Shows data as of the end of a regular time interval, such as daily or weekly. If a row for the snapshot exists in a prior period, a row is entered for it in the new period even if no activity related to it has occurred in the latest interval. This type of fact table is useful in complex business processes where it is difficult to compute snapshot values from individual transaction rows.</p>
</li>
<li>
<p>Accumulating Snapshot</p>
<p>Shows one row for each occurrence of a short-lived process. The rows contain multiple dates tracking major milestones of a short-lived process. Unlike the other two types of fact tables, rows in an accumulating snapshot are updated multiple times as the tracked process moves forward.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG9237"></a>
<div class="props_rev_3"><a id="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1"></a>
<h4 id="DWHSG-GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1" class="sect4">About Dimension Tables in Data Warehouses</h4>
<div>
<p>Dimension tables provide category data to give context to the fact data. For instance, a star schema for sales data will have dimension tables for product, date, sales location, promotion and more. Dimension tables act as lookup or reference tables because their information lets you choose the values used to constrain your queries. The values in many dimension tables may change infrequently. As an example, a dimension of geographies showing cities may be fairly static. But when dimension values do change, it is vital to update them fast and reliably. Of course, there are situations where data warehouse dimension values change frequently. The customer dimension for an enterprise will certainly be subject to a frequent stream of updates and deletions.</p>
<p>A key aspect of dimension tables is the hierarchy information they provide. Dimension data typically has rows for the lowest level of detail plus rows for aggregated dimension values. These natural rollups or aggregations within a dimension table are called hierarchies and add great value for analyses. For instance, if you want to calculate the share of sales that a specific product represents within its specific product category, it is far easier and more reliable to have a predefined hierarchy for product aggregation than to specify all the elements of the product category in each query. Because hierarchy information is so valuable, it is common to find multiple hierarchies reflected in a dimension table.</p>
<p>Dimension tables are usually textual and descriptive, and you will use their values as the row headers, column headers and page headers of the reports generated by your queries. While dimension tables have far fewer rows than fact tables, they can be quite wide, with dozens of columns. A location dimension table might have columns indicating every level of its rollup hierarchy, and may show multiple hierarchies reflected in the table. The location dimension table could have columns for its geographic rollup, such as street address, postal code, city, state/province, and country. The same table could include a rollup hierarchy set up for the sales organization, with columns for sales district, sales territory, sales region, and characteristics.</p>
<div class="infoboxnotealso" id="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1__GUID-CFCF03B1-97E6-4929-81D0-6059E57DA38F">
<p class="notep1">See Also:</p>
<p><a href="dimen.htm#GUID-106BE703-0D67-41F1-8CAC-6432B95FBF82">Dimensions</a> for further information regarding dimensions</p>
</div>
</div>
</div>
</div>
<a id="DWHSG9238"></a>
<div class="props_rev_3"><a id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448"></a>
<h3 id="DWHSG-GUID-787CD3B1-0131-47F4-A904-4F7221A29448" class="sect3">Design Concepts in Star Schemas</h3>
<div>
<p>Here we touch on some of the key terms used in star schemas. This is by no means a full set, but is intended to highlight some of the areas worth your consideration.</p>
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHCCIEF">
<p class="subhead3">Data Grain</p>
<p>One of the most important tasks when designing your model is to consider the level of detail it will provide, referred to as the grain of the data. Consider a sales schema: will the grain be very fine, storing every single item purchased by each customer? Or will it be a coarse grain, storing only the daily totals of sales for each product at each store? In modern data warehousing there is a strong emphasis on providing the finest grain data possible, because this allows for maximum analytic power. Dimensional modeling experts generally recommend that each fact table store just one grain level. Presenting fact data in single-grain tables supports more reliable querying and table maintenance, because there is no ambiguity about the scope of any row in a fact table.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHICGJA">
<p class="subhead3">Working with Multiple Star Schemas</p>
<p>Because the star schema design approach is intended to chunk data into distinct processes, you need reliable and performant ways to traverse the schemas when queries span multiple schemas. One term for this ability is a data warehouse bus architecture. A data warehouse bus architecture can be achieved with conformed dimensions and conformed facts.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHAGIB">
<p class="subhead3">Conformed Dimensions</p>
<p>Conformed dimensions means that dimensions are designed identically across the various star schemas. Conformed dimensions use the same values, column names and data types consistently across multiple stars. The conformed dimensions do not have to contain the same number of rows in each schema&#39;s copy of the dimension table, as long as the rows in the shorter tables are a true subset of the larger tables.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHEGEGE">
<p class="subhead3">Conformed Facts</p>
<p>If the fact columns in multiple fact tables have exactly the same meaning, then they are considered conformed facts. Such facts can be used together reliably in calculations even though they are from different tables. Conformed facts should have the same column names to indicate their conformed status. Facts that are not conformed should always have different names to highlight their different meanings.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHEIJJC">
<p class="subhead3">Surrogate Keys</p>
<p>Surrogate or artificial keys, usually sequential integers, are recommended for dimension tables. By using surrogate keys, the data is insulated from operational changes. Also, compact integer keys may allow for better performance than large and complex alphanumeric keys.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Degenerate Dimensions</p>
<p id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHDFJEG">Degenerate dimensions are dimension columns in fact tables that do not join to a dimension table. They are typically items such as order numbers and invoice numbers. You will see them when the grain of a fact table is at the level of an order line-item or a single transaction.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHIGFH">
<p class="subhead3">Junk Dimensions</p>
<p>Junk dimensions are abstract dimension tables used to hold text lookup values for flags and codes in fact tables. These dimensions are referred to as junk, not because they have low value, but because they hold an assortment of columns for convenience, analogous to the idea of a &#34;junk drawer&#34; in your home. The number of distinct values (cardinality) of each column in a junk dimension table is typically small.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHIFGHD">
<p class="subhead3">Embedded Hierarchy</p>
<p>Classic dimensional modeling with star schemas advocates that each table contain data at a single grain. However, there are situations where designers choose to have multiple grains in a table, and these commonly represent a rollup hierarchy. A single sales fact table, for instance, might contain both transaction-level data, then a day-level rollup by product, then a month-level rollup by product. In such cases, the fact table will need to contain a level column indicating the hierarchy level applying to each row, and queries against the table will need to include a level predicate.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHFBFFH">
<p class="subhead3">Factless Fact Tables</p>
<p>Factless fact tables do not contain measures such as sales price or quantity sold. Instead, the rows of a factless fact table are used to show events not represented by other fact tables. Another use for factless tables is as a &#34;coverage table&#34; which holds all the possible events that could have occurred in a given situation, such as all the products that were part of a sales promotion and might have been sold at the promotional price.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHHCGF">
<p class="subhead3">Slowly Changing Dimensions</p>
<p>One of the certainties of data warehousing is that the way data is categorized will change. Product names and category names will change. Characteristics of a store will change. The areas included in sales territories will change. The timing and extent of these changes will not always be predictable. How can these slowly changing dimensions be handled? Star schemas treat these in three main ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>Type 1</p>
<p>The dimension values that change are simply overwritten, with no history kept. This creates a problem for time-based analyses. Also, it invalidates any existing aggregates that depended on the old value of the dimension.</p>
</li>
<li>
<p>Type 2</p>
<p>When a dimension value changes, a new dimension row showing the new value and having a new surrogate key is created. You may choose to include date columns in our dimension showing when the new row is valid and when it is expired. No changes need be made to the fact table.</p>
</li>
<li>
<p>Type 3</p>
<p>When a dimension value is changed, the prior value is stored in a different column of the same row. This enables easy query generation if you want to compare results using the current and prior value of the column.</p>
</li>
</ul>
<p>In practice, Type 2 is the most common treatment for slowly changing dimensions.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG9250"></a><a id="DWHSG9249"></a>
<div class="props_rev_3"><a id="GUID-B88263A2-708E-4750-9CE5-273F03B233DD"></a>
<h3 id="DWHSG-GUID-B88263A2-708E-4750-9CE5-273F03B233DD" class="sect3">About Snowflake Schemas</h3>
<div>
<p>The snowflake schema<a id="d6646e659" class="indexterm-anchor"></a> is a more complex data warehouse model than a star schema, and is a type of star schema. It is called a snowflake schema because the diagram of the schema resembles a snowflake.</p>
<p>Snowflake schemas normalize dimensions to eliminate redundancy. That is, the dimension data has been grouped into multiple tables instead of one large table. For example, a product dimension table in a star schema might be normalized into a <code class="codeph">products</code> table, a <code class="codeph">product_category</code> table, and a <code class="codeph">product_manufacturer</code> table in a snowflake schema. While this saves space, it increases the number of dimension tables and requires more foreign key joins<a id="d6646e673" class="indexterm-anchor"></a>. The result is more complex queries<a id="d6646e680" class="indexterm-anchor"></a><a id="d6646e684" class="indexterm-anchor"></a> and reduced query performance. <a href="ch2logdes.htm#GUID-B88263A2-708E-4750-9CE5-273F03B233DD__BABCJCBB">Figure 2-3</a> presents a graphical representation of a snowflake schema.</p>
<div class="figure" id="GUID-B88263A2-708E-4750-9CE5-273F03B233DD__BABCJCBB">
<p class="titleinfigure">Figure 2-3 Snowflake Schema</p>
<img width="377" height="247" src="img/GUID-D676CBFE-F9B2-4570-A658-91BD65005334-default.gif" alt="Description of Figure 2-3 follows" title="Description of Figure 2-3 follows"/><br/>
<a href="img_text/GUID-D676CBFE-F9B2-4570-A658-91BD65005334-print.htm">Description of &#34;Figure 2-3 Snowflake Schema&#34;</a></div>
<!-- class="figure" --></div>
</div>
</div>
<a id="DWHSG9316"></a><a id="DWHSG9317"></a><a id="DWHSG9318"></a><a id="DWHSG9315"></a>
<div class="props_rev_3"><a id="GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997"></a>
<h2 id="DWHSG-GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997" class="sect2">About the Oracle In-Memory Column Store</h2>
<div>
<div class="infobox-note" id="GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997__GUID-0B69E3F8-E74D-47EC-9FE3-46086EB9ABEE">
<p class="notep1">Note:</p>
<p>This feature is available starting with Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2).</p>
</div>
<p>Traditional analytics has certain limitations or requirements that need to be managed to obtain good performance for analytic queries. You need to know user access patterns and then customize your data structures to provide optimal performance for these access patterns. Existing indexes, materialized views, and OLAP cubes need to be tuned. Certain data marts and reporting databases have complex ETL and thus need specialized tuning. Additionally, you need to strike a balance between performing analytics on stale data and slowing down OLTP operations on the production databases.</p>
<p>The <a id="d6646e730" class="indexterm-anchor"></a><a id="d6646e734" class="indexterm-anchor"></a>Oracle In-Memory Column Store (IM column store) within the Oracle Database provides improved performance for both ad-hoc queries and analytics on live data. The live transactional database is used to provide instant answers to queries, thus enabling you to seamlessly use the same database for OLTP transactions and data warehouse analytics.</p>
<p>The IM column store is an optional area in the SGA that stores copies of tables, table partitions, and individual columns in a compressed columnar format that is optimized for rapid scans. Columnar format lends itself to easily to vector processing thus making aggregations, joins, and certain types of data retrieval faster than the traditional on-disk formats. The columnar format exists only in memory and does not replace the on-disk or buffer cache format. Instead, it supplements the buffer cache and provides an additional, transaction-consistent, copy of the table that is independent of the disk format.</p>
<div class="infoboxnotealso" id="GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997__GUID-A68F570D-8F11-4DEA-BD43-FEDAECC83BB8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ch2logdes.htm#GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB">Benefits of Using the Oracle In-Memory Column Store</a></p>
</li>
<li>
<p><a class="olink CNCPT89659" target="_blank" href="../CNCPT/memory.htm#CNCPT89659"><span class="italic">Oracle Database Concepts</span></a> for conceptual information the about IM column store</p>
</li>
</ul>
</div>
<div class="section">
<p class="subhead2">Configuring the Oracle In-Memory Column Store</p>
</div>
<!-- class="section" -->
<div class="section">
<p>Configuring<a id="d6646e761" class="indexterm-anchor"></a><a id="d6646e765" class="indexterm-anchor"></a> the IM column store is simple. You set the <code class="codeph">INMEMORY_SIZE</code> initialization parameter, and then use DDL to specify the tablespaces, tables, partitions, or columns to be populated into the IM column store.</p>
<div class="infoboxnotealso" id="GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997__GUID-AE2C4507-FF3F-4E4C-9F2B-F239CFB0733D">
<p class="notep1">See Also:</p>
<p><a class="olink ADMIN14257" target="_blank" href="../ADMIN/memory.htm#ADMIN14257"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about configuring the IM column store</p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Populating the Oracle In-Memory Column Store</p>
</div>
<!-- class="section" -->
<div class="section">
<p>You can specify that the database populates<a id="d6646e786" class="indexterm-anchor"></a> data into the IM column store from row storage either at database instance startup or when the data is accessed for the first time.</p>
<div class="infoboxnotealso" id="GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997__GUID-EF41B06A-6E96-44C6-A57A-3E77BAB2E079">
<p class="notep1">See Also:</p>
<p><a class="olink CNCPT89659" target="_blank" href="../CNCPT/memory.htm#CNCPT89659"><span class="italic">Oracle Database Concepts</span></a> for detailed information about how the IM column store is populated</p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">In-Memory Columnar Compression</p>
</div>
<!-- class="section" -->
<div class="section">
<p>The Oracle Databases uses special compression formats that are optimized for access speeds rather than storage reductions to store data in the IM column store. You can select different compression options for each table, partition, or column.</p>
<div class="infoboxnotealso" id="GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997__GUID-2FF8753C-3C42-4D99-ABE3-E616BDF5CC35">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CNCPT89659" target="_blank" href="../CNCPT/memory.htm#CNCPT89659"><span class="italic">Oracle Database Concepts</span></a></p>
</li>
<li>
<p><a class="olink ADMIN14257" target="_blank" href="../ADMIN/memory.htm#ADMIN14257"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="DWHSG9319"></a>
<div class="props_rev_3"><a id="GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB"></a>
<h3 id="DWHSG-GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB" class="sect3">Benefits of Using the Oracle In-Memory Column Store</h3>
<div>
<p>The IM column store enables the Oracle Database to perform scans, joins, and aggregates much faster than when it uses the on-disk format exclusively. Business applications, ad-hoc analytic queries, and data warehouse workloads benefit most. Pure OLTP databases that perform short transactions using index lookups benefit less.</p>
<p>The IM column store seamlessly integrates with the Oracle Database. All existing database features, including High Availability features, are supported with no application changes required. Therefore, by configuring the IM column store, you can instantly improve the performance of existing analytic workloads and ad-hoc queries.</p>
<p>The Oracle Optimizer is aware of the IM column store making it possible for the Oracle Database to seamlessly send analytic queries to the IM column store while OLTP queries and DML are sent to the row store.</p>
<p>The <a id="d6646e850" class="indexterm-anchor"></a><a id="d6646e854" class="indexterm-anchor"></a>advantages offered by the IM column store for data warehousing environments are:</p>
<ul style="list-style-type: disc;">
<li>
<p>Faster scanning of large number of rows and applying filters that use operators such as =,&lt;,&gt;, and IN.</p>
</li>
<li>
<p>Faster querying of a subset of columns in a table, for example, selecting 5 of 100 columns. See <span class="q">&#34;<a href="ch2logdes.htm#GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__CIHFGAHG">Faster Performance for Analytic Queries</a>&#34;</span>.</p>
</li>
<li>
<p>Enhanced performance for joins by converting predicates on small dimension tables to filters on a large fact table. See <span class="q">&#34;<a href="ch2logdes.htm#GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__CIHEFHJI">Enhanced Join Performance Using Vector Joins</a>&#34;</span>.</p>
</li>
<li>
<p>Efficient aggregation by using <code class="codeph">VECTOR GROUP BY</code> transformation and vector array processing. See <span class="q">&#34;<a href="ch2logdes.htm#GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__CIHIAAIG">Enhanced Aggregation Using VECTOR GROUP BY Transformations</a>&#34;</span>.</p>
</li>
<li>
<p>Reduced storage space and significantly less processing overhead because fewer indexes, materialized views, and OLAP cubes are required when IM column store is used.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__GUID-5DD75036-915D-4351-92E3-87013D819FDB">
<p class="notep1">See Also:</p>
<p><a class="olink CNCPT89659" target="_blank" href="../CNCPT/memory.htm#CNCPT89659"><span class="italic">Oracle Database Concepts</span></a> for information about the other advantages of using IM column store</p>
</div>
<div class="section" id="GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__CIHFGAHG">
<p class="subhead3">Faster Performance for Analytic Queries</p>
<p>Storing data in memory using columnar format provides fast throughput for analyzing large amounts of data. This is useful for ad-hoc queries with unanticipated access patterns. Columnar format uses fixed-width columns for most numeric and short string data types. This enables very fast vector processing that answers queries faster. Only the columns necessary for the specific data analysis task are scanned instead of entire rows of data.</p>
<p>Data can be analyzed in real-time, thus enabling you to explore different possibilities and perform iteration. Using the IM column store requires fewer OLAP cubes to be created to obtain query results.</p>
<p>For example, you need to find the number of sales in the state of California this year. This data is stored in the <code class="codeph">SALES</code> table. When this table is stored in the IM column store, the database needs to just scan the State column and count the number of occurrences of state California.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__CIHEFHJI">
<p class="subhead3">Enhanced Join Performance Using Vector Joins</p>
<p>IM column store takes advantage of vector joins. Vector joins speed up joins by converting predicates on small dimension tables to filters on large fact tables. This is useful when performing a join of multiple dimensions with one large fact table. The dimension keys on fact tables have lots of repeat values. The scan performance and repeat value optimization speeds up joins.</p>
<div class="infoboxnotealso" id="GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__GUID-EC541316-A7D1-4AC4-A5FC-03AB483F88A7">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="ch2logdes.htm#GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355">Using Vector Joins to Enhance Join Performance</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__CIHIAAIG">
<p class="subhead3">Enhanced Aggregation Using VECTOR GROUP BY Transformations</p>
<p>An important aspect of analytics is to determine patterns and trends by aggregating data. Aggregations and complex SQL queries run faster when data is stored in the IM column store.</p>
<p><code class="codeph">VECTOR GROUP BY</code> transformations enable efficient in-memory array-based aggregation. During a fact table scan, aggregate values are accumulated into in-memory arrays and efficient algorithms are used perform aggregation. Performing joins based on the primary key and foreign key relationships are optimized for both star schemas and snowflake schemas.</p>
<div class="infoboxnotealso" id="GUID-B4DC96ED-0907-4974-9347-2FFBC24EBBDB__GUID-EA8609C8-FC69-4EE0-9F8B-C1E076AAE26D">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="aggreg.htm#GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1">Using In-Memory Aggregation</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG9415"></a><a id="DWHSG9323"></a>
<div class="props_rev_3"><a id="GUID-FB360DEE-45DB-49FF-8510-541473AAD707"></a>
<h3 id="DWHSG-GUID-FB360DEE-45DB-49FF-8510-541473AAD707" class="sect3">Using the Oracle In-Memory Column Store</h3>
<div>
<div class="section">
<p>You can store data using columnar format in the IM column store for existing databases or for new database that you plan to create. IM column store is simple to configure and does not impact existing applications. Depending on the requirement, you can configure one or more tablespaces, tables, materialized views, or partitions to be stored in memory.</p>
<div class="infoboxnotealso" id="GUID-FB360DEE-45DB-49FF-8510-541473AAD707__GUID-D47A05B8-C203-450D-B2FE-8D40F339E3FC">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ch2logdes.htm#GUID-AB46CCB2-C8A5-4411-A761-B6797DC81997">About the Oracle In-Memory Column Store</a></p>
</li>
<li>
<p><a class="olink ADMIN" target="_blank" href="../ADMIN/toc.htm"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about configuring the IM column store</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">To store data in the IM column store:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Configure the <code class="codeph">INMEMORY_SIZE</code> initialization parameter to specify the amount of memory that must be assigned to the IM column store.</span>
<div>
<pre dir="ltr">INMEMORY_SIZE = 100 GB
</pre>
<div class="infoboxnotealso" id="GUID-FB360DEE-45DB-49FF-8510-541473AAD707__GUID-65F31AB4-E1CD-48D0-A04D-94EAD2D2F965">
<p class="notep1">See Also:</p>
<p><a class="olink REFRN10348" target="_blank" href="../REFRN/GUID-B5BEB6BF-5308-485F-920D-CBB584DDDE8F.htm#REFRN10348"><span class="italic">Oracle Database Reference</span></a> for more information about the <code class="codeph">INMEMORY_SIZE</code> parameter</p>
</div>
</div>
</li>
<li class="stepexpand"><span>Specify the database objects that must be stored in memory. Objects can include tablespaces, tables, materialized views, or partitions. Any queries on these objects will run faster than when the objects are stored on disk.</span>
<div>
<p>For existing tablespaces, tables, or table partitions, use the <code class="codeph">ALTER</code> command to store them in memory.</p>
<pre dir="ltr">ALTER TABLESPACE tbs1 INMEMORY;
ALTER TABLE my_table MODIFY PARTITION p1 INMEMORY;
</pre>
<p>While creating new tablespaces or tables, use the <code class="codeph">INMEMORY</code> clause to specify that these objects must be stored in memory.</p>
<pre dir="ltr">CREATE TABLE my_table (id NUMBER, tname VARCHAR2(45)) INMEMORY;
</pre>
<div class="infoboxnotealso" id="GUID-FB360DEE-45DB-49FF-8510-541473AAD707__GUID-AFD1DAF8-7AFC-4F79-80E6-792D3DFDB49E">
<p class="notep1">See Also:</p>
<p><a class="olink ADMIN14297" target="_blank" href="../ADMIN/memory.htm#ADMIN14297"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about enabling objects to be stored in memory</p>
</div>
</div>
</li>
<li class="stepexpand"><span>Drop the indexes that were created to aid OLTP application workloads. Replace these with in-memory indexes. OLTP operations run faster because the objects that need to be accessed are now stored in memory.</span>
<div>
<div class="infoboxnotealso" id="GUID-FB360DEE-45DB-49FF-8510-541473AAD707__GUID-C4799CDD-A181-4266-95E6-02458B7C7047">
<p class="notep1">See Also:</p>
<p><a class="olink ADMIN14257" target="_blank" href="../ADMIN/memory.htm#ADMIN14257"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a></p>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="props_rev_3"><a id="GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355"></a>
<h3 id="DWHSG-GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355" class="sect3">Using Vector Joins to Enhance Join Performance</h3>
<div>
<div class="section">
<p>Joins are an integral part of data warehousing workloads. IM column store enhances the performance of joins when the tables being joined are stored in memory. Simple joins that use bloom filters and complex joins between multiple tables benefit by using the IM column store. In a data warehousing environment, the most frequently-used joins are ones in which one or more dimension tables are joined with a fact table.</p>
<p>The following types of joins run faster when the tables being joined are stored in the IM column store:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Joins that are amenable to using bloom filters</p>
</li>
<li>
<p>Joins of multiple small dimension tables with one fact table</p>
</li>
<li>
<p>Joins between two tables that have a PK-FK relationship</p>
</li>
</ul>
<p>The IM column store runs queries that contain joins more efficiently and quickly by using vector joins. Vector joins allow the Oracle Database to take advantage of the fast scanning and vector processing capability of the IM column store. A vector join transforms a join between a dimension and fact table to filter that can be applied as part of the scan of the fact table. This join conversion is performed with the use of bloom filters, which enhance hash join performance in the Oracle Database. Although bloom filters are independent of IM column store, they can be applied very efficiently to data stored in memory through SIMD vector processing.</p>
<p>Consider the following query that performs a join of the <code class="codeph">CUSTOMERS</code> dimension table with the <code class="codeph">SALES</code> fact table:</p>
<pre dir="ltr">SELECT c.customer_id, s.quantity_sold, s.amount_sold 
FROM CUSTOMERS c, SALES s
WHERE c.customer_id = s.customer_id AND c.country_id = &#39;FR&#39;;
</pre>
<p>When both these tables are stored in the IM column store, SIMD vector processing is used to quickly scan the data and apply filters. <a href="ch2logdes.htm#GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355__CIHDIHCE">Figure 2-4</a> displays a graphical representation of the how vector joins are used to implement the query. The predicate on the <code class="codeph">CUSTOMERS</code> table, <code class="codeph">c.country_id=&#39;FR&#39;</code> is converted into a filter on the <code class="codeph">SALES</code> fact table. The filter is <code class="codeph">country_id=&#39;FR&#39;</code>. Because the <code class="codeph">SALES</code> table is stored in memory using columnar format, just one column needs to be scanned to determine the result of this query.</p>
<div class="figure" id="GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355__CIHDIHCE">
<p class="titleinfigure">Figure 2-4 Vector Joins Using Oracle In-Memory Column Store</p>
<img width="737" height="382" src="img/GUID-44528718-4F25-4BDA-A036-206B2DE21D40-default.gif" alt="Description of Figure 2-4 follows" title="Description of Figure 2-4 follows"/><br/>
<a href="img_text/GUID-44528718-4F25-4BDA-A036-206B2DE21D40-default.htm">Description of &#34;Figure 2-4 Vector Joins Using Oracle In-Memory Column Store&#34;</a></div>
<!-- class="figure" --></div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG9327"></a>
<div class="props_rev_3"><a id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C"></a>
<h2 id="DWHSG-GUID-BD54F705-627B-4460-AB83-AFA992D8798C" class="sect2">Automatic Big Table Caching to Improve the Performance of In-Memory Parallel Queries</h2>
<div>
<p>Automatic <a id="d6646e1148" class="indexterm-anchor"></a>big table caching enhances the in-memory query capabilities of Oracle Database. When a table does not fit in memory, the database decides which buffers to cache based on access patterns. This provides efficient caching for large tables, even if they do not fully fit in the buffer cache.</p>
<p>An optional section of the buffer cache, called the big table cache, is used to store data for table scans. The big table cache is integrated with the buffer cache and uses a temperature-based, object-level replacement algorithm to manage the big table cache contents. This is different from the access-based, block level LRU algorithm used by the buffer cache.</p>
<div class="infobox-note" id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C__GUID-781FCD0A-43A3-48C8-81E4-DE5C22392116">
<p class="notep1">Note:</p>
<p>The automatic big table caching feature is available starting with Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2).</p>
</div>
<p>Typical data warehousing workloads scan multiple tables. Performance may be impacted if the combined size of these tables is greater than the combined size of the buffer cache. With automatic big table caching, the scanned tables are stored in the big table cache instead of the buffer cache. The temperature-based, object-level replacement algorithm used by the big table cache can provide enhanced performance for data warehousing workloads by:</p>
<ul style="list-style-type: disc;">
<li>
<p>Selectively caching the &#34;hot&#34; objects</p>
<p>Each time an object is accessed, Oracle Database increments the temperature of that object. An object in the big table cache can be replaced only by another object whose temperature is higher than its own temperature.</p>
</li>
<li>
<p>Avoiding thrashing</p>
<p>Partial objects are cached when objects cannot be fully cached.</p>
</li>
</ul>
<p>In Oracle Real Application Clusters (Oracle RAC) environments, automatic big table caching is supported only for parallel queries. In single instance environments, this functionality is supported for both serial and parallel queries.</p>
<p>To use automatic big table caching, you must enable the big table cache. To use automatic big table caching for serial queries, you must set the <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> initialization parameter to a nonzero value. To use automatic big table caching for parallel queries, you must set <code class="codeph">PARALLEL_DEGREE_POLICY</code> to <code class="codeph">AUTO</code> or <code class="codeph">ADAPTIVE</code> and <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> to a nonzero value.</p>
<div class="infoboxnotealso" id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C__GUID-F6834BA7-D22E-4EE2-96C0-5F3D2C8A248A">
<p class="notep1">See Also:</p>
<p><a class="olink VLDBG" target="_blank" href="../VLDBG/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about the big table cache and how it can be used</p>
</div>
</div>
</div>
<a id="DWHSG9328"></a>
<div class="props_rev_3"><a id="GUID-C0C57677-E420-432C-9E1F-271011F0C775"></a>
<h2 id="DWHSG-GUID-C0C57677-E420-432C-9E1F-271011F0C775" class="sect2">About In-Memory Aggregation</h2>
<div>
<p>In-memory <a id="d6646e1222" class="indexterm-anchor"></a>aggregation uses the <code class="codeph">VECTOR GROUP BY</code> operation to enhance the performance of queries that aggregate data and join one or more relatively small tables to a larger table, as often occurs in a star query. <code class="codeph">VECTOR GROUP BY</code> will be chosen by the SQL optimizer based on cost estimates. This will occur more often when the query selects from in-memory columnar tables and the tables include unique or numeric join keys (regardless of whether the uniqueness is forced by a primary key, unique constraint or schema design).</p>
<div class="infoboxnotealso" id="GUID-C0C57677-E420-432C-9E1F-271011F0C775__GUID-12199DB0-2C80-4185-9EE9-5A2F3B8CB610">
<p class="notep1">See Also:</p>
<p><a class="olink TGSQL95255" target="_blank" href="../TGSQL/tgsql_transform.htm#TGSQL95255"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for details about how In-memory aggregation works</p>
</div>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation will only by chosen for <code class="codeph">GROUP BY</code>. It will not be chosen for <code class="codeph">GROUP BY ROLLUP</code>, <code class="codeph">GROUPING SETS</code> or <code class="codeph">CUBE</code>.</p>
<div class="infobox-note" id="GUID-C0C57677-E420-432C-9E1F-271011F0C775__GUID-AFCB931C-3501-4AD5-80B0-0F97BA67D209">
<p class="notep1">Note:</p>
<p>This feature is available starting with Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2).</p>
</div>
<p>This following topics provide additional information about In-memory aggregation:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ch2logdes.htm#GUID-278FB268-D892-4556-BF7F-9F3EAD93B6A9">VECTOR GROUP BY Aggregation and the Oracle In-Memory Column Store</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-0E4F30FE-674F-4284-90F7-520ED1DB427E">When to Use VECTOR GROUP BY Aggregation</a></p>
</li>
<li>
<p><a href="ch2logdes.htm#GUID-C3786D7D-0FD6-44F7-93FD-468F3FA02056">When Is VECTOR GROUP BY Aggregation Used to Process Analytic Queries?</a></p>
</li>
</ul>
</div>
<a id="DWHSG9329"></a>
<div class="props_rev_3"><a id="GUID-278FB268-D892-4556-BF7F-9F3EAD93B6A9"></a>
<h3 id="DWHSG-GUID-278FB268-D892-4556-BF7F-9F3EAD93B6A9" class="sect3">VECTOR GROUP BY Aggregation and the Oracle In-Memory Column Store</h3>
<div>
<p>Although <a id="d6646e1302" class="indexterm-anchor"></a><a id="d6646e1306" class="indexterm-anchor"></a>using the IM column store is not a requirement for using <code class="codeph">VECTOR GROUP BY</code> aggregation, it is strongly recommended that you use both features together. Storing tables in memory using columnar format provides the foundation storage that <code class="codeph">VECTOR GROUP BY</code> aggregation leverages to provide transactionally consistent results immediately after a schema is updated without the need to wait until the data marts are populated.</p>
</div>
</div>
<a id="DWHSG9330"></a>
<div class="props_rev_3"><a id="GUID-0E4F30FE-674F-4284-90F7-520ED1DB427E"></a>
<h3 id="DWHSG-GUID-0E4F30FE-674F-4284-90F7-520ED1DB427E" class="sect3">When to Use VECTOR GROUP BY Aggregation</h3>
<div>
<p>Not all queries and scenarios benefit from the use of <code class="codeph">VECTOR GROUP BY</code> aggregation. The following sections provide guidelines about the situations in which using this aggregation can be beneficial.</p>
<div class="section">
<p class="subhead3">Situations Where VECTOR GROUP BY Aggregation Is Useful</p>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation provides benefits in the following scenarios:</p>
<ul style="list-style-type: disc;">
<li>
<p>The schema contains &#34;mostly&#34; unique keys or numeric keys for the columns that are used to join the fact and dimensions. The uniqueness can be enforced using a primary key, unique constraint or by schema design.</p>
</li>
<li>
<p>The fact table is at least 10 times larger than the dimensions.</p>
</li>
<li>
<p>The IM column store is used to store the dimensions and fact table in memory.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Situations Where VECTOR GROUP BY Aggregation Is Not Advantageous</p>
<p>Using <code class="codeph">VECTOR GROUP BY</code> aggregation does not provide substantial performance benefits in the following scenarios:</p>
<ul style="list-style-type: disc;">
<li>
<p>Joins are performed between two very large tables</p>
<p>By default, the <code class="codeph">VECTOR GROUP BY</code> transformation is used only if the fact table is at least 10 times larger than the dimensions.</p>
</li>
<li>
<p>Dimensions contain more than 2 billion rows</p>
<p>The <code class="codeph">VECTOR GROUP BY</code> transformation is not used if a dimension contains more than 2 billion rows.</p>
</li>
<li>
<p>The system does not have sufficient memory resources</p>
<p>Most systems that use the IM column store will be able to benefit from using the <code class="codeph">VECTOR GROUP BY</code> transformation.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG9333"></a>
<div class="props_rev_3"><a id="GUID-C3786D7D-0FD6-44F7-93FD-468F3FA02056"></a>
<h3 id="DWHSG-GUID-C3786D7D-0FD6-44F7-93FD-468F3FA02056" class="sect3">When Is VECTOR GROUP BY Aggregation Used to Process Analytic Queries?</h3>
<div>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation <a id="d6646e1423" class="indexterm-anchor"></a>is integrated with the Oracle Optimizer and no new SQL or initialization parameters are required to enable the use of this transformation. It also does not need additional indexes, foreign keys, or dimensions.</p>
<p>By default, Oracle Database decides whether or not to use <code class="codeph">VECTOR GROUP BY</code> aggregation for a query based on the cost, relative to other execution plans that are determined for this query. However, you can direct the database to use <code class="codeph">VECTOR GROUP BY</code> aggregation for a query by using query block hints or table hints.</p>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation can be used to process a query that uses a fact view that is derived from multiple fact tables.</p>
<p>Oracle Database uses <code class="codeph">VECTOR GROUP BY</code> aggregation to perform data aggregation when the following conditions are met:</p>
<ul style="list-style-type: disc;">
<li>
<p>The queries or subqueries aggregate data from a fact table and join the fact table to one or more dimensions.</p>
<p>Multiple fact tables joined to the same dimensions are also supported assuming that these fact tables are connected only through joins to the dimension. In this case, <code class="codeph">VECTOR GROUP BY</code> aggregates fact table separately and then joins the results on the grouping keys.</p>
</li>
<li>
<p>The dimensions and fact table are connected to each other only through join columns.</p>
<p>Specifically, the query must not have any other predicates that refer to columns across multiple dimensions or from both a dimension and the fact table. If a query performs a join between two or more tables and then joins the result to the fact, then <code class="codeph">VECTOR GROUP BY</code> aggregation treats the multiple dimensions as a single dimension.</p>
</li>
</ul>
<p>The best performance for <code class="codeph">VECTOR GROUP BY</code> aggregation is obtained when the tables being joined are stored in the IM column store.</p>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation does not support the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Semi- and anti-joins across multiple dimensions or between a dimension and the fact table</p>
</li>
<li>
<p>Equi-joins across multiple dimensions.</p>
</li>
<li>
<p>Aggregations performed using <code class="codeph">DISTINCT</code></p>
</li>
<li>
<p>Bloom filters</p>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation and bloom filters are mutually exclusive.</p>
<p>If bloom filters are used to perform joins for a query, then <code class="codeph">VECTOR GROUP BY</code> aggregation is not applicable to the processing of this query.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-C3786D7D-0FD6-44F7-93FD-468F3FA02056__GUID-6BA5F3BF-9652-4D00-A7DF-AD481BEA70A6">
<p class="notep1">See Also:</p>
<p><a href="ch2logdes.htm#GUID-0E4F30FE-674F-4284-90F7-520ED1DB427E">When to Use VECTOR GROUP BY Aggregation</a></p>
</div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1506">
<tr>
<td class="cellalignment1513">
<table class="cellalignment1511">
<tr>
<td class="cellalignment1510"><a href="concept.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1510"><a href="ch3physdes.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1515">
<table class="cellalignment1509">
<tr>
<td class="cellalignment1510"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1510"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1510"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1510"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1510"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1510"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>