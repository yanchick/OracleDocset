<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-6016"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/SQL%20for%20Aggregation%20in%20Data%20Warehouses"></a><title>SQL for Aggregation in Data Warehouses</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="GROUPING_ID function, functions, GROUPING_ID, In-Memory Column Store, aggregation, aggregation, VECTOR GROUP BY, VECTOR GROUP BY, In-Memory Column Store, In-Memory aggregation"/>
<meta name="dcterms.created" content="2017-06-07T18:07:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Warehousing Guide"/>
<meta name="dcterms.identifier" content="E41670-11"/>
<meta name="dcterms.isVersionOf" content="DWHSG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="analysis.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pattern.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41670-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2"></a> <span id="PAGE" style="display:none;">27/32</span> <!-- End Header -->
<h1 id="DWHSG-GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2" class="sect1"><span class="enumeration_chapter">19</span> SQL for Aggregation in Data Warehouses</h1>
<div>
<p>This chapter discusses aggregation of SQL, a basic aspect of data warehousing. It contains these topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-72549B30-5BB7-42E6-A910-5716CB1713EA">Overview of SQL for Aggregation in Data Warehouses</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-01BBD582-E149-47D7-A4F8-F50C1AAC66AA">ROLLUP Extension to GROUP BY</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36">CUBE Extension to GROUP BY</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818">GROUPING Functions</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49">GROUPING SETS Expression</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4">About Composite Columns and Grouping</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF">Concatenated Groupings and Data Aggregation</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-F33D5E19-33B8-424F-A717-D30EDA3D08D6">Considerations when Using Aggregation in Data Warehouses</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905">Computation Using the WITH Clause</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-FB000241-BE8E-43F4-9789-24A0472AB193">Working with Hierarchical Cubes in SQL</a></p>
</li>
</ul>
</div>
<a id="DWHSG8600"></a>
<div class="props_rev_3"><a id="GUID-72549B30-5BB7-42E6-A910-5716CB1713EA"></a>
<h2 id="DWHSG-GUID-72549B30-5BB7-42E6-A910-5716CB1713EA" class="sect2">Overview of SQL for Aggregation in Data Warehouses</h2>
<div>
<p>Aggregation is a fundamental part of data warehousing. To improve aggregation performance in your warehouse, Oracle Database provides the following functionality:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">CUBE</code> and <code class="codeph">ROLLUP</code> extensions to the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause</p>
</li>
<li>
<p>Three <code class="codeph">GROUPING</code> functions</p>
</li>
<li>
<p><code class="codeph">GROUPING</code> <code class="codeph">SETS</code> expression</p>
</li>
<li>
<p>Pivoting operations</p>
</li>
</ul>
<p>The <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, and <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> extensions to SQL make querying and reporting easier and faster. <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, and grouping sets produce a single result set that is equivalent to a <code class="codeph">UNION</code> <code class="codeph">ALL</code> of differently grouped rows. <code class="codeph">ROLLUP</code> calculates aggregations such as <code class="codeph">SUM</code>, <code class="codeph">COUNT</code>, <code class="codeph">MAX</code>, <code class="codeph">MIN</code>, and <code class="codeph">AVG</code> at increasing levels of aggregation, from the most detailed up to a grand total. <code class="codeph">CUBE</code> is an extension similar to <code class="codeph">ROLLUP</code>, enabling a single statement to calculate all possible combinations of aggregations. The <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, and the <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> extension lets you specify just the groupings needed in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. This allows efficient analysis across multiple dimensions without performing a <code class="codeph">CUBE</code> operation. Computing a <code class="codeph">CUBE</code> creates a heavy processing load, so replacing cubes with grouping sets can significantly increase performance.</p>
<p>To enhance performance, <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, and <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> can be parallelized: multiple processes can simultaneously execute all of these statements. These capabilities make aggregate calculations more efficient, thereby enhancing database performance, and scalability.</p>
<p>The three <code class="codeph">GROUPING</code> functions help you identify the group each row belongs to and enable sorting subtotal rows and filtering results.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5">About Analyzing Across Multiple Dimensions</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-C70DDA78-57D4-480A-AFDD-33EDFC1C15AE">About Optimized Aggregation Performance</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-8BD77311-23F9-4400-9D36-323326C73597">Data Warehousing: An Aggregate Scenario</a></p>
</li>
</ul>
</div>
<a id="DWHSG8602"></a><a id="DWHSG8601"></a>
<div class="props_rev_3"><a id="GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5"></a>
<h3 id="DWHSG-GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5" class="sect3">About Analyzing Across Multiple Dimensions</h3>
<div>
<p><a id="d67728e261" class="indexterm-anchor"></a><a id="d67728e265" class="indexterm-anchor"></a>One of the key concepts in decision support systems is multidimensional analysis: examining the enterprise from all necessary combinations of dimensions. The term <a href="glossary.htm#GUID-51168741-F40B-41B8-83DE-F159BEB2DE75"><span class="xrefglossterm">dimension</span></a> is used to mean any category used in specifying questions. Among the most commonly specified dimensions are time, geography, product, department, and distribution channel, but the potential dimensions are as endless as the varieties of enterprise activity. The events or entities associated with a particular set of dimension values are usually referred to as facts. The facts might be sales in units or local currency, profits, customer counts, production volumes, or anything else worth tracking.</p>
<p>Here are some examples of multidimensional requests:</p>
<ul style="list-style-type: disc;">
<li>
<p>Show total sales across all products at increasing aggregation levels for a geography dimension, from state to country to region, for 1999 and 2000.</p>
</li>
<li>
<p>Create a cross-tabular analysis of our operations showing expenses by territory in South America for 1999 and 2000. Include all possible subtotals.</p>
</li>
<li>
<p>List the top 10 sales representatives in Asia according to 2000 sales revenue for automotive products, and rank their commissions.</p>
</li>
</ul>
<p>All these requests involve multiple dimensions. Many multidimensional questions require aggregated data and comparisons of data sets, often across time, geography or budgets.</p>
<p>To visualize data that has many dimensions, analysts commonly use the analogy of a data cube, that is, a space where facts are stored at the intersection of n dimensions. <a href="aggreg.htm#GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5__I1012453">Figure 19-1</a> shows a data cube and how it can be used differently by various groups. The cube stores sales data organized by the dimensions of product, market, sales, and time. Note that this is only a metaphor: the actual data is physically stored in normal tables. The cube data consists of both detail and aggregated data.</p>
<div class="figure" id="GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5__I1012453">
<p class="titleinfigure">Figure 19-1 Logical Cubes and Views by Different Users</p>
<img width="598" height="340" src="img/GUID-757DCCF4-E025-41C7-8E5F-BEC14425BCDF-default.gif" alt="Description of Figure 19-1 follows" title="Description of Figure 19-1 follows"/><br/>
<a href="img_text/GUID-757DCCF4-E025-41C7-8E5F-BEC14425BCDF-print.htm">Description of &#34;Figure 19-1 Logical Cubes and Views by Different Users&#34;</a></div>
<!-- class="figure" -->
<p>You can retrieve slices of data from the cube. These correspond to cross-tabular reports such as the one shown in <a href="aggreg.htm#GUID-8BD77311-23F9-4400-9D36-323326C73597__G1014032" title="This table illustrates a simple cross-tabular report with subtotals">Table 19-1</a>. Regional managers might study the data by comparing slices of the cube applicable to different markets. In contrast, product managers might compare slices that apply to different products. An ad hoc user might work with a wide variety of constraints, working in a subset cube.</p>
<p>Answering multidimensional questions often involves accessing and querying huge quantities of data, sometimes in millions of rows. Because the flood of detailed data generated by large organizations cannot be interpreted at the lowest level, aggregated views of the information are essential. Aggregations, such as sums and counts, across many dimensions are vital to multidimensional analyses. Therefore, analytical tasks require convenient and efficient data aggregation.</p>
</div>
</div>
<a id="DWHSG8603"></a>
<div class="props_rev_3"><a id="GUID-C70DDA78-57D4-480A-AFDD-33EDFC1C15AE"></a>
<h3 id="DWHSG-GUID-C70DDA78-57D4-480A-AFDD-33EDFC1C15AE" class="sect3">About Optimized Aggregation Performance</h3>
<div>
<p>Not only multidimensional issues, but all types of processing can benefit from enhanced aggregation facilities. Transaction processing, financial and manufacturing systems&shy;&mdash;all of these generate large numbers of production reports needing substantial system resources. Improved efficiency when creating these reports will reduce system load. In fact, any computer process that aggregates data from details to higher levels will benefit from optimized aggregation performance.</p>
<p>These extensions provide aggregation features and bring many benefits, including:</p>
<ul style="list-style-type: disc;">
<li>
<p>Simplified programming requiring less SQL code for many tasks.</p>
</li>
<li>
<p>Quicker and more efficient query processing.</p>
</li>
<li>
<p>Reduced client processing loads and network traffic because aggregation work is shifted to servers.</p>
</li>
<li>
<p>Opportunities for caching aggregations because similar queries can leverage existing work.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8606"></a><a id="DWHSG8604"></a>
<div class="props_rev_3"><a id="GUID-8BD77311-23F9-4400-9D36-323326C73597"></a>
<h3 id="DWHSG-GUID-8BD77311-23F9-4400-9D36-323326C73597" class="sect3">Data Warehousing: An Aggregate Scenario</h3>
<div>
<p>To illustrate the use of the <code class="codeph">GROUP</code> <code class="codeph">BY</code> extension, this chapter uses the <code class="codeph">sh</code> data of the sample schema. All the examples refer to data from this scenario. The hypothetical company has sales across the world and tracks sales by both dollars and quantities information. Because there are many rows of data, the queries shown here typically have tight constraints on their <code class="codeph">WHERE</code> clauses to limit the results to a small number of rows.</p>
<p><a href="aggreg.htm#GUID-8BD77311-23F9-4400-9D36-323326C73597__G1014032" title="This table illustrates a simple cross-tabular report with subtotals">Table 19-1</a> is a sample cross-tabular report showing the total sales by <code class="codeph">country_id</code> and <code class="codeph">channel_desc</code> for the US and France through the Internet and direct sales in September 2000.</p>
<div class="tblformal" id="GUID-8BD77311-23F9-4400-9D36-323326C73597__G1014032">
<p class="titleintable">Table 19-1 Simple Cross-Tabular Report With Subtotals</p>
<table class="cellalignment1516" title="Simple Cross-Tabular Report With Subtotals" summary="This table illustrates a simple cross-tabular report with subtotals">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1517" id="d67728e403">Channel</th>
<th class="cellalignment1518" id="d67728e406">France</th>
<th class="cellalignment1519" id="d67728e409">US</th>
<th class="cellalignment1519" id="d67728e412">Total</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1520" id="d67728e417" headers="d67728e403">
<p>Internet</p>
</td>
<td class="cellalignment1521" headers="d67728e417 d67728e406">
<p>9,597</p>
</td>
<td class="cellalignment1522" headers="d67728e417 d67728e409">
<p>124,224</p>
</td>
<td class="cellalignment1522" headers="d67728e417 d67728e412">
<p>133,821</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1520" id="d67728e430" headers="d67728e403">
<p>Direct Sales</p>
</td>
<td class="cellalignment1521" headers="d67728e430 d67728e406">
<p>61,202</p>
</td>
<td class="cellalignment1522" headers="d67728e430 d67728e409">
<p>638,201</p>
</td>
<td class="cellalignment1522" headers="d67728e430 d67728e412">
<p>699,403</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1520" id="d67728e443" headers="d67728e403">
<p>Total</p>
</td>
<td class="cellalignment1521" headers="d67728e443 d67728e406">
<p>70,799</p>
</td>
<td class="cellalignment1522" headers="d67728e443 d67728e409">
<p>762,425</p>
</td>
<td class="cellalignment1522" headers="d67728e443 d67728e412">
<p>833,224</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Consider that even a simple report such as this, with just nine values in its grid, generates four subtotals and a grand total. Half of the values needed for this report would not be calculated with a query that requested <code class="codeph">SUM(amount_sold)</code> and did a <code class="codeph">GROUP BY(channel_desc, country_id)</code>. To get the higher-level aggregates would require additional queries. Database commands that offer improved calculation of subtotals bring major benefits to querying, reporting, and analytical operations.</p>
<pre dir="ltr">SELECT channels.channel_desc, countries.country_iso_code,
  TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
  (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc=&#39;2000-09&#39;
  AND customers.country_id=countries.country_id
  AND countries.country_iso_code IN (&#39;US&#39;,&#39;FR&#39;)
GROUP BY CUBE(channels.channel_desc, countries.country_iso_code);

CHANNEL_DESC         CO SALES$
-------------------- -- --------------
                               833,224
                     FR         70,799
                     US        762,425
Internet                       133,821
Internet             FR          9,597
Internet             US        124,224
Direct Sales                   699,403
Direct Sales         FR         61,202
Direct Sales         US        638,201
</pre>
<div class="section" id="GUID-8BD77311-23F9-4400-9D36-323326C73597__BCGGFFGF">
<p class="subhead3">Interpreting NULLs in Aggregation Examples</p>
<p><code class="codeph">NULLs</code> returned by the <code class="codeph">GROUP</code> <code class="codeph">BY</code> extensions are not always the traditional null meaning value unknown. Instead, a <code class="codeph">NULL</code> may indicate that its row is a subtotal. To avoid introducing another non-value in the database system, these subtotal values are not given a special tag.</p>
<div class="infoboxnotealso" id="GUID-8BD77311-23F9-4400-9D36-323326C73597__GUID-0D7BCD80-9637-4142-AD00-433419F965E2">
<p class="notep1">See Also:</p>
<p><a href="aggreg.htm#GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818">GROUPING Functions</a> for details on how the nulls representing subtotals are distinguished from nulls stored in the data</p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8608"></a>
<div class="props_rev_3"><a id="GUID-01BBD582-E149-47D7-A4F8-F50C1AAC66AA"></a>
<h2 id="DWHSG-GUID-01BBD582-E149-47D7-A4F8-F50C1AAC66AA" class="sect2">ROLLUP Extension to GROUP BY</h2>
<div>
<div class="section">
<p><a id="d67728e508" class="indexterm-anchor"></a><code class="codeph">ROLLUP</code> enables a <code class="codeph">SELECT</code> statement to calculate multiple levels of subtotals across a specified group of dimensions. It also calculates a grand total. <code class="codeph">ROLLUP</code> is a simple extension to the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, so its syntax is extremely easy to use. The <code class="codeph">ROLLUP</code> extension is highly efficient, adding minimal overhead to a query.</p>
<p>The action of <code class="codeph">ROLLUP</code> is straightforward: it creates subtotals that roll up from the most detailed level to a grand total, following a grouping list specified in the <code class="codeph">ROLLUP</code> clause. <code class="codeph">ROLLUP</code> takes as its argument an ordered list of grouping columns. First, it calculates the standard aggregate values specified in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. Then, it creates progressively higher-level subtotals, moving from right to left through the list of grouping columns. Finally, it creates a grand total.</p>
<p><code class="codeph">ROLLUP</code> creates subtotals at n+1 levels, where n is the number of grouping columns. For instance, if a query specifies <code class="codeph">ROLLUP</code> on grouping columns of <code class="codeph">time</code>, <code class="codeph">region</code>, and <code class="codeph">department(n=3)</code>, the result set will include rows at four aggregation levels.</p>
<p>You might want to compress your data when using <code class="codeph">ROLLUP</code>. This is particularly useful when there are few updates to older partitions.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-8692A003-526D-4D80-BF73-B81899A91D50">When to Use ROLLUP</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-60430684-FD7B-4C2A-813A-99769D6E19FE">Partial Rollup</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E">When to Use CUBE</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8609"></a>
<div class="props_rev_3"><a id="GUID-8692A003-526D-4D80-BF73-B81899A91D50"></a>
<h3 id="DWHSG-GUID-8692A003-526D-4D80-BF73-B81899A91D50" class="sect3">When to Use ROLLUP</h3>
<div>
<p><a id="d67728e606" class="indexterm-anchor"></a>Use the <code class="codeph">ROLLUP</code> extension in tasks involving subtotals.</p>
<ul style="list-style-type: disc;">
<li>
<p>It is very helpful for subtotaling along a hierarchical dimension such as time or geography. For instance, a query could specify a <code class="codeph">ROLLUP(y,</code> <code class="codeph">m,</code> <code class="codeph">day)</code> or <code class="codeph">ROLLUP(country,</code> <code class="codeph">state,</code> <code class="codeph">city)</code>.</p>
</li>
<li>
<p>For data warehouse administrators using summary tables, <code class="codeph">ROLLUP</code> can simplify and speed up the maintenance of summary tables.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8611"></a><a id="DWHSG8610"></a>
<div class="props_rev_3"><a id="GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8"></a>
<h3 id="DWHSG-GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8" class="sect3">ROLLUP Syntax</h3>
<div>
<div class="section">
<p><code class="codeph">ROLLUP</code> appears in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause in a <code class="codeph">SELECT</code> statement. Its form is:</p>
<pre dir="ltr">SELECT &hellip; GROUP BY ROLLUP(grouping_column_reference_list)
</pre></div>
<!-- class="section" -->
<div class="example" id="GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8__GUID-79C48D5E-8013-4A57-BF12-AD30BE658B31">
<p class="titleinexample">Example 19-1 ROLLUP</p>
<p>This example uses the data in the <code class="codeph">sh</code> sample schema data, the same data as was used in <a href="aggreg.htm#GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5">About Analyzing Across Multiple Dimensions</a>. The <code class="codeph">ROLLUP</code> is across three dimensions.</p>
<pre dir="ltr">SELECT channels.channel_desc, calendar_month_desc, 
       countries.country_iso_code,
       TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id 
  AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id
  AND sales.channel_id = channels.channel_id 
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;) 
  AND countries.country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY 
  ROLLUP(channels.channel_desc, calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-09            140,793
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Internet             2000-10            151,593
Internet                                292,387
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-09            723,424
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
Direct Sales         2000-10            774,222
Direct Sales                          1,497,646
                                      1,790,032
</pre>
<p>Note that results do not always add up due to rounding.</p>
<p>This query returns the following sets of rows:</p>
</div>
<!-- class="example" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Regular aggregation rows that would be produced by <code class="codeph">GROUP</code> <code class="codeph">BY</code> without using <code class="codeph">ROLLUP</code>.</p>
</li>
<li>
<p>First-level subtotals aggregating across <code class="codeph">country_id</code> for each combination of <code class="codeph">channel_desc</code> and <code class="codeph">calendar_month</code>.</p>
</li>
<li>
<p>Second-level subtotals aggregating across <code class="codeph">calendar_month_desc</code> and <code class="codeph">country_id</code> for each <code class="codeph">channel_desc</code> value.</p>
</li>
<li>
<p>A grand total row.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8613"></a><a id="DWHSG8612"></a>
<div class="props_rev_3"><a id="GUID-60430684-FD7B-4C2A-813A-99769D6E19FE"></a>
<h3 id="DWHSG-GUID-60430684-FD7B-4C2A-813A-99769D6E19FE" class="sect3">Partial Rollup</h3>
<div>
<div class="section">
<p><a id="d67728e765" class="indexterm-anchor"></a>You can also roll up so that only some of the sub-totals will be included. This partial rollup uses the following syntax:</p>
<pre dir="ltr">GROUP BY expr1, ROLLUP(expr2, expr3);
</pre>
<p>In this case, the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause creates subtotals at (2+1=3) aggregation levels. That is, at level (<code class="codeph">expr1</code>, <code class="codeph">expr2</code>, <code class="codeph">expr3</code>), (<code class="codeph">expr1</code>, <code class="codeph">expr2</code>), and (<code class="codeph">expr1</code>).</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-60430684-FD7B-4C2A-813A-99769D6E19FE__CHDHHCEA">
<p class="titleinexample">Example 19-2 Partial ROLLUP</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, countries.country_iso_code,
   TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;) 
  AND countries.country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY channel_desc, ROLLUP(calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-09            140,793
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Internet             2000-10            151,593
Internet                                292,387
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-09            723,424
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
Direct Sales         2000-10            774,222
Direct Sales                          1,497,646
</pre>
<p>This query returns the following sets of rows:</p>
</div>
<!-- class="example" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Regular aggregation rows that would be produced by <code class="codeph">GROUP</code> <code class="codeph">BY</code> without using <code class="codeph">ROLLUP</code>.</p>
</li>
<li>
<p>First-level subtotals aggregating across <code class="codeph">country_id</code> for each combination of <code class="codeph">channel_desc</code> and <code class="codeph">calendar_month_desc</code>.</p>
</li>
<li>
<p>Second-level subtotals aggregating across <code class="codeph">calendar_month_desc</code> and <code class="codeph">country_id</code> for each <code class="codeph">channel_desc</code> value.</p>
</li>
<li>
<p>It does not produce a grand total row.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="props_rev_3"><a id="GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36"></a>
<h2 id="DWHSG-GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36" class="sect2">CUBE Extension to GROUP BY</h2>
<div>
<div class="section">
<p><a id="d67728e869" class="indexterm-anchor"></a><code class="codeph">CUBE</code> takes a specified set of grouping columns and creates subtotals for all of their possible combinations. In terms of multidimensional analysis, <code class="codeph">CUBE</code> generates all the subtotals that could be calculated for a data cube with the specified dimensions. If you have specified <code class="codeph">CUBE(time</code>, <code class="codeph">region</code>, <code class="codeph">department)</code>, the result set will include all the values that would be included in an equivalent <code class="codeph">ROLLUP</code> statement plus additional combinations.</p>
<p>For instance, the departmental totals across regions (279,000 and 319,000) would not be calculated by a <code class="codeph">ROLLUP(time</code>, <code class="codeph">region</code>, <code class="codeph">department)</code> clause, but they would be calculated by a <code class="codeph">CUBE(time</code>, <code class="codeph">region</code>, <code class="codeph">department)</code> clause. If <span class="italic">n</span> columns are specified for a <code class="codeph">CUBE</code>, there will be 2 to the <span class="italic">n</span> combinations of subtotals returned.</p>
<p><a href="aggreg.htm#GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD">CUBE Syntax</a> gives an example of a three-dimension cube.</p>
<div class="infoboxnotealso" id="GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36__GUID-A6DADDBE-A246-4D3E-9547-A739A7C8D9A0">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF55332" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF55332"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax and restrictions</p>
</div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E">When to Use CUBE</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD">CUBE Syntax</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16">Partial CUBE</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-4EEA566F-FCB2-4BCC-9195-933A19EF0197">Calculating Subtotals Without CUBE</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8615"></a>
<div class="props_rev_3"><a id="GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E"></a>
<h3 id="DWHSG-GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E" class="sect3">When to Use CUBE</h3>
<div>
<p>Consider <a id="d67728e976" class="indexterm-anchor"></a>Using <code class="codeph">CUBE</code> in any situation requiring cross-tabular reports. The data needed for cross-tabular reports can be generated with a single <code class="codeph">SELECT</code> using <code class="codeph">CUBE</code>. Like <code class="codeph">ROLLUP</code>, <code class="codeph">CUBE</code> can be helpful in generating summary tables. Note that population of summary tables is even faster if the <code class="codeph">CUBE</code> query executes in parallel.</p>
<p><code class="codeph">CUBE</code> is typically most suitable in queries that use columns from multiple dimensions rather than columns representing different levels of a single dimension. For instance, a commonly requested cross-tabulation might need subtotals for all the combinations of month, state, and product. These are three independent dimensions, and analysis of all possible subtotal combinations is commonplace. In contrast, a cross-tabulation showing all possible combinations of year, month, and day would have several values of limited interest, because there is a natural hierarchy in the time dimension. Subtotals such as profit by day of month summed across year would be unnecessary in most analyses. Relatively few users need to ask &#34;What were the total sales for the 16th of each month across the year?&#34; See <span class="q">&#34;<a href="aggreg.htm#GUID-FB38E890-A91B-4645-9422-792E1C9BC238">Hierarchy Handling in ROLLUP and CUBE</a>&#34;</span> for an example of handling rollup calculations efficiently.</p>
</div>
</div>
<a id="DWHSG8617"></a><a id="DWHSG8616"></a>
<div class="props_rev_3"><a id="GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD"></a>
<h3 id="DWHSG-GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD" class="sect3">CUBE Syntax</h3>
<div>
<div class="section">
<p><code class="codeph">CUBE</code> appears in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause in a <code class="codeph">SELECT</code> statement. Its form is:</p>
<pre dir="ltr">SELECT &hellip;  GROUP BY CUBE (grouping_column_reference_list)
</pre></div>
<!-- class="section" -->
<div class="example" id="GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD__I1011609">
<p class="titleinexample">Example 19-3 CUBE Keyword in a Query</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, countries.country_iso_code,
      TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id
 AND customers.country_id = countries.country_id
 AND channels.channel_desc IN
  (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc IN
  (&#39;2000-09&#39;, &#39;2000-10&#39;) AND countries.country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY CUBE(channel_desc, calendar_month_desc, countries.country_iso_code); 

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
                                      1,790,032
                              GB        208,257
                              US      1,581,775
                     2000-09            864,217
                     2000-09  GB        101,792
                     2000-09  US        762,425
                     2000-10            925,815
                     2000-10  GB        106,465
                     2000-10  US        819,351
Internet                                292,387
Internet                      GB         31,109
Internet                      US        261,278
Internet             2000-09            140,793
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-10            151,593
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Direct Sales                          1,497,646
Direct Sales                  GB        177,148
Direct Sales                  US      1,320,497
Direct Sales         2000-09            723,424
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-10            774,222
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
</pre>
<p>This query illustrates <code class="codeph">CUBE</code> aggregation across three dimensions.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8619"></a><a id="DWHSG8618"></a>
<div class="props_rev_3"><a id="GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16"></a>
<h3 id="DWHSG-GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16" class="sect3">Partial CUBE</h3>
<div>
<p><a id="d67728e1079" class="indexterm-anchor"></a>Partial <code class="codeph">CUBE</code> resembles partial <code class="codeph">ROLLUP</code> in that you can limit it to certain dimensions and precede it with columns outside the <code class="codeph">CUBE</code> operator. In this case, subtotals of all possible combinations are limited to the dimensions within the cube list (in parentheses), and they are combined with the preceding items in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> list.</p>
<p>The syntax for partial <code class="codeph">CUBE</code> is as follows:</p>
<pre dir="ltr">GROUP BY expr1, CUBE(expr2, expr3)
</pre>
<p>This syntax example calculates 2*2, or 4, subtotals. That is:</p>
<ul style="list-style-type: disc;">
<li>
<p>(<code class="codeph">expr1</code>, <code class="codeph">expr2</code>, <code class="codeph">expr3</code>)</p>
</li>
<li>
<p>(<code class="codeph">expr1</code>, <code class="codeph">expr2</code>)</p>
</li>
<li>
<p>(<code class="codeph">expr1</code>, <code class="codeph">expr3</code>)</p>
</li>
<li>
<p>(<code class="codeph">expr1</code>)</p>
</li>
</ul>
<div class="example" id="GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16__GUID-0050FA62-8EEE-4C22-A0AA-02AD7AEFE7CF">
<p class="titleinexample">Example 19-4 Partial CUBE in a Query</p>
<p>Using the <code class="codeph">sales</code> database, you can issue the following statement:</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, countries.country_iso_code,
       TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id = times.time_id 
  AND sales.cust_id = customers.cust_id 
  AND customers.country_id=countries.country_id 
  AND sales.channel_id = channels.channel_id 
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;) 
  AND countries.country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY channel_desc, CUBE(calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet                                292,387
Internet                      GB         31,109
Internet                      US        261,278
Internet             2000-09            140,793
Internet             2000-09  GB         16,569
Internet             2000-09  US        124,224
Internet             2000-10            151,593
Internet             2000-10  GB         14,539
Internet             2000-10  US        137,054
Direct Sales                          1,497,646
Direct Sales                  GB        177,148
Direct Sales                  US      1,320,497
Direct Sales         2000-09            723,424
Direct Sales         2000-09  GB         85,223
Direct Sales         2000-09  US        638,201
Direct Sales         2000-10            774,222
Direct Sales         2000-10  GB         91,925
Direct Sales         2000-10  US        682,297
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8620"></a>
<div class="props_rev_3"><a id="GUID-4EEA566F-FCB2-4BCC-9195-933A19EF0197"></a>
<h3 id="DWHSG-GUID-4EEA566F-FCB2-4BCC-9195-933A19EF0197" class="sect3">Calculating Subtotals Without CUBE</h3>
<div>
<p>Just as for <code class="codeph">ROLLUP</code>, multiple <code class="codeph">SELECT</code> statements combined with <code class="codeph">UNION</code> <code class="codeph">ALL</code> statements could provide the same information gathered through <code class="codeph">CUBE</code>. However, this might require many <code class="codeph">SELECT</code> statements. For an n-dimensional cube, 2 to the <span class="italic">n</span> <code class="codeph">SELECT</code> statements are needed. In the three-dimension example, this would mean issuing <code class="codeph">SELECT</code> statements linked with <code class="codeph">UNION</code> <code class="codeph">ALL</code>. So many <code class="codeph">SELECT</code> statements yield inefficient processing and very lengthy SQL.</p>
<p>Consider the impact of adding just one more dimension when calculating all possible combinations: the number of <code class="codeph">SELECT</code> statements would double to 16. The more columns used in a <code class="codeph">CUBE</code> clause, the greater the savings compared to the <code class="codeph">UNION</code> <code class="codeph">ALL</code> approach.</p>
</div>
</div>
</div>
<a id="DWHSG8621"></a>
<div class="props_rev_3"><a id="GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818"></a>
<h2 id="DWHSG-GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818" class="sect2">GROUPING Functions</h2>
<div>
<p><a id="d67728e1250" class="indexterm-anchor"></a><a id="d67728e1252" class="indexterm-anchor"></a>Two challenges arise with the use of <code class="codeph">ROLLUP</code> and <code class="codeph">CUBE</code>. First, how can you programmatically determine which result set rows are subtotals, and how do you find the exact level of aggregation for a given subtotal? You often need to use subtotals in calculations such as percent-of-totals, so you need an easy way to determine which rows are the subtotals. Second, what happens if query results contain both stored <code class="codeph">NULL</code> values and &#34;NULL&#34; values created by a <code class="codeph">ROLLUP</code> or <code class="codeph">CUBE</code>? How can you differentiate between the two? This section discusses some of these situations.</p>
<div class="infoboxnotealso" id="GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818__GUID-66CC9AC2-2309-4B99-9F35-9A0566D73342">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF20038" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF20038"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax and restrictions</p>
</div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5">GROUPING Function</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4">When to Use GROUPING</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1">GROUPING_ID Function</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-6FF4725F-6608-4C29-9917-706BCE885678">GROUP_ID Function</a></p>
</li>
</ul>
</div>
<a id="DWHSG8623"></a><a id="DWHSG8624"></a><a id="DWHSG8622"></a>
<div class="props_rev_3"><a id="GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5"></a>
<h3 id="DWHSG-GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5" class="sect3">GROUPING Function</h3>
<div>
<div class="section">
<p><code class="codeph">GROUPING</code> handles these problems. Using a single column as its argument, <code class="codeph">GROUPING</code> returns 1 when it encounters a <code class="codeph">NULL</code> value created by a <code class="codeph">ROLLUP</code> or <code class="codeph">CUBE</code> operation. That is, if the <code class="codeph">NULL</code> indicates the row is a subtotal, <code class="codeph">GROUPING</code> returns a 1. Any other type of value, including a stored <code class="codeph">NULL</code>, returns a 0.</p>
<p><code class="codeph">GROUPING</code> appears in the selection list portion of a <code class="codeph">SELECT</code> statement. Its form is:</p>
<pre dir="ltr">SELECT &hellip;  [GROUPING(dimension_column)&hellip;]  &hellip; 
  GROUP BY &hellip;    {CUBE | ROLLUP| GROUPING SETS}  (dimension_column)
</pre></div>
<!-- class="section" -->
<div class="example" id="GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5__GUID-16D9DECF-124A-44A5-81E2-1CAB602F5910">
<p class="titleinexample">Example 19-5 GROUPING to Mask Columns</p>
<p>This example uses <code class="codeph">GROUPING</code> to create a set of mask columns for the result set shown in <a href="aggreg.htm#GUID-60430684-FD7B-4C2A-813A-99769D6E19FE__CHDHHCEA">Example 19-2</a>. The mask columns are easy to analyze programmatically.</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, country_iso_code, 
TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$, GROUPING(channel_desc) AS Ch,
   GROUPING(calendar_month_desc) AS Mo, GROUPING(country_iso_code) AS Co
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id 
  AND sales.cust_id=customers.cust_id
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;) 
  AND countries.country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY ROLLUP(channel_desc, calendar_month_desc, countries.country_iso_code);

CHANNEL_DESC         CALENDAR CO SALES$                 CH         MO         CO
-------------------- -------- -- -------------- ---------- ---------- ----------
Internet             2000-09  GB         16,569          0          0          0
Internet             2000-09  US        124,224          0          0          0
Internet             2000-09            140,793          0          0          1
Internet             2000-10  GB         14,539          0          0          0
Internet             2000-10  US        137,054          0          0          0
Internet             2000-10            151,593          0          0          1
Internet                                292,387          0          1          1
Direct Sales         2000-09  GB         85,223          0          0          0
Direct Sales         2000-09  US        638,201          0          0          0
Direct Sales         2000-09            723,424          0          0          1
Direct Sales         2000-10  GB         91,925          0          0          0
Direct Sales         2000-10  US        682,297          0          0          0
Direct Sales         2000-10            774,222          0          0          1
Direct Sales                          1,497,646          0          1          1
                                      1,790,032          1          1          1
</pre>
<p>A program can easily identify the detail rows by a mask of &#34;0 0 0&#34; on the T, R, and D columns. The first level subtotal rows have a mask of &#34;0 0 1&#34;, the second level subtotal rows have a mask of &#34;0 1 1&#34;, and the overall total row has a mask of &#34;1 1 1&#34;.</p>
<p>You can improve the readability of result sets by using the <code class="codeph">GROUPING</code> and <code class="codeph">DECODE</code> functions as shown in <a href="aggreg.htm#GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5__i1006669">Example 19-6</a>.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5__i1006669">
<p class="titleinexample">Example 19-6 GROUPING For Readability</p>
<pre dir="ltr">SELECT DECODE(GROUPING(channel_desc), 1, &#39;Multi-channel sum&#39;, channel_desc) AS
 Channel, DECODE (GROUPING (country_iso_code), 1, &#39;Multi-country sum&#39;,
 country_iso_code) AS Country, TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id 
  AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
  AND times.calendar_month_desc= &#39;2000-09&#39;
  AND country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY CUBE(channel_desc, country_iso_code);

CHANNEL              COUNTRY           SALES$
-------------------- ----------------- --------------
Multi-channel sum    Multi-country sum        864,217
Multi-channel sum    GB                       101,792
Multi-channel sum    US                       762,425
Internet             Multi-country sum        140,793
Internet             GB                        16,569
Internet             US                       124,224
Direct Sales         Multi-country sum        723,424
Direct Sales         GB                        85,223
Direct Sales         US                       638,201
</pre>
<p>To understand the previous statement, note its first column specification, which handles the channel_desc column. Consider the first line of the previous statement:</p>
<pre dir="ltr">SELECT DECODE(GROUPING(channel_desc), 1, &#39;Multi-Channel sum&#39;, channel_desc)AS Channel
</pre>
<p>In this, the <code class="codeph">channel_desc</code> value is determined with a <code class="codeph">DECODE</code> function that contains a <code class="codeph">GROUPING</code> function. The <code class="codeph">GROUPING</code> function returns a 1 if a row value is an aggregate created by <code class="codeph">ROLLUP</code> or <code class="codeph">CUBE</code>, otherwise it returns a 0. The <code class="codeph">DECODE</code> function then operates on the <code class="codeph">GROUPING</code> function&#39;s results. It returns the text &#34;All Channels&#34; if it receives a 1 and the <code class="codeph">channel_desc</code> value from the database if it receives a 0. Values from the database will be either a real value such as &#34;Internet&#34; or a stored <code class="codeph">NULL</code>. The second column specification, displaying <code class="codeph">country_id</code>, works the same way.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8626"></a><a id="DWHSG8625"></a>
<div class="props_rev_3"><a id="GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4"></a>
<h3 id="DWHSG-GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4" class="sect3">When to Use GROUPING</h3>
<div>
<p><a id="d67728e1452" class="indexterm-anchor"></a>The <code class="codeph">GROUPING</code> function is not only useful for identifying <code class="codeph">NULLs</code>, it also enables sorting subtotal rows and filtering results. In <a href="aggreg.htm#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">Example 19-7</a>, you retrieve a subset of the subtotals created by a <code class="codeph">CUBE</code> and none of the base-level aggregations. The <code class="codeph">HAVING</code> clause constrains columns that use <code class="codeph">GROUPING</code> functions.</p>
<div class="example" id="GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">
<p class="titleinexample">Example 19-7 GROUPING Combined with HAVING</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, country_iso_code, TO_CHAR(
SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$, GROUPING(channel_desc) CH, GROUPING
  (calendar_month_desc)  MO, GROUPING(country_iso_code) CO
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;) 
  AND country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY CUBE(channel_desc, calendar_month_desc, country_iso_code)
HAVING (GROUPING(channel_desc)=1 AND GROUPING(calendar_month_desc)= 1 
  AND GROUPING(country_iso_code)=1) OR (GROUPING(channel_desc)=1 
  AND GROUPING (calendar_month_desc)= 1) OR (GROUPING(country_iso_code)=1
  AND GROUPING(calendar_month_desc)= 1);

CHANNEL_DESC         C CO SALES$                 CH         MO         CO
-------------------- - -- -------------- ---------- ---------- ----------
                       US      1,581,775          1          1          0
                       GB        208,257          1          1          0
Direct Sales                   1,497,646          0          1          1
Internet                         292,387          0          1          1
                               1,790,032          1          1          1
</pre>
<p>Compare the result set of <a href="aggreg.htm#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">Example 19-7</a> with that in <a href="aggreg.htm#GUID-60430684-FD7B-4C2A-813A-99769D6E19FE__CHDHHCEA">Example 19-2</a> to see how <a href="aggreg.htm#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">Example 19-7</a> is a precisely specified group: it contains only the yearly totals, regional totals aggregated over time and department, and the grand total.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8628"></a><a id="DWHSG8627"></a>
<div class="props_rev_3"><a id="GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1"></a>
<h3 id="DWHSG-GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1" class="sect3">GROUPING_ID Function</h3>
<div>
<div class="section">
<p>To find the <code class="codeph">GROUP</code> <code class="codeph">BY</code> level of a particular row, a query must return <code class="codeph">GROUPING</code> function information for each of the <code class="codeph">GROUP</code> <code class="codeph">BY</code> columns. If you do this using the <code class="codeph">GROUPING</code> function, every <code class="codeph">GROUP</code> <code class="codeph">BY</code> column requires another column using the <code class="codeph">GROUPING</code> function. For instance, a four-column <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause must be analyzed with four <code class="codeph">GROUPING</code> functions. This is inconvenient to write in SQL and increases the number of columns required in the query. When you want to store the query result sets in tables, as with materialized views, the extra columns waste storage space.</p>
<p>To address these problems, you can use the <code class="codeph">GROUPING_ID</code> function. <code class="codeph">GROUPING_ID</code> returns a single number that enables you to determine the exact <code class="codeph">GROUP</code> <code class="codeph">BY</code> level. For each row, <code class="codeph">GROUPING_ID</code> takes the set of 1&#39;s and 0&#39;s that would be generated if you used the appropriate <code class="codeph">GROUPING</code> functions and concatenates them, forming a bit vector. The bit vector is treated as a binary number, and the number&#39;s base-10 value is returned by the <code class="codeph">GROUPING_ID</code> function. For instance, if you group with the expression <code class="codeph">CUBE(a</code>, <code class="codeph">b)</code> the possible values are as shown in <a href="aggreg.htm#GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1__g1014093" title="GROUPING_ID Example for CUBE(a, b)">Table 19-2</a>.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1__g1014093">
<p class="titleintable">Table 19-2 GROUPING_ID Example for CUBE(a, b)</p>
<table class="cellalignment1516" title="GROUPING_ID Example for CUBE(a, b)" summary="GROUPING_ID Example for CUBE(a, b)">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1523" id="d67728e1605">Aggregation Level</th>
<th class="cellalignment1524" id="d67728e1608">Bit Vector</th>
<th class="cellalignment1525" id="d67728e1611">GROUPING_ID</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1526" id="d67728e1616" headers="d67728e1605">
<p>a, b</p>
</td>
<td class="cellalignment1527" headers="d67728e1616 d67728e1608">
<p>0 0</p>
</td>
<td class="cellalignment1528" headers="d67728e1616 d67728e1611">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1526" id="d67728e1626" headers="d67728e1605">
<p>a</p>
</td>
<td class="cellalignment1527" headers="d67728e1626 d67728e1608">
<p>0 1</p>
</td>
<td class="cellalignment1528" headers="d67728e1626 d67728e1611">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1526" id="d67728e1636" headers="d67728e1605">
<p>b</p>
</td>
<td class="cellalignment1527" headers="d67728e1636 d67728e1608">
<p>1 0</p>
</td>
<td class="cellalignment1528" headers="d67728e1636 d67728e1611">
<p>2</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1526" id="d67728e1646" headers="d67728e1605">
<p>Grand Total</p>
</td>
<td class="cellalignment1527" headers="d67728e1646 d67728e1608">
<p>1 1</p>
</td>
<td class="cellalignment1528" headers="d67728e1646 d67728e1611">
<p>3</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><code class="codeph">GROUPING_ID</code> clearly distinguishes groupings created by grouping set specification, and it is very useful during refresh and rewrite of materialized views.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8630"></a><a id="DWHSG8629"></a>
<div class="props_rev_3"><a id="GUID-6FF4725F-6608-4C29-9917-706BCE885678"></a>
<h3 id="DWHSG-GUID-6FF4725F-6608-4C29-9917-706BCE885678" class="sect3">GROUP_ID Function</h3>
<div>
<div class="section">
<p>While <a id="d67728e1684" class="indexterm-anchor"></a><a id="d67728e1686" class="indexterm-anchor"></a>the extensions to <code class="codeph">GROUP</code> <code class="codeph">BY</code> offer power and flexibility, they also allow complex result sets that can include duplicate groupings. The <code class="codeph">GROUP_ID</code> function lets you distinguish among duplicate groupings. If there are multiple sets of rows calculated for a given level, <code class="codeph">GROUP_ID</code> assigns the value of 0 to all the rows in the first set. All other sets of duplicate rows for a particular grouping are assigned higher values, starting with 1. For example, consider the following query, which generates a duplicate grouping:</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-6FF4725F-6608-4C29-9917-706BCE885678__GUID-7CAADF72-D35F-44E5-9130-5FCB09F8292C">
<p class="titleinexample">Example 19-8 GROUP_ID in a Query</p>
<pre dir="ltr">SELECT country_iso_code, SUBSTR(cust_state_province,1,12), SUM(amount_sold),
  GROUPING_ID(country_iso_code, cust_state_province) GROUPING_ID, GROUP_ID()
FROM sales, customers, times, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id 
  AND customers.country_id=countries.country_id AND times.time_id= &#39;30-OCT-00&#39;
  AND country_iso_code IN (&#39;FR&#39;, &#39;ES&#39;)
GROUP BY GROUPING SETS (country_iso_code,
ROLLUP(country_iso_code, cust_state_province));

CO SUBSTR(CUST_ SUM(AMOUNT_SOLD) GROUPING_ID GROUP_ID()
-- ------------ ---------------- ----------- ----------
ES Alicante               135.32           0          0
ES Valencia              4133.56           0          0
ES Barcelona               24.22           0          0
FR Centre                   74.3           0          0
FR Aquitaine              231.97           0          0
FR Rhtne-Alpes           1624.69           0          0
FR Ile-de-Franc          1860.59           0          0
FR Languedoc-Ro           4287.4           0          0
                        12372.05           3          0
ES                        4293.1           1          0
FR                       8078.95           1          0
ES                        4293.1           1          1
FR                       8078.95           1          1
</pre>
<p>This query generates the following groupings: (<code class="codeph">country_id</code>, <code class="codeph">cust_state_province</code>), (<code class="codeph">country_id</code>), (<code class="codeph">country_id</code>), and (). Note that the grouping (<code class="codeph">country_id</code>) is repeated twice. The syntax for <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> is explained in <span class="q">&#34;<a href="aggreg.htm#GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49">GROUPING SETS Expression</a>&#34;</span>.</p>
<p>This function helps you filter out duplicate groupings from the result. For example, you can filter out duplicate (<code class="codeph">region</code>) groupings from the previous example by adding a <code class="codeph">HAVING</code> clause condition <code class="codeph">GROUP_ID()=0</code> to the query.</p>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8631"></a>
<div class="props_rev_3"><a id="GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49"></a>
<h2 id="DWHSG-GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49" class="sect2">GROUPING SETS Expression</h2>
<div>
<div class="section">
<p>You can s<a id="d67728e1771" class="indexterm-anchor"></a>electively specify the set of groups that you want to create using a <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> expression within a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. This allows precise specification across multiple dimensions without computing the whole <code class="codeph">CUBE</code>. <span class="q">&#34;<a href="aggreg.htm#GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449">GROUPING SETS Syntax</a>&#34;</span> contains the <code class="codeph">GROUPING SETS</code> syntax.</p>
<p>For example, you can say:</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, country_iso_code,
       TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
 (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc IN
 (&#39;2000-09&#39;, &#39;2000-10&#39;) AND country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY GROUPING SETS((channel_desc, calendar_month_desc, country_iso_code),
    (channel_desc, country_iso_code), (calendar_month_desc, country_iso_code));
</pre>
<p>Note that this statement uses composite columns, described in <span class="q">&#34;<a href="aggreg.htm#GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4">About Composite Columns and Grouping</a>&#34;</span>. This statement calculates aggregates over three groupings:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">(channel_desc, calendar_month_desc, country_iso_code)</code></p>
</li>
<li>
<p><code class="codeph">(channel_desc, country_iso_code)</code></p>
</li>
<li>
<p><code class="codeph">(calendar_month_desc, country_iso_code)</code></p>
</li>
</ul>
<p>Compare the previous statement with the following alternative, which uses the <code class="codeph">CUBE</code> operation and the <code class="codeph">GROUPING_ID</code> function to return the desired rows:</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, country_iso_code,
       TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$,
       GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code) gid
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
 (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc IN
 (&#39;2000-09&#39;, &#39;2000-10&#39;) AND country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY CUBE(channel_desc, calendar_month_desc, country_iso_code)
HAVING GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code)=0
  OR GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code)=2
  OR GROUPING_ID(channel_desc, calendar_month_desc, country_iso_code)=4;
</pre>
<p>This statement computes all the 8 (2 *2 *2) groupings, though only the previous 3 groups are of interest to you.</p>
<p>Another alternative is the following statement, which is lengthy due to several unions. This statement requires three scans of the base table, making it inefficient. <code class="codeph">CUBE</code> and <code class="codeph">ROLLUP</code> can be thought of as grouping sets with very specific semantics. For example, consider the following statement:</p>
<pre dir="ltr">CUBE(a, b, c)
</pre>
<p>This statement is equivalent to:</p>
<pre dir="ltr">GROUPING SETS ((a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), ())
ROLLUP(a, b, c)
</pre>
<p>And this statement is equivalent to:</p>
<pre dir="ltr">GROUPING SETS ((a, b, c), (a, b), ())
</pre></div>
<!-- class="section" --></div>
<a id="DWHSG8633"></a><a id="DWHSG8632"></a>
<div class="props_rev_3"><a id="GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449"></a>
<h3 id="DWHSG-GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449" class="sect3">GROUPING SETS Syntax</h3>
<div>
<div class="section">
<p><code class="codeph">GROUPING</code> <code class="codeph">SETS</code> syntax lets you define multiple groupings in the same query. <code class="codeph">GROUP</code> <code class="codeph">BY</code> computes all the groupings specified and combines them with <code class="codeph">UNION</code> <code class="codeph">ALL</code>. For example, consider the following statement:</p>
<pre dir="ltr">GROUP BY GROUPING sets (channel_desc, calendar_month_desc, country_id )
</pre>
<p>This statement is equivalent to:</p>
<pre dir="ltr">GROUP BY channel_desc UNION ALL
GROUP BY calendar_month_desc UNION ALL GROUP BY country_id
</pre>
<p><a href="aggreg.htm#GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449__g1014117" title="GROUPING_SETS Statements and Equivalent GROUP BY">Table 19-3</a> shows grouping sets specification and equivalent <code class="codeph">GROUP</code> <code class="codeph">BY</code> specification. Note that some examples use composite columns.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449__g1014117">
<p class="titleintable">Table 19-3 GROUPING SETS Statements and Equivalent GROUP BY</p>
<table class="cellalignment1516" title="GROUPING SETS Statements and Equivalent GROUP BY" summary="GROUPING_SETS Statements and Equivalent GROUP BY">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1529" id="d67728e1922">GROUPING SETS Statement</th>
<th class="cellalignment1530" id="d67728e1925">Equivalent GROUP BY Statement</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1531" id="d67728e1930" headers="d67728e1922">
<p><code class="codeph">GROUP BY GROUPING SETS(a, b, c)</code></p>
</td>
<td class="cellalignment1532" headers="d67728e1930 d67728e1925">
<p><code class="codeph">GROUP BY a UNION ALL GROUP BY b UNION ALL GROUP BY c</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1531" id="d67728e1939" headers="d67728e1922">
<p><code class="codeph">GROUP BY GROUPING SETS(a, b, (b, c))</code></p>
</td>
<td class="cellalignment1532" headers="d67728e1939 d67728e1925">
<p><code class="codeph">GROUP BY a UNION ALL GROUP BY b UNION ALL GROUP BY b, c</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1531" id="d67728e1948" headers="d67728e1922">
<p><code class="codeph">GROUP BY GROUPING SETS((a, b, c))</code></p>
</td>
<td class="cellalignment1532" headers="d67728e1948 d67728e1925">
<p><code class="codeph">GROUP BY a, b, c</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1531" id="d67728e1957" headers="d67728e1922">
<p><code class="codeph">GROUP BY GROUPING SETS(a, (b), ())</code></p>
</td>
<td class="cellalignment1532" headers="d67728e1957 d67728e1925">
<p><code class="codeph">GROUP BY a UNION ALL GROUP BY b UNION ALL GROUP BY ()</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1531" id="d67728e1966" headers="d67728e1922">
<p><code class="codeph">GROUP BY GROUPING SETS(a, ROLLUP(b, c))</code></p>
</td>
<td class="cellalignment1532" headers="d67728e1966 d67728e1925">
<p><code class="codeph">GROUP BY a UNION ALL GROUP BY ROLLUP(b, c)</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p>In the absence of an optimizer that looks across query blocks to generate the execution plan, a query based on <code class="codeph">UNION</code> would need multiple scans of the base table, sales. This could be very inefficient as fact tables will normally be huge. Using <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> statements, all the groupings of interest are available in the same query block.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8635"></a><a id="DWHSG8634"></a>
<div class="props_rev_3"><a id="GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4"></a>
<h2 id="DWHSG-GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4" class="sect2">About Composite Columns and Grouping</h2>
<div>
<p>A composite <a id="d67728e2010" class="indexterm-anchor"></a>column is a collection of columns that are treated as a unit during the computation of groupings. You specify the columns in parentheses as in the following statement:</p>
<pre dir="ltr">ROLLUP (year, (quarter, month), day)
</pre>
<p>In this statement, the data is not rolled up across year and quarter, but is instead equivalent to the following groupings of a <code class="codeph">UNION</code> <code class="codeph">ALL</code>:</p>
<ul style="list-style-type: disc;">
<li>
<p>(<code class="codeph">year</code>, <code class="codeph">quarter</code>, <code class="codeph">month</code>, <code class="codeph">day</code>),</p>
</li>
<li>
<p>(<code class="codeph">year</code>, <code class="codeph">quarter</code>, <code class="codeph">month</code>),</p>
</li>
<li>
<p>(<code class="codeph">year</code>)</p>
</li>
<li>
<p>()</p>
</li>
</ul>
<p>Here, (<code class="codeph">quarter</code>, <code class="codeph">month</code>) form a composite column and are treated as a unit. In general, composite columns are useful in <code class="codeph">ROLLUP</code>, <code class="codeph">CUBE</code>, <code class="codeph">GROUPING</code> <code class="codeph">SETS</code>, and concatenated groupings. For example, in <code class="codeph">CUBE</code> or <code class="codeph">ROLLUP</code>, composite columns would mean skipping aggregation across certain levels. That is, the following statement:</p>
<pre dir="ltr">GROUP BY ROLLUP(a, (b, c))
</pre>
<p>This is equivalent to:</p>
<pre dir="ltr">GROUP BY a, b, c UNION ALL
GROUP BY a UNION ALL
GROUP BY ()
</pre>
<p>Here, <code class="codeph">(b</code>, <code class="codeph">c)</code> are treated as a unit and rollup will not be applied across <code class="codeph">(b</code>, <code class="codeph">c)</code>. It is as if you have an alias, for example z, for <code class="codeph">(b</code>, <code class="codeph">c)</code> and the <code class="codeph">GROUP</code> <code class="codeph">BY</code> expression reduces to <code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">ROLLUP(a</code>, <code class="codeph">z)</code>. Compare this with the normal rollup as in the following:</p>
<pre dir="ltr">GROUP BY ROLLUP(a, b, c)
</pre>
<p>This would be the following:</p>
<pre dir="ltr">GROUP BY a, b, c UNION ALL
GROUP BY a, b UNION ALL
GROUP BY a UNION ALL
GROUP BY ().
</pre>
<p>Similarly, the following statement is equivalent to the four <code class="codeph">GROUP</code> <code class="codeph">BY</code>s:</p>
<pre dir="ltr">GROUP BY CUBE((a, b), c)

GROUP BY a, b, c UNION ALL
GROUP BY a, b UNION ALL
GROUP BY c UNION ALL
GROUP By ()
</pre>
<p>In <code class="codeph">GROUPING</code> <code class="codeph">SETS</code>, a composite column is used to denote a particular level of <code class="codeph">GROUP</code> <code class="codeph">BY</code>. See <a href="aggreg.htm#GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449__g1014117" title="GROUPING_SETS Statements and Equivalent GROUP BY">Table 19-3</a> for more examples of composite columns.</p>
<div class="example" id="GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4__GUID-7E1D9987-C87A-4746-9183-84A15BF16D50">
<p class="titleinexample">Example 19-9 Composite Columns</p>
<p>You do not have full control over what aggregation levels you want with <code class="codeph">CUBE</code> and <code class="codeph">ROLLUP</code>. For example, consider the following statement:</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, country_iso_code,
 TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id 
  AND customers.country_id = countries.country_id 
  AND sales.channel_id= channels.channel_id 
  AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
  AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;) 
  AND country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY ROLLUP(channel_desc, calendar_month_desc, country_iso_code);
</pre>
<p>This statement results in Oracle computing the following groupings:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">(channel_desc, calendar_month_desc, country_iso_code)</code></p>
</li>
<li>
<p><code class="codeph">(channel_desc, calendar_month_desc)</code></p>
</li>
<li>
<p><code class="codeph">(channel_desc)</code></p>
</li>
<li>
<p><code class="codeph">()</code></p>
</li>
</ul>
<p>If you are just interested in the first, third, and fourth of these groupings, you cannot limit the calculation to those groupings without using composite columns. With composite columns, this is possible by treating month and country as a single unit while rolling up. Columns enclosed in parentheses are treated as a unit while computing <code class="codeph">CUBE</code> and <code class="codeph">ROLLUP</code>. Thus, you would say:</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, country_iso_code,
    TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
      sales.channel_id= channels.channel_id  AND channels.channel_desc IN
 (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc IN
 (&#39;2000-09&#39;, &#39;2000-10&#39;) AND country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY ROLLUP(channel_desc, (calendar_month_desc, country_iso_code));

CHANNEL_DESC         CALENDAR CO SALES$
-------------------- -------- -- --------------
Internet             2000-09  GB        228,241
Internet             2000-09  US        228,241
Internet             2000-10  GB        239,236
Internet             2000-10  US        239,236
Internet                                934,955
Direct Sales         2000-09  GB      1,217,808
Direct Sales         2000-09  US      1,217,808
Direct Sales         2000-10  GB      1,225,584
Direct Sales         2000-10  US      1,225,584
Direct Sales                          4,886,784
                                      5,821,739
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8637"></a><a id="DWHSG8638"></a><a id="DWHSG8636"></a>
<div class="props_rev_3"><a id="GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF"></a>
<h2 id="DWHSG-GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF" class="sect2">Concatenated Groupings and Data Aggregation</h2>
<div>
<p>Concatenated <a id="d67728e2237" class="indexterm-anchor"></a>groupings offer a concise way to generate useful combinations of groupings. Groupings specified with concatenated groupings yield the cross-product of groupings from each grouping set. The cross-product operation enables even a small number of concatenated groupings to generate a large number of final groups. The concatenated groupings are specified simply by listing multiple grouping sets, cubes, and rollups, and separating them with commas. Here is an example of concatenated grouping sets:</p>
<pre dir="ltr">GROUP BY GROUPING SETS(a, b), GROUPING SETS(c, d)
</pre>
<p>This SQL defines the following groupings:</p>
<pre dir="ltr">(a, c), (a, d), (b, c), (b, d)
</pre>
<p>Concatenation of grouping sets is very helpful for these reasons:</p>
<ul style="list-style-type: disc;">
<li>
<p>Ease of query development</p>
<p>You need not enumerate all groupings manually.</p>
</li>
<li>
<p>Use by applications</p>
<p>SQL generated by analytical applications often involves concatenation of grouping sets, with each grouping set defining groupings needed for a dimension.</p>
</li>
</ul>
<div class="example" id="GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF__GUID-B9D01A95-626F-4A86-9D8C-3C4F47B88A21">
<p class="titleinexample">Example 19-10 Concatenated Groupings</p>
<p>You can also specify more than one grouping in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. For example, if you want aggregated sales values for each product rolled up across all levels in the <code class="codeph">time</code> dimension (<code class="codeph">year</code>, <code class="codeph">month</code> and <code class="codeph">day</code>), and across all levels in the <code class="codeph">geography</code> dimension (<code class="codeph">region</code>), you can issue the following statement:</p>
<pre dir="ltr">SELECT channel_desc, calendar_year, calendar_quarter_desc, country_iso_code,
  cust_state_province, TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id 
 AND sales.channel_id = channels.channel_id AND countries.country_id =
    customers.country_id AND channels.channel_desc IN
   (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc IN (&#39;2000-09&#39;,
 &#39;2000-10&#39;) AND countries.country_iso_code IN (&#39;GB&#39;, &#39;FR&#39;)
GROUP BY channel_desc, GROUPING SETS (ROLLUP(calendar_year,
   calendar_quarter_desc),
ROLLUP(country_iso_code, cust_state_province));
</pre>
<p>This results in the following groupings:</p>
</div>
<!-- class="example" -->
<ul style="list-style-type: disc;">
<li>
<p>(<code class="codeph">channel_desc</code>, <code class="codeph">calendar_year</code>, <code class="codeph">calendar_quarter_desc</code>)</p>
</li>
<li>
<p>(<code class="codeph">channel_desc</code>, <code class="codeph">calendar_year</code>)</p>
</li>
<li>
<p>(<code class="codeph">channel_desc</code>)</p>
</li>
<li>
<p>(<code class="codeph">channel_desc</code>, <code class="codeph">country_iso_code</code>, <code class="codeph">cust_state_province</code>)</p>
</li>
<li>
<p>(<code class="codeph">channel_desc</code>, <code class="codeph">country_iso_code</code>)</p>
</li>
<li>
<p>(<code class="codeph">channel_desc</code>)</p>
</li>
</ul>
<p>This is the cross-product of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>The expression, <code class="codeph">channel_desc</code></p>
</li>
<li>
<p><code class="codeph">ROLLUP</code>(<code class="codeph">calendar_year</code>, <code class="codeph">calendar_quarter_desc</code>), which is equivalent to ((<code class="codeph">calendar_year</code>, <code class="codeph">calendar_quarter_desc</code>), (<code class="codeph">calendar_year</code>), ())</p>
</li>
<li>
<p><code class="codeph">ROLLUP(country_iso_code, cust_state_province)</code>, which is equivalent to ((<code class="codeph">country_iso_code</code>, <code class="codeph">cust_state_province</code>), (<code class="codeph">country_iso_code</code>), ())</p>
</li>
</ul>
<p>Note that the output contains two occurrences of (<code class="codeph">channel_desc</code>) group. To filter out the extra (<code class="codeph">channel_desc</code>) group, the query could use a <code class="codeph">GROUP_ID</code> function.</p>
<p>Another concatenated join example is <a href="aggreg.htm#GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF__CHDJHEJJ">Example 19-11</a>, showing the cross product of two grouping sets.</p>
<div class="example" id="GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF__CHDJHEJJ">
<p class="titleinexample">Example 19-11 Concatenated Groupings (Cross-Product of Two Grouping Sets)</p>
<pre dir="ltr">SELECT country_iso_code, cust_state_province, calendar_year, 
calendar_quarter_desc, TO_CHAR(SUM(amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
 countries.country_id=customers.country_id  AND
  sales.channel_id= channels.channel_id AND channels.channel_desc IN
 (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc IN
 (&#39;2000-09&#39;, &#39;2000-10&#39;) AND country_iso_code IN (&#39;GB&#39;, &#39;FR&#39;)
GROUP BY GROUPING SETS (country_iso_code, cust_state_province),
         GROUPING SETS (calendar_year, calendar_quarter_desc);
</pre>
<p>This statement results in the computation of groupings:</p>
</div>
<!-- class="example" -->
<ul style="list-style-type: disc;">
<li>
<p>(<code class="codeph">country_iso_code</code>, <code class="codeph">year</code>), (<code class="codeph">country_iso_code</code>, <code class="codeph">calendar_quarter_desc</code>), (<code class="codeph">cust_state_province</code>, <code class="codeph">year</code>) and (<code class="codeph">cust_state_province</code>, <code class="codeph">calendar_quarter_desc</code>)</p>
</li>
</ul>
</div>
<a id="DWHSG8640"></a><a id="DWHSG8641"></a><a id="DWHSG8639"></a>
<div class="props_rev_3"><a id="GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8"></a>
<h3 id="DWHSG-GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8" class="sect3">Concatenated Groupings and Hierarchical Data Cubes</h3>
<div>
<p>One of the most importan<a id="d67728e2466" class="indexterm-anchor"></a>t uses for concatenated groupings is to generate the aggregates needed for a hierarchical cube of data. A hierarchical cube is a data set where the data is aggregated along the rollup hierarchy of each of its dimensions and these aggregations are combined across dimensions. It includes the typical set of aggregations needed for business intelligence queries. By using concatenated groupings, you can generate all the aggregations needed by a hierarchical cube with just <span class="italic">n</span> <code class="codeph">ROLLUP</code>s (where <span class="italic">n</span> is the number of dimensions), and avoid generating unwanted aggregations.</p>
<p>Consider just three of the dimensions in the <code class="codeph">sh</code> sample schema data set, each of which has a multilevel hierarchy:</p>
<ul style="list-style-type: disc;">
<li>
<p>time: <code class="codeph">year</code>, <code class="codeph">quarter</code>, <code class="codeph">month</code>, <code class="codeph">day</code> (<code class="codeph">week</code> is in a separate hierarchy)</p>
</li>
<li>
<p>product: <code class="codeph">category</code>, <code class="codeph">subcategory</code>, <code class="codeph">prod_name</code></p>
</li>
<li>
<p>geography: <code class="codeph">region</code>, <code class="codeph">subregion</code>, <code class="codeph">country</code>, <code class="codeph">state</code>, <code class="codeph">city</code></p>
</li>
</ul>
<p>This data is represented using a column for each level of the hierarchies, creating a total of twelve columns for dimensions, plus the columns holding sales figures.</p>
<p>For your business intelligence needs, you would like to calculate and store certain aggregates of the various combinations of dimensions. In <a href="aggreg.htm#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">Example 19-12</a>, you create the aggregates for all levels, except for &#34;day&#34;, which would create too many rows. In particular, you want to use <code class="codeph">ROLLUP</code> within each dimension to generate useful aggregates. Once you have the <code class="codeph">ROLLUP</code>-based aggregates within each dimension, you want to combine them with the other dimensions. This will generate a hierarchical cube. Note that this is not at all the same as a <code class="codeph">CUBE</code> using all twelve of the dimension columns: that would create 2 to the 12th power (4,096) aggregation groups, of which you need only a small fraction. Concatenated grouping sets make it easy to generate exactly the aggregations you need. <a href="aggreg.htm#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">Example 19-12</a> shows where a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause is needed.</p>
<div class="example" id="GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">
<p class="titleinexample">Example 19-12 Concatenated Groupings and Hierarchical Cubes</p>
<pre dir="ltr">SELECT calendar_year, calendar_quarter_desc, calendar_month_desc,
  country_region, country_subregion, countries.country_iso_code, 
 cust_state_province, cust_city, prod_category_desc, prod_subcategory_desc, 
 prod_name, TO_CHAR(SUM (amount_sold), &#39;9,999,999,999&#39;) SALES$
FROM sales, customers, times, channels, countries, products
WHERE sales.time_id=times.time_id AND sales.cust_id=customers.cust_id AND
  sales.channel_id= channels.channel_id AND sales.prod_id=products.prod_id AND
  customers.country_id=countries.country_id AND channels.channel_desc IN
 (&#39;Direct Sales&#39;, &#39;Internet&#39;) AND times.calendar_month_desc IN
 (&#39;2000-09&#39;, &#39;2000-10&#39;) AND prod_name IN (&#39;Envoy Ambassador&#39;,
 &#39;Mouse Pad&#39;) AND countries.country_iso_code IN (&#39;GB&#39;, &#39;US&#39;)
GROUP BY ROLLUP(calendar_year, calendar_quarter_desc, calendar_month_desc),
  ROLLUP(country_region, country_subregion, countries.country_iso_code,
         cust_state_province, cust_city),
  ROLLUP(prod_category_desc, prod_subcategory_desc, prod_name);
</pre>
<p>The rollups in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> specification generate the following groups, four for each dimension.</p>
</div>
<!-- class="example" -->
<div class="tblformalwide" id="GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__BABEHGHD">
<p class="titleintable">Table 19-4 Hierarchical CUBE Example</p>
<table class="cellalignment1533" title="Hierarchical CUBE Example" summary="Hierarchical CUBE Examples">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1519" id="d67728e2580">ROLLUP By Time</th>
<th class="cellalignment1523" id="d67728e2583">ROLLUP By Product</th>
<th class="cellalignment1529" id="d67728e2586">ROLLUP By Geography</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1522" id="d67728e2591" headers="d67728e2580">
<p><code class="codeph">year, quarter, month</code></p>
</td>
<td class="cellalignment1526" headers="d67728e2591 d67728e2583">
<p><code class="codeph">category, subcategory, name</code></p>
</td>
<td class="cellalignment1531" headers="d67728e2591 d67728e2586">
<p><code class="codeph">region, subregion, country, state, city</code></p>
<p><code class="codeph">region, subregion, country, state</code></p>
<p><code class="codeph">region, subregion, country</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1522" id="d67728e2610" headers="d67728e2580">
<p><code class="codeph">year, quarter</code></p>
</td>
<td class="cellalignment1526" headers="d67728e2610 d67728e2583">
<p><code class="codeph">category, subcategory</code></p>
</td>
<td class="cellalignment1531" headers="d67728e2610 d67728e2586">
<p><code class="codeph">region, subregion</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1522" id="d67728e2623" headers="d67728e2580">
<p><code class="codeph">year</code></p>
</td>
<td class="cellalignment1526" headers="d67728e2623 d67728e2583">
<p><code class="codeph">category</code></p>
</td>
<td class="cellalignment1531" headers="d67728e2623 d67728e2586">
<p><code class="codeph">region</code></p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1522" id="d67728e2636" headers="d67728e2580">
<p><code class="codeph">all times</code></p>
</td>
<td class="cellalignment1526" headers="d67728e2636 d67728e2583">
<p><code class="codeph">all products</code></p>
</td>
<td class="cellalignment1531" headers="d67728e2636 d67728e2586">
<p><code class="codeph">all geographies</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The concatenated grouping sets specified in the previous SQL will take the <code class="codeph">ROLLUP</code> aggregations listed in the table and perform a cross-product on them. The cross-product will create the 96 (4x4x6) aggregate groups needed for a hierarchical cube of the data. There are major advantages in using three <code class="codeph">ROLLUP</code> expressions to replace what would otherwise require 96 grouping set expressions: the concise SQL is far less error-prone to develop and far easier to maintain, and it enables much better query optimization. You can picture how a cube with more dimensions and more levels would make the use of concatenated groupings even more advantageous.</p>
<p>See <span class="q">&#34;<a href="aggreg.htm#GUID-FB000241-BE8E-43F4-9789-24A0472AB193">Working with Hierarchical Cubes in SQL</a>&#34;</span> for more information regarding hierarchical cubes.</p>
</div>
</div>
</div>
<a id="DWHSG8642"></a>
<div class="props_rev_3"><a id="GUID-F33D5E19-33B8-424F-A717-D30EDA3D08D6"></a>
<h2 id="DWHSG-GUID-F33D5E19-33B8-424F-A717-D30EDA3D08D6" class="sect2">Considerations when Using Aggregation in Data Warehouses</h2>
<div>
<p>This section discusses the following topics.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-FB38E890-A91B-4645-9422-792E1C9BC238">Hierarchy Handling in ROLLUP and CUBE</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-D4CEA4CE-3890-4440-AFC7-3634EA01FAFA">Column Capacity in ROLLUP and CUBE</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-66EBA3D0-211F-4A57-BA95-1A8A93D77360">HAVING Clause Used with GROUP BY Extensions</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-496C3409-51FA-4DE5-BF5F-6DF793E322F7">ORDER BY Clause Used with GROUP BY Extensions</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-DDCF4BCB-A56B-4C14-9056-75452022F43B">Using Other Aggregate Functions with ROLLUP and CUBE</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1">Using In-Memory Aggregation</a></p>
</li>
</ul>
</div>
<a id="DWHSG8644"></a><a id="DWHSG8643"></a>
<div class="props_rev_3"><a id="GUID-FB38E890-A91B-4645-9422-792E1C9BC238"></a>
<h3 id="DWHSG-GUID-FB38E890-A91B-4645-9422-792E1C9BC238" class="sect3">Hierarchy Handling in ROLLUP and CUBE</h3>
<div>
<p>The <code class="codeph">ROLLUP</code> and <code class="codeph">CUBE</code> extensions work independently of any hierarchy metadata in your system. Their calculations are based entirely on the columns specified in the <code class="codeph">SELECT</code> statement in which they appear. This approach enables <code class="codeph">CUBE</code> and <code class="codeph">ROLLUP</code> to be used whether or not hierarchy metadata is available. The simplest way to handle levels in hierarchical dimensions is by using the <code class="codeph">ROLLUP</code> extension and indicating levels explicitly through separate columns. The following code shows a simple example of this with months rolled up to quarters and quarters rolled up to years.</p>
<div class="example" id="GUID-FB38E890-A91B-4645-9422-792E1C9BC238__GUID-AFCD8C7F-019B-48E6-BC2E-357E8C2E91CD">
<p class="titleinexample">Example 19-13 ROLLUP and CUBE Hierarchy Handling</p>
<pre dir="ltr">SELECT calendar_year, calendar_quarter_number,
    calendar_month_number, SUM(amount_sold)
FROM sales, times, products, customers, countries
WHERE sales.time_id=times.time_id 
  AND sales.prod_id=products.prod_id 
  AND customers.country_id = countries.country_id 
  AND sales.cust_id=customers.cust_id 
  AND prod_name IN (&#39;Envoy Ambassador&#39;, &#39;Mouse Pad&#39;) 
  AND country_iso_code = &#39;GB&#39; AND calendar_year=1999
GROUP BY ROLLUP(calendar_year, calendar_quarter_number, calendar_month_number);

CALENDAR_YEAR CALENDAR_QUARTER_NUMBER CALENDAR_MONTH_NUMBER SUM(AMOUNT_SOLD)
------------- ----------------------- --------------------- ----------------
         1999                       1                     1          5521.34
         1999                       1                     2         22232.95
         1999                       1                     3         10672.63
         1999                       1                               38426.92
         1999                       2                     4         23658.05
         1999                       2                     5          5766.31
         1999                       2                     6         23939.32
         1999                       2                               53363.68
         1999                       3                     7         12132.18
         1999                       3                     8         13128.96
         1999                       3                     9         19571.96
         1999                       3                                44833.1
         1999                       4                    10         15752.18
         1999                       4                    11          7011.21
         1999                       4                    12          14257.5
         1999                       4                               37020.89
         1999                                                      173644.59
                                                                   173644.59
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8645"></a>
<div class="props_rev_3"><a id="GUID-D4CEA4CE-3890-4440-AFC7-3634EA01FAFA"></a>
<h3 id="DWHSG-GUID-D4CEA4CE-3890-4440-AFC7-3634EA01FAFA" class="sect3">Column Capacity in ROLLUP and CUBE</h3>
<div>
<p><code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, and <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> do not restrict the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause column capacity. The <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, with or without the extensions, can work with up to 255 columns. However, the combinatorial explosion of <code class="codeph">CUBE</code> makes it unwise to specify a large number of columns with the <code class="codeph">CUBE</code> extension. Consider that a 20-column list for <code class="codeph">CUBE</code> would create 2 to the 20 combinations in the result set. A very large <code class="codeph">CUBE</code> list could strain system resources, so any such query must be tested carefully for performance and the load it places on the system.</p>
</div>
</div>
<a id="DWHSG8646"></a>
<div class="props_rev_3"><a id="GUID-66EBA3D0-211F-4A57-BA95-1A8A93D77360"></a>
<h3 id="DWHSG-GUID-66EBA3D0-211F-4A57-BA95-1A8A93D77360" class="sect3">HAVING Clause Used with GROUP BY Extensions</h3>
<div>
<p>The <code class="codeph">HAVING</code> clause of <code class="codeph">SELECT</code> statements is unaffected by the use of <code class="codeph">GROUP</code> <code class="codeph">BY</code>. Note that the conditions specified in the <code class="codeph">HAVING</code> clause apply to both the subtotal and non-subtotal rows of the result set. In some cases a query may need to exclude the subtotal rows or the non-subtotal rows from the <code class="codeph">HAVING</code> clause. This can be achieved by using a <code class="codeph">GROUPING</code> or <code class="codeph">GROUPING_ID</code> function together with the <code class="codeph">HAVING</code> clause. See <a href="aggreg.htm#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">Example 19-7</a> and its associated SQL statement for an example.</p>
</div>
</div>
<a id="DWHSG8647"></a>
<div class="props_rev_3"><a id="GUID-496C3409-51FA-4DE5-BF5F-6DF793E322F7"></a>
<h3 id="DWHSG-GUID-496C3409-51FA-4DE5-BF5F-6DF793E322F7" class="sect3">ORDER BY Clause Used with GROUP BY Extensions</h3>
<div>
<p>In many cases, a query must order the rows in a certain way, and this is done with the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause. The <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause of a <code class="codeph">SELECT</code> statement is unaffected by the use of <code class="codeph">GROUP</code> <code class="codeph">BY</code>, because the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause is applied after the <code class="codeph">GROUP</code> <code class="codeph">BY</code> calculations are complete.</p>
<p>Note that the <code class="codeph">ORDER</code> <code class="codeph">BY</code> specification makes no distinction between aggregate and non-aggregate rows of the result set. For instance, you might wish to list sales figures in declining order, but still have the subtotals at the end of each group. Simply ordering sales figures in descending sequence will not be sufficient, because that will place the subtotals (the largest values) at the start of each group. Therefore, it is essential that the columns in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause include columns that differentiate aggregate from non-aggregate columns. This requirement means that queries using <code class="codeph">ORDER</code> <code class="codeph">BY</code> along with aggregation extensions to <code class="codeph">GROUP</code> <code class="codeph">BY</code> will generally need to use one or more of the <code class="codeph">GROUPING</code> functions.</p>
</div>
</div>
<a id="DWHSG8648"></a>
<div class="props_rev_3"><a id="GUID-DDCF4BCB-A56B-4C14-9056-75452022F43B"></a>
<h3 id="DWHSG-GUID-DDCF4BCB-A56B-4C14-9056-75452022F43B" class="sect3">Using Other Aggregate Functions with ROLLUP and CUBE</h3>
<div>
<p>The examples in this chapter show <code class="codeph">ROLLUP</code> and <code class="codeph">CUBE</code> used with the <code class="codeph">SUM</code> function. While this is the most common type of aggregation, these extensions can also be used with all other functions available to the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, for example, <code class="codeph">COUNT</code>, <code class="codeph">AVG</code>, <code class="codeph">MIN</code>, <code class="codeph">MAX</code>, <code class="codeph">STDDEV</code>, and <code class="codeph">VARIANCE</code>. <code class="codeph">COUNT</code>, which is often needed in cross-tabular analyses, is likely to be the second most commonly used function.</p>
</div>
</div>
<a id="DWHSG9336"></a><a id="DWHSG9337"></a><a id="DWHSG9335"></a>
<div class="props_rev_3"><a id="GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1"></a>
<h3 id="DWHSG-GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1" class="sect3">Using In-Memory Aggregation</h3>
<div>
<div class="section">
<p>Analytic queries typically attempt to find patterns and trends by performing complex aggregations on data. In-memory aggregation uses <code class="codeph">KEY VECTOR</code> and <code class="codeph">VECTOR GROUP BY</code> operations to optimize query blocks involving aggregation and joins from a single large table to multiple small tables, such as in a typical star query. These operations use efficient in-memory arrays for joins and aggregation, and are especially effective when the underlying tables are stored in the In-Memory Column Store (IM column store).</p>
<p>The <code class="codeph">VECTOR GROUP BY</code> transformation is an optimization transformation that enables efficient in-memory array-based aggregation. It accumulates aggregate values into in-memory arrays during table scans. This results in enhanced performance for joins and joins and aggregates.</p>
<p>The <code class="codeph">VECTOR GROUP BY</code> transformation is a two-part process, similar to that of star transformation, that involves the following steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>The dimension tables are scanned and any <code class="codeph">WHERE</code> clause predicates are applied. A new data structure called a key vector is created based on the results of these scans.</span>
<div>
<p>The key vector is similar to a bloom filter as it allows the join predicates to be applied as additional filter predicates during the scan of the fact table, but it also enables Oracle Database to conduct the <code class="codeph">GROUP BY</code> or aggregation during the scan of the fact table instead of having to do it afterwards.</p>
</div>
</li>
<li class="stepexpand"><span>The results of the fact table scan are joined back to the temporary tables created as part of the key vector creation.</span></li>
</ol>
<div class="section">
<p>The combination of these two phases dramatically improves the efficiency of a multiple table join with complex aggregations. Both phases are visible in the execution plan of your query.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1__GUID-10E1B395-5DC0-4DCB-94C7-BC81162940A0">
<p class="titleinexample">Example 19-14 Example: Aggregation Using VECTOR GROUP BY Transformation</p>
<p>Consider the following query that joins the <code class="codeph">products</code>, <code class="codeph">customers</code>, and <code class="codeph">times</code> dimensions with the <code class="codeph">sales</code> fact table:</p>
<pre dir="ltr">SELECT p.department_name, c.customer_id, t.fiscal_year, SUM(sales)
FROM PRODUCTS p, CUSTOMERS c, TIMES t, SALES s
WHERE p.product_id = s.product_id AND c.customer_id = s.customer_id 
     AND t.time_id = s.time_id
GROUP BY p.department_name, c.customer_id, t.fiscal_year;
</pre>
<p>When the IM column store is configured, the Optimizer rewrites this query to use vector joins and <code class="codeph">VECTOR GROUP BY</code> aggregation. <a href="aggreg.htm#GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1__BCGEIDGA">Figure 19-2</a> describes how aggregation is performed using <code class="codeph">VECTOR GROUP BY</code>. The predicates on the dimension tables <code class="codeph">PRODUCTS</code>, <code class="codeph">CUSTOMERS</code>, and <code class="codeph">TIMES</code> are converted to filters on the fact table <code class="codeph">SALES</code>. The <code class="codeph">GROUP BY</code> is performed simultaneously with the scan of the <code class="codeph">SALES</code> table by using in-memory arrays.</p>
<div class="figure" id="GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1__BCGEIDGA">
<p class="titleinfigure">Figure 19-2 VECTOR GROUP BY Using Oracle In-Memory Column Store</p>
<img width="805" height="598" src="img/GUID-4D354C13-504E-437D-A337-15948821C214-default.gif" alt="Description of Figure 19-2 follows" title="Description of Figure 19-2 follows"/><br/>
<a href="img_text/GUID-4D354C13-504E-437D-A337-15948821C214-print.htm">Description of &#34;Figure 19-2 VECTOR GROUP BY Using Oracle In-Memory Column Store&#34;</a></div>
<!-- class="figure" --></div>
<!-- class="example" --></div>
</div>
</div>
<a id="DWHSG8650"></a><a id="DWHSG8649"></a>
<div class="props_rev_3"><a id="GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905"></a>
<h2 id="DWHSG-GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905" class="sect2">Computation Using the WITH Clause</h2>
<div>
<p>The <code class="codeph">WITH</code> clause (formally known as <code class="codeph">subquery_factoring_clause</code>) enables you to reuse the same query block in a <code class="codeph">SELECT</code> statement when it occurs more than once within a complex query. <code class="codeph">WITH</code> is a part of the SQL-99 standard. This is particularly useful when a query has multiple references to the same query block and there are joins and aggregations. Using the <code class="codeph">WITH</code> clause, Oracle retrieves the results of a query block and stores them in the user&#39;s temporary tablespace. Note that Oracle Database does not support recursive use of the <code class="codeph">WITH</code> clause. Note that Oracle Database supports recursive use of the <code class="codeph">WITH</code> clause that may be used for such queries as are used with a bill of materials or expansion of parent-child hierarchies to parent-descendant hierarchies. See <a class="olink SQLRF54208" target="_blank" href="../SQLRF/statements_6003.htm#SQLRF54208"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
<p>The following query is an example of where you can improve performance and write SQL more simply by using the <code class="codeph">WITH</code> clause. The query calculates the sum of sales for each channel and holds it under the name <code class="codeph">channel_summary</code>. Then it checks each channel&#39;s sales total to see if any channel&#39;s sales are greater than one third of the total sales. By using the <code class="codeph">WITH</code> clause, the <code class="codeph">channel_summary</code> data is calculated just once, avoiding an extra scan through the large sales table.</p>
<div class="example" id="GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905__GUID-C87D4E27-A805-41F7-BDF3-A4F95EF48890">
<p class="titleinexample">Example 19-15 WITH Clause</p>
<pre dir="ltr">WITH channel_summary AS (SELECT channels.channel_desc, SUM(amount_sold)
AS channel_total FROM sales, channels
WHERE sales.channel_id = channels.channel_id GROUP BY channels.channel_desc)
SELECT channel_desc, channel_total
FROM channel_summary WHERE channel_total &gt; (SELECT SUM(channel_total) * 1/3
FROM channel_summary);

CHANNEL_DESC         CHANNEL_TOTAL
-------------------- -------------
Direct Sales            57875260.6
</pre>
<p>Note that this example could also be performed efficiently using the reporting aggregate functions described in <a href="analysis.htm#GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684">SQL for Analysis and Reporting</a>.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8651"></a>
<div class="props_rev_3"><a id="GUID-FB000241-BE8E-43F4-9789-24A0472AB193"></a>
<h2 id="DWHSG-GUID-FB000241-BE8E-43F4-9789-24A0472AB193" class="sect2">Working with Hierarchical Cubes in SQL</h2>
<div>
<p>This section illustrates<a id="d67728e3252" class="indexterm-anchor"></a> examples of working with hierarchical cubes. It contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-571478D7-A536-4574-896D-05ACDBD6AB4B">Specifying Hierarchical Cubes in SQL</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6">Querying Hierarchical Cubes in SQL</a></p>
</li>
</ul>
</div>
<a id="DWHSG8653"></a><a id="DWHSG8652"></a>
<div class="props_rev_3"><a id="GUID-571478D7-A536-4574-896D-05ACDBD6AB4B"></a>
<h3 id="DWHSG-GUID-571478D7-A536-4574-896D-05ACDBD6AB4B" class="sect3">Specifying Hierarchical Cubes in SQL</h3>
<div>
<div class="section">
<p>Oracle <a id="d67728e3292" class="indexterm-anchor"></a>Database can specify hierarchical cubes in a simple and efficient SQL query. These hierarchical cubes represent the logical cubes referred to in many analytical SQL products. To specify data in the form of hierarchical cubes, you can use one of the extensions to the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, concatenated grouping sets, to generate the aggregates needed for a hierarchical cube of data. By using concatenated rollup (rolling up along the hierarchy of each dimension and then concatenate them across multiple dimensions), you can generate all the aggregations needed by a hierarchical cube.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-571478D7-A536-4574-896D-05ACDBD6AB4B__GUID-BFBACA15-30BC-498F-8502-D7EC8528F543">
<p class="titleinexample">Example 19-16 Concatenated ROLLUP</p>
<p>The following <a id="d67728e3306" class="indexterm-anchor"></a><a id="d67728e3308" class="indexterm-anchor"></a>shows the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause needed to create a hierarchical cube for a 2-dimensional example similar to <a href="aggreg.htm#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">Example 19-12</a>. The following simple syntax performs a concatenated rollup:</p>
<pre dir="ltr">GROUP BY ROLLUP(year, quarter, month), ROLLUP(Division, brand, item)
</pre>
<p>This concatenated rollup takes the <code class="codeph">ROLLUP</code> aggregations similar to those listed in <a href="aggreg.htm#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__BABEHGHD" title="Hierarchical CUBE Examples">Table 19-4</a> in the prior section and performs a cross-product on them. The cross-product will create the 16 (4x4) aggregate groups needed for a hierarchical cube of the data.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8655"></a><a id="DWHSG8654"></a>
<div class="props_rev_3"><a id="GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6"></a>
<h3 id="DWHSG-GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6" class="sect3">Querying Hierarchical Cubes in SQL</h3>
<div>
<div class="section">
<p>Analytic applications treat data as cubes, but they want only certain slices and regions of the cube. Concatenated rollup (hierarchical cube) enables relational data to be treated as cubes. To handle complex analytic queries, the fundamental technique is to enclose a hierarchical cube query in an outer query that specifies the exact slice needed from the cube. Oracle Database optimizes the processing of hierarchical cubes nested inside slicing queries. By applying many powerful algorithms, these queries can be processed at unprecedented speed and scale. This enables SQL analytical tools and applications to use a consistent style of queries to handle the most complex questions.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6__GUID-012DD16E-5AA3-43D9-A823-CE3C12E1DF75">
<p class="titleinexample">Example 19-17 Hierarchical Cube Query</p>
<p>Consider the following analytic query. It consists of a hierarchical cube query nested in a slicing query.</p>
<pre dir="ltr">SELECT month, division, sum_sales FROM
  (SELECT year, quarter, month, division, brand, item, SUM(sales) sum_sales,
      GROUPING_ID(<span class="italic">grouping-columns</span>) gid
   FROM sales, products, time
   WHERE <span class="italic">join-condition</span>
   GROUP BY ROLLUP(year, quarter, month),
            ROLLUP(division, brand, item))
WHERE division = 25 AND month = 200201 AND gid = <span class="italic">gid-for-Division-Month</span>;
</pre>
<p>The inner hierarchical cube specified defines a simple cube, with two dimensions and four levels in each dimension. It would generate 16 groups (4 Time levels * 4 Product levels). The <code class="codeph">GROUPING_ID</code> function in the query identifies the specific group each row belongs to, based on the aggregation level of the <span class="italic">grouping-columns</span> in its argument.</p>
<p>The outer query applies the constraints needed for our specific query, limiting Division to a value of 25 and Month to a value of 200201 (representing January 2002 in this case). In conceptual terms, it slices a small chunk of data from the cube. The outer query&#39;s constraint on the <code class="codeph">GID</code> column, indicated in the query by <span class="italic">gid-for-division-month</span> would be the value of a key indicating that the data is grouped as a combination of <code class="codeph">division</code> and <code class="codeph">month</code>. The <code class="codeph">GID</code> constraint selects only those rows that are aggregated at the level of a <code class="codeph">GROUP</code> <code class="codeph">BY</code> month, division clause.</p>
<p>Oracle Database removes unneeded aggregation groups from query processing based on the outer query conditions. The outer conditions of the previous query limit the result set to a single group aggregating <code class="codeph">division</code> and <code class="codeph">month</code>. Any other groups involving <code class="codeph">year</code>, <code class="codeph">month</code>, <code class="codeph">brand</code>, and <code class="codeph">item</code> are unnecessary here. The group pruning optimization recognizes this and transforms the query into:</p>
<pre dir="ltr">SELECT month, division, sum_sales
FROM (SELECT  <span class="bold">null</span>, <span class="bold">null</span>,  month, division, <span class="bold">null</span>, <span class="bold">null</span>, SUM(sales) sum_sales,
      GROUPING_ID(<span class="italic">grouping-columns</span>) gid
      FROM sales, products, time WHERE <span class="italic">join-condition</span>
   <span class="bold">GROUP BY month</span>, <span class="bold">division</span>)
WHERE division = 25 AND month = 200201 AND gid = <span class="italic">gid-for-Division-Month</span>;
</pre>
<p>The bold items highlight the changed SQL. The inner query now has a simple <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of <code class="codeph">month</code>, <code class="codeph">division</code>. The columns <code class="codeph">year</code>, <code class="codeph">quarter</code>, <code class="codeph">brand</code>, and <code class="codeph">item</code> have been converted to null to match the simplified <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. Because the query now requests just one group, fifteen out of sixteen groups are removed from the processing, greatly reducing the work. For a cube with more dimensions and more levels, the savings possible through group pruning can be far greater. Note that the group pruning transformation works with all the <code class="codeph">GROUP</code> <code class="codeph">BY</code> extensions: <code class="codeph">ROLLUP</code>, <code class="codeph">CUBE</code>, and <code class="codeph">GROUPING</code> <code class="codeph">SETS</code>.</p>
<p>While the optimizer has simplified the previous query to a simple <code class="codeph">GROUP</code> <code class="codeph">BY</code>, faster response times can be achieved if the group is precomputed and stored in a materialized view. Because online analytical queries can ask for any slice of the cube many groups may need to be precomputed and stored in a materialized view. This is discussed in the next section.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="aggreg.htm#GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C">SQL for Creating Materialized Views to Store Hierarchical Cubes</a></p>
</li>
<li>
<p><a href="aggreg.htm#GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0">Examples of Hierarchical Cube Materialized Views</a></p>
</li>
</ul>
</div>
<!-- class="example" --></div>
<a id="DWHSG8656"></a>
<div class="props_rev_3"><a id="GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C"></a>
<h4 id="DWHSG-GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C" class="sect4">SQL for Creating Materialized Views to Store Hierarchical Cubes</h4>
<div>
<p>Analytical SQL requires fast response times for multiple users, and this in turn demands that significant parts of a cube be precomputed and held in materialized views.</p>
<p>Data warehouse designers can choose exactly how much data to materialize. A data warehouse can have the full hierarchical cube materialized. While this will take the most storage space, it ensures quick response for any query within the cube. Alternatively, a data warehouse could have just partial materialization, saving storage space, but allowing only a subset of possible queries to be answered at highest speed. If the queries cover the full range of aggregate groupings possible in its data set, it may be best to materialize the whole hierarchical cube.</p>
<p>This means that each dimension&#39;s aggregation hierarchy is precomputed in combination with each of the other dimensions. Naturally, precomputing a full hierarchical cube requires more disk space and higher creation and refresh times than a small set of aggregate groups. The trade-off in processing time and disk space versus query performance must be considered before deciding to create it. An additional possibility you could consider is to use data compression to lessen your disk space requirements.</p>
<div class="infoboxnotealso" id="GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C__GUID-463A8500-2A64-442D-A8BE-CA714346481A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF54484" target="_blank" href="../SQLRF/statements_7002.htm#SQLRF54484"><span class="italic">Oracle Database SQL Language Reference</span></a> for table compression syntax and restrictions</p>
</li>
<li>
<p><a class="olink ADMIN13948" target="_blank" href="../ADMIN/tables.htm#ADMIN13948"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for further details about table compression</p>
</li>
<li>
<p><span class="q">&#34;<a href="basicmv.htm#GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266">About Storage And Table Compression for Materialized Views</a>&#34;</span> for details regarding table compression</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8658"></a><a id="DWHSG8657"></a>
<div class="props_rev_3"><a id="GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0"></a>
<h4 id="DWHSG-GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0" class="sect4">Examples of Hierarchical Cube Materialized Views</h4>
<div>
<div class="section">
<p>This section shows complete and partial hierarchical cube materialized views. Many of the examples are meant to illustrate capabilities, and do not actually run.</p>
<p>In a data warehouse where rolling window scenario is very common, it is recommended that you store the hierarchical cube in multiple materialized views - one for each level of time you are interested in. Hence, a complete hierarchical cube will be stored in four materialized views: <code class="codeph">sales_hierarchical_mon_cube_mv</code>, <code class="codeph">sales_hierarchical_qtr_cube_mv</code>, <code class="codeph">sales_hierarchical_yr_cube_mv</code>, and <code class="codeph">sales_hierarchical_all_cube_mv</code>.</p>
<p>The following statements create a complete hierarchical cube stored in a set of three composite partitioned and one list partitioned materialized view.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0__GUID-7FCB46BE-7A74-42F4-971E-501BDCEB4A44">
<p class="titleinexample">Example 19-18 Complete Hierarchical Cube Materialized View</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW sales_hierarchical_mon_cube_mv
PARTITION BY RANGE (mon)
SUBPARTITION BY LIST (gid)
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, calendar_quarter_desc qtr, calendar_month_desc mon,
    country_id, cust_state_province, cust_city,
    prod_category, prod_subcategory, prod_name,
    GROUPING_ID(calendar_year, calendar_quarter_desc, calendar_month_desc,
                country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales,
    COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year, calendar_quarter_desc, calendar_month_desc,
  ROLLUP(country_id, cust_state_province, cust_city),
  ROLLUP(prod_category, prod_subcategory, prod_name),
...;

CREATE MATERIALIZED VIEW sales_hierarchical_qtr_cube_mv
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, calendar_quarter_desc qtr,
    country_id, cust_state_province, cust_city, 
    prod_category, prod_subcategory, prod_name, 
    GROUPING_ID(calendar_year, calendar_quarter_desc,
                country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales,
    COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id 
      AND s.time_id = t.time_id
GROUP BY calendar_year, calendar_quarter_desc,
  ROLLUP(country_id, cust_state_province, cust_city),
  ROLLUP(prod_category, prod_subcategory, prod_name),
PARTITION BY RANGE (qtr)
 SUBPARTITION BY LIST (gid)
...;

CREATE MATERIALIZED VIEW sales_hierarchical_yr_cube_mv
PARTITION BY RANGE (year)
SUBPARTITION BY LIST (gid)
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, country_id, cust_state_province, cust_city, 
    prod_category, prod_subcategory, prod_name, 
    GROUPING_ID(calendar_year, country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year,
  ROLLUP(country_id, cust_state_province, cust_city),
  ROLLUP(prod_category, prod_subcategory, prod_name),
...;

CREATE MATERIALIZED VIEW sales_hierarchical_all_cube_mv
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT country_id, cust_state_province, cust_city, 
    prod_category, prod_subcategory, prod_name, 
    GROUPING_ID(country_id, cust_state_province, cust_city,
                prod_category, prod_subcategory, prod_name) gid,
    SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY ROLLUP(country_id, cust_state_province, cust_city),
         ROLLUP(prod_category, prod_subcategory, prod_name),
PARTITION BY LIST (gid)
...;
</pre>
<p>This allows use of PCT refresh on the materialized views <code class="codeph">sales_hierarchical_mon_cube_mv</code>, <code class="codeph">sales_hierarchical_qtr_cube_mv</code>, and <code class="codeph">sales_hierarchical_yr_cube_mv</code> on partition maintenance operations to sales table. PCT refresh can also be used when there have been significant changes to the base table and log based fast refresh is estimated to be slower than PCT refresh. You can just specify the method as force (<code class="codeph">method =&gt;</code> &#39;<code class="codeph">?</code>&#39;) in to refresh sub-programs in the <code class="codeph">DBMS_MVIEW</code> package and Oracle Database will pick the best method of refresh. See <span class="q">&#34;<a href="refresh.htm#GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD">About Partition Change Tracking (PCT) Refresh for Materialized Views</a>&#34;</span> for more information regarding PCT refresh.</p>
<p>Because <code class="codeph">sales_hierarchical_qtr_cube_mv</code> does not contain any column from <code class="codeph">times</code> table, PCT refresh is not enabled on it. But, you can still call refresh sub-programs in the <code class="codeph">DBMS_MVIEW</code> package with method as force (<code class="codeph">method =&gt;</code> &#39;<code class="codeph">?</code>&#39;) and Oracle Database will pick the best method of refresh.</p>
<p>If you are interested in a partial cube (that is, a subset of groupings from the complete cube), then Oracle recommends storing the cube as a &#34;federated cube&#34;. A federated cube stores each grouping of interest in a separate materialized view.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW sales_mon_city_prod_mv
PARTITION BY RANGE (mon)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_month_desc mon, cust_city, prod_name, SUM(amount_sold) s_sales,
       COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id 
AND s.time_id = t.time_id
GROUP BY calendar_month_desc, cust_city, prod_name;

CREATE MATERIALIZED VIEW sales_qtr_city_prod_mv
PARTITION BY RANGE (qtr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_quarter_desc qtr, cust_city, prod_name,SUM(amount_sold) s_sales, 
COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_quarter_desc, cust_city, prod_name;

CREATE MATERIALIZED VIEW sales_yr_city_prod_mv
PARTITION BY RANGE (yr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, cust_city, prod_name, SUM(amount_sold) s_sales,
       COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year, cust_city, prod_name;

CREATE MATERIALIZED VIEW sales_mon_city_scat_mv
PARTITION BY RANGE (mon)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_month_desc mon, cust_city, prod_subcategory,
       SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id =t.time_id
GROUP BY calendar_month_desc, cust_city, prod_subcategory;

CREATE MATERIALIZED VIEW sales_qtr_city_cat_mv
PARTITION BY RANGE (qtr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_quarter_desc qtr, cust_city, prod_category cat,
       SUM(amount_sold) s_sales, COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id =p.prod_id AND s.time_id =t.time_id
GROUP BY calendar_quarter_desc, cust_city, prod_category;

CREATE MATERIALIZED VIEW sales_yr_city_all_mv
PARTITION BY RANGE (yr)
...
BUILD DEFERRED
REFRESH FAST ON DEMAND
  USING TRUSTED CONSTRAINTS
ENABLE QUERY REWRITE AS
SELECT calendar_year yr, cust_city, SUM(amount_sold) s_sales, 
       COUNT(amount_sold) c_sales, COUNT(*) c_star
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
GROUP BY calendar_year, cust_city;
</pre>
<p>These materialized views can be created as <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> and then, you can execute <code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT(number_of_failures, &#39;SALES&#39;, &#39;C&#39; ...)</code> so that the complete refresh of each of the materialized views defined on the detail table <code class="codeph">sales</code> is scheduled in the most efficient order. See <span class="q">&#34;<a href="refresh.htm#GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A">Scheduling Refresh of Materialized Views</a>&#34;</span> for more information.</p>
<p>Because each of these materialized views is partitioned on the time level (month, quarter, or year) present in the <code class="codeph">SELECT</code> list, PCT is enabled on <code class="codeph">sales</code> table for each one of them, thus providing an opportunity to apply PCT refresh method in addition to <code class="codeph">FAST</code> and <code class="codeph">COMPLETE</code> refresh methods.</p>
</div>
<!-- class="example" --></div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1506">
<tr>
<td class="cellalignment1513">
<table class="cellalignment1511">
<tr>
<td class="cellalignment1510"><a href="analysis.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1510"><a href="pattern.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1515">
<table class="cellalignment1509">
<tr>
<td class="cellalignment1510"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1510"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1510"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1510"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1510"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1510"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>