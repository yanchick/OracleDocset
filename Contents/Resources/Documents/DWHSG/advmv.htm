<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-6015"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Advanced%20Materialized%20Views"></a><title>Advanced Materialized Views</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="analytic processing, materialized views, cubes, hierarchical cubes, hierarchical"/>
<meta name="dcterms.created" content="2017-06-07T18:07:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Warehousing Guide"/>
<meta name="dcterms.identifier" content="E41670-11"/>
<meta name="dcterms.isVersionOf" content="DWHSG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="basicmv.htm" title="Previous" type="text/html"/>
<link rel="Next" href="refresh.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41670-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B"></a> <span id="PAGE" style="display:none;">12/32</span> <!-- End Header -->
<h1 id="DWHSG-GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" class="sect1"><span class="enumeration_chapter">6</span> Advanced Materialized Views</h1>
<div>
<p>This chapter discusses advanced topics in using materialized views. It contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="advmv.htm#GUID-43FA865F-8C02-4B99-9202-49728BAA7687">About Partitioning and Materialized Views</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A">About Materialized Views in Analytic Processing Environments</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A">About Materialized Views and Models</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">Invalidating Materialized Views</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-BC3675D3-C925-4D72-B953-34E7C818EB91">About Security Issues with Materialized Views</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E">Altering Materialized Views</a></p>
</li>
</ul>
</div>
<a id="DWHSG8227"></a>
<div class="props_rev_3"><a id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687"></a>
<h2 id="DWHSG-GUID-43FA865F-8C02-4B99-9202-49728BAA7687" class="sect2">About Partitioning and Materialized Views</h2>
<div>
<p><a id="d24346e71" class="indexterm-anchor"></a><a id="d24346e75" class="indexterm-anchor"></a>Because of the large volume of data held in a data warehouse, partitioning is an extremely useful option when designing a database. Partitioning the fact tables improves scalability, simplifies system administration, and makes it possible to define local indexes that can be efficiently rebuilt. Partitioning the fact tables also improves the opportunity of fast refreshing the materialized view because this may enable partition change tracking (PCT) refresh on the materialized view. Partitioning a materialized view also has benefits for refresh, because the refresh procedure can then use parallel DML in more scenarios and PCT-based refresh can use truncate partition to efficiently maintain the materialized view.</p>
<div class="infoboxnotealso" id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687__GUID-C0A88051-183F-4068-9B28-5A058CE6B1FD">
<p class="notep1">See Also:</p>
<p><a class="olink VLDBG002" target="_blank" href="../VLDBG/GUID-EA7EF5CB-DD49-43AF-889A-F83AAC0D7D51.htm#VLDBG002"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for further details about partitioning</p>
</div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="advmv.htm#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-0661E251-15FA-4845-A358-7209D9B22096">Partitioning a Materialized View</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-B609252D-DD65-4617-8F38-B1AB52473AA5">Partitioning a Prebuilt Table</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-5AC25C22-427B-45B8-B949-B05AC8853310">Rolling Materialized Views</a></p>
</li>
</ul>
</div>
<a id="DWHSG00324"></a>
<div class="props_rev_3"><a id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1"></a>
<h3 id="DWHSG-GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1" class="sect3">About Partition Change Tracking</h3>
<div>
<p>It is <a id="d24346e132" class="indexterm-anchor"></a><a id="d24346e134" class="indexterm-anchor"></a>possible and advantageous to track freshness to a finer grain than the entire materialized view. You can achieve this through <a href="glossary.htm#GUID-32BF9E11-2C90-446A-9C66-4D0BA8DF7798"><span class="xrefglossterm">partition change tracking (PCT)</span></a>, which is a method to identify which rows in a materialized view are affected by a certain detail table partition. When one or more of the detail tables are partitioned, it may be possible to identify the specific rows in the materialized view that correspond to a modified detail partition(s); those rows become stale when a partition is modified while all other rows remain fresh.</p>
<p>You can use PCT to identify which materialized view rows correspond to a particular partition. PCT is also used to support fast refresh after partition maintenance operations on detail tables. For instance, if a detail table partition is truncated or dropped, the affected rows in the materialized view are identified and deleted.</p>
<p>Identifying which materialized view rows are fresh or stale, rather than considering the entire materialized view as stale, allows query rewrite to use those rows that are fresh while in <code class="codeph">QUERY_REWRITE_INTEGRITY</code> = <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> modes. Several views, such as <code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code>, detail which partitions are stale or fresh. Oracle does not rewrite against partial stale materialized views if partition change tracking on the changed table is enabled by the presence of join dependent expressions in the materialized view.</p>
<div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-C6E771CD-21C4-42DC-871F-C18680BECA1D">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="advmv.htm#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">About Join Dependent Expression and Partition Change Tracking</a>&#34;</span> for more information</p>
</div>
<p>Note that, while partition change tracking tracks the staleness on a partition and subpartition level (for composite partitioned tables), the level of granularity for PCT refresh is only the top-level partitioning strategy. Consequently, any change to data in one of the subpartitions of a composite partitioned-table will only mark the single impacted subpartition as stale and have the rest of the table available for rewrite, but the PCT refresh will refresh the whole partition that contains the impacted subpartition.</p>
<p>To support PCT, a materialized view must satisfy the following requirements:</p>
<ul style="list-style-type: disc;">
<li>
<p>At least one of the detail tables referenced by the materialized view must be partitioned.</p>
</li>
<li>
<p>Partitioned tables must use either range, list or composite partitioning with range or list as the top-level partitioning strategy.</p>
</li>
<li>
<p>The top level partition key must consist of only a single column.</p>
</li>
<li>
<p>The materialized view must contain either the partition key column or a partition marker or <code class="codeph">ROWID</code> or join dependent expression of the detail table.</p>
</li>
<li>
<p>If you use a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, the partition key column or the partition marker or <code class="codeph">ROWID</code> or join dependent expression must be present in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause.</p>
</li>
<li>
<p>If you use an analytic window function or the <code class="codeph">MODEL</code> clause, the partition key column or the partition marker or <code class="codeph">ROWID</code> or join dependent expression must be present in their respective <code class="codeph">PARTITION</code> <code class="codeph">BY</code> subclauses.</p>
</li>
<li>
<p>Data modifications can only occur on the partitioned table. If PCT refresh is being done for a table which has join dependent expression in the materialized view, then data modifications should not have occurred in any of the join dependent tables.</p>
</li>
<li>
<p>The <code class="codeph">COMPATIBILITY</code> initialization parameter must be a minimum of 9.0.0.0.0.</p>
</li>
</ul>
<p>PCT is not supported for a materialized view that refers to views, remote tables, or outer joins.</p>
<div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-13A32E69-2B80-4385-A3E8-F5B10B9991C0">
<p class="notep1">See Also:</p>
<p><a class="olink ARPLS027" target="_blank" href="../ARPLS/d_mview.htm#ARPLS027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details regarding the <code class="codeph">DBMS_MVIEW.PMARKER</code> function and partition markers</p>
</div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="advmv.htm#GUID-BDF063E9-7769-4272-A54E-C5E199476C46">About Partition Key and Partition Change Tracking</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">About Join Dependent Expression and Partition Change Tracking</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79">About Partition Markers and Partition Change Tracking</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-462D637E-27E2-4581-BD50-6CA79A854000">About Partial Rewrite in Partition Change Tracking</a></p>
</li>
</ul>
</div>
<a id="DWHSG8229"></a><a id="DWHSG8228"></a>
<div class="props_rev_3"><a id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46"></a>
<h4 id="DWHSG-GUID-BDF063E9-7769-4272-A54E-C5E199476C46" class="sect4">About Partition Key and Partition Change Tracking</h4>
<div>
<p>Partition change tracking requires sufficient information in the materialized view to be able to correlate a detail row in the source partitioned detail table to the corresponding materialized view row. This can be accomplished by including the detail table partition key columns in the <code class="codeph">SELECT</code> list and, if <code class="codeph">GROUP</code> <code class="codeph">BY</code> is used, in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> list.</p>
<p>Consider an example of a materialized view storing daily customer sales. The following example uses the <code class="codeph">sh</code> sample schema and the three detail tables <code class="codeph">sales</code>, <code class="codeph">products</code>, and <code class="codeph">times</code> to create the materialized view. <code class="codeph">sales</code> table is partitioned by <code class="codeph">time_id</code> column and <code class="codeph">products</code> is partitioned by the <code class="codeph">prod_id</code> column. <code class="codeph">times</code> is not a partitioned table.</p>
<div class="example" id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46__GUID-57C843AC-0CA8-4C49-92D3-5B9D7964F9ED">
<p class="titleinexample">Example 6-1 Materialized View with Partition Key</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON SALES WITH ROWID
   (prod_id, time_id, quantity_sold, amount_sold) INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON PRODUCTS WITH ROWID
   (prod_id, prod_name, prod_desc) INCLUDING NEW VALUES;
CREATE MATERIALIZED VIEW LOG ON TIMES WITH ROWID
   (time_id, calendar_month_name, calendar_year) INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW cust_dly_sales_mv
BUILD DEFERRED REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.time_id, p.prod_id, p.prod_name, COUNT(*),
         SUM(s.quantity_sold), SUM(s.amount_sold),
         COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY s.time_id, p.prod_id, p.prod_name;
</pre>
<p>For <code class="codeph">cust_dly_sales_mv</code>, PCT is enabled on the <code class="codeph">sales</code> table because its partitioning key column <code class="codeph">time_id</code> is in the materialized view.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8231"></a><a id="DWHSG8230"></a>
<div class="props_rev_3"><a id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697"></a>
<h4 id="DWHSG-GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697" class="sect4">About Join Dependent Expression and Partition Change Tracking</h4>
<div>
<p>An expression consisting of columns from tables directly or indirectly joined through equijoins to the partitioned detail table on the partitioning key and which is either a dimensional attribute or a dimension hierarchical parent of the joining key is called a join dependent expression. The set of tables in the path to detail table are called join dependent tables. Consider the following:</p>
<pre dir="ltr">SELECT s.time_id, t.calendar_month_name 
FROM sales s, times t WHERE s.time_id = t.time_id;
</pre>
<p>In this query, <code class="codeph">times</code> table is a join dependent table because it is joined to <code class="codeph">sales</code> table on the partitioning key column <code class="codeph">time_id</code>. Moreover, <code class="codeph">calendar_month_name</code> is a dimension hierarchical attribute of <code class="codeph">times.time_id</code>, because <code class="codeph">calendar_month_name</code> is an attribute of <code class="codeph">times.mon_id</code> and <code class="codeph">times.mon_id</code> is a dimension hierarchical parent of <code class="codeph">times.time_id</code>. Hence, the expression <code class="codeph">calendar_month_name</code> from <code class="codeph">times</code> tables is a join dependent expression. Let&#39;s consider another example:</p>
<pre dir="ltr">SELECT s.time_id, y.calendar_year_name
FROM sales s, times_d d, times_m m, times_y y
WHERE s.time_id = d.time_id AND d.day_id = m.day_id AND m.mon_id = y.mon_id;
</pre>
<p>Here, <code class="codeph">times</code> table is denormalized into <code class="codeph">times_d</code>, <code class="codeph">times_m</code> and <code class="codeph">times_y</code> tables. The expression <code class="codeph">calendar_year_name</code> from <code class="codeph">times_y</code> table is a join dependent expression and the tables <code class="codeph">times_d</code>, <code class="codeph">times_m</code> and <code class="codeph">times_y</code> are join dependent tables. This is because <code class="codeph">times_y</code> table is joined indirectly through <code class="codeph">times_m</code> and <code class="codeph">times_d</code> tables to sales table on its partitioning key column <code class="codeph">time_id</code>.</p>
<p>This lets users create materialized views containing aggregates on some level higher than the partitioning key of the detail table. Consider the following example of materialized view storing monthly customer sales.</p>
<div class="example" id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697__GUID-88E6DF64-A0B7-4343-BF7A-CEAADF171F4A">
<p class="titleinexample">Example 6-2 Creating a Materialized View: Join Dependent Expression</p>
<p>Assuming the presence of materialized view logs defined earlier, the materialized view can be created using the following DDL:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW cust_mth_sales_mv
BUILD DEFERRED REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT t.calendar_month_name, p.prod_id, p.prod_name, COUNT(*),
    SUM(s.quantity_sold), SUM(s.amount_sold),
    COUNT(s.quantity_sold), COUNT(s.amount_sold)
FROM sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY t.calendar_month_name, p.prod_id, p.prod_name;
</pre>
<p>Here, you can correlate a detail table row to its corresponding materialized view row using the join dependent table <code class="codeph">times</code> and the relationship that <code class="codeph">times.calendar_month_name</code> is a dimensional attribute determined by <code class="codeph">times.time_id</code>. This enables partition change tracking on <code class="codeph">sales</code> table. In addition to this, PCT is enabled on products table because of presence of its partitioning key column <code class="codeph">prod_id</code> in the materialized view.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8233"></a><a id="DWHSG8232"></a>
<div class="props_rev_3"><a id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79"></a>
<h4 id="DWHSG-GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79" class="sect4">About Partition Markers and Partition Change Tracking</h4>
<div>
<p>The <code class="codeph">DBMS_MVIEW.PMARKER</code> function is designed to significantly reduce the cardinality (the ratio of distinct values to the number of table rows) of the materialized view (see <a href="advmv.htm#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">Example 6-3</a> for an example). The function returns a partition identifier that uniquely identifies the partition or subpartition for a specified row within a specified partitioned table. Therefore, the <code class="codeph">DBMS_MVIEW.PMARKER</code> function is used instead of the partition key column in the <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code> clauses.</p>
<p>Unlike the general case of a PL/SQL function in a materialized view, use of the <code class="codeph">DBMS_MVIEW.PMARKER</code> does not prevent rewrite with that materialized view even when the rewrite mode is <code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code>.</p>
<p>As an example of using the <code class="codeph">PMARKER</code> function, consider calculating a typical number, such as revenue generated by a product category during a given year. If there were 1000 different products sold each month, it would result in 12,000 rows in the materialized view.</p>
<div class="example" id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">
<p class="titleinexample">Example 6-3 Using Partition Markers in a Materialized View</p>
<p>Consider an example of a materialized view storing the yearly sales revenue for each product category. With approximately hundreds of different products in each product category, including the partitioning key column <code class="codeph">prod_id</code> of the <code class="codeph">products</code> table in the materialized view would substantially increase the cardinality. Instead, this materialized view uses the <code class="codeph">DBMS_MVIEW.PMARKER</code> function, which increases the cardinality of materialized view by a factor of the number of partitions in the <code class="codeph">products</code> table.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW prod_yr_sales_mv
BUILD DEFERRED
REFRESH FAST ON DEMAND
ENABLE QUERY REWRITE AS
SELECT DBMS_MVIEW.PMARKER(p.rowid), p.prod_category, t.calendar_year, COUNT(*),
       SUM(s.amount_sold), SUM(s.quantity_sold),
       COUNT(s.amount_sold), COUNT(s.quantity_sold)
FROM   sales s, products p, times t
WHERE  s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY  DBMS_MVIEW.PMARKER (p.rowid), p.prod_category, t.calendar_year;
</pre>
<p><code class="codeph">prod_yr_sales_mv</code> includes the <code class="codeph">DBMS_MVIEW.PMARKER</code> function on the <code class="codeph">products</code> table in its <code class="codeph">SELECT</code> list. This enables partition change tracking on <code class="codeph">products</code> table with significantly less cardinality impact than grouping by the partition key column <code class="codeph">prod_id</code>. In this example, the desired level of aggregation for the <code class="codeph">prod_yr_sales_mv</code> is to group by <code class="codeph">products.prod_category</code>. Using the <code class="codeph">DBMS_MVIEW.PMARKER</code> function, the materialized view cardinality is increased only by a factor of the number of partitions in the <code class="codeph">products</code> table. This would generally be significantly less than the cardinality impact of including the partition key columns.</p>
<p>Note that partition change tracking is enabled on <code class="codeph">sales</code> table because of presence of join dependent expression <code class="codeph">calendar_year</code> in the <code class="codeph">SELECT</code> list.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG8234"></a>
<div class="props_rev_3"><a id="GUID-462D637E-27E2-4581-BD50-6CA79A854000"></a>
<h4 id="DWHSG-GUID-462D637E-27E2-4581-BD50-6CA79A854000" class="sect4">About Partial Rewrite in Partition Change Tracking</h4>
<div>
<p>A subsequent <code class="codeph">INSERT</code> statement adds a new row to the <code class="codeph">sales_part3</code> partition of table <code class="codeph">sales</code>. At this point, because <code class="codeph">cust_dly_sales_mv</code> has PCT available on table <code class="codeph">sales</code> using a partition key, Oracle can identify the stale rows in the materialized view <code class="codeph">cust_dly_sales_mv</code> corresponding to <code class="codeph">sales_part3</code> partition (The other rows are unchanged in their freshness state). Query rewrite cannot identify the fresh portion of materialized views <code class="codeph">cust_mth_sales_mv</code> and <code class="codeph">prod_yr_sales_mv</code> because PCT is available on table sales using join dependent expressions. Query rewrite can determine the fresh portion of a materialized view on changes to a detail table only if PCT is available on the detail table using a partition key or partition marker.</p>
</div>
</div>
</div>
<a id="DWHSG8235"></a>
<div class="props_rev_3"><a id="GUID-0661E251-15FA-4845-A358-7209D9B22096"></a>
<h3 id="DWHSG-GUID-0661E251-15FA-4845-A358-7209D9B22096" class="sect3">Partitioning a Materialized View</h3>
<div>
<div class="section">
<p>Partitioning a materialized view involves defining the materialized view with the standard Oracle partitioning clauses, as illustrated in the following example. This statement creates a materialized view called <code class="codeph">part_sales_mv</code>, which uses three partitions, can be fast refreshed, and is eligible for query rewrite:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW part_sales_mv
PARALLEL PARTITION BY RANGE (time_id)
(PARTITION month1
      VALUES LESS THAN (TO_DATE(&#39;31-12-1998&#39;, &#39;DD-MM-YYYY&#39;))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf1,
 PARTITION month2
      VALUES LESS THAN (TO_DATE(&#39;31-12-1999&#39;, &#39;DD-MM-YYYY&#39;))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf2,
 PARTITION month3
      VALUES LESS THAN (TO_DATE(&#39;31-12-2000&#39;, &#39;DD-MM-YYYY&#39;))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf3)
BUILD DEFERRED
REFRESH FAST
ENABLE QUERY REWRITE AS
SELECT s.cust_id, s.time_id,
  SUM(s.amount_sold) AS sum_dol_sales, SUM(s.quantity_sold) AS sum_unit_sales
  FROM sales s GROUP BY s.time_id, s.cust_id;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8236"></a>
<div class="props_rev_3"><a id="GUID-B609252D-DD65-4617-8F38-B1AB52473AA5"></a>
<h3 id="DWHSG-GUID-B609252D-DD65-4617-8F38-B1AB52473AA5" class="sect3">Partitioning a Prebuilt Table</h3>
<div>
<div class="section">
<p><a id="d24346e697" class="indexterm-anchor"></a>Alternatively, a materialized view can be registered to a partitioned prebuilt table. <span class="q">&#34;<a href="advmv.htm#GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA">Benefits of Partitioning a Materialized View</a>&#34;</span> describes the benefits of partitioning a prebuilt table. The following example illustrates this:</p>
<pre dir="ltr">CREATE TABLE part_sales_tab_mv(time_id, cust_id, sum_dollar_sales, sum_unit_sale)
PARALLEL PARTITION BY RANGE (time_id)
(PARTITION month1
      VALUES LESS THAN (TO_DATE(&#39;31-12-1998&#39;, &#39;DD-MM-YYYY&#39;))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf1,
 PARTITION month2
      VALUES LESS THAN (TO_DATE(&#39;31-12-1999&#39;, &#39;DD-MM-YYYY&#39;))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf2,
PARTITION month3
      VALUES LESS THAN (TO_DATE(&#39;31-12-2000&#39;, &#39;DD-MM-YYYY&#39;))
      PCTFREE 0
      STORAGE (INITIAL 8M)
      TABLESPACE sf3)  AS
SELECT s.time_id, s.cust_id, SUM(s.amount_sold) AS sum_dollar_sales, 
  SUM(s.quantity_sold) AS sum_unit_sales
FROM sales s GROUP BY s.time_id, s.cust_id;

CREATE MATERIALIZED VIEW part_sales_tab_mv
ON PREBUILT TABLE
ENABLE QUERY REWRITE AS 
SELECT s.time_id,  s.cust_id, SUM(s.amount_sold) AS sum_dollar_sales, 
     SUM(s.quantity_sold) AS sum_unit_sales 
FROM sales s GROUP BY s.time_id, s.cust_id;
</pre>
<p>In this example, the table <code class="codeph">part_sales_tab_mv</code> has been partitioned over three months and then the materialized view was registered to use the prebuilt table. This materialized view is eligible for query rewrite because the <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> clause has been included.</p>
</div>
<!-- class="section" --></div>
<a id="DWHSG8237"></a>
<div class="props_rev_3"><a id="GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA"></a>
<h4 id="DWHSG-GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA" class="sect4">Benefits of Partitioning a Materialized View</h4>
<div>
<p>When a materialized view is partitioned on the partitioning key column or join dependent expressions of the detail table, it is more efficient to use a <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement to remove one or more partitions of the materialized view during refresh and then repopulate the partition with new data. Oracle Database uses this variant of fast refresh (called PCT refresh) with partition truncation if the following conditions are satisfied in addition to other conditions described in <span class="q">&#34;<a href="advmv.htm#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">About Partition Change Tracking</a>&#34;</span>.</p>
<ul style="list-style-type: disc;">
<li>
<p>The materialized view is partitioned on the partitioning key column or join dependent expressions of the detail table.</p>
</li>
<li>
<p>If PCT is enabled using either the partitioning key column or join expressions, the materialized view should be range or list partitioned.</p>
</li>
<li>
<p>PCT refresh is nonatomic.</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8238"></a>
<div class="props_rev_3"><a id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310"></a>
<h3 id="DWHSG-GUID-5AC25C22-427B-45B8-B949-B05AC8853310" class="sect3">Rolling Materialized Views</h3>
<div>
<p>When a data warehouse or data mart contains a time dimension, it is often desirable to archive the oldest information and then reuse the storage for new information. This is called the rolling window scenario. If the fact tables or materialized views include a time dimension and are horizontally partitioned by the time attribute, then management of rolling materialized views can be reduced to a few fast partition maintenance operations provided the unit of data that is rolled out equals, or is at least aligned with, the range partitions.</p>
<p>If you plan to have rolling materialized views in your data warehouse, you should determine how frequently you plan to perform partition maintenance operations, and you should plan to partition fact tables and materialized views to reduce the amount of system administration overhead required when old data is aged out. An additional consideration is that you might want to use data compression on your infrequently updated partitions.</p>
<p>You are not restricted to using range partitions. For example, a composite partition using both a time value and a key value could result in a good partition solution for your data.</p>
<div class="infoboxnotealso" id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310__GUID-8BAE7F52-08F0-4A6B-A4A1-864208143D3D">
<p class="notep1">See Also:</p>
<p><a href="refresh.htm#GUID-64068234-BDB0-4C12-AE70-75571046A586">Refreshing Materialized Views</a> for further details regarding <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> and for details regarding compression</p>
</div>
</div>
</div>
</div>
<a id="DWHSG8239"></a>
<div class="props_rev_3"><a id="GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A"></a>
<h2 id="DWHSG-GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" class="sect2">About Materialized Views in Analytic Processing Environments</h2>
<div>
<p>This section discusses the concepts used by analytic SQL and how relational databases can handle these types of queries. It also illustrates the best approach for creating materialized views using a common scenario.</p>
<p>The following topics contain additional information about materialized views in different environments::</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="advmv.htm#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A">About Materialized Views and Hierarchical Cubes</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D">Benefits of Partitioning Materialized Views</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444">About Compressing Materialized Views</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39">About Materialized Views with Set Operators</a></p>
</li>
</ul>
</div>
<a id="DWHSG8241"></a><a id="DWHSG8242"></a><a id="DWHSG8240"></a>
<div class="props_rev_3"><a id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A"></a>
<h3 id="DWHSG-GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A" class="sect3">About Materialized Views and Hierarchical Cubes</h3>
<div>
<p>While data warehouse environments typically view data in the form of a star schema, for analytical SQL queries, data is held in the form of a hierarchical cube. A hierarchical cube includes the data aggregated along the rollup hierarchy of each of its dimensions and these aggregations are combined across dimensions. It includes the typical set of aggregations needed for business intelligence queries.</p>
<div class="example" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__GUID-C915B982-A86F-4A53-8A1E-68BB537E1152">
<p class="titleinexample">Example 6-4 Hierarchical Cube</p>
<p>Consider a sales data set with two dimensions, each of which has a four-level hierarchy:</p>
<ul style="list-style-type: disc;">
<li>
<p>Time, which contains (all times), year, quarter, and month.</p>
</li>
<li>
<p>Product, which contains (all products), division, brand, and item.</p>
</li>
</ul>
<p>This means there are 16 aggregate groups in the hierarchical cube. This is because the four levels of time are multiplied by four levels of product to produce the cube. <a href="advmv.htm#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832" title="This table illustrates the hierarchies for the Time and Product dimensions.">Table 6-1</a> shows the four levels of each dimension.</p>
</div>
<!-- class="example" -->
<div class="section">
<div class="tblformal" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832">
<p class="titleintable">Table 6-1 ROLLUP By Time and Product</p>
<table class="cellalignment1516" title="ROLLUP By Time and Product" summary="This table illustrates the hierarchies for the Time and Product dimensions.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1552" id="d24346e929">ROLLUP By Time</th>
<th class="cellalignment1553" id="d24346e932">ROLLUP By Product</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d24346e937" headers="d24346e929">
<p>year, quarter, month</p>
</td>
<td class="cellalignment1555" headers="d24346e937 d24346e932">
<p>division, brand, item</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d24346e944" headers="d24346e929">
<p>year, quarter</p>
</td>
<td class="cellalignment1555" headers="d24346e944 d24346e932">
<p>division, brand</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d24346e951" headers="d24346e929">
<p>year</p>
</td>
<td class="cellalignment1555" headers="d24346e951 d24346e932">
<p>division</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1554" id="d24346e958" headers="d24346e929">
<p>all times</p>
</td>
<td class="cellalignment1555" headers="d24346e958 d24346e932">
<p>all products</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Note that as you increase the number of dimensions and levels, the number of groups to calculate increases dramatically. This example involves 16 groups, but if you were to add just two more dimensions with the same number of levels, you would have 4 x 4 x 4 x 4 = 256 different groups. Also, consider that a similar increase in groups occurs if you have multiple hierarchies in your dimensions. For example, the time dimension might have an additional hierarchy of fiscal month rolling up to fiscal quarter and then fiscal year. Handling the explosion of groups has historically been the major challenge in data storage for online analytical processing systems.</p>
<p>Typical online analytical queries <a href="glossary.htm#GUID-F7CC0204-822C-4C1F-AE7D-A7CC609C05C0"><span class="xrefglossterm">slice and dice</span></a> different parts of the cube comparing aggregations from one level to aggregation from another level. For instance, a query might find sales of the grocery division for the month of January, 2002 and compare them with total sales of the grocery division for all of 2001.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8243"></a>
<div class="props_rev_3"><a id="GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D"></a>
<h3 id="DWHSG-GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D" class="sect3">Benefits of Partitioning Materialized Views</h3>
<div>
<p>Materialized views with multiple aggregate groups give their best performance for refresh and query rewrite when partitioned appropriately.</p>
<p>PCT refresh in a rolling window scenario requires partitioning at the top level on some level from the time dimension. And, partition pruning for queries rewritten against this materialized view requires partitioning on <code class="codeph">GROUPING_ID</code> column. Hence, the most effective partitioning scheme for these materialized views is to use composite partitioning (range-list on (<code class="codeph">time</code>, <code class="codeph">GROUPING_ID</code>) columns). By partitioning the materialized views this way, you enable:</p>
<ul style="list-style-type: disc;">
<li>
<p>PCT refresh, thereby improving refresh performance.</p>
</li>
<li>
<p>Partition pruning: only relevant aggregate groups are accessed, thereby greatly reducing the query processing cost.</p>
</li>
</ul>
<p>If you do not want to use PCT refresh, you can just partition by list on <code class="codeph">GROUPING_ID</code> column.</p>
</div>
</div>
<a id="DWHSG8244"></a>
<div class="props_rev_3"><a id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444"></a>
<h3 id="DWHSG-GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444" class="sect3">About Compressing Materialized Views</h3>
<div>
<p>You should consider data compression when using highly redundant data, such as tables with many foreign keys. In particular, materialized views created with the <code class="codeph">ROLLUP</code> clause are likely candidates.</p>
<div class="infoboxnotealso" id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444__GUID-D26EC127-092A-4EA1-A934-D93A63CA2951">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF52876" target="_blank" href="../SQLRF/statements_2002.htm#SQLRF52876"><span class="italic">Oracle Database SQL Language Reference</span></a> for data compression syntax and restrictions</p>
</li>
<li>
<p><span class="q">&#34;<a href="basicmv.htm#GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266">About Storage And Table Compression for Materialized Views</a>&#34;</span> for details regarding compression</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG8245"></a>
<div class="props_rev_3"><a id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39"></a>
<h3 id="DWHSG-GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39" class="sect3">About Materialized Views with Set Operators</h3>
<div>
<p>Oracle Database provides support for <a id="d24346e1080" class="indexterm-anchor"></a><a id="d24346e1084" class="indexterm-anchor"></a>materialized views whose defining query involves set operators. Materialized views with set operators can now be created enabled for query rewrite. You can refresh the materialized view using either <code class="codeph">ON</code> <code class="codeph">COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code> refresh.</p>
<p>Fast refresh is supported if the defining query has the <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator at the top level and each query block in the <code class="codeph">UNION</code> <code class="codeph">ALL</code>, meets the requirements of a materialized view with aggregates or materialized view with joins only. Further, the materialized view must include a constant column (known as a <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker) that has a distinct value in each query block, which, in the following example, is columns <code class="codeph">1 marker</code> and <code class="codeph">2 marker</code>.</p>
<div class="infoboxnotealso" id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39__GUID-B5D588FD-4A69-47CE-984B-DAEDF545DA81">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="basicmv.htm#GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6">Restrictions on Fast Refresh on Materialized Views with UNION ALL</a>&#34;</span> for detailed restrictions on fast refresh for materialized views with <code class="codeph">UNION</code> <code class="codeph">ALL</code>.</p>
</div>
</div>
<a id="DWHSG8247"></a><a id="DWHSG8248"></a><a id="DWHSG8246"></a>
<div class="props_rev_3"><a id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E"></a>
<h4 id="DWHSG-GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E" class="sect4">Examples of Materialized Views Using UNION ALL</h4>
<div>
<div class="section">
<p>The following examples illustrate creation of fast refreshable materialized views involving <code class="codeph">UNION</code> <code class="codeph">ALL</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-0AAA7B44-0790-4B59-98E4-5D47DC0BC6B1">
<p class="titleinexample">Example 6-5 Materialized View Using UNION ALL with Two Join Views</p>
<p>To create a <code class="codeph">UNION</code> <code class="codeph">ALL</code> materialized view with two join views, the materialized view logs must have the rowid column and, in the following example, the <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker is the columns, <code class="codeph">1 marker</code> and <code class="codeph">2 marker</code>.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;

CREATE MATERIALIZED VIEW unionall_sales_cust_joins_mv
REFRESH FAST ON COMMIT 
ENABLE QUERY REWRITE AS
(SELECT c.rowid crid, s.rowid srid, c.cust_id, s.amount_sold, 1 marker
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND c.cust_last_name = &#39;Smith&#39;)
UNION ALL
(SELECT c.rowid crid, s.rowid srid, c.cust_id, s.amount_sold, 2 marker
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND c.cust_last_name = &#39;Brown&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-CE59DA03-7059-4C7B-A5E4-25C2341C64DC">
<p class="titleinexample">Example 6-6 Materialized View Using UNION ALL with Joins and Aggregates</p>
<p>The following example shows a <code class="codeph">UNION</code> <code class="codeph">ALL</code> of a materialized view with joins and a materialized view with aggregates. A couple of things can be noted in this example. Nulls or constants can be used to ensure that the data types of the corresponding <code class="codeph">SELECT</code> list columns match. Also, the <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker column can be a string literal, which is <code class="codeph">&#39;Year&#39; umarker</code>, <code class="codeph">&#39;Quarter&#39; umarker</code>, or <code class="codeph">&#39;Daily&#39; umarker</code> in the following example:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID, SEQUENCE
(amount_sold, time_id)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW LOG ON times WITH ROWID, SEQUENCE 
  (time_id, fiscal_year, fiscal_quarter_number, day_number_in_week) 
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW unionall_sales_mix_mv
REFRESH FAST ON DEMAND AS
(SELECT &#39;Year&#39; umarker, NULL, NULL, t.fiscal_year, 
        SUM(s.amount_sold) amt, COUNT(s.amount_sold), COUNT(*)
 FROM sales s, times t
 WHERE s.time_id = t.time_id 
 GROUP BY t.fiscal_year)
UNION ALL
(SELECT &#39;Quarter&#39; umarker, NULL, NULL, t.fiscal_quarter_number, 
        SUM(s.amount_sold) amt, COUNT(s.amount_sold), COUNT(*)
FROM sales s, times t 
WHERE s.time_id = t.time_id and t.fiscal_year = 2001
GROUP BY t.fiscal_quarter_number)
UNION ALL
(SELECT &#39;Daily&#39; umarker, s.rowid rid, t.rowid rid2, t.day_number_in_week,
        s.amount_sold amt, 1, 1
FROM sales s, times t
WHERE s.time_id = t.time_id 
AND t.time_id between &#39;01-Jan-01&#39; AND &#39;01-Dec-31&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="DWHSG8249"></a>
<div class="props_rev_3"><a id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A"></a>
<h2 id="DWHSG-GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A" class="sect2">About Materialized Views and Models</h2>
<div>
<p>Models, which provide array-based computations in SQL, can be used in materialized views. Because the <code class="codeph">MODEL</code> clause calculations can be expensive, you may want to use two separate materialized views: one for the model calculations and one for the <code class="codeph">SELECT</code> ... <code class="codeph">GROUP</code> <code class="codeph">BY</code> query. For example, instead of using one, long materialized view, you could create the following materialized views:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW my_groupby_mv
REFRESH FAST
ENABLE QUERY REWRITE AS
SELECT country_name country, prod_name prod, calendar_year year,
  SUM(amount_sold) sale, COUNT(amount_sold) cnt, COUNT(*) cntstr 
FROM sales, times, customers, countries, products
WHERE sales.time_id = times.time_id AND
      sales.prod_id = products.prod_id AND
      sales.cust_id = customers.cust_id AND
      customers.country_id = countries.country_id
GROUP BY country_name, prod_name, calendar_year;

CREATE MATERIALIZED VIEW my_model_mv
ENABLE QUERY REWRITE AS
SELECT country, prod, year, sale, cnt
FROM my_groupby_mv
MODEL PARTITION BY(country) DIMENSION BY(prod, year)
   MEASURES(sale s) IGNORE NAV
(s[&#39;Shorts&#39;, 2000] =  0.2 * AVG(s)[CV(), year BETWEEN 1996 AND 1999],
s[&#39;Kids Pajama&#39;, 2000] = 0.5 * AVG(s)[CV(), year BETWEEN 1995 AND 1999],
s[&#39;Boys Pajama&#39;, 2000] = 0.6 * AVG(s)[CV(), year BETWEEN 1994 AND 1999],
...
&lt;hundreds of other update rules&gt;);
</pre>
<p>By using two materialized views, you can incrementally maintain the materialized view <code class="codeph">my_groupby_mv</code>. The materialized view <code class="codeph">my_model_mv</code> is on a much smaller data set because it is built on <code class="codeph">my_groupby_mv</code> and can be maintained by a complete refresh.</p>
<p>Materialized views with models can use complete refresh or PCT refresh only, and are available for partial text query rewrite only.</p>
<div class="infoboxnotealso" id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A__GUID-A8CBF5AB-82C5-4793-BF59-F7C8E7C4F82B">
<p class="notep1">See Also:</p>
<p><a href="sqlmodel.htm#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a> for further details about model calculations</p>
</div>
</div>
</div>
<a id="DWHSG8250"></a>
<div class="props_rev_3"><a id="GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF"></a>
<h2 id="DWHSG-GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF" class="sect2">Invalidating Materialized Views</h2>
<div>
<div class="section">
<p><a id="d24346e1308" class="indexterm-anchor"></a><a id="d24346e1312" class="indexterm-anchor"></a>Dependencies related to materialized views are automatically maintained to ensure correct operation. When a materialized view is created, the materialized view depends on the detail tables referenced in its definition. Any DML operation, such as an <code class="codeph">INSERT</code>, or <code class="codeph">DELETE</code>, <code class="codeph">UPDATE</code>, or DDL operation on any dependency in the materialized view will cause it to become invalid. To revalidate a materialized view, use the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">COMPILE</code> statement.</p>
<p>A materialized view is automatically revalidated when it is referenced. In many cases, the materialized view will be successfully and transparently revalidated. However, if a column has been dropped in a table referenced by a materialized view or the owner of the materialized view did not have one of the query rewrite privileges and that privilege has now been granted to the owner, you should use the following statement to revalidate the materialized view:</p>
<pre dir="ltr">ALTER MATERIALIZED VIEW mview_name COMPILE;
</pre>
<p>The state of a materialized view can be checked by querying the data dictionary views <code class="codeph">USER_MVIEWS</code> or <code class="codeph">ALL_MVIEWS</code>. The column <code class="codeph">STALENESS</code> will show one of the values <code class="codeph">FRESH</code>, <code class="codeph">STALE</code>, <code class="codeph">UNUSABLE</code>, <code class="codeph">UNKNOWN</code>, <code class="codeph">UNDEFINED</code>, or <code class="codeph">NEEDS_COMPILE</code> to indicate whether the materialized view can be used. The state is maintained automatically. However, if the staleness of a materialized view is marked as <code class="codeph">NEEDS_COMPILE</code>, you could issue an <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ... <code class="codeph">COMPILE</code> statement to validate the materialized view and get the correct staleness state. If the state of a materialized view is <code class="codeph">UNUSABLE</code>, you must perform a complete refresh to bring the materialized view back to the <code class="codeph">FRESH</code> state. If the materialized view is based on a prebuilt table that you never refresh, you must drop and re-create the materialized view. The staleness of remote materialized views is not tracked. Thus, if you use remote materialized views for rewrite, they are considered to be trusted.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8251"></a>
<div class="props_rev_3"><a id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91"></a>
<h2 id="DWHSG-GUID-BC3675D3-C925-4D72-B953-34E7C818EB91" class="sect2">About Security Issues with Materialized Views</h2>
<div>
<p><a id="d24346e1416" class="indexterm-anchor"></a>To create a <a id="d24346e1421" class="indexterm-anchor"></a>materialized view in your own schema, you must have the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> privilege and the <code class="codeph">SELECT</code> or <code class="codeph">READ</code> privilege to any tables referenced that are in another schema. To create a materialized view in another schema, you must have the <code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> privilege and the owner of the materialized view needs <code class="codeph">SELECT</code> or <code class="codeph">READ</code> privileges to the tables referenced if they are from another schema. Moreover, if you enable query rewrite on a materialized view that references tables outside your schema, you must have the <code class="codeph">GLOBAL</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> privilege or the <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> object privilege on each table outside your schema.</p>
<p>If the materialized view is on a prebuilt container, the creator, if different from the owner, must have the <code class="codeph">READ WITH GRANT</code> or <code class="codeph">SELECT</code> <code class="codeph">WITH</code> <code class="codeph">GRANT</code> privilege on the container table.</p>
<p>If you continue to get a privilege error while trying to create a materialized view and you believe that all the required privileges have been granted, then the problem is most likely due to a privilege not being granted explicitly and trying to inherit the privilege from a role instead. The owner of the materialized view must have explicitly been granted <code class="codeph">SELECT</code> or <code class="codeph">READ</code> access to the referenced tables if the tables are in a different schema.</p>
<p>If the materialized view is being created with <code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code> specified, then the owner of the materialized view requires an additional privilege if any of the tables in the defining query are outside the owner&#39;s schema. In that case, the owner requires the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code> system privilege or the <code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code> object privilege on each table outside the owner&#39;s schema.</p>
<div class="infoboxnotealso" id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91__GUID-1F2568A6-4F99-40D4-9C11-24AE6998C303">
<p class="notep1">See Also:</p>
<p><a href="advmv.htm#GUID-B0671C37-8287-46D6-A3D9-236DC7917775">Querying Materialized Views with Virtual Private Database (VPD)</a></p>
</div>
</div>
<a id="DWHSG8252"></a>
<div class="props_rev_3"><a id="GUID-B0671C37-8287-46D6-A3D9-236DC7917775"></a>
<h3 id="DWHSG-GUID-B0671C37-8287-46D6-A3D9-236DC7917775" class="sect3">Querying Materialized Views with Virtual Private Database (VPD)</h3>
<div>
<p>For<a id="d24346e1555" class="indexterm-anchor"></a><a id="d24346e1559" class="indexterm-anchor"></a> all security concerns, a materialized view serves as a view that happens to be materialized when you are directly querying the materialized view. When creating a view or materialized view, the owner must have the necessary permissions to access the underlying base relations of the view or materialized view that they are creating. With these permissions, the owner can publish a view or materialized view that other users can access, assuming they have been granted access to the view or materialized view.</p>
<p>Using materialized views with Virtual Private Database is similar. When you create a materialized view, there must not be any VPD policies in effect against the base relations of the materialized view for the owner of the materialized view. If any VPD policies exist, then you must use the <code class="codeph">USING TRUSTED CONSTRAINTS</code> clause when creating the materialized view. The owner of the materialized view may establish a VPD policy on the new materialized view. Users who access the materialized view are subject to the VPD policy on the materialized view. However, they are not additionally subject to the VPD policies of the underlying base relations of the materialized view, because security processing of the underlying base relations is performed against the owner of the materialized view.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="advmv.htm#GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE">Using Query Rewrite with Virtual Private Database</a></p>
</li>
<li>
<p><a href="advmv.htm#GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034">Restrictions with Materialized Views and Virtual Private Database</a></p>
</li>
</ul>
</div>
<a id="DWHSG8253"></a>
<div class="props_rev_3"><a id="GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE"></a>
<h4 id="DWHSG-GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE" class="sect4">Using Query Rewrite with Virtual Private Database</h4>
<div>
<p>When you <a id="d24346e1604" class="indexterm-anchor"></a>access a materialized view using query rewrite, the materialized view serves as an access structure much like an index. As such, the security implications for materialized views accessed in this way are much the same as for indexes: all security checks are performed against the relations specified in the request query. The index or materialized view is used to speed the performance of accessing the data, not provide any additional security checks. Thus, the presence of the index or materialized view presents no additional security checking.</p>
<p>This holds true when you are accessing a materialized view using query rewrite in the presence of VPD. The request query is subject to any VPD policies that are present against the relations specified in the query. Query rewrite may rewrite the query to use a materialize view instead of accessing the detail relations, but only if it can guarantee to deliver exactly the same rows as if the rewrite had not occurred. Specifically, query rewrite must retain and respect any VPD policies against the relations specified in the request query. However, any VPD policies against the materialized view itself do not have effect when the materialized view is accessed using query rewrite. This is because the data is already protected by the VPD policies against the relations in the request query.</p>
</div>
</div>
<a id="DWHSG8254"></a>
<div class="props_rev_3"><a id="GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034"></a>
<h4 id="DWHSG-GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034" class="sect4">Restrictions with Materialized Views and Virtual Private Database</h4>
<div>
<div class="section">
<p>Query <a id="d24346e1634" class="indexterm-anchor"></a>rewrite does not use its full and partial text match modes with request queries that include relations with active VPD policies, but it does use general rewrite methods. This is because VPD transparently transforms the request query to affect the VPD policy. If query rewrite were to perform a text match transformation against a request query with a VPD policy, the effect would be to negate the VPD policy.</p>
<p>In addition, when you create or refresh a materialized view, the owner of the materialized view must not have any active VPD policies in effect against the base relations of the materialized view, or an error is returned. The materialized view owner must either have no such VPD policies, or any such policy must return <code class="codeph">NULL</code>. This is because VPD would transparently modify the defining query of the materialized view such that the set of rows contained by the materialized view would not match the set of rows indicated by the materialized view definition.</p>
<p>One way to work around this restriction yet still create a materialized view containing the desired VPD-specified subset of rows is to create the materialized view in a user account that has no active VPD policies against the detail relations of the materialized view. In addition, you can include a predicate in the <code class="codeph">WHERE</code> clause of the materialized view that embodies the effect of the VPD policy. When query rewrite attempts to rewrite a request query that has that VPD policy, it matches up the VPD-generated predicate on the request query with the predicate you directly specify when you create the materialized view.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<a id="DWHSG8255"></a>
<div class="props_rev_3"><a id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E"></a>
<h2 id="DWHSG-GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E" class="sect2">Altering Materialized Views</h2>
<div>
<div class="section">
<p><a id="d24346e1672" class="indexterm-anchor"></a>Six modifications can be made to a materialized view. You can:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Change its refresh option (<code class="codeph">FAST/FORCE/COMPLETE/NEVER</code>).</p>
</li>
<li>
<p>Change its refresh mode (<code class="codeph">ON</code> <code class="codeph">COMMIT/ON</code> <code class="codeph">DEMAND</code>).</p>
</li>
<li>
<p>Recompile it.</p>
</li>
<li>
<p>Enable or disable its use for query rewrite.</p>
</li>
<li>
<p>Consider it fresh.</p>
</li>
<li>
<p>Partition maintenance operations.</p>
</li>
</ul>
<p>All other changes are achieved by dropping and then re-creating the materialized view.</p>
<p>The <code class="codeph">COMPILE</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement can be used when the materialized view has been invalidated. This compile process is quick, and allows the materialized view to be used by query rewrite again.</p>
<div class="infoboxnotealso" id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E__GUID-FE37E5E9-CD02-4786-BA38-AE9F48C02595">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF009" target="_blank" href="../SQLRF/statements_2.htm#SQLRF009"><span class="italic">Oracle Database SQL Language Reference</span></a> for further information about the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement</p>
</li>
<li>
<p><span class="q">&#34;<a href="advmv.htm#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">Invalidating Materialized Views</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1506">
<tr>
<td class="cellalignment1513">
<table class="cellalignment1511">
<tr>
<td class="cellalignment1510"><a href="basicmv.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1510"><a href="refresh.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1515">
<table class="cellalignment1509">
<tr>
<td class="cellalignment1510"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1510"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1510"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1510"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1510"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1510"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>