<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-6087"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Data%20Warehousing%20Optimizations%20and%20Techniques"></a><title>Data Warehousing Optimizations and Techniques</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="cardinality, degree of, degree of cardinality, indexes, columns, B-tree indexes, bitmap indexes versus"/>
<meta name="dcterms.created" content="2017-06-07T18:07:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Warehousing Guide"/>
<meta name="dcterms.identifier" content="E41670-11"/>
<meta name="dcterms.isVersionOf" content="DWHSG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="ch3physdes.htm" title="Previous" type="text/html"/>
<link rel="Next" href="part3.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41670-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-79C29A60-3477-448D-835D-2940D060D050"></a> <span id="PAGE" style="display:none;">9/32</span> <!-- End Header -->
<h1 id="DWHSG-GUID-79C29A60-3477-448D-835D-2940D060D050" class="sect1"><span class="enumeration_chapter">4</span> Data Warehousing Optimizations and Techniques</h1>
<div>
<p>The following topics provide information about schemas in a data warehouse:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-E4C8F817-8CD9-437B-819F-2917B7F48304">Using Indexes in Data Warehouses</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7">Using Integrity Constraints in a Data Warehouse</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-2207CC57-A4D8-4ED1-8676-151EFD7E3528">About Parallel Execution in Data Warehouses</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-11CD602C-2C37-4771-97A6-CFFEABB4259D">About Optimizing Storage Requirements in Data Warehouses</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-3AF4B9BF-F429-4AAF-983A-6F722484D0E2">Optimizing Star Queries and 3NF Schemas</a></p>
</li>
</ul>
</div>
<a id="DWHSG8130"></a>
<div class="props_rev_3"><a id="GUID-E4C8F817-8CD9-437B-819F-2917B7F48304"></a>
<h2 id="DWHSG-GUID-E4C8F817-8CD9-437B-819F-2917B7F48304" class="sect2">Using Indexes in Data Warehouses</h2>
<div>
<p>Indexes enable faster retrieval of data stored in data warehouses. This section discusses the following aspects of using indexes in data warehouses:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB">About Using Bitmap Indexes in Data Warehouses</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65">Benefits of Indexes for Data Warehousing Applications</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251">About Cardinality and Bitmap Indexes</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-017284C6-3D68-4469-BEB6-E3C6FB886A0C">How to Determine Candidates for Using a Bitmap Index</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F">Using Bitmap Join Indexes in Data Warehouses</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-DB336AF1-3550-4B89-AC53-9BDEE89327CA">Using B-Tree Indexes in Data Warehouses</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0">Using Index Compression</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-BEC3FACE-B5B1-4904-9BC9-9CA060BB9C76">Choosing Between Local Indexes and Global Indexes</a></p>
</li>
</ul>
</div>
<a id="DWHSG9041"></a>
<div class="props_rev_3"><a id="GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB"></a>
<h3 id="DWHSG-GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB" class="sect3">About Using Bitmap Indexes in Data Warehouses</h3>
<div>
<p><a id="d9535e129" class="indexterm-anchor"></a>Bitmap indexes are widely used in data warehousing environments. The environments typically have large amounts of data and ad hoc queries, but a low level of concurrent DML transactions. For such applications, bitmap indexing provides:</p>
<ul style="list-style-type: disc;">
<li>
<p>Reduced response time for large classes of ad hoc queries.</p>
</li>
<li>
<p>Reduced storage requirements compared to other indexing techniques.</p>
</li>
<li>
<p>Dramatic performance gains even on hardware with a relatively small number of CPUs or a small amount of memory.</p>
</li>
</ul>
<p>Fully indexing a large table with a traditional B-tree index can be prohibitively expensive in terms of disk space because the indexes can be several times larger than the data in the table. Bitmap indexes are typically only a fraction of the size of the indexed data in the table.</p>
<p>An index provides pointers to the rows in a table that contain a given key value. A regular index stores a list of rowids for each key corresponding to the rows with that key value. In a bitmap index, a bitmap for each key value replaces a list of rowids.</p>
<p>Each bit in the bitmap corresponds to a possible rowid, and if the bit is set, it means that the row with the corresponding rowid contains the key value. A mapping function converts the bit position to an actual rowid, so that the bitmap index provides the same functionality as a regular index. Bitmap indexes store the bitmaps in a compressed way. If the number of distinct key values is small, bitmap indexes compress better and the space saving benefit compared to a B-tree index becomes even better.</p>
<p>Bitmap indexes are most effective for queries that contain multiple conditions in the <code class="codeph">WHERE</code> clause. Rows that satisfy some, but not all, conditions are filtered out before the table itself is accessed. This improves response time, often dramatically. If you are unsure of which indexes to create, the SQL Access Advisor can generate recommendations on what to create. As the bitmaps from bitmap indexes can be combined quickly, it is usually best to use single-column bitmap indexes.</p>
<p>When creating bitmap indexes, you should use <code class="codeph">NOLOGGING</code> and <code class="codeph">COMPUTE</code> <code class="codeph">STATISTICS</code>. In addition, you should keep in mind that bitmap indexes are usually easier to destroy and re-create than to maintain.</p>
</div>
<a id="DWHSG8138"></a><a id="DWHSG9045"></a>
<div class="props_rev_3"><a id="GUID-1D0A6F59-1C6C-4221-BE3B-0352C6F0F07D"></a>
<h4 id="DWHSG-GUID-1D0A6F59-1C6C-4221-BE3B-0352C6F0F07D" class="sect4">About Bitmap Indexes and Nulls</h4>
<div>
<p>Unlike most other types of indexes, <a id="d9535e187" class="indexterm-anchor"></a><a id="d9535e191" class="indexterm-anchor"></a><a id="d9535e195" class="indexterm-anchor"></a>bitmap indexes include rows that have <code class="codeph">NULL</code> values. Indexing of nulls can be useful for some types of <a id="d9535e203" class="indexterm-anchor"></a>SQL statements, such as queries with the aggregate function <code class="codeph">COUNT</code>.</p>
<div class="example" id="GUID-1D0A6F59-1C6C-4221-BE3B-0352C6F0F07D__GUID-30AE74AE-E706-4AF7-86C2-3821C42D0EC3">
<p class="titleinexample">Example 4-1 Bitmap Index</p>
<pre dir="ltr">SELECT COUNT(*) FROM customers WHERE cust_marital_status IS NULL;
</pre>
<p>This query uses a bitmap index on <code class="codeph">cust_marital_status</code>. Note that this query would not be able to use a B-tree index, because B-tree indexes do not store the <code class="codeph">NULL</code> values.</p>
<pre dir="ltr">SELECT COUNT(*) FROM customers;
</pre>
<p>Any bitmap index can be used for this query because all table rows are indexed, including those that have <code class="codeph">NULL</code> data. If nulls were not indexed, the optimizer would be able to use indexes only on columns with <code class="codeph">NOT NULL</code> constraints.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="DWHSG9046"></a>
<div class="props_rev_3"><a id="GUID-BB615445-CF86-434E-9B16-5A8F0624A184"></a>
<h4 id="DWHSG-GUID-BB615445-CF86-434E-9B16-5A8F0624A184" class="sect4">About Bitmap Indexes on Partitioned Tables</h4>
<div>
<p><a id="d9535e255" class="indexterm-anchor"></a><a id="d9535e259" class="indexterm-anchor"></a><a id="d9535e261" class="indexterm-anchor"></a><a id="d9535e265" class="indexterm-anchor"></a><a id="d9535e269" class="indexterm-anchor"></a>You can create bitmap indexes on partitioned tables but they must be local to the partitioned table&mdash;they cannot be global indexes. A partitioned table can only have global B-tree indexes, partitioned or nonpartitioned.</p>
<div class="infoboxnotealso" id="GUID-BB615445-CF86-434E-9B16-5A8F0624A184__GUID-545DD362-4E47-4487-B5F3-08C21FE1A88A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF53981" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF53981"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink VLDBG1082" target="_blank" href="../VLDBG/GUID-0713E6BC-53D8-4CC4-A358-BF84596D2435.htm#VLDBG1082"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="DWHSG9042"></a>
<div class="props_rev_3"><a id="GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65"></a>
<h3 id="DWHSG-GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65" class="sect3">Benefits of Indexes for Data Warehousing Applications</h3>
<div>
<p><a id="d9535e309" class="indexterm-anchor"></a><a id="d9535e313" class="indexterm-anchor"></a>Bitmap indexes are primarily intended for data warehousing applications where users query the data rather than update it. They are not suitable for OLTP applications with large numbers of concurrent transactions modifying the data.</p>
<p>Indexes are more beneficial for high cardinality columns.</p>
<div class="infoboxnotealso" id="GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65__GUID-97DE73BF-6FE3-4094-B595-C93C3F51863A">
<p class="notep1">See Also:</p>
<p><a href="schemas.htm#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251">About Cardinality and Bitmap Indexes</a></p>
</div>
<p><a id="d9535e326" class="indexterm-anchor"></a><a id="d9535e328" class="indexterm-anchor"></a><a id="d9535e332" class="indexterm-anchor"></a><a id="d9535e336" class="indexterm-anchor"></a><a id="d9535e340" class="indexterm-anchor"></a>Parallel query and parallel DML work with bitmap indexes. Bitmap indexing also supports parallel create indexes and concatenated indexes.</p>
</div>
</div>
<a id="DWHSG8134"></a><a id="DWHSG8135"></a><a id="DWHSG9043"></a>
<div class="props_rev_3"><a id="GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251"></a>
<h3 id="DWHSG-GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251" class="sect3">About Cardinality and Bitmap Indexes</h3>
<div>
<p>The advantages of using bitmap indexes are greatest for columns in which the ratio of the number of distinct values to the number of rows in the table is small. This ratio is referred to as the <a href="glossary.htm#GUID-50473CD3-62C8-476E-8E04-CC2A6AEEA7EE"><span class="xrefglossterm">degree of cardinality</span></a>. A gender column, which has only two distinct values (male and female), is optimal for a bitmap index. However, data warehouse administrators also build bitmap indexes on columns with higher cardinalities.</p>
<p>For example, on a table with one million rows, a column with 10,000 distinct values is a candidate for a bitmap index. A bitmap index on this column can outperform a B-tree index, particularly when this column is often queried in conjunction with other indexed columns. In fact, in a typical data warehouse environments, a bitmap index can be considered for any non-unique column.</p>
<p>B-tree indexes are most effective for high-cardinality data: that is, for data with many possible values, such as <code class="codeph">customer_name</code> or <code class="codeph">phone_number</code>. In a data warehouse, B-tree indexes should be used only for unique columns or other columns with very high cardinalities (that is, columns that are almost unique). The majority of indexes in a data warehouse should be bitmap indexes.</p>
<p>In ad hoc queries and similar situations, bitmap indexes can dramatically improve query performance. <code class="codeph">AND</code> and <code class="codeph">OR</code> conditions in the <code class="codeph">WHERE</code> clause of a query can be resolved quickly by performing the corresponding Boolean operations directly on the bitmaps before converting the resulting bitmap to rowids. If the resulting number of rows is small, the query can be answered quickly without resorting to a full table scan.</p>
<p>The following query output shows a portion of a company&#39;s <code class="codeph">customers</code> table.</p>
<pre dir="ltr">SELECT cust_id, cust_gender, cust_marital_status, cust_income_level
FROM customers;

CUST_ID    C CUST_MARITAL_STATUS  CUST_INCOME_LEVEL
---------- - -------------------- ---------------------
... 
        70 F                      D: 70,000 - 89,999
        80 F married              H: 150,000 - 169,999
        90 M single               H: 150,000 - 169,999
       100 F                      I: 170,000 - 189,999
       110 F married              C: 50,000 - 69,999
       120 M single               F: 110,000 - 129,999
       130 M                      J: 190,000 - 249,999
       140 M married              G: 130,000 - 149,999
...
</pre>
<p>Because <code class="codeph">cust_gender</code>, <code class="codeph">cust_marital_status</code>, and <code class="codeph">cust_income_level</code> are all low-cardinality columns (there are only three possible values for marital status, two possible values for gender, and 12 for income level), bitmap indexes are ideal for these columns. Do not create a bitmap index on <code class="codeph">cust_id</code> because this is a unique column. Instead, a unique B-tree index on this column provides the most efficient representation and retrieval.</p>
<p><a href="schemas.htm#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__G1007545" title="This table illustrates a sample bitmap index.">Table 4-1</a> illustrates the bitmap index for the <code class="codeph">cust_gender</code> column in this example. It consists of two separate bitmaps, one for gender.</p>
<div class="tblformal" id="GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__G1007545">
<p class="titleintable">Table 4-1 Sample Bitmap Index</p>
<table class="cellalignment1516" title="Sample Bitmap Index" summary="This table illustrates a sample bitmap index.">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1572" id="d9535e455">Customer ID</th>
<th class="cellalignment1572" id="d9535e458">gender=&#39;M&#39;</th>
<th class="cellalignment1573" id="d9535e461">gender=&#39;F&#39;</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e466" headers="d9535e455">
<p><code class="codeph">cust_id 70</code></p>
</td>
<td class="cellalignment1574" headers="d9535e466 d9535e458">
<p>0</p>
</td>
<td class="cellalignment1575" headers="d9535e466 d9535e461">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e477" headers="d9535e455">
<p><code class="codeph">cust_id 80</code></p>
</td>
<td class="cellalignment1574" headers="d9535e477 d9535e458">
<p>0</p>
</td>
<td class="cellalignment1575" headers="d9535e477 d9535e461">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e488" headers="d9535e455">
<p><code class="codeph">cust_id 90</code></p>
</td>
<td class="cellalignment1574" headers="d9535e488 d9535e458">
<p>1</p>
</td>
<td class="cellalignment1575" headers="d9535e488 d9535e461">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e499" headers="d9535e455">
<p><code class="codeph">cust_id 100</code></p>
</td>
<td class="cellalignment1574" headers="d9535e499 d9535e458">
<p>0</p>
</td>
<td class="cellalignment1575" headers="d9535e499 d9535e461">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e510" headers="d9535e455">
<p><code class="codeph">cust_id 110</code></p>
</td>
<td class="cellalignment1574" headers="d9535e510 d9535e458">
<p>0</p>
</td>
<td class="cellalignment1575" headers="d9535e510 d9535e461">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e521" headers="d9535e455">
<p><code class="codeph">cust_id 120</code></p>
</td>
<td class="cellalignment1574" headers="d9535e521 d9535e458">
<p>1</p>
</td>
<td class="cellalignment1575" headers="d9535e521 d9535e461">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e532" headers="d9535e455">
<p><code class="codeph">cust_id 130</code></p>
</td>
<td class="cellalignment1574" headers="d9535e532 d9535e458">
<p>1</p>
</td>
<td class="cellalignment1575" headers="d9535e532 d9535e461">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1574" id="d9535e543" headers="d9535e455">
<p><code class="codeph">cust_id 140</code></p>
</td>
<td class="cellalignment1574" headers="d9535e543 d9535e458">
<p>1</p>
</td>
<td class="cellalignment1575" headers="d9535e543 d9535e461">
<p>0</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Each entry (or bit) in the bitmap corresponds to a single row of the <code class="codeph">customers</code> table. The value of each bit depends upon the values of the corresponding row in the table. For example, the bitmap <code class="codeph">cust_gender=&#39;F&#39;</code> contains a one as its first bit because the gender is <code class="codeph">F</code> in the first row of the <code class="codeph">customers</code> table. The bitmap <code class="codeph">cust_gender=&#39;F&#39;</code> has a zero for its third bit because the gender of the third row is not <code class="codeph">F</code>.</p>
<p>An analyst investigating demographic trends of the company&#39;s customers might ask, &#34;How many of our married customers have an income level of G or H?&#34; This corresponds to the following query:</p>
<pre dir="ltr">SELECT COUNT(*) FROM customers
WHERE cust_marital_status = &#39;married&#39; 
AND cust_income_level IN (&#39;H: 150,000 - 169,999&#39;, &#39;G: 130,000 - 149,999&#39;);
</pre>
<p>Bitmap indexes can efficiently process this query by merely counting the number of ones in the bitmap illustrated in <a href="schemas.htm#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__I1006355">Figure 4-1</a>. The result set will be found by using bitmap <code class="codeph">OR</code> merge operations without the necessity of a conversion to rowids. To identify additional specific customer attributes that satisfy the criteria, use the resulting bitmap to access the table after a bitmap to rowid conversion.</p>
<div class="figure" id="GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__I1006355">
<p class="titleinfigure">Figure 4-1 Executing a Query Using Bitmap Indexes</p>
<img width="489" height="187" src="img/GUID-16B98D72-136C-4F5B-A6A8-F8899625AB01-default.gif" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows"/><br/>
<a href="img_text/GUID-16B98D72-136C-4F5B-A6A8-F8899625AB01-print.htm">Description of &#34;Figure 4-1 Executing a Query Using Bitmap Indexes&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="DWHSG9044"></a>
<div class="props_rev_3"><a id="GUID-017284C6-3D68-4469-BEB6-E3C6FB886A0C"></a>
<h3 id="DWHSG-GUID-017284C6-3D68-4469-BEB6-E3C6FB886A0C" class="sect3">How to Determine Candidates for Using a Bitmap Index</h3>
<div>
<p>Bitmap indexes should help when either the fact table is queried alone, and there are predicates on the indexed column, or when the fact table is joined with two or more dimension tables, and there are indexes on foreign key columns in the fact table, and predicates on dimension table columns.</p>
<p>A fact table column is a candidate for a bitmap index when the following conditions are met:</p>
<ul style="list-style-type: disc;">
<li>
<p>There are 100 or more rows for each distinct value in the indexed column. When this limit is met, the bitmap index will be much smaller than a regular index, and you will be able to create the index much faster than a regular index. An example would be one million distinct values in a multi-billion row table.</p>
</li>
</ul>
<p>And either of the following are true:</p>
<ul style="list-style-type: disc;">
<li>
<p>The indexed column will be restricted in queries (referenced in the <code class="codeph">WHERE</code> clause).</p>
</li>
</ul>
<p>or</p>
<ul style="list-style-type: disc;">
<li>
<p>The indexed column is a foreign key for a dimension table. In this case, such an index will make star transformation more likely.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG9047"></a>
<div class="props_rev_3"><a id="GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F"></a>
<h3 id="DWHSG-GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F" class="sect3">Using Bitmap Join Indexes in Data Warehouses</h3>
<div>
<p>In addition <a id="d9535e656" class="indexterm-anchor"></a><a id="d9535e658" class="indexterm-anchor"></a>to a bitmap index on a single table, you can create a bitmap join index, which is a bitmap index for the join of two or more tables. In a bitmap join index, the bitmap for the table to be indexed is built for values coming from the joined tables. In a data warehousing environment, the join condition is an equi-inner join between the primary key column or columns of the dimension tables and the foreign key column or columns in the fact table.</p>
<p>A bitmap join index can improve the performance by an order of magnitude. By storing the result of a join, the join can be avoided completely for SQL statements using a bitmap join index. Furthermore, because it is most likely to have a much smaller number of distinct values for a bitmap join index compared to a regular bitmap index on the join column, the bitmaps compress better, yielding to less space consumption than a regular bitmap index on the join column.</p>
<p>Bitmap join indexes are much more efficient in storage than materialized join views, an alternative for materializing joins in advance. This is because the materialized join views do not compress the rowids of the fact tables.</p>
<p>B-tree and bitmap indexes have different maximum column limitations.</p>
<div class="infoboxnotealso" id="GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F__GUID-ED545731-5592-42C8-A1D5-C0DCFE8F9AA5">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A">Four Join Models for Bitmap Join Indexes in Data Warehouses</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-DE86EDE6-3D64-49C0-8909-A787140E3B9F">Bitmap Join Index Restrictions and Requirements</a></p>
</li>
<li>
<p><a class="olink SQLRF54037" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF54037"><span class="italic">Oracle Database SQL Language Reference</span></a> for details regarding these limitations</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG8143"></a><a id="DWHSG8144"></a><a id="DWHSG8145"></a><a id="DWHSG8146"></a><a id="DWHSG9048"></a>
<div class="props_rev_3"><a id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A"></a>
<h4 id="DWHSG-GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A" class="sect4">Four Join Models for Bitmap Join Indexes in Data Warehouses</h4>
<div>
<p>The most common usage of a bitmap join index is in star model environments, where a large table is indexed on columns joined by one or several smaller tables. The large table is referred to as the fact table and the smaller tables as dimension tables. The following section describes the four different join models supported by bitmap join indexes.</p>
<p>The following example shows a bitmap join index where one dimension table column joins one fact table. Unlike the example in <a href="schemas.htm#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251">About Cardinality and Bitmap Indexes</a>, where a bitmap index on the <code class="codeph">cust_gender</code> column on the <code class="codeph">customers</code> table was built, you now create a bitmap join index on the fact table <code class="codeph">sales</code> for the joined column <code class="codeph">customers(cust_gender)</code>. Table <code class="codeph">sales</code> stores <code class="codeph">cust_id</code> values only:</p>
<pre dir="ltr">SELECT time_id, cust_id, amount_sold FROM sales;

TIME_ID   CUST_ID    AMOUNT_SOLD
--------- ---------- -----------
01-JAN-98      29700        2291
01-JAN-98       3380         114
01-JAN-98      67830         553
01-JAN-98     179330           0
01-JAN-98     127520         195
01-JAN-98      33030         280
...
</pre>
<p>To create such a bitmap join index, column <code class="codeph">customers(cust_gender)</code> has to be joined with table <code class="codeph">sales</code>. The join condition is specified as part of the <code class="codeph">CREATE</code> statement for the bitmap join index as follows:</p>
<pre dir="ltr">CREATE BITMAP INDEX sales_cust_gender_bjix
ON sales(customers.cust_gender)
FROM sales, customers
WHERE sales.cust_id = customers.cust_id
LOCAL NOLOGGING COMPUTE STATISTICS;
</pre>
<p>The following query shows the join result that is used to create the bitmaps that are stored in the bitmap join index:</p>
<pre dir="ltr">SELECT sales.time_id, customers.cust_gender, sales.amount_sold
FROM sales, customers
WHERE sales.cust_id = customers.cust_id;

TIME_ID   C AMOUNT_SOLD
--------- - -----------
01-JAN-98 M        2291
01-JAN-98 F         114
01-JAN-98 M         553
01-JAN-98 M           0
01-JAN-98 M         195
01-JAN-98 M         280
01-JAN-98 M          32
...
</pre>
<p><a href="schemas.htm#GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__G1007505" title="This table illustrates a sample bitmap join index">Table 4-2</a> illustrates the bitmap representation for the bitmap join index in this example.</p>
<div class="tblformal" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__G1007505">
<p class="titleintable">Table 4-2 Sample Bitmap Join Index</p>
<table class="cellalignment1516" title="Sample Bitmap Join Index" summary="This table illustrates a sample bitmap join index">
<thead>
<tr class="cellalignment1507">
<th class="cellalignment1576" id="d9535e774">Sales Record</th>
<th class="cellalignment1523" id="d9535e777">cust_gender=&#39;M&#39;</th>
<th class="cellalignment1577" id="d9535e780">cust_gender=&#39;F&#39;</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1507">
<td class="cellalignment1578" id="d9535e785" headers="d9535e774">
<p>sales record 1</p>
</td>
<td class="cellalignment1526" headers="d9535e785 d9535e777">
<p>1</p>
</td>
<td class="cellalignment1579" headers="d9535e785 d9535e780">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1578" id="d9535e795" headers="d9535e774">
<p>sales record 2</p>
</td>
<td class="cellalignment1526" headers="d9535e795 d9535e777">
<p>0</p>
</td>
<td class="cellalignment1579" headers="d9535e795 d9535e780">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1578" id="d9535e805" headers="d9535e774">
<p>sales record 3</p>
</td>
<td class="cellalignment1526" headers="d9535e805 d9535e777">
<p>1</p>
</td>
<td class="cellalignment1579" headers="d9535e805 d9535e780">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1578" id="d9535e815" headers="d9535e774">
<p>sales record 4</p>
</td>
<td class="cellalignment1526" headers="d9535e815 d9535e777">
<p>1</p>
</td>
<td class="cellalignment1579" headers="d9535e815 d9535e780">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1578" id="d9535e825" headers="d9535e774">
<p>sales record 5</p>
</td>
<td class="cellalignment1526" headers="d9535e825 d9535e777">
<p>1</p>
</td>
<td class="cellalignment1579" headers="d9535e825 d9535e780">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1578" id="d9535e835" headers="d9535e774">
<p>sales record 6</p>
</td>
<td class="cellalignment1526" headers="d9535e835 d9535e777">
<p>1</p>
</td>
<td class="cellalignment1579" headers="d9535e835 d9535e780">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1507">
<td class="cellalignment1578" id="d9535e845" headers="d9535e774">
<p>sales record 7</p>
</td>
<td class="cellalignment1526" headers="d9535e845 d9535e777">
<p>1</p>
</td>
<td class="cellalignment1579" headers="d9535e845 d9535e780">
<p>0</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>You can create other bitmap join indexes using more than one column or more than one table, as shown in these examples.</p>
<div class="example" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__GUID-63280F75-D92E-4253-96CD-76C4ACA943E0">
<p class="titleinexample">Example 4-2 Bitmap Join Index: Multiple Dimension Columns Join One Fact Table</p>
<p>You can create a bitmap join index on more than one column from a single dimension table, as in the following example, which uses <code class="codeph">customers(cust_gender, cust_marital_status)</code> from the <code class="codeph">sh</code> schema:</p>
<pre dir="ltr">CREATE BITMAP INDEX sales_cust_gender_ms_bjix
ON sales(customers.cust_gender, customers.cust_marital_status)
FROM sales, customers
WHERE sales.cust_id = customers.cust_id
LOCAL NOLOGGING COMPUTE STATISTICS;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__GUID-032899A1-681D-4FEE-91E4-995D5AC2B7A2">
<p class="titleinexample">Example 4-3 Bitmap Join Index: Multiple Dimension Tables Join One Fact Table</p>
<p>You can create a bitmap join index on multiple dimension tables, as in the following, which uses <code class="codeph">customers(gender)</code> and <code class="codeph">products(category)</code>:</p>
<pre dir="ltr">CREATE BITMAP INDEX sales_c_gender_p_cat_bjix
ON sales(customers.cust_gender, products.prod_category)
FROM sales, customers, products
WHERE sales.cust_id = customers.cust_id
AND sales.prod_id = products.prod_id
LOCAL NOLOGGING COMPUTE STATISTICS;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__GUID-8D898CC8-DE27-4121-887C-766A09C66264">
<p class="titleinexample">Example 4-4 Bitmap Join Index: Snowflake Schema</p>
<p>You can create a bitmap join index on more than one table, in which the indexed column is joined to the indexed table by using another table. For example, you can build an index on <code class="codeph">countries.country_name</code>, even though the <code class="codeph">countries</code> table is not joined directly to the <code class="codeph">sales</code> table. Instead, the <code class="codeph">countries</code> table is joined to the <code class="codeph">customers</code> table, which is joined to the <code class="codeph">sales</code> table. This type of schema is commonly called a <a href="glossary.htm#GUID-D7A24E71-C96A-48CB-A4A8-C1D33FD2678A"><span class="xrefglossterm">snowflake schema</span></a>.</p>
<pre dir="ltr">CREATE BITMAP INDEX sales_co_country_name_bjix
ON sales(countries.country_name)
FROM sales, customers, countries
WHERE sales.cust_id = customers.cust_id
  AND customers.country_id = countries.country_id
LOCAL NOLOGGING COMPUTE STATISTICS;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="DWHSG9049"></a>
<div class="props_rev_3"><a id="GUID-DE86EDE6-3D64-49C0-8909-A787140E3B9F"></a>
<h4 id="DWHSG-GUID-DE86EDE6-3D64-49C0-8909-A787140E3B9F" class="sect4">Bitmap Join Index Restrictions and Requirements</h4>
<div>
<div class="section">
<p>Join results must be stored, therefore, bitmap join indexes have the following restrictions:</p>
<ul style="list-style-type: disc;">
<li>
<p>Parallel DML is only supported on the fact table. Parallel DML on one of the participating dimension tables will mark the index as unusable.</p>
</li>
<li>
<p>Only one table can be updated concurrently by different transactions when using the bitmap join index.</p>
</li>
<li>
<p>No table can appear twice in the join.</p>
</li>
<li>
<p>You cannot create a bitmap join index on a temporary table.</p>
</li>
<li>
<p>The columns in the index must all be columns of the dimension tables.</p>
</li>
<li>
<p>The dimension table join columns must be either primary key columns or have unique constraints.</p>
</li>
<li>
<p>The dimension table column(s) participating the join with the fact table must be either the primary key column(s) or with the unique constraint.</p>
</li>
<li>
<p>If a dimension table has composite primary key, each column in the primary key must be part of the join.</p>
</li>
<li>
<p>The restrictions for creating a regular bitmap index also apply to a bitmap join index. For example, you cannot create a bitmap index with the <code class="codeph">UNIQUE</code> attribute. See <a class="olink SQLRF01209" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF01209"><span class="italic">Oracle Database SQL Language Reference</span></a> for other restrictions.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG9050"></a>
<div class="props_rev_3"><a id="GUID-DB336AF1-3550-4B89-AC53-9BDEE89327CA"></a>
<h3 id="DWHSG-GUID-DB336AF1-3550-4B89-AC53-9BDEE89327CA" class="sect3">Using B-Tree Indexes in Data Warehouses</h3>
<div>
<p><a id="d9535e993" class="indexterm-anchor"></a><a id="d9535e995" class="indexterm-anchor"></a>A B-tree index is organized like an upside-down tree. The bottom level of the index holds the actual data values and pointers to the corresponding rows, much as the index in a book has a page number associated with each index entry.</p>
<p>In general, use B-tree indexes when you know that your typical query refers to the indexed column and retrieves a few rows. In these queries, it is faster to find the rows by looking at the index. However, using the book index analogy, if you plan to look at every single topic in a book, you might not want to look in the index for the topic and then look up the page. It might be faster to read through every chapter in the book. Similarly, if you are retrieving most of the rows in a table, it might not make sense to look up the index to find the table rows. Instead, you might want to read or scan the table.</p>
<p>B-tree indexes are most commonly used in a data warehouse to enforce unique keys. In many cases, it may not even be necessary to index these columns in a data warehouse, because the uniqueness was enforced as part of the preceding ETL processing, and because typical data warehouse queries may not work better with such indexes. B-tree indexes are more common in environments using third normal form schemas. In general, bitmap indexes should be more common than B-tree indexes in most data warehouse environments.</p>
<p>B-tree and bitmap indexes have different maximum column limitations. See <a class="olink SQLRF54037" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF54037"><span class="italic">Oracle Database SQL Language Reference</span></a> for these limitations.</p>
</div>
</div>
<a id="DWHSG9051"></a>
<div class="props_rev_3"><a id="GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0"></a>
<h3 id="DWHSG-GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0" class="sect3">Using Index Compression</h3>
<div>
<p>Bitmap indexes are always stored in a patented, compressed manner without the need of any user intervention. B-tree indexes, however, can be stored specifically in a compressed manner to enable huge space savings, storing more keys in each index block, which also leads to less I/O and better performance.</p>
<p>Key compression lets you compress a B-tree index, which reduces the storage overhead of repeated values. In the case of a nonunique index, all index columns can be stored in a compressed format, whereas in the case of a unique index, at least one index column has to be stored uncompressed. In addition to key compression, OLTP index compression may provide a higher degree of compression, but is more appropriate for OLTP applications than data warehousing environments.</p>
<p>Generally, keys in an index have two pieces, a grouping piece and a unique piece. If the key is not defined to have a unique piece, Oracle Database provides one in the form of a rowid appended to the grouping piece. Key compression is a method of breaking off the grouping piece and storing it so it can be shared by multiple unique pieces. The cardinality of the chosen columns to be compressed determines the compression ratio that can be achieved. So, for example, if a unique index that consists of five columns provides the uniqueness mostly by the last two columns, it is most optimal to choose the three leading columns to be stored compressed. If you choose to compress four columns, the repetitiveness will be almost gone, and the compression ratio will be worse.</p>
<p>Although key compression reduces the storage requirements of an index, it can increase the CPU time required to reconstruct the key column values during an index scan. It also incurs some additional storage overhead, because every prefix entry has an overhead of four bytes associated with it.</p>
<div class="infoboxnotealso" id="GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0__GUID-FE68F4F0-4601-446E-BD17-9437FEA7D705">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN11692" target="_blank" href="../ADMIN/tables.htm#ADMIN11692"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information regarding key compression</p>
</li>
<li>
<p><a class="olink ADMIN11731" target="_blank" href="../ADMIN/indexes.htm#ADMIN11731"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information regarding OLTP index compression</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG9052"></a>
<div class="props_rev_3"><a id="GUID-BEC3FACE-B5B1-4904-9BC9-9CA060BB9C76"></a>
<h3 id="DWHSG-GUID-BEC3FACE-B5B1-4904-9BC9-9CA060BB9C76" class="sect3">Choosing Between Local Indexes and Global Indexes</h3>
<div>
<p>B-tree indexes on partitioned tables can be global or local. With Oracle8<span class="italic">i</span> and earlier releases, Oracle recommended that global indexes not be used in data warehouse environments because a partition DDL statement (for example, <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ... <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>) would invalidate the entire index, and rebuilding the index is expensive. Global indexes can be maintained without Oracle marking them as unusable after DDL, which makes global indexes effective for data warehouse environments.</p>
<p>However, local indexes will be more common than global indexes. Global indexes should be used when there is a specific requirement which cannot be met by local indexes (for example, a unique index on a non-partitioning key, or a performance requirement).</p>
<p>Bitmap indexes on partitioned tables are always local.</p>
</div>
</div>
</div>
<a id="DWHSG8151"></a>
<div class="props_rev_3"><a id="GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7"></a>
<h2 id="DWHSG-GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7" class="sect2">Using Integrity Constraints in a Data Warehouse</h2>
<div>
<p><a id="d9535e1117" class="indexterm-anchor"></a><a id="d9535e1119" class="indexterm-anchor"></a>Integrity constraints provide a mechanism for ensuring that data conforms to guidelines specified by the database administrator.</p>
<p>The most common types of constraints include:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">UNIQUE</code> constraints</p>
<p>To ensure that a given column is unique</p>
</li>
<li>
<p><code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints</p>
<p>To ensure that no null values are allowed</p>
</li>
<li>
<p><code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraints</p>
<p>To ensure that two keys share a primary key to foreign key relationship</p>
</li>
</ul>
<p>Constraints can be used for these purposes in a data warehouse:</p>
<ul style="list-style-type: disc;">
<li>
<p>Data cleanliness</p>
<p>Constraints verify that the data in the data warehouse conforms to a basic level of data consistency and correctness, preventing the introduction of dirty data.</p>
</li>
<li>
<p>Query optimization</p>
<p>The Oracle Database utilizes constraints when optimizing SQL queries. Although constraints can be useful in many aspects of query optimization, constraints are particularly important for query rewrite of materialized views.</p>
</li>
</ul>
<p>Unlike data in many relational database environments, data in a data warehouse is typically added or modified under controlled circumstances during the extraction, transformation, and loading (<a id="d9535e1167" class="indexterm-anchor"></a>ETL) process. Multiple users normally do not update the data warehouse directly, as they do in an OLTP system.</p>
<div class="infoboxnotealso" id="GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7__GUID-BB811190-5A41-46F3-8579-E8FD22EEA027">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ettover.htm#GUID-50E33D2C-6F47-4449-8E49-90E4D7974A08">Data Movement/ETL Overview</a></p>
</li>
</ul>
</div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-FD72032A-105D-4E3E-9B08-7C0AB2095208">Overview of Constraint States</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-906B8374-0CD7-4BF5-AA0F-925AD1D53E87">Typical Data Warehouse Integrity Constraints</a></p>
</li>
</ul>
</div>
<a id="DWHSG9053"></a>
<div class="props_rev_3"><a id="GUID-FD72032A-105D-4E3E-9B08-7C0AB2095208"></a>
<h3 id="DWHSG-GUID-FD72032A-105D-4E3E-9B08-7C0AB2095208" class="sect3">Overview of Constraint States</h3>
<div>
<p>To understand how bes<a id="d9535e1214" class="indexterm-anchor"></a>t to use constraints in a data warehouse, you should first understand the basic purposes of constraints.</p>
<p>Some of these purposes are:</p>
<ul style="list-style-type: disc;">
<li>
<p>Enforcement</p>
<p>In order to use a constraint for enforcement, the constraint must be in the <code class="codeph">ENABLE</code> state. An enabled constraint ensures that all data modifications upon a given table (or tables) satisfy the conditions of the constraints. Data modification operations which produce data that violates the constraint fail with a constraint violation error.</p>
</li>
<li>
<p>Validation</p>
<p>To use a constraint for validation, the constraint must be in the <code class="codeph">VALIDATE</code> state. If the constraint is validated, then all data that currently resides in the table satisfies the constraint.</p>
<p>Note that validation is independent of enforcement. Although the typical constraint in an operational system is both enabled and validated, any constraint could be validated but not enabled or vice versa (enabled but not validated). These latter two cases are useful for data warehouses.</p>
</li>
<li>
<p>Belief</p>
<p>In some cases, you will know that the conditions for a given constraint are true, so you do not need to validate or enforce the constraint. However, you may wish for the constraint to be present anyway to improve query optimization and performance. When you use a constraint in this way, it is called a belief or <code class="codeph">RELY</code> constraint, and the constraint must be in the <code class="codeph">RELY</code> state. The <code class="codeph">RELY</code> state provides you with a mechanism for telling Oracle that a given constraint is believed to be true.</p>
<p>Note that the <code class="codeph">RELY</code> state only affects constraints that have not been validated.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG9054"></a>
<div class="props_rev_3"><a id="GUID-906B8374-0CD7-4BF5-AA0F-925AD1D53E87"></a>
<h3 id="DWHSG-GUID-906B8374-0CD7-4BF5-AA0F-925AD1D53E87" class="sect3">Typical Data Warehouse Integrity Constraints</h3>
<div>
<p>This section assumes that you are familiar with the typical use of constraints. That is, constraints that are both enabled and validated. For data warehousing, many users have discovered that such constraints may be prohibitively costly to build and maintain. The topics discussed are:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-87A7A37B-8BE9-4B05-B6C6-373C843E3D7D">UNIQUE Constraints in a Data Warehouse</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-791D9619-3AE8-4E2A-920A-4FF4A8F90643">FOREIGN KEY Constraints in a Data Warehouse</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-5D3BD56C-E637-4F6D-940D-3D69E8A06A31">RELY Constraints in a Data Warehouse</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-60854384-F566-4193-8457-AFF0598A2A52">NOT NULL Constraints in a Data Warehouse</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-40C66E78-C107-4CB1-90BE-02A9ADCFF2B3">Integrity Constraints and Parallelism in a Data Warehouse</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-C98E4A18-20EE-4C95-A18E-3811BB714D01">Integrity Constraints and Partitioning in a Data Warehouse</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-72719F57-92C2-4628-9E4E-0CA939C949A6">View Constraints in a Data Warehouse</a></p>
</li>
</ul>
</div>
<a id="DWHSG9055"></a>
<div class="props_rev_3"><a id="GUID-87A7A37B-8BE9-4B05-B6C6-373C843E3D7D"></a>
<h4 id="DWHSG-GUID-87A7A37B-8BE9-4B05-B6C6-373C843E3D7D" class="sect4">UNIQUE Constraints in a Data Warehouse</h4>
<div>
<p><a id="d9535e1338" class="indexterm-anchor"></a><a id="d9535e1342" class="indexterm-anchor"></a>A <code class="codeph">UNIQUE</code> constraint is typically enforced using a <code class="codeph">UNIQUE</code> index. However, in a data warehouse whose tables can be extremely large, creating a unique index can be costly both in processing time and in disk space.</p>
<p>Suppose that a data warehouse contains a table <code class="codeph">sales</code>, which includes a column <code class="codeph">sales_id</code>. <code class="codeph">sales_id</code> uniquely identifies a single sales transaction, and the data warehouse administrator must ensure that this column is unique within the data warehouse.</p>
<p>One way to create the constraint is as follows:</p>
<pre dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_uk
UNIQUE (prod_id, cust_id, promo_id, channel_id, time_id);
</pre>
<p>By default, this constraint is both enabled and validated. Oracle implicitly creates a unique index on <code class="codeph">sales_id</code> to support this constraint. However, this index can be problematic in a data warehouse for three reasons:</p>
<ul style="list-style-type: disc;">
<li>
<p>The unique index can be very large, because the <code class="codeph">sales</code> table can easily have millions or even billions of rows.</p>
</li>
<li>
<p>The unique index is rarely used for query execution. Most data warehousing queries do not have predicates on unique keys, so creating this index will probably not improve performance.</p>
</li>
<li>
<p>If <code class="codeph">sales</code> is partitioned along a column other than <code class="codeph">sales_id</code>, the unique index must be global. This can detrimentally affect all maintenance operations on the <code class="codeph">sales</code> table.</p>
</li>
</ul>
<p>A unique index is required for unique constraints to ensure that each individual row modified in the <code class="codeph">sales</code> table satisfies the <code class="codeph">UNIQUE</code> constraint.</p>
<p>For data warehousing tables, an alternative mechanism for unique constraints is illustrated in the following statement:</p>
<pre dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_uk
UNIQUE (prod_id, cust_id, promo_id, channel_id, time_id) DISABLE VALIDATE;
</pre>
<p>This statement creates a unique constraint, but, because the constraint is disabled, a unique index is not required. This approach can be advantageous for many data warehousing environments because the constraint now ensures uniqueness without the cost of a unique index.</p>
<p>However, there are trade-offs for the data warehouse administrator to consider with <code class="codeph">DISABLE</code> <code class="codeph">VALIDATE</code> constraints. Because this constraint is disabled, no DML statements that modify the unique column are permitted against the <code class="codeph">sales</code> table. You can use one of two strategies for modifying this table in the presence of a constraint:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use DDL to add data to this table (such as exchanging partitions). See the example in <a href="refresh.htm#GUID-64068234-BDB0-4C12-AE70-75571046A586">Refreshing Materialized Views</a>.</p>
</li>
<li>
<p>Before modifying this table, drop the constraint. Then, make all necessary data modifications. Finally, re-create the disabled constraint. Re-creating the constraint is more efficient than re-creating an enabled constraint. However, this approach does not guarantee that data added to the <code class="codeph">sales</code> table while the constraint has been dropped is unique.</p>
</li>
</ul>
</div>
</div>
<a id="DWHSG9056"></a>
<div class="props_rev_3"><a id="GUID-791D9619-3AE8-4E2A-920A-4FF4A8F90643"></a>
<h4 id="DWHSG-GUID-791D9619-3AE8-4E2A-920A-4FF4A8F90643" class="sect4">FOREIGN KEY Constraints in a Data Warehouse</h4>
<div>
<p><a id="d9535e1456" class="indexterm-anchor"></a><a id="d9535e1460" class="indexterm-anchor"></a>In a star schema data warehouse, <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraints validate the relationship between the fact table and the dimension tables. A sample constraint might be:</p>
<pre dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_time_fk
FOREIGN KEY (time_id) REFERENCES times (time_id)
ENABLE VALIDATE;
</pre>
<p>However, in some situations, you may choose to use a different state for the <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraints, in particular, the <code class="codeph">ENABLE NOVALIDATE</code> state. A data warehouse administrator might use an <code class="codeph">ENABLE NOVALIDATE</code> constraint when either:</p>
<ul style="list-style-type: disc;">
<li>
<p>The tables contain data that currently disobeys the constraint, but the data warehouse administrator wishes to create a constraint for future enforcement.</p>
</li>
<li>
<p>An enforced constraint is required immediately.</p>
</li>
</ul>
<p>Suppose that the data warehouse loaded new data into the fact tables every day, but refreshed the dimension tables only on the weekend. During the week, the dimension tables and fact tables may in fact disobey the <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraints. Nevertheless, the data warehouse administrator might wish to maintain the enforcement of this constraint to prevent any changes that might affect the <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraint outside of the ETL process. Thus, you can create the <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraints every night, after performing the ETL process, as shown in the following:</p>
<pre dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_time_fk
FOREIGN KEY (time_id) REFERENCES times (time_id)
ENABLE NOVALIDATE;
</pre>
<p><code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code> can quickly create an enforced constraint, even when the constraint is believed to be true. Suppose that the ETL process verifies that a <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraint is true. Rather than have the database re-verify this <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraint, which would require time and database resources, the data warehouse administrator could instead create a <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraint using <code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code>.</p>
</div>
</div>
<a id="DWHSG9057"></a>
<div class="props_rev_3"><a id="GUID-5D3BD56C-E637-4F6D-940D-3D69E8A06A31"></a>
<h4 id="DWHSG-GUID-5D3BD56C-E637-4F6D-940D-3D69E8A06A31" class="sect4">RELY Constraints in a Data Warehouse</h4>
<div>
<p><a id="d9535e1571" class="indexterm-anchor"></a><a id="d9535e1573" class="indexterm-anchor"></a>The ETL process commonly verifies that certain constraints are true. For example, it can validate all of the foreign keys in the data coming into the fact table. This means that you can trust it to provide clean data, instead of implementing constraints in the data warehouse. You create a <code class="codeph">RELY</code> constraint as follows:</p>
<pre dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_time_fk
FOREIGN KEY (time_id) REFERENCES times (time_id) 
RELY DISABLE NOVALIDATE;
</pre>
<p>This statement assumes that the primary key is in the <code class="codeph">RELY</code> state. <code class="codeph">RELY</code> constraints, even though they are not used for data validation, can:</p>
<ul style="list-style-type: disc;">
<li>
<p>Enable more sophisticated query rewrites for materialized views. See <a href="qrbasic.htm#GUID-DB76286B-8557-446B-A6CC-BC987C378076">Basic Query Rewrite for Materialized Views</a> for further details.</p>
</li>
<li>
<p>Enable other data warehousing tools to retrieve information regarding constraints directly from the Oracle data dictionary.</p>
</li>
</ul>
<p>Creating a <code class="codeph">RELY</code> constraint is inexpensive and does not impose any overhead during DML or load. Because the constraint is not being validated, no data processing is necessary to create it.</p>
</div>
</div>
<a id="DWHSG9058"></a>
<div class="props_rev_3"><a id="GUID-60854384-F566-4193-8457-AFF0598A2A52"></a>
<h4 id="DWHSG-GUID-60854384-F566-4193-8457-AFF0598A2A52" class="sect4">NOT NULL Constraints in a Data Warehouse</h4>
<div>
<p>When using query rewrite, you should consider whether <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints are required. The primary situation where you will need to use them is for join back query rewrite.</p>
<div class="infoboxnotealso" id="GUID-60854384-F566-4193-8457-AFF0598A2A52__GUID-EC0FE4BA-D960-4A0E-B8B4-F5BAB9B44DCA">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="qradv.htm#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36">Advanced Query Rewrite for Materialized Views</a> for further information regarding <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints when using query rewrite</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG9059"></a>
<div class="props_rev_3"><a id="GUID-40C66E78-C107-4CB1-90BE-02A9ADCFF2B3"></a>
<h4 id="DWHSG-GUID-40C66E78-C107-4CB1-90BE-02A9ADCFF2B3" class="sect4">Integrity Constraints and Parallelism in a Data Warehouse</h4>
<div>
<p>All constraints can be validated in parallel. When validating constraints on very large tables, parallelism is often necessary to meet performance goals. The degree of parallelism for a given constraint operation is determined by the default degree of parallelism of the underlying table.</p>
</div>
</div>
<a id="DWHSG9060"></a>
<div class="props_rev_3"><a id="GUID-C98E4A18-20EE-4C95-A18E-3811BB714D01"></a>
<h4 id="DWHSG-GUID-C98E4A18-20EE-4C95-A18E-3811BB714D01" class="sect4">Integrity Constraints and Partitioning in a Data Warehouse</h4>
<div>
<p><a id="d9535e1693" class="indexterm-anchor"></a>You can create and maintain constraints before you partition the data. Later chapters discuss the significance of partitioning for data warehousing. Partitioning can improve constraint management just as it does to management of many other operations. For example, <a href="refresh.htm#GUID-64068234-BDB0-4C12-AE70-75571046A586">Refreshing Materialized Views</a> provides a scenario creating <code class="codeph">UNIQUE</code> and <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> constraints on a separate staging table, and these constraints are maintained during the<a id="d9535e1711" class="indexterm-anchor"></a> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> statement.</p>
</div>
</div>
<a id="DWHSG9061"></a>
<div class="props_rev_3"><a id="GUID-72719F57-92C2-4628-9E4E-0CA939C949A6"></a>
<h4 id="DWHSG-GUID-72719F57-92C2-4628-9E4E-0CA939C949A6" class="sect4">View Constraints in a Data Warehouse</h4>
<div>
<p>You can <a id="d9535e1743" class="indexterm-anchor"></a><a id="d9535e1745" class="indexterm-anchor"></a>create constraints on views. The only type of constraint supported on a view is a <code class="codeph">RELY</code> constraint.</p>
<p>This type of constraint is useful when queries typically access views instead of base tables, and the database administrator thus needs to define the data relationships between views rather than tables.</p>
<div class="infoboxnotealso" id="GUID-72719F57-92C2-4628-9E4E-0CA939C949A6__GUID-8575DCC0-A6B9-4290-997E-35D4BF1852CE">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="basicmv.htm#GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF">Basic Materialized Views</a></p>
</li>
<li>
<p><a href="qrbasic.htm#GUID-DB76286B-8557-446B-A6CC-BC987C378076">Basic Query Rewrite for Materialized Views</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<a id="DWHSG9062"></a>
<div class="props_rev_3"><a id="GUID-2207CC57-A4D8-4ED1-8676-151EFD7E3528"></a>
<h2 id="DWHSG-GUID-2207CC57-A4D8-4ED1-8676-151EFD7E3528" class="sect2">About Parallel Execution in Data Warehouses</h2>
<div>
<p>Data<a id="d9535e1790" class="indexterm-anchor"></a><a id="d9535e1792" class="indexterm-anchor"></a>bases today, irrespective of whether they are data warehouses, operational data stores, or OLTP systems, contain a large amount of information. However, finding and presenting the right information in a timely fashion can be a challenge because of the vast quantity of data involved.</p>
<p>Parallel execution is the capability that addresses this challenge. Using parallel execution (also called parallelism), terabytes of data can be processed in minutes, not hours or days, simply by using multiple processes to accomplish a single task. This dramatically reduces response time for data-intensive operations on large databases typically associated with decision support systems (DSS) and data warehouses. You can also implement parallel execution on OLTP system for batch processing or schema maintenance operations such as index creation. Parallelism is the idea of breaking down a task so that, instead of one process doing all of the work in a query, many processes do part of the work at the same time. An example of this is when four processes combine to calculate the total sales for a year, each process handles one quarter of the year instead of a single processing handling all four quarters by itself. The improvement in performance can be quite significant.</p>
<p>Parallel execution improves processing for:</p>
<ul style="list-style-type: disc;">
<li>
<p>Queries requiring large table scans, joins, or partitioned index scans</p>
</li>
<li>
<p>Creations of large indexes</p>
</li>
<li>
<p>Creation of large tables (including materialized views)</p>
</li>
<li>
<p>Bulk inserts, updates, merges, and deletes</p>
</li>
</ul>
<p>You can also use parallel execution to access object types within an Oracle database. For example, you can use parallel execution to access large objects (LOBs).</p>
<p>Large data warehouses should always use parallel execution to achieve good performance. Specific operations in OLTP applications, such as batch operations, can also significantly benefit from parallel execution.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-86C93668-2C9B-4538-9F75-B0FC4072B238">Why Use Parallel Execution?</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C">Automatic Degree of Parallelism and Statement Queuing</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD">About In-Memory Parallel Execution in Data Warehouses</a></p>
</li>
</ul>
</div>
<a id="DWHSG9063"></a>
<div class="props_rev_3"><a id="GUID-86C93668-2C9B-4538-9F75-B0FC4072B238"></a>
<h3 id="DWHSG-GUID-86C93668-2C9B-4538-9F75-B0FC4072B238" class="sect3">Why Use Parallel Execution?</h3>
<div>
<p>Imagine that your task is to count the number of cars in a street. There are two ways to do this. One, you can go through the street by yourself and count the number of cars or you can enlist a friend and then the two of you can start on opposite ends of the street, count cars until you meet each other and add the results of both counts to complete the task.</p>
<p>Assuming your friend counts equally fast as you do, you expect to complete the task of counting all cars in a street in roughly half the time compared to when you perform the job all by yourself. If this is the case, then your operations scales linearly. That is, twice the number of resources halves the total processing time.</p>
<p>A database is not very different from the counting cars example. If you allocate twice the number of resources and achieve a processing time that is half of what it was with the original amount of resources, then the operation scales linearly. Scaling linearly is the ultimate goal of parallel processing, both in counting cars as well as in delivering answers from a database query.</p>
<div class="infoboxnotealso" id="GUID-86C93668-2C9B-4538-9F75-B0FC4072B238__GUID-1DFA9FCB-C7FD-4AD5-8EFD-C7EF4D4EE4A2">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink VLDBG010" target="_blank" href="../VLDBG/GUID-3E2AE088-2505-465E-A8B2-AC38813EA355.htm#VLDBG010"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about using parallel execution</p>
</li>
</ul>
</div>
<p>This following topics provide guidance on the scenarios in which parallel execution is useful:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-C70CA94F-C5C0-4B49-9EF9-E96F37AE125B">When to Implement Parallel Execution</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-AC9BB244-D331-4F8E-B7E7-A1D79E7EA673">When Not to Implement Parallel Execution</a></p>
</li>
</ul>
</div>
<a id="DWHSG9064"></a>
<div class="props_rev_3"><a id="GUID-C70CA94F-C5C0-4B49-9EF9-E96F37AE125B"></a>
<h4 id="DWHSG-GUID-C70CA94F-C5C0-4B49-9EF9-E96F37AE125B" class="sect4">When to Implement Parallel Execution</h4>
<div>
<p>Parallel execution benefits systems with all of the following characteristics:</p>
<ul style="list-style-type: disc;">
<li>
<p>Symmetric multiprocessors (SMPs), clusters, or massively parallel systems</p>
</li>
<li>
<p>Sufficient I/O bandwidth</p>
</li>
<li>
<p>Underutilized or intermittently used CPUs (for example, systems where CPU usage is typically less than 30%)</p>
</li>
<li>
<p>Sufficient memory to support additional memory-intensive processes, such as sorts, hashing, and I/O buffers</p>
</li>
</ul>
<p>If your system lacks any of these characteristics, parallel execution might not significantly improve performance. In fact, parallel execution may reduce system performance on overutilized systems or systems with small I/O bandwidth.</p>
<p>The benefits of parallel execution can be seen in DSS and data warehousing environments. OLTP systems can also benefit from parallel execution during batch processing and during schema maintenance operations such as creation of indexes. The average simple DML or <code class="codeph">SELECT</code> statements, accessing or manipulating small sets of records or even single records, that characterize OLTP applications would not see any benefit from being executed in parallel.</p>
</div>
</div>
<a id="DWHSG9065"></a>
<div class="props_rev_3"><a id="GUID-AC9BB244-D331-4F8E-B7E7-A1D79E7EA673"></a>
<h4 id="DWHSG-GUID-AC9BB244-D331-4F8E-B7E7-A1D79E7EA673" class="sect4">When Not to Implement Parallel Execution</h4>
<div>
<p>Parallel execution is not normally useful for:</p>
<ul style="list-style-type: disc;">
<li>
<p>Environments in which the typical query or transaction is very short (a few seconds or less). This includes most online transaction systems. Parallel execution is not useful in these environments because there is a cost associated with coordinating the parallel execution servers; for short transactions, the cost of this coordination may outweigh the benefits of parallelism.</p>
</li>
<li>
<p>Environments in which the CPU, memory, or I/O resources are heavily utilized, even with parallel execution. Parallel execution is designed to exploit additional available hardware resources; if no such resources are available, then parallel execution does not yield any benefits and indeed may be detrimental to performance.</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG9067"></a><a id="DWHSG9066"></a>
<div class="props_rev_3"><a id="GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C"></a>
<h3 id="DWHSG-GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C" class="sect3">Automatic Degree of Parallelism and Statement Queuing</h3>
<div>
<p>As the name implies, automatic degree of parallelism is where Oracle Database determines the degree of parallelism (DOP) with which to run a statement (DML, DDL, and queries) based on the execution cost - the resource consumption of CPU, I/O, and memory - as determined by the Optimizer. That means that the database parses a query, calculates the cost and then determines a DOP to run with. The cheapest plan may be to run serially, which is also an option. <a href="schemas.htm#GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C__CIHGFIID">Figure 4-2</a> illustrates this decision making process.</p>
<div class="figure" id="GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C__CIHGFIID">
<p class="titleinfigure">Figure 4-2 Optimizer Calculation: Serial or Parallel?</p>
<img width="647" height="359" src="img/GUID-0295B79A-56EB-42EF-8A17-0AAF03F013A6-default.gif" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows"/><br/>
<a href="img_text/GUID-0295B79A-56EB-42EF-8A17-0AAF03F013A6-print.htm">Description of &#34;Figure 4-2 Optimizer Calculation: Serial or Parallel?&#34;</a></div>
<!-- class="figure" -->
<p>Should you choose to use automatic DOP, you may potentially see many more statements running in parallel, especially if the threshold is relatively low, where low is relative to the system and not an absolute quantifier.</p>
<p>Because of this expected behavior of more statements running in parallel with automatic DOP, it becomes more important to manage the utilization of the parallel processes available. That means that the system must be intelligent about when to run a statement and verify whether the requested numbers of parallel processes are available. The requested number of processes in this is the DOP for that statement.</p>
<p>The answer to this workload management question is parallel statement queuing with the Database Resource Manager. Parallel statement queuing runs a statement when its requested DOP is available. For example, when a statement requests a DOP of 64, it will not run if there are only 32 processes currently free to assist this customer, so the statement will be placed into a queue.</p>
<p>With Database Resource Manager, you can classify statements into workloads through consumer groups. Each consumer group can then be given the appropriate priority and the appropriate levels of parallel processes. Each consumer group also has its own queue to queue parallel statements based on the system load.</p>
<div class="infoboxnotealso" id="GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C__GUID-A9E604BC-5D37-44C8-8133-5ABF3D5ADFEF">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink VLDBG0103" target="_blank" href="../VLDBG/GUID-76AC9190-43AC-4529-89AD-1BDA95C6DFBD.htm#VLDBG0103"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about using automatic DOP with parallel execution</p>
</li>
<li>
<p><a class="olink ADMIN027" target="_blank" href="../ADMIN/dbrm.htm#ADMIN027"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about using the Database Resource Manager</p>
</li>
</ul>
</div>
</div>
</div>
<a id="DWHSG9068"></a>
<div class="props_rev_3"><a id="GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD"></a>
<h3 id="DWHSG-GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD" class="sect3">About In-Memory Parallel Execution in Data Warehouses</h3>
<div>
<p>Traditionally, parallel processing by-passed the database buffer cache for most operations, reading data directly from disk (through direct path I/O) into the parallel execution server&#39;s private working space. Only objects smaller than about 2% of <code class="codeph">DB_CACHE_SIZE</code> would be cached in the database buffer cache of an instance, and most objects accessed in parallel are larger than this limit. This behavior meant that parallel processing rarely took advantage of the available memory other than for its private processing. However, over the last decade, hardware systems have evolved quite dramatically; the memory capacity on a typical database server is now in the double or triple digit gigabyte range. This, together with Oracle&#39;s compression technologies and the capability of Oracle Database to exploit the aggregated database buffer cache of an Oracle Real Application Clusters environment, enables caching of objects in the terabyte range.</p>
<p>In-memory parallel execution takes advantage of this large aggregated database buffer cache. Having parallel execution servers accessing objects using the buffer cache enables full parallel in-memory processing of large volumes of data, leading to performance improvements in orders of magnitudes.</p>
<p>With in-memory parallel execution, when a SQL statement is issued in parallel, a check is conducted to determine if the objects accessed by the statement should be cached in the aggregated buffer cache of the system. In this context, an object can either be a table, index, or, in the case of partitioned objects, one or multiple partitions.</p>
<div class="infoboxnotealso" id="GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD__GUID-AA11E37F-5091-4A34-BA3F-2A8BC114B20C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink VLDBG13912" target="_blank" href="../VLDBG/GUID-AFEB5E27-9E6F-4924-B9C2-5354A948A8A5.htm#VLDBG13912"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about using in-memory parallel execution</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="DWHSG8912"></a>
<div class="props_rev_3"><a id="GUID-11CD602C-2C37-4771-97A6-CFFEABB4259D"></a>
<h2 id="DWHSG-GUID-11CD602C-2C37-4771-97A6-CFFEABB4259D" class="sect2">About Optimizing Storage Requirements in Data Warehouses</h2>
<div>
<p>You can <a id="d9535e2068" class="indexterm-anchor"></a>reduce your storage requirements by compressing data, which is achieved by eliminating duplicate values in a database block. <span class="q">&#34;<a href="schemas.htm#GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE">Using Data Compression to Improve Storage in Data Warehouses</a>&#34;</span> describes how you can use compress data.</p>
<p>Database objects that can be compressed include tables and materialized views. For partitioned tables, you can compress some or all partitions. Compression attributes can be declared for a tablespace, a table, or a partition of a table. If declared at the tablespace level, then all tables created in that tablespace are compressed by default. You can alter the compression attribute for a table (or a partition or tablespace), and the change applies only to new data going into that table. As a result, a single table or partition may contain some compressed blocks and some regular blocks. This guarantees that data size will not increase as a result of compression. In cases where compression could increase the size of a block, it is not applied to that block.</p>
</div>
<a id="DWHSG8914"></a><a id="DWHSG8913"></a>
<div class="props_rev_3"><a id="GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE"></a>
<h3 id="DWHSG-GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE" class="sect3">Using Data Compression to Improve Storage in Data Warehouses</h3>
<div>
<div class="section">
<p>You can compr<a id="d9535e2104" class="indexterm-anchor"></a>ess several partitions or a complete partitioned heap-organized table. You do this either by defining a complete partitioned table as being compressed, or by defining it on a per-partition level. Partitions without a specific declaration inherit the attribute from the table definition or, if nothing is specified on the table level, from the tablespace definition.</p>
<p>The decision about whether or not a partition should be compressed is based on the same rules as a nonpartitioned table. Because of the ability of range and composite partitioning to separate data logically into distinct partitions, a partitioned table is an ideal candidate for compressing parts of the data (partitions) that are mainly read-only. It is, for example, beneficial in all rolling window operations as a kind of intermediate stage before aging out old data. With data compression, you can keep more old data online, minimizing the burden of additional storage use.</p>
<p>You can also change any existing uncompressed table partition later, add new compressed and uncompressed partitions, or change the compression attribute as part of any partition maintenance operation that requires data movement, such as <a id="d9535e2111" class="indexterm-anchor"></a><code class="codeph">MERGE</code> <code class="codeph">PARTITION</code>, <a id="d9535e2119" class="indexterm-anchor"></a><code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>, or <a id="d9535e2128" class="indexterm-anchor"></a><code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>. The partitions can contain data, or they can be empty.</p>
<p>The access and maintenance of a partially or fully compressed partitioned table are the same as for a fully uncompressed partitioned table. All rules that apply to fully uncompressed partitioned tables are also valid for partially or fully compressed partitioned tables.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">To use data compression:</p>
</div>
<!-- class="section" -->
<div class="section">
<p>The following example creates a <a id="d9535e2144" class="indexterm-anchor"></a>range-partitioned table with one compressed partition <code class="codeph">costs_old</code>. The compression attribute for the table and all other partitions is inherited from the tablespace level.</p>
<pre dir="ltr">CREATE TABLE costs_demo (
   prod_id     NUMBER(6),    time_id     DATE, 
   unit_cost   NUMBER(10,2), unit_price  NUMBER(10,2))
PARTITION BY RANGE (time_id)
   (PARTITION costs_old 
       VALUES LESS THAN (TO_DATE(&#39;01-JAN-2003&#39;, &#39;DD-MON-YYYY&#39;)) COMPRESS,
    PARTITION costs_q1_2003 
       VALUES LESS THAN (TO_DATE(&#39;01-APR-2003&#39;, &#39;DD-MON-YYYY&#39;)),
    PARTITION costs_q2_2003
       VALUES LESS THAN (TO_DATE(&#39;01-JUN-2003&#39;, &#39;DD-MON-YYYY&#39;)),
    PARTITION costs_recent VALUES LESS THAN (MAXVALUE));
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8591"></a>
<div class="props_rev_3"><a id="GUID-3AF4B9BF-F429-4AAF-983A-6F722484D0E2"></a>
<h2 id="DWHSG-GUID-3AF4B9BF-F429-4AAF-983A-6F722484D0E2" class="sect2">Optimizing Star Queries and 3NF Schemas</h2>
<div>
<div class="section">
<p>Oracle data warehouses can work well with star schemas and third normal form schemas. This section presents important techniques for optimizing performance in both types of schema. For conceptual background on star and 3NF schemas, see <span class="q">&#34;<a href="ch2logdes.htm#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822">About Third Normal Form Schemas</a>&#34;</span>. and <span class="q">&#34;<a href="ch2logdes.htm#GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF">About Star Schemas</a>&#34;</span>.</p>
<p>You should consider the following when using star queries:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-095A1BEC-E373-49B2-A3CF-E059D42B6E7A">Optimizing Star Queries</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-56922781-3FDD-4E42-96BD-8CF5E199C951">Using Star Transformation</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-FA933363-8297-405F-BCE7-48EDA4AB8393">Optimizing Third Normal Form Schemas</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-355E68D9-2987-4AD5-9620-E37897A1635D">Optimizing Star Queries Using VECTOR GROUP BY Aggregation</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG9069"></a>
<div class="props_rev_3"><a id="GUID-095A1BEC-E373-49B2-A3CF-E059D42B6E7A"></a>
<h3 id="DWHSG-GUID-095A1BEC-E373-49B2-A3CF-E059D42B6E7A" class="sect3">Optimizing Star Queries</h3>
<div>
<div class="section">
<p>A star query is a join between a fact table and a number of dimension tables. Each dimension table is joined to the fact table using a primary key to foreign key join, but the dimension tables are not joined to each other. The optimizer recognizes star queries and generates efficient execution plans for them. <span class="q">&#34;<a href="schemas.htm#GUID-8B14F89D-6DB8-43C2-AC26-E1D9B7217DA0">Tuning Star Queries</a>&#34;</span> describes how to improve the performance of star queries.</p>
</div>
<!-- class="section" --></div>
<a id="DWHSG9070"></a>
<div class="props_rev_3"><a id="GUID-8B14F89D-6DB8-43C2-AC26-E1D9B7217DA0"></a>
<h4 id="DWHSG-GUID-8B14F89D-6DB8-43C2-AC26-E1D9B7217DA0" class="sect4">Tuning Star Queries</h4>
<div>
<div class="section">
<p>To get the best possible performance for star queries, it is important to follow some basic guidelines:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>A bitmap index should be built on each of the foreign key columns of the fact table or tables.</p>
</li>
<li>
<p>The initialization parameter <code class="codeph">STAR_TRANSFORMATION_ENABLED</code> should be set to <code class="codeph">TRUE</code>. This enables an important optimizer feature for star-queries. It is set to <code class="codeph">FALSE</code> by default for backward-compatibility.</p>
</li>
</ul>
<p>When a data warehouse satisfies these conditions, the majority of the star queries running in the data warehouse uses a query execution strategy known as the star transformation. The star transformation provides very efficient query performance for star queries.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG8593"></a>
<div class="props_rev_3"><a id="GUID-56922781-3FDD-4E42-96BD-8CF5E199C951"></a>
<h3 id="DWHSG-GUID-56922781-3FDD-4E42-96BD-8CF5E199C951" class="sect3">Using Star Transformation</h3>
<div>
<div class="section">
<p>The star transformation is a powerful optimization technique that relies upon implicitly rewriting (or transforming) the SQL of the original star query. The end user never needs to know any of the details about the star transformation. Oracle Database&#39;s query optimizer automatically chooses the star transformation where appropriate.</p>
<p><a id="d9535e2303" class="indexterm-anchor"></a><a id="d9535e2307" class="indexterm-anchor"></a>The star transformation is a query transformation aimed at executing star queries efficiently. Oracle Database processes a star query using two basic phases. The first phase retrieves exactly the necessary rows from the fact tabl<a id="d9535e2310" class="indexterm-anchor"></a>e (the result set). Because this retrieval utilizes bitmap indexes, it is very efficient. The second phase joins this result set to the dimension tables. An example of an end user query is: &#34;What were the sales and profits for the grocery department of stores in the west and southwest sales districts over the last three quarters?&#34; This is a simple star query.</p>
<p>This section contains the following topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="schemas.htm#GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD">Star Transformation with a Bitmap Index</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-C1F74A25-D794-4AA0-BDE2-BE84EFE70092">Execution Plan for a Star Transformation with a Bitmap Index</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-461A7350-5783-4E7E-9AE0-ED226D4AD864">Star Transformation with a Bitmap Join Index</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E">Execution Plan for a Star Transformation with a Bitmap Join Index</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-8CD0D8CE-CFD8-45B0-9D25-AC8804D5063D">How Oracle Chooses to Use Star Transformation</a></p>
</li>
<li>
<p><a href="schemas.htm#GUID-7F4319EA-6A11-4F0F-90DF-E4EF3E50EBE2">Star Transformation Restrictions</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="DWHSG8594"></a>
<div class="props_rev_3"><a id="GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD"></a>
<h4 id="DWHSG-GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD" class="sect4">Star Transformation with a Bitmap Index</h4>
<div>
<div class="section">
<p>A prerequisite of the star transformation is that there be a single-column bitmap index on every join column of the fact table. These join columns include all foreign key columns.</p>
<p>For example, the <code class="codeph">sales</code> table of the <code class="codeph">sh</code> sample schema has bitmap indexes on the <code class="codeph">time_id</code>, <code class="codeph">channel_id</code>, <code class="codeph">cust_id</code>, <code class="codeph">prod_id</code>, and <code class="codeph">promo_id</code> columns.</p>
<p>Consider the following star query:</p>
<pre dir="ltr">SELECT ch.channel_class, c.cust_city, t.calendar_quarter_desc,
   SUM(s.amount_sold) sales_amount
FROM sales s, times t, customers c, channels ch
WHERE s.time_id = t.time_id
AND   s.cust_id = c.cust_id
AND   s.channel_id = ch.channel_id
AND   c.cust_state_province = &#39;CA&#39;
AND   ch.channel_desc in (&#39;Internet&#39;,&#39;Catalog&#39;)
AND   t.calendar_quarter_desc IN (&#39;1999-Q1&#39;,&#39;1999-Q2&#39;)
GROUP BY ch.channel_class, c.cust_city, t.calendar_quarter_desc;
</pre>
<p>This query is processed in two phases. In the first phase, Oracle Database uses the bitmap indexes on the foreign key columns of the fact table to identify and retrieve only the necessary rows from the fact table. That is, Oracle Database retrieves the result set from the fact table using essentially the following query:</p>
<pre dir="ltr">SELECT ... FROM sales
WHERE time_id IN
  (SELECT time_id FROM times 
   WHERE calendar_quarter_desc IN(&#39;1999-Q1&#39;,&#39;1999-Q2&#39;))
   AND cust_id IN
  (SELECT cust_id FROM customers WHERE cust_state_province=&#39;CA&#39;)
   AND channel_id IN
  (SELECT channel_id FROM channels WHERE channel_desc IN(&#39;Internet&#39;,&#39;Catalog&#39;));
</pre>
<p>This is the transformation step of the algorithm, because the original star query has been transformed into this subquery representation. This method of accessing the fact table leverages the strengths of bitmap indexes. Intuitively, bitmap indexes provide a set-based processing scheme within a relational database. Oracle has implemented very fast methods for doing set operations such as <code class="codeph">AND</code> (an intersection in standard set-based terminology), <code class="codeph">OR</code> (a set-based union), <code class="codeph">MINUS</code>, and <code class="codeph">COUNT</code>.</p>
<p>In this star query, a bitmap index on <code class="codeph">time_id</code> is used to identify the set of all rows in the fact table corresponding to <code class="codeph">sales</code> in <code class="codeph">1999-Q1</code>. This set is represented as a bitmap (a string of 1&#39;s and 0&#39;s that indicates which rows of the fact table are members of the set).</p>
<p>A similar bitmap is retrieved for the fact table rows corresponding to the sale from <code class="codeph">1999-Q2</code>. The bitmap <code class="codeph">OR</code> operation is used to combine this set of <code class="codeph">Q1</code> sales with the set of <code class="codeph">Q2</code> sales.</p>
<p>Additional set operations will be done for the <code class="codeph">customer</code> dimension and the <code class="codeph">product</code> dimension. At this point in the star query processing, there are three bitmaps. Each bitmap corresponds to a separate dimension table, and each bitmap represents the set of rows of the fact table that satisfy that individual dimension&#39;s constraints.</p>
<p>These three bitmaps are combined into a single bitmap using the bitmap <code class="codeph">AND</code> operation. This final bitmap represents the set of rows in the fact table that satisfy all of the constraints on the dimension table. This is the result set, the exact set of rows from the fact table needed to evaluate the query. Note that none of the actual data in the fact table has been accessed. All of these operations rely solely on the bitmap indexes and the dimension tables. Because of the bitmap indexes&#39; compressed data representations, the bitmap set-based operations are extremely efficient.</p>
<p>Once the result set is identified, the bitmap is used to access the actual data from the sales table. Only those rows that are required for the end user&#39;s query are retrieved from the fact table. At this point, Oracle Database has effectively joined all of the dimension tables to the fact table using bitmap indexes. This technique provides excellent performance because Oracle Database is joining all of the dimension tables to the fact table with one logical join operation, rather than joining each dimension table to the fact table independently.</p>
<p>The second phase of this query is to join these rows from the fact table (the result set) to the dimension tables. Oracle uses the most efficient method for accessing and joining the dimension tables. Many dimension are very small, and table scans are typically the most efficient access method for these dimension tables. For large dimension tables, table scans may not be the most efficient access method. In the previous example, a bitmap index on <code class="codeph">product.department</code> can be used to quickly identify all of those products in the grocery department. Oracle Database&#39;s optimizer automatically determines which access method is most appropriate for a given dimension table, based upon the optimizer&#39;s knowledge about the sizes and data distributions of each dimension table.</p>
<p>The specific join method (as well as indexing method) for each dimension table will likewise be intelligently determined by the optimizer. A hash join is often the most efficient algorithm for joining the dimension tables. The final answer is returned to the user once all of the dimension tables have been joined. The query technique of retrieving only the matching rows from one table and then joining to another table is commonly known as a semijoin.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="DWHSG8595"></a>
<div class="props_rev_3"><a id="GUID-C1F74A25-D794-4AA0-BDE2-BE84EFE70092"></a>
<h4 id="DWHSG-GUID-C1F74A25-D794-4AA0-BDE2-BE84EFE70092" class="sect4">Execution Plan for a Star Transformation with a Bitmap Index</h4>
<div>
<p><a id="d9535e2485" class="indexterm-anchor"></a><a id="d9535e2489" class="indexterm-anchor"></a><a id="d9535e2493" class="indexterm-anchor"></a>The following typical execution plan might result from <span class="q">&#34;<a href="schemas.htm#GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD">Star Transformation with a Bitmap Index</a>&#34;</span>:</p>
<pre dir="ltr">SELECT STATEMENT
 SORT GROUP BY
  HASH JOIN
   TABLE ACCESS FULL                          CHANNELS
   HASH JOIN
    TABLE ACCESS FULL                         CUSTOMERS
    HASH JOIN
     TABLE ACCESS FULL                        TIMES
     PARTITION RANGE ITERATOR
      TABLE ACCESS BY LOCAL INDEX ROWID       SALES
       BITMAP CONVERSION TO ROWIDS
        BITMAP AND
         BITMAP MERGE
          BITMAP KEY ITERATION
           BUFFER SORT
            TABLE ACCESS FULL                 CUSTOMERS
           BITMAP INDEX RANGE SCAN            SALES_CUST_BIX
         BITMAP MERGE
          BITMAP KEY ITERATION
           BUFFER SORT
            TABLE ACCESS FULL                 CHANNELS
           BITMAP INDEX RANGE SCAN            SALES_CHANNEL_BIX
         BITMAP MERGE
          BITMAP KEY ITERATION
           BUFFER SORT
            TABLE ACCESS FULL                 TIMES
           BITMAP INDEX RANGE SCAN            SALES_TIME_BIX
</pre>
<p>In this plan, the fact table is accessed through a bitmap access path based on a bitmap <code class="codeph">AND</code>, of three merged bitmaps. The three bitmaps are generated by the <code class="codeph">BITMAP</code> <code class="codeph">MERGE</code> row source being fed bitmaps from row source trees underneath it. Each such row source tree consists of a <code class="codeph">BITMAP</code> <code class="codeph">KEY</code> <code class="codeph">ITERATION</code> row source which fetches values from the subquery row source tree, which in this example is a full table access. For each such value, the <code class="codeph">BITMAP</code> <code class="codeph">KEY</code> <code class="codeph">ITERATION</code> row source retrieves the bitmap from the bitmap index. After the relevant fact table rows have been retrieved using this access path, they are joined with the dimension tables and temporary tables to produce the answer to the query.</p>
</div>
</div>
<a id="DWHSG8596"></a>
<div class="props_rev_3"><a id="GUID-461A7350-5783-4E7E-9AE0-ED226D4AD864"></a>
<h4 id="DWHSG-GUID-461A7350-5783-4E7E-9AE0-ED226D4AD864" class="sect4">Star Transformation with a Bitmap Join Index</h4>
<div>
<p>In addition to bitmap indexes, you can use a bitmap join index during star transformations. Assume you have the following additional index structure:</p>
<pre dir="ltr">CREATE BITMAP INDEX sales_c_state_bjix
ON sales(customers.cust_state_province)
FROM sales, customers
WHERE sales.cust_id = customers.cust_id
LOCAL NOLOGGING COMPUTE STATISTICS;
</pre>
<p>The processing of the same star query using the bitmap join index is similar to the previous example. The only difference is that Oracle utilizes the join index, instead of a single-table bitmap index, to access the customer data in the first phase of the star query.</p>
</div>
</div>
<a id="DWHSG8597"></a>
<div class="props_rev_3"><a id="GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E"></a>
<h4 id="DWHSG-GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E" class="sect4">Execution Plan for a Star Transformation with a Bitmap Join Index</h4>
<div>
<p>The following typical execution plan might result from <span class="q">&#34;<a href="schemas.htm#GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E">Execution Plan for a Star Transformation with a Bitmap Join Index</a>&#34;</span>:</p>
<pre dir="ltr">SELECT STATEMENT
 SORT GROUP BY
  HASH JOIN
   TABLE ACCESS FULL                          CHANNELS
   HASH JOIN
    TABLE ACCESS FULL                         CUSTOMERS
    HASH JOIN
     TABLE ACCESS FULL                        TIMES
     PARTITION RANGE ALL
      TABLE ACCESS BY LOCAL INDEX ROWID       SALES
       BITMAP CONVERSION TO ROWIDS
        BITMAP AND
         BITMAP INDEX SINGLE VALUE            SALES_C_STATE_BJIX
         BITMAP MERGE
          BITMAP KEY ITERATION
           BUFFER SORT
            TABLE ACCESS FULL                 CHANNELS
           BITMAP INDEX RANGE SCAN            SALES_CHANNEL_BIX
         BITMAP MERGE
          BITMAP KEY ITERATION
           BUFFER SORT
            TABLE ACCESS FULL                 TIMES
           BITMAP INDEX RANGE SCAN            SALES_TIME_BIX
</pre>
<p>The difference between this plan as compared to the previous one is that the inner part of the bitmap index scan for the <code class="codeph">customer</code> dimension has no subselect. This is because the join predicate information on <code class="codeph">customer.cust_state_province</code> can be satisfied with the bitmap join index <code class="codeph">sales_c_state_bjix</code>.</p>
</div>
</div>
<a id="DWHSG8598"></a>
<div class="props_rev_3"><a id="GUID-8CD0D8CE-CFD8-45B0-9D25-AC8804D5063D"></a>
<h4 id="DWHSG-GUID-8CD0D8CE-CFD8-45B0-9D25-AC8804D5063D" class="sect4">How Oracle Chooses to Use Star Transformation</h4>
<div>
<p>The optimizer generates and saves the best plan it can produce without the transformation. If the transformation is enabled, the optimizer then tries to apply it to the query and, if applicable, generates the best plan using the transformed query. Based on a comparison of the cost estimates between the best plans for the two versions of the query, the optimizer then decides whether to use the best plan for the transformed or untransformed version.</p>
<p>If the query requires accessing a large percentage of the rows in the fact table, it might be better to use a full table scan and not use the transformations. However, if the constraining predicates on the dimension tables are sufficiently selective that only a small portion of the fact table must be retrieved, the plan based on the transformation will probably be superior.</p>
<p>Note that the optimizer generates a subquery for a dimension table only if it decides that it is reasonable to do so based on a number of criteria. There is no guarantee that subqueries will be generated for all dimension tables. The optimizer may also decide, based on the properties of the tables and the query, that the transformation does not merit being applied to a particular query. In this case, the best regular plan will be used.</p>
</div>
</div>
<a id="DWHSG8599"></a>
<div class="props_rev_3"><a id="GUID-7F4319EA-6A11-4F0F-90DF-E4EF3E50EBE2"></a>
<h4 id="DWHSG-GUID-7F4319EA-6A11-4F0F-90DF-E4EF3E50EBE2" class="sect4">Star Transformation Restrictions</h4>
<div>
<div class="section">
<p><a id="d9535e2651" class="indexterm-anchor"></a>Star transformation is not supported for tables with any of the following characteristics:</p>
<ul style="list-style-type: disc;">
<li>
<p>Queries with a table hint that is incompatible with a bitmap access path</p>
</li>
<li>
<p>Tables with too few bitmap indexes. There must be a bitmap index on a fact table column for the optimizer to generate a subquery for it.</p>
</li>
<li>
<p>Remote fact tables. However, remote dimension tables are allowed in the subqueries that are generated.</p>
</li>
<li>
<p>Anti-joined tables</p>
</li>
<li>
<p>Tables that are already used as a dimension table in a subquery</p>
</li>
<li>
<p>Tables that are really unmerged views, which are not view partitions</p>
</li>
<li>
<p>Tables where the fact table is an unmerged view</p>
</li>
<li>
<p>Tables where a partitioned view is used as a fact table</p>
</li>
</ul>
<p>The star transformation may not be chosen by the optimizer for the following cases:</p>
<ul style="list-style-type: disc;">
<li>
<p>Tables that have a good single-table access path</p>
</li>
<li>
<p>Tables that are too small for the transformation to be worthwhile</p>
</li>
</ul>
<p>In addition, temporary tables will not be used by star transformation under the following conditions:</p>
<ul style="list-style-type: disc;">
<li>
<p>The database is in read-only mode</p>
</li>
<li>
<p>The star query is part of a transaction that is in serializable mode</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG9071"></a>
<div class="props_rev_3"><a id="GUID-FA933363-8297-405F-BCE7-48EDA4AB8393"></a>
<h3 id="DWHSG-GUID-FA933363-8297-405F-BCE7-48EDA4AB8393" class="sect3">Optimizing Third Normal Form Schemas</h3>
<div>
<p>Optimizing a third normal form (3NF) schema requires the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Power</p>
<p>Power means that the hardware configuration must be balanced. Many data warehouse operations are based upon large table scans and other IO-intensive operations, which perform vast quantities of random IOs. In order to achieve optimal performance the hardware configuration must be sized end to end to sustain this level of throughput. This type of hardware configuration is called a balanced system. In a balanced system, all components - from the CPU to the disks - are orchestrated to work together to guarantee the maximum possible IO throughput.</p>
</li>
<li>
<p>Partitioning</p>
<p>The larger tables should be partitioned using composite partitioning (range-hash or list-hash). There are three reasons for this:</p>
<ul style="list-style-type: disc;">
<li>
<p>Easier manageability of terabytes of data</p>
</li>
<li>
<p>Faster accessibility to the necessary data</p>
</li>
<li>
<p>Efficient and performant table joins</p>
</li>
</ul>
<p>See <a href="schemas.htm#GUID-26000567-78DB-4E77-B07E-A51804A976E2">3NF Schemas: Partitioning</a>.</p>
</li>
<li>
<p>Parallel Execution</p>
<p>Parallel Execution enables a database task to be parallelized or divided into smaller units of work, thus allowing multiple processes to work concurrently. By using parallelism, a terabyte of data can be scanned and processed in minutes or less, not hours or days.</p>
<p>See <a href="schemas.htm#GUID-C4E08017-3A33-448A-9662-5421F9B2F272">3NF Schemas: Parallel Query Execution</a>.</p>
</li>
</ul>
</div>
<a id="DWHSG9072"></a>
<div class="props_rev_3"><a id="GUID-26000567-78DB-4E77-B07E-A51804A976E2"></a>
<h4 id="DWHSG-GUID-26000567-78DB-4E77-B07E-A51804A976E2" class="sect4">3NF Schemas: Partitioning</h4>
<div>
<p>Partitioning allows a table, index or index-organized table to be subdivided into smaller pieces. Each piece of the database object is called a partition. Each partition has its own name, and may optionally have its own storage characteristics. From the perspective of a database administrator, a partitioned object has multiple pieces that can be managed either collectively or individually.</p>
<p>This gives the administrator considerable flexibility in managing partitioned objects. However, from the perspective of the application, a partitioned table is identical to a non-partitioned table; no modifications are necessary when accessing a partitioned table using SQL DML commands. Partitioning can provide tremendous benefits to a wide variety of applications by improving manageability, availability, and performance.</p>
</div>
<a id="DWHSG9073"></a>
<div class="props_rev_3"><a id="GUID-EBB30A06-BA15-482F-A8BD-4E78DFED4220"></a>
<h5 id="DWHSG-GUID-EBB30A06-BA15-482F-A8BD-4E78DFED4220" class="sect5">Partitioning for Manageability</h5>
<div>
<p>Range partitioning will help improve the manageability and availability of large volumes of data. Consider the case where two year&#39;s worth of sales data or 100 terabytes (TB) is stored in a table. At the end of each day a new batch of data needs to be to loaded into the table and the oldest days worth of data needs to be removed. If the Sales table is ranged partitioned by day the new data can be loaded using a partition exchange load. This is a sub-second operation and should have little or no impact to end user queries. In order to remove the oldest day of data simply issue the following command:</p>
<pre dir="ltr">SH@DBM1 &gt; ALTER TABLE SALES DROP PARTITION Sales_Q4_2009;
</pre></div>
</div>
<a id="DWHSG9075"></a><a id="DWHSG9074"></a>
<div class="props_rev_3"><a id="GUID-12FA4D3D-126C-4841-91C9-89A67D293B87"></a>
<h5 id="DWHSG-GUID-12FA4D3D-126C-4841-91C9-89A67D293B87" class="sect5">Partitioning for Easier Data Access</h5>
<div>
<p>Range partitioning will also help ensure only the necessary data to answer a query will be scanned. Let&#39;s assume that the business users predominately accesses the sales data on a weekly basis, e.g. total sales per week then range partitioning this table by day will ensure that the data is accessed in the most efficient manner, as only 4 partitions need to be scanned to answer the business users query instead of the entire table. The ability to avoid scanning irrelevant partitions is known as partition pruning.</p>
<div class="figure" id="GUID-12FA4D3D-126C-4841-91C9-89A67D293B87__GUID-6C98ADA9-FF3A-4C13-9A9F-133B5D5F4DAF">
<p class="titleinfigure">Figure 4-3 Partition Pruning</p>
<img width="606" height="341" src="img/GUID-EBF01D64-A112-4658-BC7A-F08812DDBE2A-default.png" alt="Description of Figure 4-3 follows" title="Description of Figure 4-3 follows"/><br/>
<a href="img_text/GUID-EBF01D64-A112-4658-BC7A-F08812DDBE2A-print.htm">Description of &#34;Figure 4-3 Partition Pruning&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="DWHSG9077"></a><a id="DWHSG9078"></a><a id="DWHSG9076"></a>
<div class="props_rev_3"><a id="GUID-EE8606E5-1E0E-470C-9390-552502699E40"></a>
<h5 id="DWHSG-GUID-EE8606E5-1E0E-470C-9390-552502699E40" class="sect5">Partitioning for Join Performance</h5>
<div>
<div class="section">
<p>Sub-partitioning by hash is used predominately for performance reasons. Oracle uses a linear hashing algorithm to create sub-partitions. In order to ensure that the data gets evenly distributed among the hash partitions it is highly recommended that the number of hash partitions is a power of 2 (for example, 2, 4, 8, and so on). Each hash partition should be at least 16MB in size. Any smaller and they will not have efficient scan rates with parallel query.</p>
<p>One of the main performance benefits of hash partitioning is partition-wise joins. Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. This significantly reduces response time and improves both CPU and memory resource usage. In a clustered data warehouse, this significantly reduces response times by limiting the data traffic over the interconnect (IPC), which is the key to achieving good scalability for massive join operations. Partition-wise joins can be full or partial, depending on the partitioning scheme of the tables to be joined.</p>
<p>A full partition-wise join divides a join between two large tables into multiple smaller joins. Each smaller join performs a joins on a pair of partitions, one for each of the tables being joined. For the optimizer to choose the full partition-wise join method, both tables must be equi-partitioned on their join keys. That is, they have to be partitioned on the same column with the same partitioning method. Parallel execution of a full partition-wise join is similar to its serial execution, except that instead of joining one partition pair at a time, multiple partition pairs are joined in parallel by multiple parallel query servers. The number of partitions joined in parallel is determined by the Degree of Parallelism (DOP).</p>
<div class="figure" id="GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHCHHBJ">
<p class="titleinfigure">Figure 4-4 Full Partition-Wise Join</p>
<img width="620" height="318" src="img/GUID-C02CAEA3-F334-4966-BB12-01371EEFB676-default.png" alt="Description of Figure 4-4 follows" title="Description of Figure 4-4 follows"/><br/>
<a href="img_text/GUID-C02CAEA3-F334-4966-BB12-01371EEFB676-print.htm">Description of &#34;Figure 4-4 Full Partition-Wise Join&#34;</a></div>
<!-- class="figure" -->
<p><a href="schemas.htm#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHCHHBJ">Figure 4-4</a> illustrates the parallel execution of a full partition-wise join between two tables, <code class="codeph">Sales</code> and <code class="codeph">Customers</code>. Both tables have the same degree of parallelism and the same number of partitions. They are range partitioned on a date field and sub partitioned by hash on the <code class="codeph">cust_id</code> field. As illustrated in the picture, each partition pair is read from the database and joined directly. There is no data redistribution necessary, thus minimizing IPC communication, especially across nodes. <a href="schemas.htm#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">Figure 4-5</a> below shows the execution plan you would see for this join.</p>
<p>To ensure that you get optimal performance when executing a partition-wise join in parallel, the number of partitions in each of the tables should be larger than the degree of parallelism used for the join. If there are more partitions than parallel servers, each parallel server will be given one pair of partitions to join, when the parallel server completes that join, it will requests another pair of partitions to join. This process repeats until all pairs have been processed. This method enables the load to be balanced dynamically (for example, 128 partitions with a degree of parallelism of 32).</p>
<p>What happens if only one of the tables you are joining is partitioned? In this case the optimizer could pick a partial partition-wise join. Unlike full partition-wise joins, partial partition-wise joins can be applied if only one table is partitioned on the join key. Hence, partial partition-wise joins are more common than full partition-wise joins. To execute a partial partition-wise join, Oracle dynamically repartitions the other table based on the partitioning strategy of the partitioned table. Once the other table is repartitioned, the execution is similar to a full partition-wise join. The redistribution operation involves exchanging rows between parallel execution servers. This operation leads to interconnect traffic in Oracle RAC environments, because data needs to be repartitioned across node boundaries.</p>
<div class="figure" id="GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">
<p class="titleinfigure">Figure 4-5 Partial Partition-Wise Join</p>
<img width="620" height="305" src="img/GUID-B5D4F5D0-0215-4CE4-8950-F6F459224B35-default.png" alt="Description of Figure 4-5 follows" title="Description of Figure 4-5 follows"/><br/>
<a href="img_text/GUID-B5D4F5D0-0215-4CE4-8950-F6F459224B35-print.htm">Description of &#34;Figure 4-5 Partial Partition-Wise Join&#34;</a></div>
<!-- class="figure" -->
<p><a href="schemas.htm#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">Figure 4-5</a> illustrates a partial partition-wise join. It uses the same example as in <a href="schemas.htm#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHCHHBJ">Figure 4-4</a>, except that the customer table is not partitioned. Before the join operation is executed, the rows from the customers table are dynamically redistributed on the join key.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="DWHSG9079"></a>
<div class="props_rev_3"><a id="GUID-C4E08017-3A33-448A-9662-5421F9B2F272"></a>
<h4 id="DWHSG-GUID-C4E08017-3A33-448A-9662-5421F9B2F272" class="sect4">3NF Schemas: Parallel Query Execution</h4>
<div>
<p>3NF schemas can leverage parallelism in multiple ways, but here the focus is on one facet of parallelism that is specially significant to 3NF: SQL parallel execution for large queries. SQL parallel execution in the Oracle Database is based on the principles of a coordinator (often called the Query Coordinator or QC) and parallel servers. The QC is the session that initiates the parallel SQL statement and the parallel servers are the individual sessions that perform work in parallel. The QC distributes the work to the parallel servers and may have to perform a minimal mostly logistical - portion of the work that cannot be executed in parallel. For example a parallel query with a <code class="codeph">SUM()</code> operation requires adding the individual sub-totals calculated by each parallel server.</p>
<p>The QC is easily identified in the parallel execution in <a href="schemas.htm#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">Figure 4-5</a> as PX COORDINATOR. The process acting as the QC of a parallel SQL operation is the actual user session process itself. The parallel servers are taken from a pool of globally available parallel server processes and assigned to a given operation. The parallel servers do all the work shown in a parallel plan BELOW the QC.</p>
<p>By default, the Oracle Database is configured to support parallel execution out-of-the-box and is controlled by two initialization parameters <code class="codeph">parallel_max_servers</code> and <code class="codeph">parallel_min_servers</code>. While parallel execution provides a very powerful and scalable framework to speed up SQL operations, you should not forget to use some common sense rules; while parallel execution might buy you an additional incremental performance boost, it requires more resources and might also have side effects on other users or operations on the same system. Small tables/indexes (up to thousands of records; up to 10s of data blocks) should never be enabled for parallel execution. Operations that only hit small tables will not benefit much from executing in parallel, but they will use parallel servers that you will want to be available for operations accessing large tables. Remember also that once an operation starts at a certain degree of parallelism (DOP), there is no way to reduce its DOP during the execution.</p>
<p>The general rules of thumb for determining the appropriate DOP for an object are:</p>
<ul style="list-style-type: disc;">
<li>
<p>Objects smaller than 200 MB should not use any parallelism</p>
</li>
<li>
<p>Objects between 200 MB and 5GB should use a DOP of 4</p>
</li>
<li>
<p>Objects beyond 5GB use a DOP of 32</p>
</li>
</ul>
<p>Needless to say the optimal settings may vary on your system- either in size range or DOP - and highly depend on your target workload, the business requirements, and your hardware configuration. <a href="schemas.htm#GUID-76DC6364-A588-48BC-B651-101081E5ECB6">Whether or Not to Use Cross Instance Parallel Execution in Oracle RAC</a> describes parallel execution in Oracle RAC environments.</p>
</div>
<a id="DWHSG9080"></a>
<div class="props_rev_3"><a id="GUID-76DC6364-A588-48BC-B651-101081E5ECB6"></a>
<h5 id="DWHSG-GUID-76DC6364-A588-48BC-B651-101081E5ECB6" class="sect5">Whether or Not to Use Cross Instance Parallel Execution in Oracle RAC</h5>
<div>
<p>By default, Oracle Database enables inter-node parallel execution (parallel execution of a single statement involving more than one node). As mentioned earlier, the interconnect in an Oracle RAC environment must be sized appropriately as inter-node parallel execution may result in a lot of interconnect traffic. If you are using a relatively weak interconnect in comparison to the I/O bandwidth from the server to the storage subsystem, you may be better off restricting parallel execution to a single node or to a limited number of nodes. Inter-node parallel execution will not scale with an undersized interconnect. From Oracle Database 11<span class="italic">g</span> onwards, it is recommended to use Oracle RAC services to control parallel execution on a cluster.</p>
</div>
</div>
</div>
</div>
<a id="DWHSG9334"></a>
<div class="props_rev_3"><a id="GUID-355E68D9-2987-4AD5-9620-E37897A1635D"></a>
<h3 id="DWHSG-GUID-355E68D9-2987-4AD5-9620-E37897A1635D" class="sect3">Optimizing Star Queries Using VECTOR GROUP BY Aggregation</h3>
<div>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation <a id="d9535e3003" class="indexterm-anchor"></a>optimizes queries that aggregate data and join one or more relatively small tables to a larger table. This transformation can be chosen by the SQL optimizer based on cost estimates. In the context of data warehousing, <code class="codeph">VECTOR GROUP BY</code> will often be chosen for star queries that select data from in-memory columnar tables.</p>
<p><code class="codeph">VECTOR GROUP BY</code> aggregation is similar to a bloom filter in that it transforms the join condition between a small table and a large table into a filter on the larger table. <code class="codeph">VECTOR GROUP BY</code> aggregation further enhances query performance by aggregating data during the scan of the fact table rather than as a separate step following the scan.</p>
<div class="infoboxnotealso" id="GUID-355E68D9-2987-4AD5-9620-E37897A1635D__GUID-DA6FB3A0-4AE1-4859-A9C2-CD788E106993">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="ch2logdes.htm#GUID-C0C57677-E420-432C-9E1F-271011F0C775">About In-Memory Aggregation</a>&#34;</span></p>
</li>
<li>
<p><a class="olink TGSQL" target="_blank" href="../TGSQL/toc.htm"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for a detailed <code class="codeph">VECTOR GROUP BY</code> scenario</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1506">
<tr>
<td class="cellalignment1513">
<table class="cellalignment1511">
<tr>
<td class="cellalignment1510"><a href="ch3physdes.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1510"><a href="part3.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1515">
<table class="cellalignment1509">
<tr>
<td class="cellalignment1510"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1510"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1510"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1510"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1510"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1510"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>