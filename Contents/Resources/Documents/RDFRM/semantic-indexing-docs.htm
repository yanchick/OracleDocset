<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-88966"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Semantic%20Indexing%20for%20Documents"></a><title>Semantic Indexing for Documents</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="semantic index, using for documents, documents, semantic indexing for, information extractors, extractors, information, extractor policies, policies, indexing documents, mdsys.SemContent index type, SemContent, mdsys.SemContent index type, SEM_CONTAINS operator, syntax, SEM_CONTAINS_SELECT ancillary operator, SEM_CONTAINS_COUNTancillary operator, SPARQL, searching for documents using SPARQL query pattern, using in queries, quality of search, search, quality of, external documents, indexing, Calais, configuring the Calais extractor type, General Architecture for Text Engineering (GATE), using, GATE (General Architecture for Text Engineering), corpus-centric inference, document-centric inference"/>
<meta name="dcterms.created" content="2017-06-29T10:38:43Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Spatial and Graph RDF Semantic Graph Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E51611-08"/>
<meta name="dcterms.isVersionOf" content="RDFRM"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="skos.htm" title="Previous" type="text/html"/>
<link rel="Next" href="fine-grained-access.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E51611-08.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-842F5A67-7971-41C3-97FD-8B2BB21F25B3"></a> <span id="PAGE" style="display:none;">11/28</span> <!-- End Header -->
<a id="RDFRM99921"></a>
<h1 id="RDFRM-GUID-842F5A67-7971-41C3-97FD-8B2BB21F25B3" class="sect1"><span class="enumeration_chapter">4</span> Semantic Indexing for Documents</h1>
<div>
<p>Information extractors locate and extract meaningful information from unstructured documents. The ability to search for documents based on this extracted information is a significant improvement over the keyword-based searches supported by the full-text search engines.</p>
<p>Semantic indexing for documents introduces an index type that can make use of information extractors and annotators to semantically index documents stored in relational tables. Documents indexed semantically can be searched using SEM_CONTAINS operator within a standard SQL query. The search criteria for these documents are expressed using SPARQL query patterns that operate on the information extracted from the documents, as in the following example.</p>
<pre dir="ltr">SELECT docId
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
     &#39; { ?org    rdf:type            typ:Organization  . 
         ?org    pred:hasCategory    cat:BusinessFinance } &#39;, ..) = 1
</pre>
<p>The key components that facilitate Semantic Indexing for documents in an Oracle Database include:</p>
<ul style="list-style-type: disc;">
<li>
<p>Extensible information extractor framework, which allows third-party information extractors to be plugged into the database</p>
</li>
<li>
<p>SEM_CONTAINS operator to identify documents of interest, based on their extracted information, using standard SQL queries</p>
</li>
<li>
<p>SEM_CONTAINS_SELECT ancillary operator to return relevant information about the documents identified using SEM_CONTAINS operator</p>
</li>
<li>
<p>SemContext index type to interact with the information extractor and manage the information extracted from a document set in an index structure and to facilitate semantically meaningful searches on the documents</p>
</li>
</ul>
<p>The application program interface (API) for managing extractor policies and semantic indexes created for documents is provided in the SEM_RDFCTX PL/SQL package. <a href="sem-rdfctx-ref.htm#GUID-6C654E4C-4D2F-4EF6-B085-EDD1B7BC2F27">SEM_RDFCTX Package Subprograms</a> provides the reference information about the subprograms in SEM_RDFCTX package.</p>
<p>This chapter contains the following major sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="semantic-indexing-docs.htm#GUID-60317EBF-89EB-4581-9327-58A08A215F8D">Information Extractors for Semantically Indexing Documents</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-A06511AE-88AF-4341-8C1D-A4A5DAB19551">Extractor Policies</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-65ED585E-8107-4960-997E-ED180627B4C8">Semantically Indexing Documents</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-196189F0-AA72-4900-9D9A-4AD17F036133">SEM_CONTAINS and Ancillary Operators</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-23F6471D-60C8-4A81-BAC4-D01EBD4820BD">Searching for Documents Using SPARQL Query Patterns</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-316F984A-2C96-48B5-8C47-3EA0B10A8CE7">Bindings for SPARQL Variables in Matching Subgraphs in a Document (SEM_CONTAINS_SELECT Ancillary Operator)</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-3DE7ED65-BE78-421D-97D7-D64A2866A833">Improving the Quality of Document Search Operations</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-665B4669-4771-46BC-AF58-9A5A0B4E3C98">Indexing External Documents</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-5A73F616-66EF-4887-B123-9DB538E1C269">Configuring the Calais Extractor type</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-C293FD06-1FD8-426B-8D9F-661AE09389F4">Working with General Architecture for Text Engineering (GATE)</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-C37D3C31-0E22-40D6-AC6F-B090AD5C1992">Creating a New Extractor Type</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-8E3A0C41-6CF5-4A6A-9C89-02DBC2920CD6">Creating a Local Semantic Index on a Range-Partitioned Table</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-78F0B53C-3CE6-4700-844B-44F53119583A">Altering a Semantic Index</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-447F1C60-7EA6-44D5-9D0C-56DE01C6F09A">Passing Extractor-Specific Parameters in CREATE INDEX and ALTER INDEX</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-9E82A191-0B7B-4508-BE78-E10D3CB19234">Performing Document-Centric Inference</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-0C0409E6-2EED-4468-8F29-2FB00A51995C">Metadata Views for Semantic Indexing</a></p>
</li>
<li>
<p><a href="semantic-indexing-docs.htm#GUID-F631DC90-2FB2-41F4-8A00-FF8777480A03">Default Style Sheet for GATE Extractor Output</a></p>
</li>
</ul>
</div>
<a id="RDFRM99923"></a><a id="RDFRM99922"></a>
<div class="props_rev_3"><a id="GUID-60317EBF-89EB-4581-9327-58A08A215F8D"></a>
<h2 id="RDFRM-GUID-60317EBF-89EB-4581-9327-58A08A215F8D" class="sect2"><span class="enumeration_section">4.1</span> Information Extractors for Semantically Indexing Documents</h2>
<div>
<p><span class="bold">Information extractors</span> process unstructured documents and extract meaningful information from them, often using natural-language processing engines with the aid of ontologies. The quality and the completeness of information extracted from a document vary from one extractor to another. Some extractors simply identify the entities (such as names of persons, organizations, and geographic locations from a document), while the others attempt to identify the relationships among the identified entities and additional description for those entities. You can search for a specific document from a large set when the information extracted from the documents is maintained as a semantic index.</p>
<p>You can use an information extractor to create a semantic index on the documents stored in a column of a relational table. An extensible framework allows any third-party information extractor that is accessible from the database to be plugged into the database. An object type created for an extractor encapsulates the extraction logic, and has methods to configure the extractor and receive information extracted from a given document in RDF/XML format.</p>
<p>An abstract type MDSYS.RDFCTX_EXTRACTOR defines the common interfaces to all information extractors. An implementation of this abstract type interacts with a specific information extractor to produce RDF/XML for a given document. An implementation for this type can access a third-party information extractor that either is available as a database application or is installed on the network (accessed using Web service callouts). <a href="semantic-indexing-docs.htm#GUID-60317EBF-89EB-4581-9327-58A08A215F8D__BEIBDDEG">Example 4-1</a> shows the definition of the RDFCTX_EXTRACTOR abstract type.</p>
<div class="example" id="GUID-60317EBF-89EB-4581-9327-58A08A215F8D__BEIBDDEG">
<p class="titleinexample">Example 4-1 RDFCTX_EXTRACTOR Abstract Type Definition</p>
<pre dir="ltr">create or replace type rdfctx_extractor authid current_user as object (
  extr_type        VARCHAR2(32),
  member function  getDescription return VARCHAR2,
  member function  rdfReturnType return VARCHAR2,
  member function  getContext(attribute VARCHAR2) return VARCHAR2,
  member procedure startDriver,
  member function  extractRDF(document CLOB,
                              docId    VARCHAR2) return CLOB,
  member function  extractRdf(document CLOB,
                              docId    VARCHAR2,
                              params   VARCHAR2,
                              options  VARCHAR2 default NULL) return CLOB
  member function  batchExtractRdf(docCursor        SYS_REFCURSOR,
                              extracted_info_table  VARCHAR2,
                              params                VARCHAR2,
                              partition_name        VARCHAR2 default NULL,
                              docId                 VARCHAR2 default NULL,
                              preferences           SYS.XMLType default NULL,
                              options               VARCHAR2 default NULL)  
                              return CLOB,
  member procedure closeDriver
) not instantiable not final
/
</pre>
<p>A specific implementation of the RDFCTX_EXTRACTOR type sets an identifier for the extractor type in the <code class="codeph">extr_type</code> attribute, and it returns a short description for the extractor type using <code class="codeph">getDescription</code> method. All implementations of this abstract type return the extracted information as RDF triples. In the current release, the RDF triples are expected to be serialized using RDF/XML format, and therefore the <code class="codeph">rdfReturnType</code> method should return &#39;<code class="codeph">RDF/XML</code>&#39;.</p>
<p>An extractor type implementation uses the <code class="codeph">extractRDF</code> method to encapsulate the extraction logic, possibly by invoking external information extractor using proprietary interfaces, and returns the extracted information in RDF/XML format. When a third-party extractor uses some proprietary XML Schema to capture the extracted information, an XML style sheet can be used to generate an equivalent RDF/XML. The <code class="codeph">startDriver</code> and <code class="codeph">closeDriver</code> methods can perform any housekeeping operations pertaining to the information extractor. The optional <code class="codeph">params</code> parameter allows the extractor to obtain additional information about the type of extraction needed (for example, the desired quality of extraction).</p>
<p>Optionally, an extractor type implementation may support a batch interface by providing an implementation of the <code class="codeph">batchExtractRdf</code> member function. This function accepts a cursor through the input parameter <code class="codeph">docCursor</code> and typically uses that cursor to retrieve each document, extract information from the document, and then insert the extracted information into (the specified partition identified by the <code class="codeph">partition_name</code> partition of the <code class="codeph">extracted_info_table</code> table. The <code class="codeph">preferences</code> parameter is used to obtain the preferences value associated with the policy (as described in <a href="semantic-indexing-docs.htm#GUID-665B4669-4771-46BC-AF58-9A5A0B4E3C98">Indexing External Documents</a> and in the <a href="sem-rdfctx-ref.htm#GUID-B1F06381-1709-4335-AE8F-D937A76936A8">SEM_RDFCTX.CREATE_POLICY</a> reference section).</p>
<p>The <code class="codeph">getContext</code> member function accepts an attribute name and returns the value for that attribute. Currently this function is used only for extractors supporting the batch interface. The attribute names and corresponding possible return values are the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>For the <code class="codeph">BATCH_SUPPORT</code> attribute, the return values are &#39;<code class="codeph">YES</code>&#39; or &#39;<code class="codeph">NO</code>&#39; depending on whether the extractor supports the batch interface.</p>
</li>
<li>
<p>For the <code class="codeph">DBUSER</code> attribute, the return value is the name of a database user that will connect to the database to retrieve rows from the cursor (identified by the <code class="codeph">docCursor</code> parameter) and that will write to the table <code class="codeph">extracted_info_table</code>.</p>
</li>
</ul>
<p>This information is used for granting appropriate privileges to the table being indexed and the table <code class="codeph">extracted_info_table</code>.</p>
<p>The <code class="codeph">startDriver</code> and <code class="codeph">closeDriver</code> methods can perform any housekeeping operations pertaining to the information extractor.</p>
<p>An extractor type for the General Architecture for Text Engineering (GATE) engine is defined as a subtype of the RDFCTX_EXTRACTOR type. The implementation of this extractor type sends the documents to a GATE engine over a TCP connection, receives annotations extracted by the engine in XML format, and converts this proprietary XML document to an RDF/XML document. For more information on configuring a GATE engine to work with Oracle Database, see <a href="semantic-indexing-docs.htm#GUID-C293FD06-1FD8-426B-8D9F-661AE09389F4">Working with General Architecture for Text Engineering (GATE)</a>. For an example of creating a new information extractor, see <a href="semantic-indexing-docs.htm#GUID-C37D3C31-0E22-40D6-AC6F-B090AD5C1992">Creating a New Extractor Type</a>.</p>
<p>Information extractors that are deployed as Web services can be invoked from the database by extending the RDFCTX_WS_EXTRACTOR type, which is a subtype of the RDFCTX_EXTRACTOR type. The RDFCTX_WS_EXTRACTOR type encapsulates the Web service callouts in the <code class="codeph">extractRDF</code> method; specific implementations for network-based extractors can reuse this implementation by setting relevant attribute values in the type constructor.</p>
<p>Thomson Reuters Calais is an example of a network-based information extractor that can be accessed using web-service callouts. The CALAIS_EXTRACTOR type, which is a subtype of the RDFCTX_WS_EXTRACTOR type, encapsulates the Calais extraction logic, and it can be used to semantically index the documents. The CALAIS_EXTRACTOR type must be configured for the database instance before it can be used to create semantic indexes, as explained in <a href="semantic-indexing-docs.htm#GUID-5A73F616-66EF-4887-B123-9DB538E1C269">Configuring the Calais Extractor type</a>.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="RDFRM99924"></a>
<div class="props_rev_3"><a id="GUID-A06511AE-88AF-4341-8C1D-A4A5DAB19551"></a>
<h2 id="RDFRM-GUID-A06511AE-88AF-4341-8C1D-A4A5DAB19551" class="sect2"><span class="enumeration_section">4.2</span> Extractor Policies</h2>
<div>
<p>An <span class="bold">extractor policy</span> is a named dictionary entity that determines the characteristics of a semantic index that is created using the policy. Each extractor policy refers, directly or indirectly, to an instance of an extractor type. An extractor policy with a direct reference to an extractor type instance can be used to compose other extractor policies that include additional RDF models for ontologies.</p>
<p>The following example creates a basic extractor policy created using the GATE extractor type:</p>
<pre dir="ltr">begin
  sem_rdfctx.create_policy (policy_name =&gt; &#39;SEM_EXTR&#39;,
                            extractor   =&gt; mdsys.gatenlp_extractor());
end;
/
</pre>
<p>The following example creates a dependent extractor policy that combines the metadata extracted by the policy in the preceding example with a user-defined RDF model named <code class="codeph">geo_ontology</code>:</p>
<pre dir="ltr">begin
  sem_rdfctx.create_policy (policy_name =&gt; &#39;SEM_EXTR_PLUS_GEOONT&#39;,
                            base_policy =&gt; &#39;SEM_EXTR&#39;,
                            user_models =&gt; SEM_MODELS (&#39;geo_ontology&#39;));
end;
/
</pre>
<p>You can use an extractor policy to create one or more semantic indexes on columns that store unstructured documents, as explained in <a href="semantic-indexing-docs.htm#GUID-65ED585E-8107-4960-997E-ED180627B4C8">Semantically Indexing Documents</a>.</p>
</div>
</div>
<a id="RDFRM99925"></a>
<div class="props_rev_3"><a id="GUID-65ED585E-8107-4960-997E-ED180627B4C8"></a>
<h2 id="RDFRM-GUID-65ED585E-8107-4960-997E-ED180627B4C8" class="sect2"><span class="enumeration_section">4.3</span> Semantically Indexing Documents</h2>
<div>
<p>Textual documents stored in a CLOB or VARCHAR2 column of a relational table can be indexed using the MDSYS.SEMCONTEXT index type, to facilitate semantically meaningful searches. The extractor policy specified at index creation determines the information extractor used to semantically index the documents. The extracted information, captured as a set of RDF triples for each document, is managed in the semantic data store. Each instance of the semantic index is associated with a system-generated RDF model, which maintains the RDF triples extracted from the corresponding documents.</p>
<p>The following example creates a semantic index named <code class="codeph">ArticleIndex</code> on the textual documents in the ARTICLE column of the NEWSFEED table, using the extractor policy named <code class="codeph">SEM_EXTR</code>:</p>
<pre dir="ltr">CREATE INDEX ArticleIndex on Newsfeed (article)
   INDEXTYPE IS mdsys.SemContext PARAMETERS (&#39;SEM_EXTR&#39;);
</pre>
<p>The RDF model created for an index is managed internally and it is not associated with an application table. The triples stored in such model are automatically maintained for any modifications (such as update, insert, or delete) made to the documents stored in the table column. Although a single RDF model is used to index all documents stored in a table column, the triples stored in the model maintain references to the documents from which they are extracted; therefore, all the triples extracted from a specific document form an individual graph within the RDF model. The documents that are semantically indexed can then be searched using a SPARQL query pattern that operates on the triples extracted from the documents.</p>
<p>When creating a semantic index for documents, you can use a basic extractor policy or a dependent policy, which may include one or more user-defined RDF models. When you create an index with a dependent extractor policy, the document search pattern specified using SPARQL could span the triples extracted from the documents as well as those defined in user-defined models.</p>
<p>You can create an index using multiple extractor policies, in which case the triples extracted by the corresponding extractors are maintained separately in distinct RDF models. A document search query using one such index can select the specific policy to be used for answering the query. For example, an extractor policy named <code class="codeph">CITY_EXTR</code> can be created to extract the names of the cities from a given document, and this extractor policy can be used in combination with the SEM_EXTR policy to create a semantic index, as in the following example:</p>
<pre dir="ltr">CREATE INDEX ArticleIndex on Newsfeed (article)
   INDEXTYPE IS mdsys.SemContext PARAMETERS (<span class="bold">&#39;SEM_EXTR CITY_EXTR&#39;</span>);
</pre>
<p>The first extractor policy in the PARAMETERS list is considered to be the default policy if a query does not refer to a specific policy; however, you can change the default extractor policy for a semantic index by using the <a href="sem-rdfctx-ref.htm#GUID-2EBB554D-B440-4F75-B4D8-30C4490AB9AE">SEM_RDFCTX.SET_DEFAULT_POLICY</a> procedure, as in the following example:</p>
<pre dir="ltr">begin
  sem_rdfctx.set_default_policy (index_name =&gt; &#39;ArticleIndex&#39;,
                                 policy_name =&gt; &#39;CITY_EXTR&#39;);
end;
/
</pre></div>
</div>
<a id="RDFRM220"></a>
<div class="props_rev_3"><a id="GUID-196189F0-AA72-4900-9D9A-4AD17F036133"></a>
<h2 id="RDFRM-GUID-196189F0-AA72-4900-9D9A-4AD17F036133" class="sect2"><span class="enumeration_section">4.4</span> SEM_CONTAINS and Ancillary Operators</h2>
<div>
<p>You can use the SEM_CONTAINS operator in a standard SQL statement to search for documents or document references that are stored in relational tables. This operator has the following syntax:</p>
<pre dir="ltr">SEM_CONTAINS(
  column   VARCHAR2 / CLOB,
  sparql   VARCHAR2,
  policy   VARCHAR2,
  aliases  SEM_ALIASES,
  index_status  NUMBER,
  ancoper  NUMBER
 ) RETURN NUMBER;
</pre>
<p>The <code class="codeph">column</code> and <code class="codeph">sparql</code> attributes attribute are required. The other attributes are optional (that is, each can be a null value).</p>
<p>The <code class="codeph">column</code> attribute identifies a VARCHAR2 or CLOB column in a relational table that stores the documents or references to documents that are semantically indexed. An index of type MDSYS.SEMCONTEXT must be defined in this column for the SEM_CONTAINS operator to use.</p>
<p>The <code class="codeph">sparql</code> attribute is a string literal that defines the document search criteria, expressed in SPARQL format.</p>
<p>The optional <code class="codeph">policy</code> attribute specifies the name of an extractor policy, usually to override the default policy. A semantic document index can have one or more extractor policies specified at index creation, and one of these policies is the default, which is used if the <code class="codeph">policy</code> attribute is null in the call to SEM_CONTAINS.</p>
<p><a id="d33581e568" class="indexterm-anchor"></a><a id="d33581e570" class="indexterm-anchor"></a><a id="d33581e572" class="indexterm-anchor"></a>The optional <code class="codeph">aliases</code> attribute identifies one or more namespaces, including a default namespace, to be used for expansion of qualified names in the query pattern. Its data type is SEM_ALIASES, which has the following definition: <code class="codeph">TABLE OF SEM_ALIAS</code>, where each SEM_ALIAS element identifies a namespace ID and namespace value. The SEM_ALIAS data type has the following definition: <code class="codeph">(namespace_id VARCHAR2(30), namespace_val VARCHAR2(4000))</code></p>
<p>The optional <code class="codeph">index_status</code> attribute is relevant only when a dependent policy involving one or more entailments is being used for the SEM_CONTAINS invocation. The <code class="codeph">index_status</code> value identifies the minimum required validity status of the entailments. The possible values are <code class="codeph">0</code> (for VALID, the default), <code class="codeph">1</code> (for INCOMPLETE), and <code class="codeph">2</code> (for INVALID).</p>
<p><a id="d33581e603" class="indexterm-anchor"></a>The optional <code class="codeph">ancoper</code> attribute specifies a number as the binding to be used when the SEM_CONTAINS_SELECT ancillary operator is used with this operator in a query. The number specified for the <code class="codeph">ancoper</code> attribute should be the same as number specified for the <code class="codeph">operbind</code> attribute in the SEM_CONTAINS_SELECT ancillary operator.</p>
<p>The SEM_CONTAINS operator returns 1 for each document instance matching the specified search criteria, and returns 0 for all other cases.</p>
<p>For more information about using the SEM_CONTAINS operator, including an example, see <a href="semantic-indexing-docs.htm#GUID-23F6471D-60C8-4A81-BAC4-D01EBD4820BD">Searching for Documents Using SPARQL Query Patterns</a>.</p>
</div>
<a id="RDFRM221"></a>
<div class="props_rev_3"><a id="GUID-492C7896-76AC-489C-B9FF-EE6FFE83A720"></a>
<h3 id="RDFRM-GUID-492C7896-76AC-489C-B9FF-EE6FFE83A720" class="sect3"><span class="enumeration_section">4.4.1</span> SEM_CONTAINS_SELECT Ancillary Operator</h3>
<div>
<p>You can use the SEM_CONTAINS_SELECT ancillary operator to return additional information about each document that matches some search criteria. This ancillary operator has a single numerical attribute (<code class="codeph">operbind</code>) that associates an instance of the SEM_CONTAINS_SELECT ancillary operator with a SEM_CONTAINS operator by using the same value for the binding. This ancillary operator returns an object of type CLOB that contains the additional information from the matching document, formatted in SPARQL Query Results XML format.</p>
<p>The SEM_CONTAINS_SELECT ancillary operator has the following syntax:</p>
<pre dir="ltr">SEM_CONTAINS_SELECT(
  operbind  NUMBER
 ) RETURN CLOB;
</pre>
<p>For more information about using the SEM_CONTAINS_SELECT ancillary operator, including examples, see <a href="semantic-indexing-docs.htm#GUID-316F984A-2C96-48B5-8C47-3EA0B10A8CE7">Bindings for SPARQL Variables in Matching Subgraphs in a Document (SEM_CONTAINS_SELECT Ancillary Operator)</a>.</p>
</div>
</div>
<a id="RDFRM222"></a>
<div class="props_rev_3"><a id="GUID-052122C5-1DC1-405D-A8F8-8E7A8E7E0F6C"></a>
<h3 id="RDFRM-GUID-052122C5-1DC1-405D-A8F8-8E7A8E7E0F6C" class="sect3"><span class="enumeration_section">4.4.2</span> SEM_CONTAINS_COUNT Ancillary Operator</h3>
<div>
<p>You can use the SEM_CONTAINS_COUNT ancillary operator for a SEM_CONTAINS operator invocation. For each matched document, it returns the count of matching subgraphs for the SPARQL graph pattern specified in the SEM_CONTAINS invocation.</p>
<p>The SEM_CONTAINS_COUNT ancillary operator has the following syntax:</p>
<pre dir="ltr">SEM_CONTAINS_COUNT(
  operbind  NUMBER
 ) RETURN NUMBER;
</pre>
<p>The following example excerpt shows the use of the SEM_CONTAINS_COUNT ancillary operator to return the count of matching subgraphs for each matched document:</p>
<pre dir="ltr">SELECT docId, SEM_CONTAINS_COUNT(1) as matching_subgraph_count
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
  &#39;{ ?org   rdf:type          class:Organization  . 
     ?org   pred:hasCategory  cat:BusinessFinance }&#39;, .., 
   1)= 1;
</pre></div>
</div>
</div>
<a id="RDFRM99926"></a>
<div class="props_rev_3"><a id="GUID-23F6471D-60C8-4A81-BAC4-D01EBD4820BD"></a>
<h2 id="RDFRM-GUID-23F6471D-60C8-4A81-BAC4-D01EBD4820BD" class="sect2"><span class="enumeration_section">4.5</span> Searching for Documents Using SPARQL Query Patterns</h2>
<div>
<p>Documents that are semantically indexed (that is, indexed using the mdsys.SemContext index type) can be searched using SEM_CONTAINS operator within a standard SQL query. In the query, the SEM_CONTAINS operator must have at least two parameters, the first specifying the column in which the documents are stored and the second specifying the document search criteria expressed as a SPARQL query pattern, as in the following example:</p>
<pre dir="ltr">SELECT docId FROM Newsfeed
WHERE  SEM_CONTAINS (article, 
  &#39;{ ?org  rdf:type  &lt;http://www.example.com/classes/Organization&gt;  . 
     ?org  &lt;http://example.com/pred/hasCategory&gt;  
             &lt;http://www.example.com/category/BusinessFinance&gt; }&#39;
           )= 1;
</pre>
<p>The SPARQL query pattern specified with the SEM_CONTAINS operator is matched against the individual graphs corresponding to each document, and a document is considered to match a search criterion if the triples from the corresponding graph satisfy the query pattern. In the preceding example, the SPARQL query pattern identifies the individual graphs (thus, the documents) that refer to an <code class="codeph">Organization</code> that belong to <code class="codeph">BusinessFinance</code> category. The SQL query returns the rows corresponding to the matching documents in its result set. The preceding example assumes that the URIs used in the query are generated by the underlying extractor, and that you (the user searching for documents) are aware of the properties and terms that are generated by the extractor in use.</p>
<p>When you create an index using a dependent extractor policy that includes one or more user-defined RDF models, the triples asserted in the user models are considered to be common to all the documents. Document searches involving such policies test the search criteria against the triples in individual graphs corresponding to the documents, combined with the triples in the user models. For example, the following query identifies all articles referring to organizations in the state of New Hampshire, using the geographical ontology (<code class="codeph">geo_ontology</code> RDF Model from a preceding example) that maps cities to states:</p>
<pre dir="ltr">SELECT docId FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
        &#39;{ ?org     rdf:type          class:Organization  . 
           ?org     pred:hasLocation  <span class="bold">?city</span> . 
           <span class="bold">?city    geo:hasState      state:NewHampshire</span> }&#39;, 
        &#39;SEM_EXTR_PLUS_GEOONT&#39;, 
               sem_aliases(                              
                  sem_alias(&#39;class&#39;, &#39;http://www.myorg.com/classes/&#39;),
                  sem_alias(&#39;pred&#39;, &#39;http://www.myorg.com/pred/&#39;),
                  sem_alias(&#39;geo&#39;, &#39;http://geoont.org/rel/&#39;),
                  sem_alias(&#39;state&#39;, &#39;http://geoont.org/state/&#39;))) = 1;
</pre>
<p>The preceding query, with a reference to the extractor policy SEM_EXTR_PLUS_GEOONT (created in an example in <a href="semantic-indexing-docs.htm#GUID-A06511AE-88AF-4341-8C1D-A4A5DAB19551">Extractor Policies</a>), combines the triples extracted from the indexed documents and the triples in the user model to find matching documents. In this example, the name of the extractor policy is optional if the corresponding index is created with just this policy or if this is the default extractor policy for the index. When the query pattern uses some qualified names, an optional parameter to the SEM_CONTAINS operator can specify the namespaces to be used for expanding the qualified names.</p>
<p>SPARQL-based document searches can make use of the SPARQL syntax that is supported through SEM_MATCH queries.</p>
</div>
</div>
<a id="RDFRM99927"></a>
<div class="props_rev_3"><a id="GUID-316F984A-2C96-48B5-8C47-3EA0B10A8CE7"></a>
<h2 id="RDFRM-GUID-316F984A-2C96-48B5-8C47-3EA0B10A8CE7" class="sect2"><span class="enumeration_section">4.6</span> Bindings for SPARQL Variables in Matching Subgraphs in a Document (SEM_CONTAINS_SELECT Ancillary Operator)</h2>
<div>
<p>You can use the SEM_CONTAINS_SELECT ancillary operator to return additional information about each document matched using the SEM_CONTAINS operator. Specifically, the bindings for the variables used in SPARQL-based document search criteria can be returned using this operator. This operator is ancillary to the SEM_CONTAINS operator, and a literal number is used as an argument to this operator to associate it with a specific instance of SEM_CONTAINS operator, as in the following example:</p>
<pre dir="ltr">SELECT docId, <span class="bold">SEM_CONTAINS_SELECT(1)</span> as result
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
  &#39;{ ?org   rdf:type          class:Organization  . 
     ?org   pred:hasCategory  cat:BusinessFinance }&#39;, .., 
   <span class="bold">1</span>)= 1;
</pre>
<p>The SEM_CONTAINS_SELECT ancillary operator returns the bindings for the variables in SPARQL Query Results XML format, as CLOB data. The variables may be bound to multiple data instances from a single document, in which case all bindings for the variables are returned. The following example is an excerpt from the output of the preceding query: a value returned by the SEM_CONTAINS_SELECT ancillary operator for a document matching the specified search criteria.</p>
<pre dir="ltr">&lt;results&gt;
  &lt;result&gt; 
     &lt;binding name=&#34;ORG&#34;&gt;
        &lt;uri&gt;http://newscorp.com/Org/AcmeCorp&lt;/uri&gt;
     &lt;/binding&gt;
  &lt;/result&gt; 
  &lt;result&gt;
     &lt;binding name=&#34;ORG&#34;&gt;
       &lt;uri&gt;http://newscorp.com/Org/ABCCorp&lt;/uri&gt;
     &lt;/binding&gt;
  &lt;/result&gt;
&lt;/results&gt;
</pre>
<p>You can rank the search results by creating an instance of XMLType for the CLOB value returned by the SEM_CONTAINS_SELECT ancillary operator and applying an XPath expression to sort the results on some attribute values.</p>
<p>By default, the SEM_CONTAINS_SELECT ancillary operator returns bindings for all variables used in the SPARQL-based document search criteria. However, when the values for only a subset of the variables are relevant for a search, the SPARQL pattern can include a SELECT clause with space-separated list of variables for which the values should be returned, as in the following example:</p>
<pre dir="ltr">SELECT docId, SEM_CONTAINS_SELECT(1) as result
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
        &#39;<span class="bold">SELECT ?org  ?city</span> 
         <span class="bold">WHERE</span> { ?org     rdf:type          class:Organization  . 
                 ?org     pred:hasLocation  ?city . 
                 ?city    geo:hasState      state:NewHampshire }&#39;, .., 
         1) = 1;
</pre></div>
</div>
<a id="RDFRM99928"></a>
<div class="props_rev_3"><a id="GUID-3DE7ED65-BE78-421D-97D7-D64A2866A833"></a>
<h2 id="RDFRM-GUID-3DE7ED65-BE78-421D-97D7-D64A2866A833" class="sect2"><span class="enumeration_section">4.7</span> Improving the Quality of Document Search Operations</h2>
<div>
<p>The quality of a document search operation depends on the quality of the information produced by the extractor used to index the documents. If the information extracted is incomplete, you may want to add some annotations to a document. You can use the <a href="sem-rdfctx-ref.htm#GUID-58C106B6-67E1-451B-ABA5-7A1C6B14D92E">SEM_RDFCTX.MAINTAIN_TRIPLES</a> procedure to add annotations, in the form of RDF triples, to specific documents in order to improve the quality of search, as shown in the following example:</p>
<pre dir="ltr">begin
  sem_rdfctx.maintain_triples(
     index_name      =&gt; &#39;ArticleIndex&#39;,
     where_clause    =&gt; &#39;docid in (1,15,20)&#39;,  
     rdfxml_content =&gt; sys.xmltype(
      &#39;&lt;rdf:RDF xmlns:rdf=&#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#34; 
                xmlns:rdfs=&#34;http://www.w3.org/2000/01/rdf-schema#&#34;
                xmlns:pred=&#34;http://example.com/pred/&#34;&gt;
       &lt;rdf:Description rdf:about=&#34; http://newscorp.com/Org/ExampleCorp&#34;&gt;
         &lt;pred:hasShortName 
               rdf:datatype=&#34;http://www.w3.org/2001/XMLSchema#string&#34;&gt;
             Example
         &lt;/pred:hasShortName&gt;
     &lt;/rdf:Description&gt; 
    &lt;/rdf:RDF&gt;&#39;));
end;
/
</pre>
<p>The index name and the WHERE clause specified in the preceding example identify specific instances of the document to be annotated, and the RDF/XML content passed in is used to add additional triples to the individual graphs corresponding to those documents. This allows domain experts and user communities to improve the quality of search by adding relevant triples to annotate some documents.</p>
</div>
</div>
<a id="RDFRM99929"></a>
<div class="props_rev_3"><a id="GUID-665B4669-4771-46BC-AF58-9A5A0B4E3C98"></a>
<h2 id="RDFRM-GUID-665B4669-4771-46BC-AF58-9A5A0B4E3C98" class="sect2"><span class="enumeration_section">4.8</span> Indexing External Documents</h2>
<div>
<p>You can use semantic indexing on documents that are stored in a file system or on the network. In such cases, you store the references to external documents in a table column, and you create a semantic index on the column using an appropriate extractor policy.</p>
<p>To index external documents, define an extractor policy with appropriate preferences, using an XML document that is assigned to the <code class="codeph">preferences</code> parameter of the <a href="sem-rdfctx-ref.htm#GUID-B1F06381-1709-4335-AE8F-D937A76936A8">SEM_RDFCTX.CREATE_POLICY</a> procedure, as in the following example:</p>
<pre dir="ltr">begin
  sem_rdfctx.create_policy (
       policy_name =&gt; &#39;SEM_EXTR_FROM_FILE&#39;,
       extractor   =&gt; mdsys.gatenlp_extractor()),
       preferences =&gt; sys.xmltype(&#39;<span class="bold">&lt;RDFCTXPreferences&gt;</span>
                                     <span class="bold">&lt;Datastore type=&#34;FILE&#34;&gt;</span> 
                                        <span class="bold">&lt;Path&gt;EXTFILES_DIR&lt;/Path&gt;</span>
                                     <span class="bold">&lt;/Datastore&gt;</span>
                                   <span class="bold">&lt;/RDFCTXPreferences&gt;</span>&#39;)); 
end;
/
</pre>
<p>The <code class="codeph">&lt;Datastore&gt;</code> element in the preferences document specifies the type of repository used for the documents to be indexed. When the value for the <code class="codeph">type</code> attribute is set to <code class="codeph">FILE</code>, the <code class="codeph">&lt;Path&gt;</code> element identifies a directory object in the database (created using the SQL statement CREATE DIRECTORY). A table column indexed using the specified extractor policy is expected to contain relative paths to individual files within the directory object, as shown in the following example:</p>
<pre dir="ltr">CREATE TABLE newsfeed (docid       number, 
                       articleLoc  VARCHAR2(100)); 
INSERT INTO into newsfeed (docid, articleLoc) values
                     (1, &#39;<span class="bold">article1.txt</span>&#39;); 
INSERT INTO newsfeed (docid, articleLoc) values
                     (2, &#39;<span class="bold">folder/article2.txt</span>&#39;); 
 
CREATE INDEX ArticleIndex on newsfeed (articleLoc)
   INDEXTYPE IS mdsys.SemContext PARAMETERS (&#39;<span class="bold">SEM_EXTR_FROM_FILE</span>&#39;);
</pre>
<p>To index documents that are accessed using HTTP protocol, create a extractor policy with preferences that set the <code class="codeph">type</code> attribute of the <code class="codeph">&lt;Datastore&gt;</code> element to <code class="codeph">URL</code> and that list one or more hosts in the <code class="codeph">&lt;Path&gt;</code> elements, as shown in the following excerpt:</p>
<pre dir="ltr">&lt;RDFCTXPreferences&gt;
   &lt;Datastore <span class="bold">type=&#34;URL&#34;</span>&gt; 
       <span class="bold">&lt;Path&gt;http://cnn.com&lt;/Path&gt;</span>
       <span class="bold">&lt;Path&gt;http://abc.com&lt;/Path&gt;</span>
   &lt;/Datastore&gt;
&lt;/RDFCTXPreferences&gt;
</pre>
<p>The schema in which a semantic index for external documents is created must have the necessary privileges to access the external objects, including access to any proxy server used to access documents outside the firewall, as shown in the following example:</p>
<pre dir="ltr">-- Grant read access to the directory object for FILE data store -- 
grant read on directory EXTFILES_DIR to SEMUSR;
 
-- Grant connect access to set of hosts for URL data store -- 
begin
  dbms_network_acl_admin.create_acl (
                acl          =&gt; &#39;network_docs.xml&#39;,
                description  =&gt; &#39;Normal Access&#39;,
                principal    =&gt; &#39;SEMUSR&#39;,
                is_grant     =&gt; TRUE,
                privilege    =&gt; &#39;connect&#39;);
end;
/
 
begin
  dbms_network_acl_admin.assign_acl (
               acl        =&gt; &#39;network_docs.xml&#39;,
               host       =&gt;  &#39;cnn.com&#39;,
               lower_port =&gt; 1,
               upper_port =&gt; 10000);
end;
/
</pre>
<p>External documents that are semantically indexed in the database may be in one of the well-known formats such as Microsoft Word, RTF, and PDF. This takes advantage of the Oracle Text capability to extract plain text version from formatted documents using filters (see the CTX_DOC.POLICY_FILTER procedure, described in <a class="olink CCREF2116" target="_blank" href="../CCREF/cdocpkg.htm#CCREF2116"><span class="italic">Oracle Text Reference</span></a>). To semantically index formatted documents, you must specify the name of a CTX policy in the extractor preferences, as shown in the following excerpt:</p>
<pre dir="ltr">&lt;RDFCTXPreferences&gt;
   &lt;Datastore type=&#34;FILE&#34; <span class="bold">filter=&#34;CTX_FILTER_POLICY&#34;</span>&gt; 
       &lt;Path&gt;EXTFILES_DIR&lt;/Path&gt;
   &lt;/Datastore&gt;
&lt;/RDFCTXPreferences&gt;
</pre>
<p>In the preceding example, the <code class="codeph">CTX_FILTER_POLICY</code> policy, created using the CTX_DDL.CREATE_POLICY procedure, must exist in your schema. The table columns that are semantically indexed using this preferences document can store paths to formatted documents, from which plain text is extracted using the specified CTX policy. The information extractor associated with the extractor policy then processes the plain text further, to extract the semantics in RDF/XML format.</p>
</div>
</div>
<a id="RDFRM99930"></a>
<div class="props_rev_3"><a id="GUID-5A73F616-66EF-4887-B123-9DB538E1C269"></a>
<h2 id="RDFRM-GUID-5A73F616-66EF-4887-B123-9DB538E1C269" class="sect2"><span class="enumeration_section">4.9</span> Configuring the Calais Extractor type</h2>
<div>
<div class="section">
<p>The CALAIS_EXTRACTOR type, which is a subtype of the RDFCTX_WS_EXTRACTOR type, enables you to access a Web service end point anywhere on the network, including the one that is publicly accessible (<code class="codeph">OpenCalais.com</code>). To do so, you must connect with SYSDBA privileges and configure the Calais extractor type with Web service end point, the SOAP action, and the license key by setting corresponding parameters, as shown in the following example:</p>
<pre dir="ltr">begin
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; &#39;CALAIS_WS_ENDPOINT&#39;,
     param_value =&gt; &#39;http://api1.opencalais.com/enlighten/calais.asmx&#39;,
     param_desc  =&gt; &#39;Calais web service end-point&#39;);
       
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; &#39;CALAIS_KEY&#39;,
     param_value =&gt; &#39;&lt;Calais license key goes here&gt;&#39;,
     param_desc  =&gt; &#39;Calais extractor license key&#39;);
 
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; &#39;CALAIS_WS_SOAPACTION&#39;,
     param_value =&gt; &#39;http://clearforest.com/Enlighten&#39;,
     param_desc  =&gt; &#39;Calais web service SOAP Action&#39;);
end;
</pre>
<p>To enable access to a Web service outside the firewall, you must also set the parameter for the proxy host, as in the following example:</p>
<pre dir="ltr">begin
  sem_rdfctx.set_extractor_param (
      param_key   =&gt; &#39;HTTP_PROXY&#39;,
      param_value =&gt; &#39;www-proxy.acme.com&#39;,
      param_desc  =&gt; &#39;Proxy server&#39;);
end;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="RDFRM99931"></a>
<div class="props_rev_3"><a id="GUID-C293FD06-1FD8-426B-8D9F-661AE09389F4"></a>
<h2 id="RDFRM-GUID-C293FD06-1FD8-426B-8D9F-661AE09389F4" class="sect2"><span class="enumeration_section">4.10</span> Working with General Architecture for Text Engineering (GATE)</h2>
<div>
<p>General Architecture for Text Engineering (GATE) is an open source natural language processor and information extractor (see <a href="http://gate.ac.uk" target="_blank"><code class="codeph">http://gate.ac.uk</code></a>). You can use GATE to perform semantic indexing of documents stored in the database. The extractor type <code class="codeph">mdsys.gatenlp_extractor</code> is defined as a subtype of the RDFCTX_EXTRACTOR type. The implementation of this extractor type sends an unstructured document to a GATE engine over a TCP connection, receives corresponding annotations, and converts them into RDF following a user-specified XML style sheet.</p>
<p>The requests for information extraction are handled by a server socket implementation, which instantiates the GATE components and listens to extraction requests at a pre-determined port. The host and the post for the GATE listener are recorded in the database, as shown in the following example, for all instances of the <code class="codeph">mdsys.gatenlp_extractor</code> type to use.</p>
<pre dir="ltr">begin 
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; &#39;GATE_NLP_HOST&#39;,
     param_value =&gt; &#39;gateserver.acme.com&#39;,
     param_desc  =&gt; &#39;Host for GATE NLP Listener &#39;);
       
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; &#39;GATE_NLP_PORT&#39;,
     param_value =&gt; &#39;7687&#39;,
     param_desc  =&gt; &#39;Port for Gate NLP Listener&#39;);
end;
</pre>
<p>The server socket application receives an unstructured document and constructs an annotation set with the desired types of annotations. Each annotation in the set may be customized to include additional features, such as the relevant phrase from the input document and some domain specific features. The resulting annotation set is serialized into XML (using the <code class="codeph">annotationSetToXml</code> method in the <code class="codeph">gate.corpora.DocumentXmlUtils</code> Java package) and returned back to the socket client.</p>
<p><a id="d33581e1209" class="indexterm-anchor"></a><a id="d33581e1213" class="indexterm-anchor"></a><a id="d33581e1217" class="indexterm-anchor"></a>A sample Java implementation for the GATE listener is available for download from the code samples and examples page on OTN (see <a href="rdf-overview.htm#GUID-2A9B194C-2540-42C7-A783-4A32ADA6F1F4">Semantic Data Examples (PL/SQL and Java)</a> for information about this page).</p>
<p>The <code class="codeph">mdsys.gatenlp_extractor</code> implementation in the database receives the annotation set encoded in XML, and converts it to RDF/XML using an XML style sheet. You can replace the default style sheet (listed in <a href="semantic-indexing-docs.htm#GUID-F631DC90-2FB2-41F4-8A00-FF8777480A03">Default Style Sheet for GATE Extractor Output</a>) used by the <code class="codeph">mdsys.gatenlp_extractor</code> implementation with a custom style sheet when you instantiate the type.</p>
<p>The following example creates an extractor policy that uses a custom style sheet to generate RDF from the annotation set produced by the GATE extractor:</p>
<pre dir="ltr">begin
  sem_rdfctx.create_policy (policy_name =&gt; &#39;GATE_EXTR&#39;,
                            extractor   =&gt; mdsys.gatenlp_extractor(
      sys.XMLType(&#39;&lt;?xml version=&#34;1.0&#34;?&gt; 
                 &lt;xsl:stylesheet version=&#34;2.0&#34; 
                    xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34; &gt;
                   ..
                 &lt;/xsl:stylesheet&gt;&#39;)));
end;
/
</pre></div>
</div>
<a id="RDFRM99932"></a>
<div class="props_rev_3"><a id="GUID-C37D3C31-0E22-40D6-AC6F-B090AD5C1992"></a>
<h2 id="RDFRM-GUID-C37D3C31-0E22-40D6-AC6F-B090AD5C1992" class="sect2"><span class="enumeration_section">4.11</span> Creating a New Extractor Type</h2>
<div>
<p>You can create a new extractor type by extending the RDFCTX_EXTRACTOR or RDFCTX_WS_EXTRACTOR extractor type. The extractor type to be extended must be accessible using Web service calls. The schema in which the new extractor type is created must be granted additional privileges to allow creation of the subtype. For example, if a new extractor type is created in the schema RDFCTXU, you must enter the following commands to grant the UNDER and RDFCTX_ADMIN privileges to that schema:</p>
<pre dir="ltr">GRANT under ON mdsys.rdfctx_extractor TO rdfctxu;
GRANT rdfctx_admin TO rdfctxu;
</pre>
<p>As an example, assume that an information extractor can process an incoming document and return an XML document that contains extracted information. To enable the information extractor to be invoked using a PL/SQL wrapper, you can create the corresponding extractor type implementation, as in the following example:</p>
<pre dir="ltr">create or replace type rdfctxu.info_extractor under rdfctx_extractor (
  xsl_trans   sys.XMLtype,
  constructor function info_extractor (
                 xsl_trans  sys.XMLType ) return self as result,
  overriding member function getDescription return VARCHAR2,
  overriding member function rdfReturnType return VARCHAR2,
  overriding member function extractRDF(document CLOB,
                                        docId    VARCHAR2) return CLOB
)
/
 
create or replace type body rdfctxu.info_extractor as 
  constructor function info_extractor (
                 xsl_trans  sys.XMLType ) return self as result is
  begin
    self.extr_type := &#39;Info Extractor Inc.&#39;; 
    -- XML style sheet to generate RDF/XML from proprietary XML documents
    self.xsl_trans := xsl_trans; 
    return;
  end info_extractor; 
 
  overriding member function getDescription return VARCHAR2 is
  begin
    return &#39;Extactor by Info Extractor Inc.&#39;;
  end getDescription;
 
  overriding member function rdfReturnType return VARCHAR2 is
  begin
    return &#39;RDF/XML&#39;;
  end rdfReturnType;
 
  overriding member function extractRDF(document CLOB,
                                        docId    VARCHAR2) return CLOB is
    ce_xmlt  sys.xmltype;
  begin
    EXECUTE IMMEDIATE 
      &#39;begin :1 = info_extract_xml(doc =&gt; :2); end;&#39;
       USING IN OUT ce_xmlt, IN document;
 
    -- Now pass the ce_xmlt through RDF/XML transformation -- 
    return ce_xmlt.transform(self.xsl_trans).getClobVal();
  end extractRdf;
 
end;
</pre>
<p>In the preceding example:</p>
<ul style="list-style-type: disc;">
<li>
<p>The implementation for the created <code class="codeph">info_extractor</code> extractor type relies on the XML style sheet, set in the constructor, to generate RDF/XML from the proprietary XML schema used by the underlying information extractor.</p>
</li>
<li>
<p>The <code class="codeph">extractRDF</code> function assumes that the <code class="codeph">info_extract_xml</code> function contacts the desired information extractor and returns an XML document with the information extracted from the document that was passed in.</p>
</li>
<li>
<p>The XML style sheet is applied on the XML document to generate equivalent RDF/XML, which is returned by the <code class="codeph">extractRDF</code> function.</p>
</li>
</ul>
</div>
</div>
<a id="RDFRM223"></a>
<div class="props_rev_3"><a id="GUID-8E3A0C41-6CF5-4A6A-9C89-02DBC2920CD6"></a>
<h2 id="RDFRM-GUID-8E3A0C41-6CF5-4A6A-9C89-02DBC2920CD6" class="sect2"><span class="enumeration_section">4.12</span> Creating a Local Semantic Index on a Range-Partitioned Table</h2>
<div>
<p>A local index can be created on a VARCHAR2 or CLOB column of a range-partitioned table by using the following syntax:</p>
<pre dir="ltr">CREATE INDEX <span class="italic">&lt;index-name&gt;</span> &hellip; LOCAL;
</pre>
<p>The following example creates a range-partitioned table and a local semantic index on that table:</p>
<pre dir="ltr">CREATE TABLE part_newsfeed (
  docid number, article CLOB, cdate DATE) 
partition by range (cdate)
(partition p1 values less than (to_date(&#39;01-Jan-2001&#39;)),
 partition p2 values less than (to_date(&#39;01-Jan-2004&#39;)),
 partition p3 values less than (to_date(&#39;01-Jan-2008&#39;)),
 partition p4 values less than (to_date(&#39;01-Jan-2012&#39;))
);
 
CREATE INDEX ArticleLocalIndex on part_newsfeed (article)
   INDEXTYPE IS mdsys.SemContext PARAMETERS (&#39;SEM_EXTR&#39;)
LOCAL;
</pre>
<p>Note that every partition of the local semantic index will have content generated for the same set of policies. When you use the ALTER INDEX statement on a local index to add or drop policies associated with a semantic index partition, you should try to keep the same set of policies associated with each partition. You can achieve this result by using ALTER INDEX statements in a loop over the set of partitions. (For more information about altering semantic indexes, see <a href="semantic-indexing-docs.htm#GUID-78F0B53C-3CE6-4700-844B-44F53119583A">Altering a Semantic Index</a>,)</p>
</div>
</div>
<a id="RDFRM224"></a>
<div class="props_rev_3"><a id="GUID-78F0B53C-3CE6-4700-844B-44F53119583A"></a>
<h2 id="RDFRM-GUID-78F0B53C-3CE6-4700-844B-44F53119583A" class="sect2"><span class="enumeration_section">4.13</span> Altering a Semantic Index</h2>
<div>
<p>This section discusses using the ALTER INDEX statement with a semantic index. For a local semantic index, the ALTER INDEX statement applies to a specified partition. The general syntax of the ALTER INDEX command for a semantic index is as follows:</p>
<pre dir="ltr">ALTER INDEX <span class="italic">&lt;index-name&gt;</span> REBUILD [PARTITION <span class="italic">&lt;index-partition-name&gt;</span>]
  [PARAMETERS (&#39;-<span class="italic">&lt;action_for_policy&gt;</span> <span class="italic">&lt;policy-name&gt;</span>&#39;)];
</pre></div>
<a id="RDFRM225"></a>
<div class="props_rev_3"><a id="GUID-CCA874D0-B21B-45CB-AF7C-688755361024"></a>
<h3 id="RDFRM-GUID-CCA874D0-B21B-45CB-AF7C-688755361024" class="sect3"><span class="enumeration_section">4.13.1</span> Rebuilding Content for All Existing Policies in a Semantic Index</h3>
<div>
<p>If the PARAMETERS clause is not included in the ALTER INDEX statement, the content of the semantic index (or index partition) is rebuilt for every policy presently associated with the index. The following are two examples:</p>
<pre dir="ltr">ALTER INDEX ArticleIndex REBUILD;
ALTER INDEX ArticleLocalIndex REBUILD PARTITION p1;
</pre></div>
</div>
<a id="RDFRM226"></a>
<div class="props_rev_3"><a id="GUID-078F16FE-C7C2-4CB5-B7D0-E810B8F23427"></a>
<h3 id="RDFRM-GUID-078F16FE-C7C2-4CB5-B7D0-E810B8F23427" class="sect3"><span class="enumeration_section">4.13.2</span> Rebuilding to Add Content for a New Policy to a Semantic Index</h3>
<div>
<p>Using <code class="codeph">add_policy</code> for <span class="italic">&lt;action_for_policy&gt;</span>, you can add content for a new base policy or a dependent policy to a semantic index (or index partition). If a dependent policy is being added and if its base policy is not already a part of the index, then content for the base policy is also added implicitly (by invoking the extractor specified as part of the base policy definition). The following is an example:</p>
<pre dir="ltr">ALTER INDEX ArticleIndex REBUILD PARAMETERS (&#39;-add_policy MY_POLICY&#39;);
</pre></div>
</div>
<a id="RDFRM227"></a>
<div class="props_rev_3"><a id="GUID-2FA2DDC6-F920-48FB-A216-2DE4BD6C36E0"></a>
<h3 id="RDFRM-GUID-2FA2DDC6-F920-48FB-A216-2DE4BD6C36E0" class="sect3"><span class="enumeration_section">4.13.3</span> Rebuilding Content for an Existing Policy from a Semantic Index</h3>
<div>
<p>Using <code class="codeph">rebuild_policy</code> for <span class="italic">&lt;action_for_policy&gt;</span>, you can rebuild the content of the semantic index (or index partition) for an existing policy presently associated with the index. The following is an example:</p>
<pre dir="ltr">ALTER INDEX ArticleIndex REBUILD PARAMETERS (&#39;-rebuild_policy MY_POLICY&#39;);
</pre></div>
</div>
<a id="RDFRM228"></a>
<div class="props_rev_3"><a id="GUID-FFB6FD78-C201-4C76-A5FE-00A81ABEDC37"></a>
<h3 id="RDFRM-GUID-FFB6FD78-C201-4C76-A5FE-00A81ABEDC37" class="sect3"><span class="enumeration_section">4.13.4</span> Rebuilding to Drop Content for an Existing Policy from a Semantic Index</h3>
<div>
<p>Using <code class="codeph">drop_policy</code> for <span class="italic">&lt;action_for_policy&gt;</span>, you can drop content corresponding to an existing base policy or a dependent policy from a semantic index (or index partition). Note that dropping the content for a base policy will fail if it is the only policy for the index (or index partition) or if it is used by dependent policies associated with this index (or index partition).</p>
<p>The following example drops the content for a policy from an index:</p>
<pre dir="ltr">ALTER INDEX ArticleIndex REBUILD PARAMETERS (&#39;-drop_policy MY_POLICY&#39;);
</pre></div>
</div>
</div>
<a id="RDFRM229"></a>
<div class="props_rev_3"><a id="GUID-447F1C60-7EA6-44D5-9D0C-56DE01C6F09A"></a>
<h2 id="RDFRM-GUID-447F1C60-7EA6-44D5-9D0C-56DE01C6F09A" class="sect2"><span class="enumeration_section">4.14</span> Passing Extractor-Specific Parameters in CREATE INDEX and ALTER INDEX</h2>
<div>
<p>The CREATE INDEX and ALTER INDEX statements allow the passing of parameters needed by extractors. These parameters are passed on to the extractor using the <code class="codeph">params</code> parameter of the <code class="codeph">extractRdf</code> and <code class="codeph">batchExtractRdf</code> methods. The following two examples show their use:</p>
<pre dir="ltr">CREATE INDEX ArticleIndex on Newsfeed (article)
  INDEXTYPE IS mdsys.SemContext PARAMETERS (&#39;SEM_EXTR=(NE_ONLY)&#39;);

ALTER INDEX ArticleIndex REBUILD 
  PARAMETERS (&#39;-add_policy MY_POLICY=(NE_ONLY)&#39;);
</pre></div>
</div>
<a id="RDFRM231"></a><a id="RDFRM230"></a>
<div class="props_rev_3"><a id="GUID-9E82A191-0B7B-4508-BE78-E10D3CB19234"></a>
<h2 id="RDFRM-GUID-9E82A191-0B7B-4508-BE78-E10D3CB19234" class="sect2"><span class="enumeration_section">4.15</span> Performing Document-Centric Inference</h2>
<div>
<p>Document-centric inference refers to the ability to infer from each document individually. It does not allow triples extracted from two different documents to be used together for inference. It contrasts with the more common corpus-centric inference, where new triples can be inferred from combinations of triples extracted from multiple documents.</p>
<p>Document-centric inference can be desirable in document search applications because inclusion of a document in the search result is based on the extracted and/or inferred triples for that document only, that is, triples extracted and/or inferred from any other documents in the corpus do not play any role in the selection of this document. (Document-centric inference might be preferred, for example, if there is inconsistency among documents because of differences in the reliability of the data or in the biases of the document creators.)</p>
<p>To perform document-centric inference, use named graph based local inference (explained in <a href="owl-concepts.htm#GUID-1C7CAF17-945F-4452-97A3-5F2E1D7A2C84">Named Graph Based Local Inference (NGLI)</a>) by specifying <code class="codeph">options =&gt; &#39;LOCAL_NG_INF=T&#39;</code> in the call to the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> procedure.</p>
<p>Entailments created through document-centric inference can be included as content of a semantic index by creating a dependent policy and adding that policy to the semantic index, as shown in <a href="semantic-indexing-docs.htm#GUID-9E82A191-0B7B-4508-BE78-E10D3CB19234__BEIEDJCI">Example 4-2</a>.</p>
<div class="example" id="GUID-9E82A191-0B7B-4508-BE78-E10D3CB19234__BEIEDJCI">
<p class="titleinexample">Example 4-2 Using Document-Centric Inference</p>
<pre dir="ltr">-- Create entailment &#39;extr_data_inf&#39; using document-centric inference
-- assuming:
--   model_name for semantic index based on base policy: &#39;RDFCTX_MOD_1&#39;
--    (model name is available from the RDFCTX_INDEX_POLICIES view; 
--     see <a href="semantic-indexing-docs.htm#GUID-4D2F049C-403B-49CB-969C-C9C46DB3AC5C">RDFCTX_INDEX_POLICIES View</a>)
--   ontology: dataOntology
--   rulebase: OWL2RL
-- options: &#39;LOCAL_NG_INF=T&#39; (for document-centric inference)
BEGIN
sem_apis.create_entailment(&#39;extr_data_inf&#39;,
  models_in    =&gt; sem_models(&#39;RDFCTX_MOD_1&#39;, &#39;dataOntology&#39;),
  rulebases_in =&gt; sem_rulebases(&#39;OWL2RL&#39;),
  options      =&gt; &#39;LOCAL_NG_INF=T&#39;);
END;
/
-- Create a dependent policy to augment data extracted using base policy
-- with content of entailment extr_data_inf (computed in previous statement)
BEGIN
sem_rdfctx.create_policy (
  policy_name =&gt; &#39;SEM_EXTR_PLUS_DATA_INF&#39;,
  base_policy =&gt; &#39;SEM_EXTR&#39;,
  user_models =&gt; NULL,
  user_entailments =&gt; sem_models(&#39;extr_data_inf&#39;));
END;
/
-- Add the dependent policy to the ARTICLEINDEX index.
EXECUTE sem_rdfctx.add_dependent_policy(&#39;ARTICLEINDEX&#39;,&#39;SEM_EXTR_PLUS_DATA_INF&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="RDFRM99933"></a>
<div class="props_rev_3"><a id="GUID-0C0409E6-2EED-4468-8F29-2FB00A51995C"></a>
<h2 id="RDFRM-GUID-0C0409E6-2EED-4468-8F29-2FB00A51995C" class="sect2"><span class="enumeration_section">4.16</span> Metadata Views for Semantic Indexing</h2>
<div>
<p>This section describes views that contain metadata about semantic indexing.</p>
</div>
<a id="RDFRM99935"></a><a id="RDFRM99934"></a>
<div class="props_rev_3"><a id="GUID-670213CA-F4C2-4EA0-907A-3317066C788B"></a>
<h3 id="RDFRM-GUID-670213CA-F4C2-4EA0-907A-3317066C788B" class="sect3"><span class="enumeration_section">4.16.1</span> MDSYS.RDFCTX_POLICIES View</h3>
<div>
<p><a id="d33581e1807" class="indexterm-anchor"></a><a id="d33581e1809" class="indexterm-anchor"></a>Information about extractor policies defined in the current schema is maintained in the MDSYS.RDFCTX_POLICIES view, which has the columns shown in <a href="semantic-indexing-docs.htm#GUID-670213CA-F4C2-4EA0-907A-3317066C788B__BEIBBEEF" title="MDSYS.RDFCTX_POLICIES view columns">Table 4-1</a> and one row for each extractor policy.</p>
<div class="tblformal" id="GUID-670213CA-F4C2-4EA0-907A-3317066C788B__BEIBBEEF">
<p class="titleintable">Table 4-1 MDSYS.RDFCTX_POLICIES View Columns</p>
<table class="cellalignment4510" title="MDSYS.RDFCTX_POLICIES View Columns" summary="MDSYS.RDFCTX_POLICIES view columns">
<thead>
<tr class="cellalignment4501">
<th class="cellalignment4519" id="d33581e1830">Column Name</th>
<th class="cellalignment4519" id="d33581e1833">Data Type</th>
<th class="cellalignment4519" id="d33581e1836">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1841" headers="d33581e1830">
<p>POLICY_OWNER</p>
</td>
<td class="cellalignment4501" headers="d33581e1841 d33581e1833">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e1841 d33581e1836">
<p>Owner of the extractor policy</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1851" headers="d33581e1830">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment4501" headers="d33581e1851 d33581e1833">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e1851 d33581e1836">
<p>Name of the extractor policy</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1861" headers="d33581e1830">
<p>EXTRACTOR</p>
</td>
<td class="cellalignment4501" headers="d33581e1861 d33581e1833">
<p>MDSYS.RDFCTX_EXTRACTOR</p>
</td>
<td class="cellalignment4501" headers="d33581e1861 d33581e1836">
<p>Instance of extractor type</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1871" headers="d33581e1830">
<p>IS_DEPENDENT</p>
</td>
<td class="cellalignment4501" headers="d33581e1871 d33581e1833">
<p>VARCHAR2(3)</p>
</td>
<td class="cellalignment4501" headers="d33581e1871 d33581e1836">
<p>Contains <code class="codeph">YES</code> if the extractor policy is dependent on a base policy; contains <code class="codeph">NO</code> if the extractor policy is not dependent on a base policy.</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1887" headers="d33581e1830">
<p>BASE_POLICY</p>
</td>
<td class="cellalignment4501" headers="d33581e1887 d33581e1833">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e1887 d33581e1836">
<p>For a dependent policy, the name of the base policy</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1897" headers="d33581e1830">
<p>USER_MODELS</p>
</td>
<td class="cellalignment4501" headers="d33581e1897 d33581e1833">
<p>MDSYS.RDF_MODELS</p>
</td>
<td class="cellalignment4501" headers="d33581e1897 d33581e1836">
<p>For a dependent policy, a list of the RDF models included in the policy</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="RDFRM99937"></a><a id="RDFRM99936"></a>
<div class="props_rev_3"><a id="GUID-4D2F049C-403B-49CB-969C-C9C46DB3AC5C"></a>
<h3 id="RDFRM-GUID-4D2F049C-403B-49CB-969C-C9C46DB3AC5C" class="sect3"><span class="enumeration_section">4.16.2</span> RDFCTX_INDEX_POLICIES View</h3>
<div>
<p><a id="d33581e1945" class="indexterm-anchor"></a><a id="d33581e1947" class="indexterm-anchor"></a>Information about semantic indexes defined in the current schema and the extractor policies used to create the index is maintained in the MDSYS.RDFCTX_POLICIES view, which has the columns shown in <a href="semantic-indexing-docs.htm#GUID-4D2F049C-403B-49CB-969C-C9C46DB3AC5C__BEIBCCAC" title="MDSYS.RDFCTX_INDEX_POLICIES view columns">Table 4-2</a> and one row for each combination of semantic index and extractor policy.</p>
<div class="tblformal" id="GUID-4D2F049C-403B-49CB-969C-C9C46DB3AC5C__BEIBCCAC">
<p class="titleintable">Table 4-2 MDSYS.RDFCTX_INDEX_POLICIES View Columns</p>
<table class="cellalignment4510" title="MDSYS.RDFCTX_INDEX_POLICIES View Columns" summary="MDSYS.RDFCTX_INDEX_POLICIES view columns">
<thead>
<tr class="cellalignment4501">
<th class="cellalignment4519" id="d33581e1968">Column Name</th>
<th class="cellalignment4519" id="d33581e1971">Data Type</th>
<th class="cellalignment4519" id="d33581e1974">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1979" headers="d33581e1968">
<p>INDEX_OWNER</p>
</td>
<td class="cellalignment4501" headers="d33581e1979 d33581e1971">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e1979 d33581e1974">
<p>Owner of the semantic index</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1989" headers="d33581e1968">
<p>INDEX_NAME</p>
</td>
<td class="cellalignment4501" headers="d33581e1989 d33581e1971">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e1989 d33581e1974">
<p>Name of the semantic index</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e1999" headers="d33581e1968">
<p>INDEX_PARTITION</p>
</td>
<td class="cellalignment4501" headers="d33581e1999 d33581e1971">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e1999 d33581e1974">
<p>Name of the index partition (for LOCAL index only)</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2009" headers="d33581e1968">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment4501" headers="d33581e2009 d33581e1971">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e2009 d33581e1974">
<p>Name of the extractor policy</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2019" headers="d33581e1968">
<p>EXTR_PARAMETERS</p>
</td>
<td class="cellalignment4501" headers="d33581e2019 d33581e1971">
<p>VARCHAR2(100)</p>
</td>
<td class="cellalignment4501" headers="d33581e2019 d33581e1974">
<p>Parameters specified for the extractor</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2029" headers="d33581e1968">
<p>IS_DEFAULT</p>
</td>
<td class="cellalignment4501" headers="d33581e2029 d33581e1971">
<p>VARCHAR2(3)</p>
</td>
<td class="cellalignment4501" headers="d33581e2029 d33581e1974">
<p>Contains <code class="codeph">YES</code> if POLICY_NAME is the default extractor policy for the index; contains <code class="codeph">NO</code> if POLICY_NAME is not the default extractor policy for the index.</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2045" headers="d33581e1968">
<p>STATUS</p>
</td>
<td class="cellalignment4501" headers="d33581e2045 d33581e1971">
<p>VARCHAR2(10)</p>
</td>
<td class="cellalignment4501" headers="d33581e2045 d33581e1974">
<p>Contains <code class="codeph">VALID</code> if the index is valid, <code class="codeph">INPROGRESS</code> if the index is being created, or <code class="codeph">FAILED</code> if a system failure occurred during the creation of the index.</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2064" headers="d33581e1968">
<p>RDF_MODEL</p>
</td>
<td class="cellalignment4501" headers="d33581e2064 d33581e1971">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e2064 d33581e1974">
<p>Name of the RDF model maintaining the index data</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="RDFRM99939"></a><a id="RDFRM99938"></a>
<div class="props_rev_3"><a id="GUID-2C3797E4-E835-41D2-9721-B48F555AC185"></a>
<h3 id="RDFRM-GUID-2C3797E4-E835-41D2-9721-B48F555AC185" class="sect3"><span class="enumeration_section">4.16.3</span> RDFCTX_INDEX_EXCEPTIONS View</h3>
<div>
<p><a id="d33581e2113" class="indexterm-anchor"></a><a id="d33581e2115" class="indexterm-anchor"></a>Information about exceptions encountered while creating or maintaining semantic indexes in the current schema is maintained in the MDSYS.RDFCTX_INDEX_EXCEPTIONS view, which has the columns shown in <a href="semantic-indexing-docs.htm#GUID-2C3797E4-E835-41D2-9721-B48F555AC185__BEIFIEDE" title="MDSYS.RDFCTX_INDEX_EXCEPTIONS view columns">Table 4-3</a> and one row for each exception.</p>
<div class="tblformal" id="GUID-2C3797E4-E835-41D2-9721-B48F555AC185__BEIFIEDE">
<p class="titleintable">Table 4-3 MDSYS.RDFCTX_INDEX_EXCEPTIONS View Columns</p>
<table class="cellalignment4510" title="MDSYS.RDFCTX_INDEX_EXCEPTIONS View Columns" summary="MDSYS.RDFCTX_INDEX_EXCEPTIONS view columns">
<thead>
<tr class="cellalignment4501">
<th class="cellalignment4519" id="d33581e2136">Column Name</th>
<th class="cellalignment4519" id="d33581e2139">Data Type</th>
<th class="cellalignment4519" id="d33581e2142">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2147" headers="d33581e2136">
<p>INDEX_OWNER</p>
</td>
<td class="cellalignment4501" headers="d33581e2147 d33581e2139">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e2147 d33581e2142">
<p>Owner of the semantic index associated with the exception</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2157" headers="d33581e2136">
<p>INDEX_NAME</p>
</td>
<td class="cellalignment4501" headers="d33581e2157 d33581e2139">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e2157 d33581e2142">
<p>Name of the semantic index associated with the exception</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2167" headers="d33581e2136">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment4501" headers="d33581e2167 d33581e2139">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment4501" headers="d33581e2167 d33581e2142">
<p>Name of the extractor policy associated with the exception</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2177" headers="d33581e2136">
<p>DOC_IDENTIFIER</p>
</td>
<td class="cellalignment4501" headers="d33581e2177 d33581e2139">
<p>VARCHAR2(38)</p>
</td>
<td class="cellalignment4501" headers="d33581e2177 d33581e2142">
<p>Row identifier (rowid) of the document associated with the exception</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2187" headers="d33581e2136">
<p>EXCEPTION_TYPE</p>
</td>
<td class="cellalignment4501" headers="d33581e2187 d33581e2139">
<p>VARCHAR2(13)</p>
</td>
<td class="cellalignment4501" headers="d33581e2187 d33581e2142">
<p>Type of exception</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2197" headers="d33581e2136">
<p>EXCEPTION_CODE</p>
</td>
<td class="cellalignment4501" headers="d33581e2197 d33581e2139">
<p>NUMBER</p>
</td>
<td class="cellalignment4501" headers="d33581e2197 d33581e2142">
<p>Error code associated with the exception</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2207" headers="d33581e2136">
<p>EXCEPTION_TEXT</p>
</td>
<td class="cellalignment4501" headers="d33581e2207 d33581e2139">
<p>CLOB</p>
</td>
<td class="cellalignment4501" headers="d33581e2207 d33581e2142">
<p>Text associated with the exception</p>
</td>
</tr>
<tr class="cellalignment4501">
<td class="cellalignment4501" id="d33581e2217" headers="d33581e2136">
<p>EXTRACTED_AT</p>
</td>
<td class="cellalignment4501" headers="d33581e2217 d33581e2139">
<p>TIMESTAMP</p>
</td>
<td class="cellalignment4501" headers="d33581e2217 d33581e2142">
<p>Time at which the exception occurred</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<a id="RDFRM99940"></a>
<div class="props_rev_3"><a id="GUID-F631DC90-2FB2-41F4-8A00-FF8777480A03"></a>
<h2 id="RDFRM-GUID-F631DC90-2FB2-41F4-8A00-FF8777480A03" class="sect2"><span class="enumeration_section">4.17</span> Default Style Sheet for GATE Extractor Output</h2>
<div>
<p>This section lists the default XML style sheet that the <code class="codeph">mdsys.gatenlp_extractor</code> implementation uses to convert the annotation set (encoded in XML) into RDF/XML. (This extractor is explained in <a href="semantic-indexing-docs.htm#GUID-C293FD06-1FD8-426B-8D9F-661AE09389F4">Working with General Architecture for Text Engineering (GATE)</a>.)</p>
<pre dir="ltr">&lt;?xml version=&#34;1.0&#34;?&gt; 
  &lt;xsl:stylesheet version=&#34;2.0&#34; 
                   xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34; &gt; 
     &lt;xsl:output encoding=&#34;utf-8&#34; indent=&#34;yes&#34;/&gt; 
     &lt;xsl:param name=&#34;docbase&#34;&gt;http://xmlns.oracle.com/rdfctx/&lt;/xsl:param&gt;
     &lt;xsl:param name=&#34;docident&#34;&gt;0&lt;/xsl:param&gt;
     &lt;xsl:param name=&#34;classpfx&#34;&gt;
       &lt;xsl:value-of select=&#34;$docbase&#34;/&gt;
       &lt;xsl:text&gt;class/&lt;/xsl:text&gt; 
     &lt;/xsl:param&gt;
     &lt;xsl:template match=&#34;/&#34;&gt;
        &lt;rdf:RDF xmlns:rdf=&#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#34; 
                 xmlns:rdfs=&#34;http://www.w3.org/2000/01/rdf-schema#&#34;
                 xmlns:owl=&#34;http://www.w3.org/2002/07/owl#&#34; 
                 xmlns:prop=&#34;http://xmlns.oracle.com/rdfctx/property/&#34;&gt;  
        &lt;xsl:for-each select=&#34;AnnotationSet/Annotation&#34;&gt; 
          &lt;rdf:Description&gt; 
            &lt;xsl:attribute name=&#34;rdf:about&#34;&gt; 
              &lt;xsl:value-of select=&#34;$docbase&#34;/&gt;
              &lt;xsl:text&gt;docref/&lt;/xsl:text&gt;
              &lt;xsl:value-of select=&#34;$docident&#34;/&gt;
              &lt;xsl:text&gt;/&lt;/xsl:text&gt;
              &lt;xsl:value-of select=&#34;@Id&#34;/&gt;
            &lt;/xsl:attribute&gt;
            &lt;xsl:for-each select=&#34;./Feature&#34;&gt; 
              &lt;xsl:choose&gt;
                &lt;xsl:when test=&#34;./Name[text()=&#39;majorType&#39;]&#34;&gt; 
                  &lt;rdf:type&gt; 
                    &lt;xsl:attribute name=&#34;rdf:resource&#34;&gt; 
                       &lt;xsl:value-of select=&#34;$classpfx&#34;/&gt;
                       &lt;xsl:text&gt;major/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select=&#34;translate(./Value/text(),
                                                       &#39; &#39;, &#39;#&#39;)&#34;/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/rdf:type&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:when test=&#34;./Name[text()=&#39;minorType&#39;]&#34;&gt; 
                  &lt;xsl:element name=&#34;prop:hasMinorType&#34;&gt; 
                    &lt;xsl:attribute name=&#34;rdf:resource&#34;&gt; 
                       &lt;xsl:value-of select=&#34;$docbase&#34;/&gt;
                       &lt;xsl:text&gt;minorType/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select=&#34;translate(./Value/text(),
                                                       &#39; &#39;, &#39;#&#39;)&#34;/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:when test=&#34;./Name[text()=&#39;kind&#39;]&#34;&gt; 
                  &lt;xsl:element name=&#34;prop:hasKind&#34;&gt; 
                    &lt;xsl:attribute name=&#34;rdf:resource&#34;&gt; 
                       &lt;xsl:value-of select=&#34;$docbase&#34;/&gt;
                       &lt;xsl:text&gt;kind/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select=&#34;translate(./Value/text(),
                                                       &#39; &#39;, &#39;#&#39;)&#34;/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:when test=&#34;./Name[text()=&#39;locType&#39;]&#34;&gt; 
                  &lt;xsl:element name=&#34;prop:hasLocType&#34;&gt; 
                    &lt;xsl:attribute name=&#34;rdf:resource&#34;&gt; 
                       &lt;xsl:value-of select=&#34;$docbase&#34;/&gt;
                       &lt;xsl:text&gt;locType/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select=&#34;translate(./Value/text(),
                                                       &#39; &#39;, &#39;#&#39;)&#34;/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:when test=&#34;./Name[text()=&#39;entityValue&#39;]&#34;&gt; 
                  &lt;xsl:element name=&#34;prop:hasEntityValue&#34;&gt; 
                    &lt;xsl:attribute name=&#34;rdf:datatype&#34;&gt; 
                      &lt;xsl:text&gt;
                         http://www.w3.org/2001/XMLSchema#string
                      &lt;/xsl:text&gt;
                    &lt;/xsl:attribute&gt; 
                    &lt;xsl:value-of select=&#34;./Value/text()&#34;/&gt;
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt; 
                  &lt;xsl:element name=&#34;prop:has{translate(
                                        substring(./Name/text(),1,1),
                                        &#39;abcdefghijklmnopqrstuvwxyz&#39;,
                                        &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;)}{
                                      substring(./Name/text(),2)}&#34;&gt; 
                     &lt;xsl:attribute name=&#34;rdf:datatype&#34;&gt; 
                        &lt;xsl:text&gt;
                          http://www.w3.org/2001/XMLSchema#string
                        &lt;/xsl:text&gt; 
                     &lt;/xsl:attribute&gt; 
                    &lt;xsl:value-of select=&#34;./Value/text()&#34;/&gt;
                  &lt;/xsl:element&gt; 
                &lt;/xsl:otherwise&gt; 
              &lt;/xsl:choose&gt;
            &lt;/xsl:for-each&gt; 
          &lt;/rdf:Description&gt; 
        &lt;/xsl:for-each&gt;
        &lt;/rdf:RDF&gt; 
      &lt;/xsl:template&gt;
   &lt;/xsl:stylesheet&gt;
</pre></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4500">
<tr>
<td class="cellalignment4507">
<table class="cellalignment4505">
<tr>
<td class="cellalignment4504"><a href="skos.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4504"><a href="fine-grained-access.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4509">
<table class="cellalignment4503">
<tr>
<td class="cellalignment4504"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4504"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4504"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4504"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4504"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4504"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>