<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-88970"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/User-Defined%20Inferencing%20and%20Querying"></a><title>User-Defined Inferencing and Querying</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="user-defined inferencing, inferencing, user-defined, user-defined querying, inf_ext_user_func_name parameter, user-defined inferencing function, user-defined functions, functions, user-defined aggregates, aggregates, SDO_RDF_TERM data type, ODCIAggregate interface, user-defined aggregates (RDF Semantic Graph)"/>
<meta name="dcterms.created" content="2017-06-29T10:38:43Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Spatial and Graph RDF Semantic Graph Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E51611-08"/>
<meta name="dcterms.isVersionOf" content="RDFRM"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="rdf-sesame.htm" title="Previous" type="text/html"/>
<link rel="Next" href="rdf-views.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E51611-08.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E"></a> <span id="PAGE" style="display:none;">16/28</span> <!-- End Header -->
<a id="RDFRM519"></a>
<h1 id="RDFRM-GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E" class="sect1"><span class="enumeration_chapter">9</span> User-Defined Inferencing and Querying</h1>
<div>
<div class="infobox-note" id="GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E__GUID-5AB07393-28D9-4C76-9E14-9468F960BAF9">
<p class="notep1">Note:</p>
<p>The capabilities described in this chapter are intended for advanced users. You are assumed to be familiar with the main concepts and techniques described in <a href="rdf-overview.htm#GUID-F422BB9F-8473-4980-9D6C-848F708C10E0">RDF Semantic Graph Overview</a> and <a href="owl-concepts.htm#GUID-3EC5F30E-9175-4B7B-946C-3117BC30610A">OWL Concepts</a> .</p>
</div>
<p>This chapter describes RDF Semantic Graph extension architectures that, effective with Oracle Database 12<span class="italic">c</span> Release 1 (12.1), enable the addition of user-defined capabilities:</p>
<ul style="list-style-type: disc;">
<li>
<p>The inference extension architecture enables you to add user-defined inferencing to the presupplied inferencing support, as explained in <a href="user-defined-inf.htm#GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC">User-Defined Inferencing</a>.</p>
</li>
<li>
<p>The query extension architecture enables you to add user-defined functions and aggregates to be used in SPARQL queries, both through the SEM_MATCH table function and through the support for Apache Jena and OpenRDF Sesame, as explained in <a href="user-defined-inf.htm#GUID-26520C46-3A90-40AB-8403-140A82AC73CC">User-Defined Functions and Aggregates</a>.</p>
</li>
</ul>
</div>
<a id="RDFRM520"></a>
<div class="props_rev_3"><a id="GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC"></a>
<h2 id="RDFRM-GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC" class="sect2"><span class="enumeration_section">9.1</span> User-Defined Inferencing</h2>
<div>
<p>The RDF Semantic Graph inference extension architecture enables you to add user-defined inferencing to the presupplied inferencing support.</p>
<p>This section contains the following major topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="user-defined-inf.htm#GUID-2BB9DDF4-36A8-4790-9C80-80AD75A0DCE6">Problem Solved and Benefit Provided by User-Defined Inferencing</a></p>
</li>
<li>
<p><a href="user-defined-inf.htm#GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698">API Support for User-Defined Inferencing</a></p>
</li>
<li>
<p><a href="user-defined-inf.htm#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">User-Defined Inference Extension Function Examples</a></p>
</li>
</ul>
</div>
<a id="RDFRM521"></a>
<div class="props_rev_3"><a id="GUID-2BB9DDF4-36A8-4790-9C80-80AD75A0DCE6"></a>
<h3 id="RDFRM-GUID-2BB9DDF4-36A8-4790-9C80-80AD75A0DCE6" class="sect3"><span class="enumeration_section">9.1.1</span> Problem Solved and Benefit Provided by User-Defined Inferencing</h3>
<div>
<p>Before Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the Oracle Database inference engine provided native support for OWL 2 RL,RDFS, SKOS, SNOMED (core EL), and user-defined rules, which covered a wide range of applications and requirements. However, there was the limitation that <span class="bold">no new RDF resources</span> could be created as part of the rules deduction process.</p>
<p>As an example of the capabilities and the limitation before Oracle Database 12<span class="italic">c</span> Release 1 (12.1), consider the following straightforward inference rule:</p>
<pre dir="ltr">?C   rdfs:subClassOf  ?D .
?x    rdf:type  ?C  .  ==&gt;  ?x   rdf:type  ?D
</pre>
<p>The preceding rule says that any instance <code class="codeph">x</code> of a subclass <code class="codeph">C</code> will be an instance of <code class="codeph">C</code>&#39;s superclass, <code class="codeph">D</code>. The consequent part of the rule mentions two variables <code class="codeph">?x</code> and <code class="codeph">?D</code>. However, these variables must already exist in the antecedents of the rule, which further implies that these RDF resources must already exist in the knowledge base. In other words, for example, you can derive that <code class="codeph">John</code> is a <code class="codeph">Student</code> only if you know that <code class="codeph">John</code> <span class="italic">exists</span> as a <code class="codeph">GraduateStudent</code> and if an axiom specifies that the <code class="codeph">GraduateStudent</code> class is a subclass of the <code class="codeph">Student</code> class.</p>
<p>Another example of a limitation is that before Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the inference functions did not support combining a person&#39;s first name and last name to produce a full name as a <span class="italic">new</span> RDF resource in the inference process. Specifically, this requirement can be captured as a rule like the following:</p>
<pre dir="ltr">?x   :firstName  ?fn
?x   :lastName   ?ln  ==&gt;  ?x  :fullName  concatenate(?fn ?ln)
</pre>
<p>Effective with Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the RDF Semantic Graph inference extension architecture opens the inference process so that users can implement their own inference extension functions and integrate them into the native inference process. This architecture:</p>
<ul style="list-style-type: disc;">
<li>
<p>Supports rules that require the generation of new RDF resources.</p>
<p>Examples might include concatenation of strings or other string operations, mathematical calculations, and web service callouts.</p>
</li>
<li>
<p>Allows implementation of certain existing rules using customized optimizations.</p>
<p>Although the native OWL inference engine has optimizations for many rules and these rules work efficiently for a variety of large-scale ontologies, for some new untested ontologies a customized optimization of a particular inference component may work even better. In such a case, you can disable a particular inference component in the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> call and specify a customized inference extension function (using the <code class="codeph">inf_ext_user_func_name</code> parameter) that implements the new optimization.</p>
</li>
<li>
<p>Allows the inference engine to be extended with sophisticated inference capabilities.</p>
<p>Examples might include integrating geospatial reasoning, time interval reasoning, and text analytical functions into the native database inference process.</p>
</li>
</ul>
</div>
</div>
<a id="RDFRM522"></a>
<div class="props_rev_3"><a id="GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698"></a>
<h3 id="RDFRM-GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698" class="sect3"><span class="enumeration_section">9.1.2</span> API Support for User-Defined Inferencing</h3>
<div>
<p>The primary application programming interface (API) for user-defined inferencing is the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> procedure, specifically the last parameter:</p>
<pre dir="ltr">inf_ext_user_func_name  IN VARCHAR2 DEFAULT NULL
</pre>
<p>The <code class="codeph">inf_ext_user_func_name</code> parameter, if specified, identifies one or more user-defined inference functions that implement the specialized logic that you want to use. Each user-defined inference function must follow the requirements and guidelines in <a href="user-defined-inf.htm#GUID-48E4608D-B19C-4502-B67D-39C3174A610A">User-Defined Inference Function Requirements</a>.</p>
</div>
<a id="RDFRM523"></a>
<div class="props_rev_3"><a id="GUID-48E4608D-B19C-4502-B67D-39C3174A610A"></a>
<h4 id="RDFRM-GUID-48E4608D-B19C-4502-B67D-39C3174A610A" class="sect4"><span class="enumeration_section">9.1.2.1</span> User-Defined Inference Function Requirements</h4>
<div>
<p>Each user-defined inference function that is specified in the <code class="codeph">inf_ext_user_func_name</code> parameter in the call to the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> procedure must:</p>
<ul style="list-style-type: disc;">
<li>
<p>Have a name that starts with the following string: <code class="codeph">SEM_INF_</code></p>
</li>
<li>
<p>Be created with definer&#39;s rights, not invoker&#39;s rights. (For an explanation of definer&#39;s rights and invoker&#39;s rights, see <a class="olink DBSEG659" target="_blank" href="../DBSEG/dr_ir.htm#DBSEG659"><span class="italic">Oracle Database Security Guide</span></a>.)</p>
</li>
</ul>
<p>The format of the user-defined inference function must be that shown in the following example for a hypothetical function named <code class="codeph">SEM_INF_EXAMPLE</code>:</p>
<pre dir="ltr">create or replace function sem_inf_example(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  pragma autonomous_transaction;
begin
  if (action = SDO_SEM_INFERENCE.INF_EXT_ACTION_START) then
    <span class="italic">&lt;... preparation work ...&gt;</span>  
  end if;
  if (action = SDO_SEM_INFERENCE.INF_EXT_ACTION_RUN) then
    <span class="italic">&lt;... actual inference logic ...&gt;</span>
    commit;
  end if;
  if (action = SDO_SEM_INFERENCE.INF_EXT_ACTION_END) then
    <span class="italic">&lt;... clean up ...&gt;</span> 
  end if;
return true;  -- succeed
end;
/
grant execute on sem_inf_example to MDSYS;
</pre>
<p>In the user-defined function format, the <code class="codeph">optimization_flag</code> output parameter can specify one or more Oracle-defined names that are associated with numeric values. You can specify one or more of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NONE</code> indicates that the inference engine should not enable any optimizations for the extension function. (This is the default behavior of the inference engine when the <code class="codeph">optimization_flag</code> parameter is not set.)</p>
</li>
<li>
<p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS</code> indicates that all triples/quads inferred by the extension function use only resource IDs. In other words, the <code class="codeph">output_tab</code> table only contains resource IDs (columns <code class="codeph">gid</code>, <code class="codeph">sid</code>, <code class="codeph">pid</code>, and <code class="codeph">oid</code>) and does not contain any lexical values (columns <code class="codeph">g</code>, <code class="codeph">s</code>, <code class="codeph">p</code>, and <code class="codeph">o</code> are all null). Enabling this optimization flag allows the inference engine to skip resource ID lookups.</p>
</li>
<li>
<p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY</code> indicates that all the triples/quads inferred by the extension function are new and do not already exist in <code class="codeph">src_tab_view</code>. Enabling this optimization flag allows the inference engine to skip checking for duplicates between the <code class="codeph">output_tab</code> table and <code class="codeph">src_tab_view</code>. Note that the <code class="codeph">src_tab_view</code> contains triples/quads from previous rounds of reasoning, including triples/quads inferred from extension functions.</p>
</li>
<li>
<p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY</code> indicates that all the triples/quads inferred by the extension function are unique and do not already exist in the <code class="codeph">output_tab</code> table. Enabling this optimization flag allows the inference engine to skip checking for duplicates within the <code class="codeph">output_tab</code> table (for example, no need to check for the same triple inferred twice by an extension function). Note that the <code class="codeph">output_tab</code> table is empty at the beginning of each round of reasoning for an extension function, so uniqueness of the data must only hold for the current round of reasoning.</p>
</li>
<li>
<p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_IGNORE_NULL</code> indicates that the inference engine should ignore an inferred triple or quad if the subject, predicate, or object resource is null. The inference engine considers a resource null if both of its columns in the <code class="codeph">output_tab</code> table are null (for example, subject is null if the <code class="codeph">s</code> and <code class="codeph">sid</code> columns are both null). Enabling this optimization flag allows the inference engine to skip invalid triples/quads in the <code class="codeph">output_tab</code> table. Note that the inference engine interprets null graph columns (<code class="codeph">g</code> and <code class="codeph">gid</code>) as the default graph.</p>
</li>
</ul>
<p>To specify more than one value for the <code class="codeph">optimization_flag</code> output parameter, use the plus sign (<code class="codeph">+</code>) to concatenate the values. For example:</p>
<pre dir="ltr">optimization_flag := SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS +
                     SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY +
                     SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY;
</pre>
<p>For more information about using the <code class="codeph">optimization_flag</code> output parameter, see <a href="user-defined-inf.htm#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">Example 3: Optimizing Performance</a>.</p>
</div>
</div>
</div>
<a id="RDFRM524"></a>
<div class="props_rev_3"><a id="GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2"></a>
<h3 id="RDFRM-GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2" class="sect3"><span class="enumeration_section">9.1.3</span> User-Defined Inference Extension Function Examples</h3>
<div>
<p>The following examples demonstrate how to use user-defined inference extension functions to create entailments.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="user-defined-inf.htm#GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6">Example 1: Adding Static Triples</a>, <a href="user-defined-inf.htm#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">Example 2: Adding Dynamic Triples</a>, and <a href="user-defined-inf.htm#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">Example 3: Optimizing Performance</a> cover the basics of user-defined inference extensions.</p>
<p><a href="user-defined-inf.htm#GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6">Example 1: Adding Static Triples</a> and <a href="user-defined-inf.htm#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">Example 2: Adding Dynamic Triples</a> focus on adding new, inferred triples.</p>
<p><a href="user-defined-inf.htm#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">Example 3: Optimizing Performance</a> focuses on optimizing performance.</p>
</li>
<li>
<p><a href="user-defined-inf.htm#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">Example 4: Temporal Reasoning (Several Related Examples)</a> and <a href="user-defined-inf.htm#GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3">Example 5: Spatial Reasoning</a> demonstrate how to handle special data types efficiently by leveraging native Oracle types and operators.</p>
<p><a href="user-defined-inf.htm#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">Example 4: Temporal Reasoning (Several Related Examples)</a> focuses on the <code class="codeph">xsd:dateTime</code> data type.</p>
<p><a href="user-defined-inf.htm#GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3">Example 5: Spatial Reasoning</a> focuses on geospatial data types.</p>
</li>
<li>
<p><a href="user-defined-inf.htm#GUID-537C3916-D0F0-4909-BC05-50353621C220">Example 6: Calling a Web Service</a> makes a web service call to the Oracle Geocoder service.</p>
</li>
</ul>
<p>The first three examples assume that the model <code class="codeph">EMPLOYEES</code> exists and contains the following semantic data, displayed in Turtle format:</p>
<pre dir="ltr">:John   :firstName  &#34;John&#34;  ;
        :lastName   &#34;Smith&#34; .
 
:Mary   :firstName  &#34;Mary&#34;  ;
        :lastName   &#34;Smith&#34; ;
        :name       &#34;Mary Smith&#34; .
 
:Alice  :firstName  &#34;Alice&#34; .
 
:Bob    :firstName  &#34;Bob&#34; ;
        :lastName   &#34;Billow&#34; .
</pre>
<p>For requirements and guidelines for creating user-defined inference extension functions, see <a href="user-defined-inf.htm#GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698">API Support for User-Defined Inferencing</a>.</p>
</div>
<a id="RDFRM525"></a>
<div class="props_rev_3"><a id="GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6"></a>
<h4 id="RDFRM-GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6" class="sect4"><span class="enumeration_section">9.1.3.1</span> Example 1: Adding Static Triples</h4>
<div>
<p>The most basic method to infer new data in a user-defined inference extension function is adding static data. Static data does not depend on any existing data in a model. This is not a common case for a user-defined inference extension function, but it demonstrates the basics of adding triples to an entailment. Inserting static data is more commonly done during the preparation phase (that is, <code class="codeph">action=&#39;START&#39;</code>) to expand on the existing ontology.</p>
<p>The following user-defined inference extension function (<code class="codeph">sem_inf_static</code>) adds three static triples to an entailment:</p>
<pre dir="ltr">-- this user-defined rule adds static triples
create or replace function sem_inf_static(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  query varchar2(4000);
  pragma autonomous_transaction;
begin
  if (action = &#39;RUN&#39;) then
    -- generic query we use to insert triples
    query := 
      &#39;insert /*+ parallel append */ into &#39; || output_tab || 
      &#39; ( s,  p,  o) VALUES &#39; ||
      &#39; (:1, :2, :3) &#39;;
 
    -- execute the query with different values
    execute immediate query using 
      &#39;&lt;http://example.org/S1&gt;&#39;, &#39;&lt;http://example.org/P2&gt;&#39;, &#39;&#34;O1&#34;&#39;;
 
    execute immediate query using
      &#39;&lt;http://example.org/S2&gt;&#39;, &#39;&lt;http://example.org/P2&gt;&#39;, &#39;&#34;2&#34;^^xsd:int&#39;;
 
    -- duplicate quad
    execute immediate query using
      &#39;&lt;http://example.org/S2&gt;&#39;, &#39;&lt;http://example.org/P2&gt;&#39;, &#39;&#34;2&#34;^^xsd:int&#39;;
 
    execute immediate query using
      &#39;&lt;http://example.org/S3&gt;&#39;, &#39;&lt;http://example.org/P3&gt;&#39;, &#39;&#34;3.0&#34;^^xsd:double&#39;;
 
    -- commit our changes
    commit;
  end if;
 
  -- return true to indicate success
  return true;
end sem_inf_static;
/
show errors;
</pre>
<p>The <code class="codeph">sem_inf_static</code> function inserts new data by executing a SQL insert query, with <code class="codeph">output_tab</code> as the target table for insertion. The <code class="codeph">output_tab</code> table will only contain triples added by the <code class="codeph">sem_inf_static</code> function during the current call (see the <code class="codeph">num_calls</code> parameter). The inference engine will always call a user-defined inference extension function at least three times, once for each possible value of the action parameter (<code class="codeph">&#39;START&#39;</code>, <code class="codeph">&#39;RUN</code><code class="codeph">&#39;</code>, and <code class="codeph">&#39;END&#39;</code>). Because <code class="codeph">sem_inf_static</code> does not need to perform any preparation or cleanup, the function only adds data during the <code class="codeph">RUN</code> phase. The extension function can be called more than once during the <code class="codeph">RUN</code> phase, depending on the data inferred during the current round of reasoning.</p>
<p>Although the <code class="codeph">sem_inf_static</code> function makes no checks for existing triples (to prevent duplicate triples), the inference engine will not generate duplicate triples in the resulting entailment. The inference engine will filter out duplicates from the <code class="codeph">output_tab</code> table (the data inserted by the extension function) and from the final entailment (the model or models and other inferred data). Setting the appropriate optimization flags (using the <code class="codeph">optimization_flag</code> parameter) will disable this convenience feature and improve performance. (See <a href="user-defined-inf.htm#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">Example 3: Optimizing Performance</a> for more information about optimization flags.)</p>
<p>Although the table definition for <code class="codeph">output_tab</code> shows a column for graph names, the inference engine will ignore and override all graph names on triples added by extension functions when performing Global Inference (default behavior of <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>) and Named Graph Global Inference (NGGI). To add triples to specific named graphs in a user-defined extension function, use NGLI (Named Graph Local Inference). During NGLI, all triples must belong to a named graph (that is, the <code class="codeph">gid</code> and <code class="codeph">g</code> columns of <code class="codeph">output_tab</code> cannot both be null).</p>
<p>The MDSYS user must have execute privileges on the <code class="codeph">sem_inf_static</code> function to use the function for reasoning. The following example shows how to grant the appropriate privileges on the <code class="codeph">sem_inf_static</code> function and create an entailment using the function (along with OWLPRIME inference logic):</p>
<pre dir="ltr">-- grant appropriate privileges
grant execute on sem_inf_static to mdsys;
 
-- create the entailment
begin
  sem_apis.create_entailment( 
    &#39;EMPLOYEES_INF&#39;
  , sem_models(&#39;EMPLOYEES&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , passes =&gt; SEM_APIS.REACH_CLOSURE
  , inf_ext_user_func_name =&gt; &#39;sem_inf_static&#39; 
);
end;
/
</pre>
<p>The following example displays the newly entailed data:</p>
<pre dir="ltr">-- formatting
column s format a23;
column p format a23;
column o format a23;
set linesize 100;
 
-- show results
select s, p, o from table(SEM_MATCH(
    &#39;select ?s ?p ?o where { ?s ?p ?o } order by ?s ?p ?o&#39;
  , sem_models(&#39;EMPLOYEES&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , null, null, null
  , &#39;INF_ONLY=T&#39;));
</pre>
<p>The preceding query returns the three unique static triples added by <code class="codeph">sem_inf_static</code>, with no duplicates:</p>
<pre dir="ltr">S                      P                      O
---------------------- ---------------------- -----------------------
http://example.org/S1  http://example.org/P2  O1
http://example.org/S2  http://example.org/P2  2
http://example.org/S3  http://example.org/P3  3E0
</pre></div>
</div>
<a id="RDFRM526"></a>
<div class="props_rev_3"><a id="GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412"></a>
<h4 id="RDFRM-GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412" class="sect4"><span class="enumeration_section">9.1.3.2</span> Example 2: Adding Dynamic Triples</h4>
<div>
<p>Adding static data is useful, but it is usually done during the preparation (that is, <code class="codeph">action=&#39;START&#39;</code>) phase. Adding <span class="italic">dynamic</span> data involves looking at existing data in the model and generating new data based on the existing data. This is the most common case for a user-defined inference extension function.</p>
<p>The following user-defined inference extension function (<code class="codeph">sem_inf_dynamic</code>) concatenates the first and last names of employees to create a new triple that represents the full name.</p>
<pre dir="ltr">-- this user-defined rule adds static triples
create or replace function sem_inf_dynamic(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  firstNamePropertyId number;
  lastNamePropertyId  number;
  fullNamePropertyId  number;
 
  sqlStmt    varchar2(4000);
  insertStmt varchar2(4000);
  pragma autonomous_transaction;
begin
  if (action = &#39;RUN&#39;) then
    -- retrieve ID of resource that already exists in the data (will
    -- throw exception if resource does not exist). These will improve
    -- performance of our SQL queries. 
    firstNamePropertyId := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/firstName&#39;);
    lastNamePropertyId  := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/lastName&#39;);
    fullNamePropertyId  := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/name&#39;);
 
    -- SQL query to find all employees and their first and last names
    sqlStmt :=
      &#39;select ids1.sid employeeId,
              values1.value_name firstName,
              values2.value_name lastName
       from   &#39; || resource_id_map_view || &#39; values1,
              &#39; || resource_id_map_view || &#39; values2,
              &#39; || src_tab_view || &#39;         ids1,
              &#39; || src_tab_view || &#39;         ids2
       where  ids1.sid = ids2.sid 
         AND  ids1.pid = &#39; || to_char(firstNamePropertyId,&#39;TM9&#39;) || &#39; 
         AND  ids2.pid = &#39; || to_char(lastNamePropertyId,&#39;TM9&#39;)  || &#39; 
         AND  ids1.oid = values1.value_id 
         AND  ids2.oid = values2.value_id 
       /* below ensures we have NEWDATA (a no duplicate optimization flag) */
         AND  not exists
               (select 1 
                from   &#39; || src_tab_view || &#39; 
                where  sid = ids1.sid AND 
                       pid = &#39; || to_char(fullNamePropertyId,&#39;TM9&#39;) || &#39;)&#39;;
 
    -- create the insert statement that concatenates the first and
    -- last names from our sqlStmt into a new triple.
    insertStmt :=
      &#39;insert /*+ parallel append */ 
       into &#39; || output_tab || &#39; (sid, pid, o) 
       select employeeId, &#39; || to_char(fullNamePropertyId,&#39;TM9&#39;) || &#39;, &#39;&#39;&#34;&#39;&#39; || firstName || &#39;&#39; &#39;&#39; || lastName ||  &#39;&#39;&#34;&#39;&#39;
       from   (&#39; || sqlStmt || &#39;)&#39;;
 
    -- execute the insert statement
    execute immediate insertStmt;
 
    -- commit our changes
    commit;
 
    -- set our optimization flags indicating we already checked for
    -- duplicates in the model (src_tab_view)
    optimization_flag := SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY;
  end if;
 
  -- return true to indicate success
  return true;
end sem_inf_dynamic;
/
show errors;
</pre>
<p>The <code class="codeph">sem_inf_dynamic</code> function inserts new data using two main steps. First, the function builds a SQL query that collects all first and last names from the existing data. The <code class="codeph">sqlStmt</code> variable stores this SQL query. Next, the function inserts new triples based on the first and last names it collects, to form a full name for each employee. The <code class="codeph">insertStmt</code> variable stores this SQL query. Note that the <code class="codeph">insertStmt</code> query includes the <code class="codeph">sqlStmt</code> query because it is performing an INSERT with a subquery.</p>
<p>The <code class="codeph">sqlStmt</code> query performs a join across two main views: the resource view (<code class="codeph">resource_id_map_view</code>) and the existing data view (<code class="codeph">src_tab_view</code>). The existing data view contains all existing triples but stores the values of those triples using numeric IDs instead of lexical values. Because the <code class="codeph">sqlStmt</code> query must extract the lexical values of the first and last names of an employee, it joins with the resource view twice (once for the first name and once for the last name).</p>
<p>The <code class="codeph">sqlStmt</code> query contains the <code class="codeph">PARALLEL</code> SQL hint to help improve performance. Parallel execution on a balanced hardware configuration can significantly improve performance. (See <a href="user-defined-inf.htm#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">Example 3: Optimizing Performance</a> for more information.)</p>
<p>The <code class="codeph">insertStmt</code> query also performs a duplicate check to avoid adding a triple if it already exists in the existing data view (<code class="codeph">src_tab_view</code>). The function indicates it has performed this check by enabling the <code class="codeph">INF_EXT_OPT_FLAG_NEWDATA_ONLY</code> optimization flag. Doing the check inside the extension function improves overall performance of the reasoning. Note that the existing data view does not contain the new triples currently being added by the <code class="codeph">sem_inf_dynamic</code> function, so duplicates may still exist within the <code class="codeph">output_tab</code> table. If the <code class="codeph">sem_inf_dynamic</code> function additionally checked for duplicates within the output_tab table, then it could also enable the <code class="codeph">INF_EXT_OPT_FLAG_UNIQUEDATA_ONLY</code> optimization flag.</p>
<p>Both SQL queries use numeric IDs of RDF resources to perform their joins and inserts. Using IDs instead of lexical values improves the performance of the queries. The <code class="codeph">sem_inf_dynamic</code> function takes advantage of this performance benefit by looking up the IDs of the lexical values it plans to use. In this case, the function looks up three URIs representing the first name, last name, and full name properties. If the <code class="codeph">sem_inf_dynamic</code> function inserted all new triples purely as IDs, then it could enable the <code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code> optimization flag. For this example, however, the new triples each contain a single, new, lexical value: the full name of the employee.</p>
<p>To create an entailment with the <code class="codeph">sem_inf_dynamic</code> function, grant execution privileges to the MDSYS user, then pass the function name to the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> procedure, as follows:</p>
<pre dir="ltr">-- grant appropriate privileges
grant execute on sem_inf_dynamic to mdsys;
 
-- create the entailment
begin
  sem_apis.create_entailment( 
    &#39;EMPLOYEES_INF&#39;
  , sem_models(&#39;EMPLOYEES&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , passes =&gt; SEM_APIS.REACH_CLOSURE
  , inf_ext_user_func_name =&gt; &#39;sem_inf_dynamic&#39; 
);
end;
/
</pre>
<p>The entailment should contain the following two new triples added by <code class="codeph">sem_inf_dynamic</code>:</p>
<pre dir="ltr">S                        P                        O
------------------------ ------------------------ -----------------------
http://example.org/Bob   http://example.org/name  Bob Billow
http://example.org/John  http://example.org/name  John Smith
</pre>
<p>Note that the <code class="codeph">sem_inf_dynamic</code> function in the preceding example did not infer a full name for Mary Smith, because Mary Smith already had her full name specified in the existing data.</p>
</div>
</div>
<a id="RDFRM527"></a>
<div class="props_rev_3"><a id="GUID-9130DB03-063F-4ECA-BC72-F841816D03A2"></a>
<h4 id="RDFRM-GUID-9130DB03-063F-4ECA-BC72-F841816D03A2" class="sect4"><span class="enumeration_section">9.1.3.3</span> Example 3: Optimizing Performance</h4>
<div>
<p>Several techniques can improve the performance of an inference extension function. One such technique is to use the numeric IDs of resources rather than their lexical values in queries. By only using resource IDs, the extension function avoids having to join with the resource view (<code class="codeph">resource_id_map_view</code>), and this can greatly improve query performance. Inference extension functions can obtain additional performance benefits by also using resource IDs when adding new triples to the <code class="codeph">output_tab</code> table (that is, using only using the <code class="codeph">gid</code>, <code class="codeph">sid</code>, <code class="codeph">pid</code>, and <code class="codeph">oid</code> columns of the <code class="codeph">output_tab</code> table).</p>
<p>The following user-defined inference extension function (<code class="codeph">sem_inf_related</code>) infers a new property, <code class="codeph">:possibleRelative</code>, for employees who share the same last name. The SQL queries for finding such employees use only resource IDs (no lexical values, no joins with the resource view). Additionally, the inference extension function in this example inserts the new triples using only resource IDs, allowing the function to enable the <code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code> optimization flag.</p>
<pre dir="ltr">-- this user-defined rule adds static triples
create or replace function sem_inf_related(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  lastNamePropertyId  number;
  relatedPropertyId   number;
 
  sqlStmt    varchar2(4000);
  insertStmt varchar2(4000);
  pragma autonomous_transaction;
begin
  if (action = &#39;RUN&#39;) then
    -- retrieve ID of resource that already exists in the data (will
    -- throw exception if resource does not exist).
    lastNamePropertyId := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/lastName&#39;);
 
    -- retreive ID of resource or generate a new ID if resource does
    -- not already exist
    relatedPropertyId := sdo_sem_inference.oracle_orardf_add_res(&#39;http://example.org/possibleRelative&#39;);
 
    -- SQL query to find all employees that share a last name
    sqlStmt :=
      &#39;select ids1.sid employeeId,
              ids2.sid relativeId
       from   &#39; || src_tab_view || &#39;         ids1,
              &#39; || src_tab_view || &#39;         ids2
       where  ids1.pid = &#39; || to_char(lastNamePropertyId,&#39;TM9&#39;) || &#39; 
         AND  ids2.pid = &#39; || to_char(lastNamePropertyId,&#39;TM9&#39;) || &#39; 
         AND  ids1.oid  = ids2.oid 
       /* avoid employees related to themselves */
         AND  ids1.sid != ids2.sid 
       /* below ensures we have NEWDATA (a no duplicate optimization flag) */
         AND  not exists
               (select 1 
                from   &#39; || src_tab_view || &#39; 
                where  sid = ids1.sid 
                  AND  pid = &#39; || to_char(relatedPropertyId,&#39;TM9&#39;) || &#39; 
                  AND  oid = ids2.sid) 
       /* below ensures we have UNIQDATA (a no duplicate optimization flag) */
         AND  not exists
               (select 1 
                from   &#39; || output_tab || &#39; 
                where  sid = ids1.sid 
                  AND  pid = &#39; || to_char(relatedPropertyId,&#39;TM9&#39;) || &#39; 
                  AND  oid = ids2.sid)&#39;;
 
    -- create the insert statement that only uses resource IDs
    insertStmt :=
      &#39;insert /*+ parallel append */ 
       into &#39; || output_tab || &#39; (sid, pid, oid) 
       select employeeId, &#39; || to_char(relatedPropertyId,&#39;TM9&#39;) || &#39;, relativeId
       from   (&#39; || sqlStmt || &#39;)&#39;;
 
    -- execute the insert statement
    execute immediate insertStmt;
 
    -- commit our changes
    commit;
 
    -- set flag indicating our new triples
    --   1) are specified using only IDs
    --   2) produce no duplicates with the model (src_tab_view)
    --   3) produce no duplicates in the output (output_tab)
    optimization_flag := SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS +
                         SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY +
                         SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY;
  end if;
 
  -- return true to indicate success
  return true;
end sem_inf_related;
/
show errors;
</pre>
<p>The <code class="codeph">sem_inf_related</code> function has a few key differences from previous examples. First, the <code class="codeph">sem_inf_related</code> function queries purely with resource IDs and inserts new triples using only resource IDs. Because all the added triples in the <code class="codeph">output_tab</code> table only use resource IDs, the function can enable the <code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code> optimization flag. For optimal performance, functions should try to use resource IDs over lexical values. However, sometimes this is not possible, as in <a href="user-defined-inf.htm#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">Example 2: Adding Dynamic Triples</a>, which concatenates lexical values to form a new lexical value. Note that in cases like <a href="user-defined-inf.htm#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">Example 2: Adding Dynamic Triples</a>, it is usually better to join with the resource view (<code class="codeph">resource_id_map_view</code>) than to embed calls to <code class="codeph">oracle_orardf_res2vid</code> within the SQL query. This is due to the overhead of calling the function for each possible match as opposed to joining with another table.</p>
<p>Another key difference in the <code class="codeph">sem_inf_related</code> function is the use of the <code class="codeph">oracle_orardf_add_res</code> function (compared to <code class="codeph">oracle_orardf_res2vid</code>). Unlike the <code class="codeph">res2vid</code> function, the <code class="codeph">add_res</code> function will add a resource to the resource view (<code class="codeph">resource_id_map_view</code>) if the resource does not already exist. Inference extensions functions should use the <code class="codeph">add_res</code> function if adding the resource to the resource view is not a concern. Calling the function multiple times will not generate duplicate entries in the resource view.</p>
<p>The last main difference is the additional <code class="codeph">NOT EXISTS</code> clause in the SQL query. The first <code class="codeph">NOT EXISTS</code> clause avoids adding any triples that may be duplicates of triples already in the model or triples inferred by other rules (<code class="codeph">src_tab_view</code>). Checking for these duplicates allows <code class="codeph">sem_inf_related</code> to enable the <code class="codeph">INF_EXT_OPT_FLAG_NEWDATA_ONLY</code> optimization flag. The second <code class="codeph">NOT EXISTS</code> clause avoids adding triples that may be duplicates of triples already added by the <code class="codeph">sem_inf_related</code> function to the output_tab table during the current round of reasoning (see the <code class="codeph">num_calls</code> parameter). Checking for these duplicates allows <code class="codeph">sem_inf_related</code> to enable the <code class="codeph">INF_EXT_OPT_FLAG_UNIQDATA_ONLY</code> optimization flag.</p>
<p>Like the <code class="codeph">sem_inf_dynamic</code> example, <code class="codeph">sem_inf_related</code> example uses a <code class="codeph">PARALLEL</code> SQL query hint in its insert statement. Parallel execution on a balanced hardware configuration can significantly improve performance. For a data-intensive application, a good I/O subsystem is usually a critical component to the performance of the whole system.</p>
<p>To create an entailment with the <code class="codeph">sem_inf_dynamic</code> function, grant execution privileges to the MDSYS user, then pass the function name to the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> procedure, as follows:</p>
<pre dir="ltr">-- grant appropriate privileges
grant execute on sem_inf_related to mdsys;
 
-- create the entailment
begin
  sem_apis.create_entailment( 
    &#39;EMPLOYEES_INF&#39;
  , sem_models(&#39;EMPLOYEES&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , passes =&gt; SEM_APIS.REACH_CLOSURE
  , inf_ext_user_func_name =&gt; &#39;sem_inf_related&#39; 
);
end;
/
</pre>
<p>The entailment should contain the following two new triples added by <code class="codeph">sem_inf_related</code>:</p>
<pre dir="ltr">S                        P                                    O
------------------------ ------------------------------------ ------------------------
http://example.org/John  http://example.org/possibleRelative  http://example.org/Mary
http://example.org/Mary  http://example.org/possibleRelative  http://example.org/John
</pre></div>
</div>
<a id="RDFRM529"></a><a id="RDFRM530"></a><a id="RDFRM528"></a>
<div class="props_rev_3"><a id="GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF"></a>
<h4 id="RDFRM-GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF" class="sect4"><span class="enumeration_section">9.1.3.4</span> Example 4: Temporal Reasoning (Several Related Examples)</h4>
<div>
<p>User-defined extension functions enable you to better leverage certain data types (like <code class="codeph">xsd:dateTime</code>) in the triples. For example, with user-defined extension functions, it is possible to infer relationships between triples based on the difference between two <code class="codeph">xsd:dateTime</code> values. The three examples in this section explore two different temporal reasoning rules and how to combine them into one entailment. The examples assume the models <code class="codeph">EVENT</code> and <code class="codeph">EVENT_ONT</code> exist and contain the following semantic data:</p>
<div class="section">
<p class="subhead3">EVENT_ONT</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">@prefix owl:  &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix :     &lt;http://example.org/event/&gt; .
 
# we model two types of events
:Meeting      rdfs:subClassOf :Event .
:Presentation rdfs:subClassOf :Event .
 
# events have topics
:topic        rdfs:domain     :Event .
 
# events have start and end times 
:startTime    rdfs:domain     :Event ;
              rdfs:range      xsd:dateTime .
:endTime      rdfs:domain     :Event ;
              rdfs:range      xsd:dateTime .
 
# duration (in minutes) of an event
:lengthInMins rdfs:domain      :Event ;
              rdfs:range       xsd:integer .
 
# overlaps property identifies conflicting events
:overlaps     rdfs:domain      :Event ;
              rdf:type         owl:SymmetricProperty .
:noOverlap    rdfs:domain      :Event ;
              rdf:type         owl:SymmetricProperty .
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">EVENT_TBOX</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix :    &lt;http://example.org/event/&gt; .
 
:m1 rdf:type   :Meeting ;
    :topic     &#34;Beta1 launch&#34; ;
    :startTime &#34;2012-04-01T09:30:00-05:00&#34;^^xsd:dateTime ;
    :endTime   &#34;2012-04-01T11:00:00-05:00&#34;^^xsd:dateTime .
 
:m2 rdf:type   :Meeting ;
    :topic     &#34;Standards compliance&#34; ;
    :startTime &#34;2012-04-01T12:30:00-05:00&#34;^^xsd:dateTime ;
    :endTime   &#34;2012-04-01T13:30:00-05:00&#34;^^xsd:dateTime .
 
:p1 rdf:type   :Presentation ;
    :topic     &#34;OWL Reasoners&#34; ;
    :startTime &#34;2012-04-01T11:00:00-05:00&#34;^^xsd:dateTime ;
    :endTime   &#34;2012-04-01T13:00:00-05:00&#34;^^xsd:dateTime .
</pre>
<p>The examples are the following:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="user-defined-inf.htm#GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D">Example 4a: Duration Rule</a></p>
</li>
<li>
<p><a href="user-defined-inf.htm#GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B">Example 4b: Overlap Rule</a></p>
</li>
<li>
<p><a href="user-defined-inf.htm#GUID-23952501-FEBE-49CD-8579-BCB4D0908F56">Example 4c: Duration and Overlap Rules</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="RDFRM531"></a>
<div class="props_rev_3"><a id="GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D"></a>
<h5 id="RDFRM-GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D" class="sect5"><span class="enumeration_section">9.1.3.4.1</span> Example 4a: Duration Rule</h5>
<div>
<p>The following user-defined inference extension function (<code class="codeph">sem_inf_durations</code>) infers the duration in minutes of events, given the start and end times of an event. For example, an event starting at 9:30 AM and ending at 11:00 AM has duration of 90 minutes. The following extension function extracts the start and end times for each event, converts the <code class="codeph">xsd:dateTime</code> values into Oracle timestamps, then computes the difference between the timestamps. Notice that this extension function can handle time zones.</p>
<pre dir="ltr">create or replace function sem_inf_durations(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  eventClassId        number;
  rdfTypePropertyId   number;
  startTimePropertyId number;
  endTimePropertyId   number;
  durationPropertyId  number;
 
  xsdTimeFormat       varchar2(100);
  sqlStmt             varchar2(4000);
  insertStmt          varchar2(4000);
 
  pragma autonomous_transaction;
begin
  if (action = &#39;RUN&#39;) then
    -- retrieve ID of resource that already exists in the data (will
    -- throw exception if resource does not exist).
    eventClassId        := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/Event&#39;);
    startTimePropertyId := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/startTime&#39;);
    endTimePropertyId   := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/endTime&#39;);
    durationPropertyId  := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/lengthInMins&#39;);
    rdfTypePropertyId   := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&#39;);
 
    -- set the TIMESTAMP format we will use to parse XSD times
    xsdTimeFormat := &#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;;
 
    -- query we use to extract the event ID and start/end times.  
    sqlStmt := 
      &#39;select ids1.sid eventId,
              TO_TIMESTAMP_TZ(values1.value_name,&#39;&#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;&#39;) startTime,
              TO_TIMESTAMP_TZ(values2.value_name,&#39;&#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;&#39;) endTime
       from   &#39; || resource_id_map_view || &#39; values1,
              &#39; || resource_id_map_view || &#39; values2,
              &#39; || src_tab_view || &#39;         ids1,
              &#39; || src_tab_view || &#39;         ids2,
              &#39; || src_tab_view || &#39;         ids3
       where  ids1.sid = ids3.sid 
         AND  ids3.pid = &#39; || to_char(rdfTypePropertyId,&#39;TM9&#39;) || &#39; 
         AND  ids3.oid = &#39; || to_char(eventClassId,&#39;TM9&#39;)      || &#39; 
         AND  ids1.sid = ids2.sid 
         AND  ids1.pid = &#39; || to_char(startTimePropertyId,&#39;TM9&#39;) || &#39; 
         AND  ids2.pid = &#39; || to_char(endTimePropertyId,&#39;TM9&#39;)   || &#39; 
         AND  ids1.oid = values1.value_id 
         AND  ids2.oid = values2.value_id 
       /* ensures we have NEWDATA */
         AND  not exists
               (select 1 
                from   &#39; || src_tab_view || &#39; 
                where  sid = ids3.sid 
                  AND  pid = &#39; || to_char(durationPropertyId,&#39;TM9&#39;) || &#39;) 
       /* ensures we have UNIQDATA */
         AND  not exists
               (select 1 
                from   &#39; || output_tab || &#39; 
                where  sid = ids3.sid 
                  AND  pid = &#39; || to_char(durationPropertyId,&#39;TM9&#39;) || &#39;)&#39;;
 
    -- compute the difference (in minutes) between the two Oracle
    -- timestamps from our sqlStmt query.  Store the minutes as
    -- xsd:integer.
    insertStmt :=
      &#39;insert /*+ parallel append */ into &#39; || output_tab || &#39; (sid, pid, o) 
       select eventId, 
              &#39; || to_char(durationPropertyId,&#39;TM9&#39;) || &#39;, 
              &#39;&#39;&#34;&#39;&#39; || minutes || &#39;&#39;&#34;^^xsd:integer&#39;&#39;
       from   (
         select eventId,
                (extract(day    from (endTime - startTime))*24*60 +
                 extract(hour   from (endTime - startTime))*60 +
                 extract(minute from (endTime - startTime))) minutes
         from   (&#39; || sqlStmt || &#39;))&#39;;
 
    -- execute the query
    execute immediate insertStmt;
 
    -- commit our changes
    commit;
  end if;
 
  -- we already checked for duplicates in src_tab_view (NEWDATA) and
  -- in output_tab (UNIQDATA)
  optimization_flag := SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY +
                       SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY;
 
  -- return true to indicate success
  return true;
 
  -- handle any exceptions
  exception 
    when others then
      diag_message := &#39;error occurred: &#39; || SQLERRM;
      return false;
end sem_inf_durations;
/
show errors;
</pre>
<p>The <code class="codeph">sem_inf_durations</code> function leverages built-in Oracle temporal functions to compute the event durations. First, the function converts the <code class="codeph">xsd:dateTime</code> literal value to an Oracle <code class="codeph">TIMESTAMP</code> object using the <code class="codeph">TO_TIMESTAMP_TZ</code> function. Taking the difference between two Oracle <code class="codeph">TIMESTAMP</code> objects produces an <code class="codeph">INTERVAL</code> object that represents a time interval. Using the <code class="codeph">EXTRACT</code> operator, the <code class="codeph">sem_inf_durations</code> function computes the duration of each event in minutes by extracting the days, hours, and minutes out of the duration intervals.</p>
<p>Because the <code class="codeph">sem_inf_durations</code> function checks for duplicates against both data in the existing model (<code class="codeph">src_tab_view</code>) and data in the <code class="codeph">output_tab</code> table, it can enable the <code class="codeph">INF_EXT_OPT_FLAG_NEWDATA_ONLY</code> and <code class="codeph">INF_EXT_OPT_FLAG_UNIQDATA_ONLY</code> optimization flags. (See <a href="user-defined-inf.htm#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">Example 3: Optimizing Performance</a> for more information about optimization flags.)</p>
<p>Notice that unlike previous examples, <code class="codeph">sem_inf_durations</code> contains an exception handler. Exception handlers are useful for debugging issues in user-defined inference extension functions. To produce useful debugging messages, catch exceptions in the extension function, set the <code class="codeph">diag_message</code> parameter to reflect the error, and return <code class="codeph">FALSE</code> to indicate that an error occurred during execution of the extension function. The <code class="codeph">sem_inf_durations</code> function catches all exceptions and sets the <code class="codeph">diag_message</code> value to the exception message.</p>
<p>To create an entailment with the <code class="codeph">sem_inf_durations</code> function, grant execution privileges to the MDSYS user, then pass the function name to the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> procedure, as follows:</p>
<pre dir="ltr">-- grant appropriate privileges
grant execute on sem_inf_durations to mdsys;
 
-- create the entailment
begin
  sem_apis.create_entailment( 
    &#39;EVENT_INF&#39;
  , sem_models(&#39;EVENT&#39;, &#39;EVENT_ONT&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , passes =&gt; SEM_APIS.REACH_CLOSURE
  , inf_ext_user_func_name =&gt; &#39;sem_inf_durations&#39; 
);
end;
/
</pre>
<p>In addition to the triples inferred by OWLPRIME, the entailment should contain the following three new triples added by <code class="codeph">sem_inf_durations</code>:</p>
<pre dir="ltr">S                            P                                      O
---------------------------- -------------------------------------- ---------
http://example.org/event/m1  http://example.org/event/lengthInMins  90
http://example.org/event/m2  http://example.org/event/lengthInMins  60
http://example.org/event/p1  http://example.org/event/lengthInMins  120
</pre></div>
</div>
<a id="RDFRM532"></a>
<div class="props_rev_3"><a id="GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B"></a>
<h5 id="RDFRM-GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B" class="sect5"><span class="enumeration_section">9.1.3.4.2</span> Example 4b: Overlap Rule</h5>
<div>
<p>The following user-defined inference extension function (<code class="codeph">sem_inf_overlap</code>) infers whether two events overlap. Two events overlap if one event starts while the other event is in progress. The function extracts the start and end times for every pair of events, converts the <code class="codeph">xsd:dateTime</code> values into Oracle timestamps, then computes whether one event starts within the other.</p>
<pre dir="ltr">create or replace function sem_inf_overlap(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  eventClassId        number;
  rdfTypePropertyId   number;
  startTimePropertyId number;
  endTimePropertyId   number;
  overlapsPropertyId  number;
  noOverlapPropertyId number;
 
  xsdTimeFormat       varchar2(100);
  sqlStmt             varchar2(4000);
  insertStmt          varchar2(4000);
 
  pragma autonomous_transaction;
begin
  if (action = &#39;RUN&#39;) then
    -- retrieve ID of resource that already exists in the data (will
    -- throw exception if resource does not exist).
    eventClassId        := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/Event&#39;);
    startTimePropertyId := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/startTime&#39;);
    endTimePropertyId   := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/endTime&#39;);
    overlapsPropertyId  := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/overlaps&#39;);
    noOverlapPropertyId := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/event/noOverlap&#39;);
    rdfTypePropertyId   := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&#39;);
 
    -- set the TIMESTAMP format we will use to parse XSD times
    xsdTimeFormat := &#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;;
 
    -- query we use to extract the event ID and start/end times.  
    sqlStmt := 
      &#39;select idsA1.sid eventAId,
              idsB1.sid eventBId,
              TO_TIMESTAMP_TZ(valuesA1.value_name,&#39;&#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;&#39;) startTimeA,
              TO_TIMESTAMP_TZ(valuesA2.value_name,&#39;&#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;&#39;) endTimeA,
              TO_TIMESTAMP_TZ(valuesB1.value_name,&#39;&#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;&#39;) startTimeB,
              TO_TIMESTAMP_TZ(valuesB2.value_name,&#39;&#39;YYYY-MM-DD&#34;T&#34;HH24:MI:SSTZH:TZM&#39;&#39;) endTimeB
       from   &#39; || resource_id_map_view || &#39; valuesA1,
              &#39; || resource_id_map_view || &#39; valuesA2,
              &#39; || resource_id_map_view || &#39; valuesB1,
              &#39; || resource_id_map_view || &#39; valuesB2,
              &#39; || src_tab_view || &#39;         idsA1,
              &#39; || src_tab_view || &#39;         idsA2,
              &#39; || src_tab_view || &#39;         idsA3,
              &#39; || src_tab_view || &#39;         idsB1,
              &#39; || src_tab_view || &#39;         idsB2,
              &#39; || src_tab_view || &#39;         idsB3
       where  idsA1.sid = idsA3.sid 
         AND  idsA3.pid = &#39; || to_char(rdfTypePropertyId,&#39;TM9&#39;) || &#39; 
         AND  idsA3.oid = &#39; || to_char(eventClassId,&#39;TM9&#39;)      || &#39; 
         AND  idsB1.sid = idsB3.sid 
         AND  idsB3.pid = &#39; || to_char(rdfTypePropertyId,&#39;TM9&#39;) || &#39; 
         AND  idsB3.oid = &#39; || to_char(eventClassId,&#39;TM9&#39;)      || &#39; 
       /* only do half the checks, our TBOX ontology will handle symmetries */
         AND  idsA1.sid &lt; idsB1.sid                   
       /* grab values of startTime and endTime for event A */
         AND  idsA1.sid = idsA2.sid 
         AND  idsA1.pid = &#39; || to_char(startTimePropertyId,&#39;TM9&#39;) || &#39; 
         AND  idsA2.pid = &#39; || to_char(endTimePropertyId,&#39;TM9&#39;)   || &#39; 
         AND  idsA1.oid = valuesA1.value_id 
         AND  idsA2.oid = valuesA2.value_id 
       /* grab values of startTime and endTime for event B */
         AND  idsB1.sid = idsB2.sid 
         AND  idsB1.pid = &#39; || to_char(startTimePropertyId,&#39;TM9&#39;) || &#39; 
         AND  idsB2.pid = &#39; || to_char(endTimePropertyId,&#39;TM9&#39;)   || &#39; 
         AND  idsB1.oid = valuesB1.value_id 
         AND  idsB2.oid = valuesB2.value_id 
       /* ensures we have NEWDATA */
         AND  not exists
               (select 1 
                from   &#39; || src_tab_view || &#39; 
                where  sid = idsA1.sid  
                  AND  oid = idsB1.sid 
                  AND  pid in (&#39; || to_char(overlapsPropertyId,&#39;TM9&#39;)  || &#39;,&#39; || 
                                    to_char(noOverlapPropertyId,&#39;TM9&#39;) || &#39;)) 
       /* ensures we have UNIQDATA */
         AND  not exists
               (select 1
                from   &#39; || output_tab   || &#39;
                where  sid = idsA1.sid 
                  AND  oid = idsB1.sid 
                  AND  pid in (&#39; || to_char(overlapsPropertyId,&#39;TM9&#39;)  || &#39;,&#39; || 
                                    to_char(noOverlapPropertyId,&#39;TM9&#39;) || &#39;))&#39;;
 
    -- compare the two event times
    insertStmt :=
      &#39;insert /*+ parallel append */ into &#39; || output_tab || &#39; (sid, pid, oid) 
       select eventAId, overlapStatusId, eventBId
       from   (
         select eventAId,
                (case 
                 when (startTimeA &lt; endTimeB and 
                       startTimeA &gt; startTimeB) then
                   &#39; || to_char(overlapsPropertyId,&#39;TM9&#39;) || &#39;
                 when (startTimeB &lt; endTimeA and
                       startTimeB &gt; startTimeA) then
                   &#39; || to_char(overlapsPropertyId,&#39;TM9&#39;) || &#39;
                 else
                   &#39; || to_char(noOverlapPropertyId,&#39;TM9&#39;) || &#39;
                 end) overlapStatusId,
                 eventBId
         from   (&#39; || sqlStmt || &#39;))&#39;;
 
    -- execute the query
    execute immediate insertStmt;
 
    -- commit our changes
    commit;
  end if;
 
  -- we only use ID values in the output_tab and we check for
  -- duplicates with our NOT EXISTS clause.
  optimization_flag := SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS +
                       SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY +
                       SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY;
 
  -- return true to indicate success
  return true;
 
  -- handle any exceptions
  exception 
    when others then
      diag_message := &#39;error occurred: &#39; || SQLERRM;
      return false;
end sem_inf_overlap;
/
show errors;
</pre>
<p>The <code class="codeph">sem_inf_overlap</code> function is similar to the <code class="codeph">sem_inf_durations</code> function in <a href="user-defined-inf.htm#GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B">Example 4b: Overlap Rule</a>. The main difference between the two is that the query in <code class="codeph">sem_inf_overlap</code> contains more joins and enables the INF_EXT_OPT_FLAG_ALL_IDS optimization flag because it does not need to generate new lexical values. (See <a href="user-defined-inf.htm#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">Example 3: Optimizing Performance</a> for more information about optimization flags.)</p>
<p>To create an entailment with the <code class="codeph">sem_inf_overlap</code> function, grant execution privileges to the MDSYS user, then pass the function name to the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> procedure, as follows:</p>
<pre dir="ltr">-- grant appropriate privileges
grant execute on sem_inf_overlap to mdsys;
 
-- create the entailment
begin
  sem_apis.create_entailment( 
    &#39;EVENT_INF&#39;
  , sem_models(&#39;EVENT&#39;, &#39;EVENT_ONT&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , passes =&gt; SEM_APIS.REACH_CLOSURE
  , inf_ext_user_func_name =&gt; &#39;sem_inf_overlap&#39; 
);
end;
/
</pre>
<p>In addition to the triples inferred by OWLPRIME, the entailment should contain the following six new triples added by <code class="codeph">sem_inf_overlap</code>:</p>
<pre dir="ltr">S                            P                                   O
---------------------------- ----------------------------------- ----------------------------
http://example.org/event/m1  http://example.org/event/noOverlap  http://example.org/event/m2
http://example.org/event/m1  http://example.org/event/noOverlap  http://example.org/event/p1
http://example.org/event/m2  http://example.org/event/noOverlap  http://example.org/event/m1
http://example.org/event/m2  http://example.org/event/overlaps   http://example.org/event/p1
http://example.org/event/p1  http://example.org/event/noOverlap  http://example.org/event/m1
http://example.org/event/p1  http://example.org/event/overlaps   http://example.org/event/m2
</pre></div>
</div>
<a id="RDFRM533"></a>
<div class="props_rev_3"><a id="GUID-23952501-FEBE-49CD-8579-BCB4D0908F56"></a>
<h5 id="RDFRM-GUID-23952501-FEBE-49CD-8579-BCB4D0908F56" class="sect5"><span class="enumeration_section">9.1.3.4.3</span> Example 4c: Duration and Overlap Rules</h5>
<div>
<p>The example in this section uses the extension functions from <a href="user-defined-inf.htm#GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D">Example 4a: Duration Rule</a> (<code class="codeph">sem_inf_durations</code>) and <a href="user-defined-inf.htm#GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B">Example 4b: Overlap Rule</a> (<code class="codeph">sem_inf_overlap</code>) together to produce a single entailment. The extension functions are left unmodified for this example.</p>
<p>To create an entailment using multiple extension functions, use a comma to separate each extension function passed to the <code class="codeph">inf_ext_user_func_name</code> parameter of <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>. The following example assumes that the MDSYS user has already been granted the appropriate privileges on the extension functions.</p>
<pre dir="ltr">-- use multiple user-defined inference functions
begin
  sem_apis.create_entailment( 
    &#39;EVENT_INF&#39;
  , sem_models(&#39;EVENT&#39;, &#39;EVENT_ONT&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , passes =&gt; SEM_APIS.REACH_CLOSURE
  , inf_ext_user_func_name =&gt; &#39;sem_inf_durations,sem_inf_overlap&#39; 
);
end;
/
</pre>
<p>In addition to the triples inferred by OWLPRIME, the entailment should contain the following nine new triples added by <code class="codeph">sem_inf_durations</code> and <code class="codeph">sem_inf_overlap</code>:</p>
<pre dir="ltr">S                            P                                      O
---------------------------- -------------------------------------- ----------------------------
http://example.org/event/m1  http://example.org/event/lengthInMins  90
http://example.org/event/m1  http://example.org/event/noOverlap     http://example.org/event/m2
http://example.org/event/m1  http://example.org/event/noOverlap     http://example.org/event/p1
http://example.org/event/m2  http://example.org/event/lengthInMins  60
http://example.org/event/m2  http://example.org/event/noOverlap     http://example.org/event/m1
http://example.org/event/m2  http://example.org/event/overlaps      http://example.org/event/p1
http://example.org/event/p1  http://example.org/event/lengthInMins  120
http://example.org/event/p1  http://example.org/event/noOverlap     http://example.org/event/m1
http://example.org/event/p1  http://example.org/event/overlaps      http://example.org/event/m2
</pre>
<p>Notice that the extension functions, <code class="codeph">sem_inf_durations</code> and <code class="codeph">sem_inf_overlap</code>, did not need to use the same optimization flags. It is possible to use extension functions with contradictory optimization flags (for example, one function using <code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code> and another function inserting all new triples as lexical values).</p>
</div>
</div>
</div>
<a id="RDFRM534"></a>
<div class="props_rev_3"><a id="GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3"></a>
<h4 id="RDFRM-GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3" class="sect4"><span class="enumeration_section">9.1.3.5</span> Example 5: Spatial Reasoning</h4>
<div>
<p>User-defined inference extension functions can also leverage geospatial data types, like WKT (well-known text), to perform spatial reasoning. For example, with user-defined extension functions, it is possible to infer a &#34;contains&#34; relationship between geometric entities, such as states and cities.</p>
<p>The example in this section demonstrates how to infer whether a geometry (a US state) contains a point (a US city). This example assumes the RDF network already has a spatial index (described in section 1.6.6.2). This example also assumes the model <code class="codeph">STATES</code> exists and contains the following semantic data:</p>
<pre dir="ltr">@prefix orageo: &lt;http://xmlns.oracle.com/rdf/geo/&gt; .
@prefix rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs:   &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix :       &lt;http://example.org/geo/&gt; .
 
:Colorado rdf:type  :State ;
          :boundary &#34;Polygon((-109.0448 37.0004, -102.0424 36.9949, -102.0534 41.0006, -109.0489 40.9996, -109.0448 37.0004))&#34;^^orageo:WKTLiteral .
:Utah     rdf:type  :State ;
          :boundary &#34;Polygon((-114.0491 36.9982, -109.0462 37.0026, -109.0503 40.9986, -111.0471 41.0006, -111.0498 41.9993, -114.0395 41.9901, -114.0491 36.9982))&#34;^^orageo:WKTLiteral .
:Wyoming  rdf:type  :State ;
          :boundary &#34;Polygon((-104.0556 41.0037, -104.0584 44.9949, -111.0539 44.9998, -111.0457 40.9986, -104.0556 41.0037))&#34;^^orageo:WKTLiteral
 
:StateCapital rdfs:subClassOf :City ;
 
:Denver   rdf:type  :StateCapital ;
          :location &#34;Point(-104.984722 39.739167)&#34;^^orageo:WKTLiteral .
:SaltLake rdf:type  :StateCaptial ;
          :location &#34;Point(-111.883333 40.75)&#34;^^orageo:WKTLiteral .
:Cheyenne rdf:type  :StateCapital ;
          :location &#34;Point(-104.801944 41.145556)&#34;^^orageo:WKTLiteral .
</pre>
<p>The following user-defined inference extension function (<code class="codeph">sem_inf_capitals</code>) searches for capital cities within each state using the WKT geometries. If the function finds a capital city, it infers the city is the capital of the state containing it.</p>
<pre dir="ltr">create or replace function sem_inf_capitals(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  stateClassId        number;
  capitalClassId      number;
  
  boundaryPropertyId  number;
  locationPropertyId  number;
  rdfTypePropertyId   number;
  capitalPropertyId   number;
 
  defaultSRID         number := 8307;
 
  xsdTimeFormat       varchar2(100);
  sqlStmt             varchar2(4000);
  insertStmt          varchar2(4000);
 
  pragma autonomous_transaction;
begin
  if (action = &#39;RUN&#39;) then
    -- retrieve ID of resource that already exists in the data (will
    -- throw exception if resource does not exist).
    stateClassId       := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/geo/State&#39;);
    capitalClassId     := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/geo/StateCapital&#39;);
    boundaryPropertyId := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/geo/boundary&#39;);
    locationPropertyId := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://example.org/geo/location&#39;);
    rdfTypePropertyId  := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&#39;);
 
    -- retreive ID of resource or generate a new ID if resource does
    -- not already exist
    capitalPropertyId := sdo_sem_inference.oracle_orardf_add_res(&#39;http://example.org/geo/capital&#39;);
 
    -- query we use to extract the capital cities contained within state boundaries
    sqlStmt := 
      &#39;select idsA1.sid stateId,
              idsB1.sid cityId
       from   &#39; || resource_id_map_view || &#39; valuesA,
              &#39; || resource_id_map_view || &#39; valuesB,
              &#39; || src_tab_view || &#39;         idsA1,
              &#39; || src_tab_view || &#39;         idsA2,
              &#39; || src_tab_view || &#39;         idsB1,
              &#39; || src_tab_view || &#39;         idsB2
       where  idsA1.pid = &#39; || to_char(rdfTypePropertyId,&#39;TM9&#39;) || &#39; 
         AND  idsA1.oid = &#39; || to_char(stateClassId,&#39;TM9&#39;)      || &#39; 
         AND  idsB1.pid = &#39; || to_char(rdfTypePropertyId,&#39;TM9&#39;) || &#39; 
         AND  idsB1.oid = &#39; || to_char(capitalClassId,&#39;TM9&#39;)    || &#39; 
       /* grab geometric lexical values */
         AND  idsA2.sid = idsA1.sid                                  
         AND  idsA2.pid = &#39; || to_char(boundaryPropertyId,&#39;TM9&#39;)|| &#39; 
         AND  idsA2.oid = valuesA.value_id                           
         AND  idsB2.sid = idsB1.sid                                  
         AND  idsB2.pid = &#39; || to_char(locationPropertyId,&#39;TM9&#39;)|| &#39; 
         AND  idsB2.oid = valuesB.value_id                           
       /* compare geometries to see if city is contained by state */              
         AND  SDO_RELATE( 
                SDO_RDF.getV$GeometryVal( 
                  valuesA.value_type, 
                  valuesA.vname_prefix, 
                  valuesA.vname_suffix, 
                  valuesA.literal_type, 
                  valuesA.language_type, 
                  valuesA.long_value, 
                  &#39; || to_char(defaultSRID,&#39;TM9&#39;) || &#39;),
                SDO_RDF.getV$GeometryVal(
                  valuesB.value_type, 
                  valuesB.vname_prefix, 
                  valuesB.vname_suffix, 
                  valuesB.literal_type, 
                  valuesB.language_type, 
                  valuesB.long_value, 
                  &#39; || to_char(defaultSRID,&#39;TM9&#39;) || &#39;),
                &#39;&#39;mask=CONTAINS&#39;&#39;) = &#39;&#39;TRUE&#39;&#39; 
       /* ensures we have NEWDATA and only check capitals not assigned to a state */
         AND  not exists
               (select 1 
                from   &#39; || src_tab_view || &#39; 
                where  pid = &#39; || to_char(capitalPropertyId,&#39;TM9&#39;) || &#39; 
                  AND  (sid = idsA1.sid OR oid = idsB1.sid)) 
       /* ensures we have UNIQDATA and only check capitals not assigned to a state */
         AND  not exists
               (select 1
                from   &#39; || output_tab   || &#39;
                where  pid = &#39; || to_char(capitalPropertyId,&#39;TM9&#39;) || &#39; 
                  AND  (sid = idsA1.sid OR oid = idsB1.sid))&#39;;
 
    -- insert new triples using only IDs
    insertStmt :=
      &#39;insert /*+ parallel append */ into &#39; || output_tab || &#39; (sid, pid, oid) 
       select stateId, &#39; || to_char(capitalPropertyId,&#39;TM9&#39;) || &#39;, cityId
       from   (&#39; || sqlStmt || &#39;)&#39;;
 
    -- execute the query
    execute immediate insertStmt;
 
    -- commit our changes
    commit;
  end if;
 
  -- we only use ID values in the output_tab and we check for
  -- duplicates with our NOT EXISTS clauses.
  optimization_flag := SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS +
                       SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY +
                       SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY;
 
  -- return true to indicate success
  return true;
 
  -- handle any exceptions
  exception 
    when others then
      diag_message := &#39;error occurred: &#39; || SQLERRM;
      return false;
end sem_inf_capitals;
/
show errors;
</pre>
<p>The <code class="codeph">sem_inf_capitals</code> function is similar to the <code class="codeph">sem_inf_durations</code> function in <a href="user-defined-inf.htm#GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D">Example 4a: Duration Rule</a>, in that both functions must convert the lexical values of some triples into Oracle types to leverage native Oracle operators. In the case of <code class="codeph">sem_inf_capitals</code>, the function converts the WKT lexical values encoding polygons and points into the Oracle Spatial and Graph SDO_GEOMETRY type, using the <code class="codeph">SDO_RDF.getV$GeometryVal</code> function. The <code class="codeph">getV$GeometryVal</code> function requires arguments mostly provided by the resource view (<code class="codeph">resource_id_map_view</code>) and an additional argument, an ID to a spatial reference system (SRID). The <code class="codeph">getV$GeometryVal</code> function will convert the geometry into the spatial reference system specified by SRID. The <code class="codeph">sem_inf_capitals</code> function uses the default Oracle Spatial and Graph reference system, WGS84 Longitude-Latitude, specified by SRID value 8307. (For more information about support in RDF Semantic Graph for spatial references systems, see <a href="rdf-overview.htm#GUID-3986DFD4-F23A-4379-A859-9EA1F1582D43">Spatial Support</a>.)</p>
<p>After converting the WKT values into SDO_GEOMETRY types using the <code class="codeph">getV$GeometryVal</code> function, the <code class="codeph">sem_inf_capitals</code> function compares the state geometry with the city geometry to see if the state contains the city. The <code class="codeph">SDO_RELATE</code> operator performs this comparison and returns the literal value <code class="codeph">&#39;TRUE&#39;</code> when the state contains the city. The <code class="codeph">SDO_RELATE</code> operator can perform various different types of comparisons. (See <a class="olink SPATL110" target="_blank" href="../SPATL/spatial-operators.htm#SPATL110"><span class="italic">Oracle Spatial and Graph Developer&#39;s Guide</span></a> for more information about <code class="codeph">SDO_RELATE</code> and other spatial operators.)</p>
<p>To create an entailment with the <code class="codeph">sem_inf_capitals</code> function, grant execution privileges to the MDSYS user, then pass the function name to the <a href="sem-apis-ref.htm#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>procedure, as follows:</p>
<pre dir="ltr">-- grant appropriate privileges
grant execute on sem_inf_capitals to mdsys;
 
-- create the entailment
begin
  sem_apis.create_entailment( 
    &#39;STATES_INF&#39;
  , sem_models(&#39;STATES&#39;)
  , sem_rulebases(&#39;OWLPRIME&#39;)
  , passes =&gt; SEM_APIS.REACH_CLOSURE
  , inf_ext_user_func_name =&gt; &#39;sem_inf_capitals&#39; 
);
end;
/
</pre>
<p>In addition to the triples inferred by OWLPRIME, the entailment should contain the following three new triples added by <code class="codeph">sem_inf_capitals</code>:</p>
<pre dir="ltr">S                                P                               O
-------------------------------- ------------------------------- --------------------------------
http://example.org/geo/Colorado  http://example.org/geo/capital  http://example.org/geo/Denver
http://example.org/geo/Utah      http://example.org/geo/capital  http://example.org/geo/SaltLake
http://example.org/geo/Wyoming   http://example.org/geo/capital  http://example.org/geo/Cheyenne
</pre></div>
</div>
<a id="RDFRM535"></a>
<div class="props_rev_3"><a id="GUID-537C3916-D0F0-4909-BC05-50353621C220"></a>
<h4 id="RDFRM-GUID-537C3916-D0F0-4909-BC05-50353621C220" class="sect4"><span class="enumeration_section">9.1.3.6</span> Example 6: Calling a Web Service</h4>
<div>
<p>This section contains a user-defined inference extension function (<code class="codeph">sem_inf_geocoding</code>) and a related helper procedure (<code class="codeph">geocoding</code>), which enable you to make a web service call to the Oracle Geocoder service. The user-defined inference extension function looks for the object values of triples using predicate <code class="codeph">&lt;urn:streetAddress&gt;</code>, makes callouts to the Oracle public Geocoder service endpoint at <code class="codeph">http://maps.oracle.com/geocoder/gcserver</code>, and inserts the longitude and latitude information as two separate triples.</p>
<p>For example, assume that the semantic model contains the following assertion:</p>
<pre dir="ltr">&lt;urn:NEDC&gt;  &lt;urn:streetAddress&gt;  &#34;1 Oracle Dr., Nashua, NH&#34;
</pre>
<p>In this case, an inference call using <code class="codeph">sem_inf_geocoding</code> will produce the following new assertions:</p>
<pre dir="ltr">&lt;urn:NEDC&gt; &lt;http://www.w3.org/2003/01/geo/wgs84_pos#long&gt;  &#34;-71.46421&#34;
&lt;urn:NEDC&gt; &lt;http://www.w3.org/2003/01/geo/wgs84_pos#lat&gt;   &#34;42.75836&#34;
&lt;urn:NEDC&gt; &lt;http://www.opengis.net/geosparql#asWKT&gt;  &#34;POINT(-71.46421 42.75836)&#34;^^&lt;http://www.opengis.net/geosparql#wktLiteral&gt;
&lt;urn:NEDC&gt; &lt;http://xmlns.oracle.com/rdf/geo/asWKT&gt;   &#34;POINT(-71.46421 42.75836)&#34;^^&lt;http://xmlns.oracle.com/rdf/geo/WKTLiteral&gt;
</pre>
<p>The <code class="codeph">sem_inf_geocoding</code> function is defined as follows:</p>
<pre dir="ltr">create or replace function sem_inf_geocoding(
    src_tab_view         in  varchar2,
    resource_id_map_view in  varchar2,
    output_tab           in  varchar2,
    action               in  varchar2,
    num_calls            in  number,
    tplInferredLastRound in  number,
    options              in  varchar2 default null,
    optimization_flag    out number,
    diag_message         out varchar2
    )
return boolean
as
  pragma autonomous_transaction;
  iCount integer;
  
  nLong number;
  nLat  number;
  nWKT  number;
  nOWKT number;
  nStreetAddr number;
  
  sidTab    dbms_sql.number_table;
  oidTab    dbms_sql.number_table;
  
  vcRequestBody varchar2(32767);
  vcStmt        varchar2(32767);
  vcStreeAddr   varchar2(3000);
  
  type cur_type is ref cursor;
  cursorFind    cur_type; 
  vcLong varchar2(100);
  vcLat  varchar2(100);
begin
  if (action = &#39;START&#39;) then
    nLat := sdo_sem_inference.oracle_orardf_add_res(&#39;http://www.w3.org/2003/01/geo/wgs84_pos#lat&#39;);
    nLong := sdo_sem_inference.oracle_orardf_add_res(&#39;http://www.w3.org/2003/01/geo/wgs84_pos#long&#39;);
    nWKT  := sdo_sem_inference.oracle_orardf_add_res(&#39;http://www.opengis.net/geosparql#asWKT&#39;);
    nOWKT := sdo_sem_inference.oracle_orardf_add_res(&#39;http://xmlns.oracle.com/rdf/geo/asWKT&#39;);
  end if; 
  
  if (action = &#39;RUN&#39;) then
    nStreetAddr := sdo_sem_inference.oracle_orardf_res2vid(&#39;&lt;urn:streetAddress&gt;&#39;);
    nLat := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://www.w3.org/2003/01/geo/wgs84_pos#lat&#39;);
    nLong := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://www.w3.org/2003/01/geo/wgs84_pos#long&#39;);
    nWKT  := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://www.opengis.net/geosparql#asWKT&#39;);
    nOWKT := sdo_sem_inference.oracle_orardf_res2vid(&#39;http://xmlns.oracle.com/rdf/geo/asWKT&#39;);
 
    vcStmt := &#39;
      select /*+ parallel */ distinct s1.sid as s_id, s1.oid as o_id
        from &#39; || src_tab_view || &#39; s1
       where s1.pid = :1
         and not exists ( select 1
                            from   &#39; || src_tab_view || &#39; x
                           where  x.sid = s1.sid
                             and  x.pid = :2
                        ) &#39;;
    open cursorFind for vcStmt using nStreetAddr, nLong;
    
    loop
      fetch cursorFind bulk collect into sidTab, oidTab limit 10000;
      for i in 1..sidTab.count loop 
        vcStreeAddr := sdo_sem_inference.oracle_orardf_vid2lit(oidTab(i));
        -- dbms_output.put_line(&#39;Now processing street addr &#39; || vcStreeAddr);
        geocoding(vcStreeAddr, vcLong, vcLat);
        execute immediate &#39;insert into &#39; || output_tab || &#39;(sid,pid,oid,gid,s,p,o,g)
            values(:1, :2, null, null, null, null, :3, null) &#39;
            using sidTab(i), nLong, &#39;&#34;&#39;||vcLong||&#39;&#34;&#39;;
        execute immediate &#39;insert into &#39; || output_tab || &#39;(sid,pid,oid,gid,s,p,o,g)
            values(:1, :2, null, null, null, null, :3, null) &#39;
            using sidTab(i), nLat, &#39;&#34;&#39;||vcLat||&#39;&#34;&#39;;
        execute immediate &#39;insert into &#39; || output_tab || &#39;(sid,pid,oid,gid,s,p,o,g) 
            values(:1, :2, null, null, null, null, :3, null) &#39;
            using sidTab(i), nWKT, &#39;&#34;POINT(&#39;|| vcLong || &#39; &#39; ||vcLat ||&#39;)&#34;^^&lt;http://www.opengis.net/geosparql#wktLiteral&gt;&#39;;
        execute immediate &#39;insert into &#39; || output_tab || &#39;(sid,pid,oid,gid,s,p,o,g) 
            values(:1, :2, null, null, null, null, :3, null) &#39;
            using sidTab(i), nOWKT, &#39;&#34;POINT(&#39;|| vcLong || &#39; &#39; ||vcLat ||&#39;)&#34;^^&lt;http://xmlns.oracle.com/rdf/geo/WKTLiteral&gt;&#39;;
      end loop;
      exit when cursorFind%notfound;
    end loop;   
    commit;
  end if;
  return true;
end;
/
grant execute on sem_inf_geocoding to mdsys;
</pre>
<p>The <code class="codeph">sem_inf_geocoding</code> function makes use of the following helper procedure named <code class="codeph">geocoding</code>, which does the actual HTTP communication with the Geocoder web service endpoint. Note that proper privileges are required to connect to the web server.</p>
<pre dir="ltr">create or replace procedure geocoding(addr varchar2,
                                     vcLong out varchar2,
                                     vcLat  out varchar2
                                    )
as
  httpReq  utl_http.req;
  httpResp utl_http.resp;
  
  vcRequestBody varchar2(32767);
  
  vcBuffer  varchar2(32767);
  idxLat integer;
  idxLatEnd integer;
begin
  vcRequestBody := utl_url.escape(&#39;xml_request=&lt;?xml version=&#34;1.0&#34; standalone=&#34;yes&#34;?&gt;
    &lt;geocode_request vendor=&#34;elocation&#34;&gt;
      &lt;address_list&gt; 
      &lt;input_location id=&#34;27010&#34;&gt;
      &lt;input_address match_mode=&#34;relax_street_type&#34;&gt;
        &lt;unformatted country=&#34;US&#34;&gt;
           &lt;address_line value=&#34;&#39;|| addr ||&#39;&#34;/&gt;
        &lt;/unformatted&gt;
       &lt;/input_address&gt;
      &lt;/input_location&gt;
    &lt;/address_list&gt;
    &lt;/geocode_request&gt;
  &#39;);
  dbms_output.put_line(&#39;request &#39; || vcRequestBody);
  
  -- utl_http.set_proxy(&#39;&lt;your_proxy_here_if_necessary&gt;&#39;, null);
  httpReq := utl_http.begin_request (
    &#39;http://maps.oracle.com/geocoder/gcserver&#39;, &#39;POST&#39;);
    
  utl_http.set_header(httpReq, &#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);
  utl_http.set_header(httpReq, &#39;Content-Length&#39;, lengthb(vcRequestBody));
  
  utl_http.write_text(httpReq, vcRequestBody);
  
  httpResp := utl_http.get_response(httpReq);
  
  utl_http.read_text(httpResp, vcBuffer, 32767);
  utl_http.end_response(httpResp);
  
  -- dbms_output.put_line(&#39;response &#39; || vcBuffer);
  -- Here we are doing some simple string parsing out of an XML.
  -- It is more robust to use XML functions instead.
  idxLat := instr(vcBuffer, &#39;longitude=&#34;&#39;); 
  idxLatEnd := instr(vcBuffer, &#39;&#34;&#39;, idxLat + 12);
  vcLong := substr(vcBuffer, idxLat + 11, idxLatEnd - idxLat - 11);
  dbms_output.put_line(&#39;long = &#39; || vcLong);
  
  idxLat := instr(vcBuffer, &#39;latitude=&#34;&#39;);
  idxLatEnd := instr(vcBuffer, &#39;&#34;&#39;, idxLat + 11);
  vcLat := substr(vcBuffer, idxLat + 10, idxLatEnd - idxLat - 10);
  dbms_output.put_line(&#39;lat = &#39; || vcLat);
exception
  when others then
    dbms_output.put_line(&#39;geocoding: error &#39; || dbms_utility.format_error_backtrace || &#39; &#39;
                                             || dbms_utility.format_error_stack);
end;
/
</pre></div>
</div>
</div>
</div>
<a id="RDFRM536"></a>
<div class="props_rev_3"><a id="GUID-26520C46-3A90-40AB-8403-140A82AC73CC"></a>
<h2 id="RDFRM-GUID-26520C46-3A90-40AB-8403-140A82AC73CC" class="sect2"><span class="enumeration_section">9.2</span> User-Defined Functions and Aggregates</h2>
<div>
<p>The RDF Semantic Graph query extension architecture enables you to add user-defined functions and aggregates to be used in SPARQL queries, both through the SEM_MATCH table function and through the support for Apache Jena and OpenRDF Sesame.</p>
<p>The SPARQL 1.1 Standard provides several functions used mainly for filtering and categorizing data obtained by a query. However, you may need specialized functions not supported by the standard.</p>
<p>Some simple examples include finding values that belong to a specific type, or obtaining values with a square sum value that is greater than a certain threshold. Although this can be done by means of combining functions, it may be useful to have a single function that handles the calculations, which also allows for a simpler and shorter query.</p>
<p>The RDF Semantic Graph query extension allows you to include your own query functions and aggregates. This architecture allows:</p>
<ul style="list-style-type: disc;">
<li>
<p>Custom query functions that can be used just like built-in SPARQL query functions, as explained in <a href="user-defined-inf.htm#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">API Support for User-Defined Functions</a></p>
</li>
<li>
<p>Custom aggregates that can be used just like built-in SPARQL aggregates, as explained in <a href="user-defined-inf.htm#GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE">API Support for User-Defined Aggregates</a></p>
</li>
</ul>
</div>
<a id="RDFRM413"></a>
<div class="props_rev_3"><a id="GUID-120431A3-D767-4068-B1E8-0BFC1C505200"></a>
<h3 id="RDFRM-GUID-120431A3-D767-4068-B1E8-0BFC1C505200" class="sect3"><span class="enumeration_section">9.2.1</span> Data Types for User-Defined Functions and Aggregates</h3>
<div>
<p>The SDO_RDF_TERM object type is used to represent an RDF term when creating user-defined functions and aggregates.</p>
<p>SDO_RDF_TERM has the following attributes, which correspond to columns in the MDSYS.RDF_VALUE$ table (see <a href="rdf-overview.htm#GUID-F7D6E792-CFF4-4183-AECE-3CF4A3332D9E__CHDBFGII" title="RDF_VALUE$ table columns">Table 1-3</a> in <a href="rdf-overview.htm#GUID-F7D6E792-CFF4-4183-AECE-3CF4A3332D9E">Statements</a> for a description of these attributes). The CTX1 attribute is reserved for future use and does not have a corresponding column in MDSYS.RDF_VALUE$.</p>
<pre dir="ltr">SDO_RDF_TERM(
  VALUE_TYPE   VARCHAR2(10),
  VALUE_NAME    VARCHAR2(4000), 
  VNAME_PREFIX   VARCHAR2(4000), 
  VNAME_SUFFIX   VARCHAR2(512), 
  LITERAL_TYPE   VARCHAR2(1000), 
  LANGUAGE_TYPE   VARCHAR2(80), 
  LONG_VALUE   CLOB, 
  CTX1   VARCHAR2(4000) )
</pre>
<p>The following constructors are available for creating SDO_RDF_TERM objects. The first constructor populates each attribute from a single, lexical RDF term string. The second and third constructors receive individual attribute values as input. Only the first RDF term string constructor sets values for VNAME_PREFIX and VNAME_SUFFIX. These values are initialized to null by the other constructors.</p>
<pre dir="ltr">SDO_RDF_TERM (
  rdf_term_str  VARCHAR2) 
  RETURN SELF;

SDO_RDF_TERM (
  value_type  VARCHAR2, 
  value_name  VARCHAR2, 
  literal_type  VARCHAR2, 
  language_type  VARCHAR2, 
  long_value  CLOB) 
  RETURN SELF;

SDO_RDF_TERM (
  value_type  VARCHAR2, 
  value_name  VARCHAR2, 
  literal_type  VARCHAR2, 
  language_type  VARCHAR2, 
  long_value  CLOB, 
  ctx1 VARCHAR2) 
  RETURN SELF;
</pre>
<p><a id="d52586e1852" class="indexterm-anchor"></a>The SDO_RDF_TERM_LIST type is used to hold a list of SDO_RDF_TERM objects and is defined as <code class="codeph">VARRAY(32767) of SDO_RDF_TERM</code>.</p>
</div>
</div>
<a id="RDFRM537"></a>
<div class="props_rev_3"><a id="GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F"></a>
<h3 id="RDFRM-GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F" class="sect3"><span class="enumeration_section">9.2.2</span> API Support for User-Defined Functions</h3>
<div>
<p>A user-defined function is created by implementing a PL/SQL function with a specific signature, and a specific URI is used to invoke the function in a SPARQL query pattern.</p>
<p>After each successful inference extension function call, a commit is executed to persist changes made in the inference extension function call. If an inference extension function is defined as autonomous by specifying <code class="codeph">pragma autonomous_transaction</code>, then it should either commit or roll back at the end of its implementation logic. Note that the inference engine may call an extension function multiple times when creating an entailment (once per round). Commits and rollbacks from one call will not affect other calls.</p>
</div>
<a id="RDFRM538"></a>
<div class="props_rev_3"><a id="GUID-0FD72275-EF1D-4E4A-A204-D3EAA3E25C73"></a>
<h4 id="RDFRM-GUID-0FD72275-EF1D-4E4A-A204-D3EAA3E25C73" class="sect4"><span class="enumeration_section">9.2.2.1</span> PL/SQL Function Implementation</h4>
<div>
<p>Each user-defined function must be implemented by a PL/SQL function with a signature in the following format:</p>
<pre dir="ltr">FUNCTION <span class="italic">user_function_name</span> (params IN SDO_RDF_TERM_LIST)
  RETURN SDO_RDF_TERM
</pre>
<p>This signature supports an arbitrary number of RDF term arguments, which are passed in using a single SDO_RDF_TERM_LIST object, and returns a single RDF term as output, which is represented as a single SDO_RDF_TERM object. Type checking or other verifications for these parameters are not performed. You should take steps to validate the data according to the function goals.</p>
<p>Note that PL/SQL supports callouts to functions written in other programming languages, such as C and Java, so the PL/SQL function that implements a user-defined query function can serve only as a wrapper for functions written in other programming languages.</p>
</div>
</div>
<a id="RDFRM539"></a>
<div class="props_rev_3"><a id="GUID-11A4BB0A-F723-4D1A-8FD5-BCC2CF6F2AFF"></a>
<h4 id="RDFRM-GUID-11A4BB0A-F723-4D1A-8FD5-BCC2CF6F2AFF" class="sect4"><span class="enumeration_section">9.2.2.2</span> Invoking User-Defined Functions from a SPARQL Query Pattern</h4>
<div>
<p>After a user-defined function is implemented in PL/SQL, it can be invoked from a SPARQL query pattern using a function URI constructed from the prefix <code class="codeph">&lt;http://xmlns.oracle.com/rdf/extensions/&gt;</code> followed by <span class="italic"><code class="codeph">schema.package_name.function_name</code></span> if the corresponding PL/SQL function is part of a PL/SQL package, or <span class="italic"><code class="codeph">schema.function_name</code></span> if the function is not part of a PL/SQL package. The following are two example function URIs:</p>
<pre dir="ltr">&lt;http://xmlns.oracle.com/rdf/extensions/my_schema.my_package.my_function&gt;(arg_1, &hellip;, arg_n)

&lt;http://xmlns.oracle.com/rdf/extensions/my_schema.my_function&gt;(arg_1, &hellip;, arg_n)
</pre></div>
</div>
<a id="RDFRM541"></a><a id="RDFRM542"></a><a id="RDFRM543"></a><a id="RDFRM544"></a><a id="RDFRM540"></a>
<div class="props_rev_3"><a id="GUID-87FC6170-3247-4926-B981-EC2672904845"></a>
<h4 id="RDFRM-GUID-87FC6170-3247-4926-B981-EC2672904845" class="sect4"><span class="enumeration_section">9.2.2.3</span> User-Defined Function Examples</h4>
<div>
<p>This section presents examples of the implementation of a user-defined function and the use of that function in a FILTER clause, in a SELECT expression, and in a BIND operation.</p>
<p>For the examples, assume that the following data, presented here in N-triple format, exists inside a model called <code class="codeph">MYMODEL</code>:</p>
<pre dir="ltr">&lt;a&gt;  &lt;p&gt;  &#34;1.0&#34;^^xsd:double .
&lt;b&gt;  &lt;p&gt;  &#34;1.5&#34;^^xsd:float .
&lt;c&gt;  &lt;p&gt;  &#34;3&#34;^^xsd:decimal .
&lt;d&gt;  &lt;p&gt;  &#34;4&#34;^^xsd:string .
</pre>
<div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">
<p class="titleinexample">Example 9-1 User-Defined Function to Calculate Sum of Two Squares</p>
<p><a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">Example 9-1</a> shows the implementation of a simple function that receives two values and calculates the sum of the squares of each value.</p>
<pre dir="ltr">CREATE OR REPLACE FUNCTION sum_squares (params IN MDSYS.SDO_RDF_TERM_LIST) 
   RETURN MDSYS.SDO_RDF_TERM
   AS 
     retTerm    SDO_RDF_TERM;
     sqr1       NUMBER;
     sqr2       NUMBER;
     addVal     NUMBER;
     val1       SDO_RDF_TERM;
     val2       SDO_RDF_TERM;
   BEGIN 
     &ndash;- Set the return value to null.
     retTerm := SDO_RDF_TERM(NULL,NULL,NULL,NULL,NULL);
     &ndash;- Obtain the data from the first two parameters.
     val1 := params(1); 
     val2 := params(2);
     &ndash;- Convert the value stored in the sdo_rdf_term to number.
     &ndash;- If any exception occurs, return the null value.
     BEGIN
       sqr1 := TO_NUMBER(val1.value_name);
       sqr2 := TO_NUMBER(val2.value_name);
       EXCEPTION WHEN OTHERS THEN RETURN retTerm;
     END;
     &ndash;- Compute the square sum of both values.
       addVal := (sqr1 * sqr1) + (sqr2 * sqr2);
     &ndash;- Set the return value to the desired rdf term type.
     retTerm := SDO_RDF_TERM(&#39;LIT&#39;,to_char(addVal),
                &#39;http://www.w3.org/2001/XMLSchema#integer&#39;,&#39;&#39;,NULL);
     &ndash; Return the new value.
     RETURN retTerm;
END;
/
SHOW ERRORS;
</pre>
<p>Note that the <code class="codeph">sum_squares</code> function in <a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">Example 9-1</a> does not verify the data type of the value received. It is intended as a demonstration only, and relies on TO_NUMBER to obtain the numeric value stored in the VALUE_NAME field of SDO_RDF_TERM.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDBDIAE">
<p class="titleinexample">Example 9-2 User-Defined Function Used in a FILTER Clause</p>
<p><a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDBDIAE">Example 9-2</a> shows the <code class="codeph">sum_squares</code> function (from <a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">Example 9-1</a>) used in a FILTER clause.</p>
<pre dir="ltr">SELECT s, o
FROM table(sem_match(
&#39;SELECT  ?s ?o
 WHERE { ?s ?p ?o 
 <span class="bold">FILTER (&lt;http://xmlns.oracle.com/rdf/extensions/schema.sum_squares&gt;(?o,?o) &gt; 2)}&#39;</span>,
sem_models(&#39;MYMODEL&#39;),null,null,null,null,&#39;&#39;));
</pre>
<p>The query in <a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDBDIAE">Example 9-2</a> returns the following result:</p>
<pre dir="ltr">s                    o                    
-------------------- -------------------- 
b                    1.5
c                    3                  
d                    4
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDECBEC">
<p class="titleinexample">Example 9-3 User-Defined Function Used in a SELECT Expression</p>
<p><a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDECBEC">Example 9-3</a> shows the <code class="codeph">sum_squares</code> function (from <a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">Example 9-1</a>) used in an expression in the SELECT clause.</p>
<pre dir="ltr">SELECT s, o, sqr_sum
FROM table(sem_match(
&#39;SELECT  ?s ?o 
       <span class="bold">(&lt;http://xmlns.oracle.com/rdf/extensions/schema.sum_squares&gt;(?o,?o) AS</span>    
        <span class="bold">?sqr_sum)</span>
 WHERE { ?s ?p ?o }&#39;,
sem_models(&#39;MYMODEL&#39;),null,null,null,null,&#39;&#39;));
</pre>
<p>The query in <a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDECBEC">Example 9-3</a> returns the following result:</p>
<pre dir="ltr">s                    o                    sqr_sum
-------------------- -------------------- -------------------- 
a                    1                    2
b                    1.5                  4.5
c                    3                    18
d                    4                    32
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDHIJBD">
<p class="titleinexample">Example 9-4 User-Defined Function Used in a BIND Operation</p>
<p><a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDHIJBD">Example 9-4</a> shows the <code class="codeph">sum_squares</code> function (from <a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">Example 9-1</a>) used in a BIND operation.</p>
<pre dir="ltr">SELECT s, o, sqr_sum
FROM table(sem_match(
&#39;SELECT  ?s ?o ?sqr_sum
 WHERE { ?s ?p ?o .
 <span class="bold">BIND (&lt;http://xmlns.oracle.com/rdf/extensions/schema.sum_squares&gt;(?o,?o) AS</span>
       <span class="bold">?sqr_sum)}&#39;</span>,
sem_models(&#39;MYMODEL&#39;),null,null,null,null,&#39;&#39;));
</pre>
<p>The query in <a href="user-defined-inf.htm#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDHIJBD">Example 9-4</a> returns the following result:</p>
<pre dir="ltr">s                    o                    sqr_sum
-------------------- -------------------- -------------------- 
a                    1                    2
b                    1.5                  4.5
c                    3                    18
d                    4                    32
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="RDFRM545"></a>
<div class="props_rev_3"><a id="GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE"></a>
<h3 id="RDFRM-GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE" class="sect3"><span class="enumeration_section">9.2.3</span> API Support for User-Defined Aggregates</h3>
<div>
<p>User-defined aggregates are implemented by defining a PL/SQL object type that implements a set of interface methods. After the user-defined aggregate is created, a specific URI is used to invoke it.</p>
</div>
<a id="RDFRM546"></a>
<div class="props_rev_3"><a id="GUID-842124C0-686B-447A-9B69-63DB8F13D8AE"></a>
<h4 id="RDFRM-GUID-842124C0-686B-447A-9B69-63DB8F13D8AE" class="sect4"><span class="enumeration_section">9.2.3.1</span> ODCIAggregate Interface</h4>
<div>
<p>User-defined aggregates use the <code class="codeph">ODCIAggregate</code> PL/SQL interface. For more detailed information about this interface, see the chapter about user-defined aggregate functions in <a class="olink ADDCI2120" target="_blank" href="../ADDCI/aggr_functions.htm#ADDCI2120"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a>.</p>
<p>The <code class="codeph">ODCIAggregate</code> interface is implemented by a PL/SQL object type that implements four main functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">ODCIAggregateInitialize</code></p>
</li>
<li>
<p><code class="codeph">ODCIAggregateIterate</code></p>
</li>
<li>
<p><code class="codeph">ODCIAggregateMerge</code></p>
</li>
<li>
<p><code class="codeph">ODCIAggregateTerminate</code></p>
</li>
</ul>
<p>As with user-defined functions (described in <a href="user-defined-inf.htm#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">API Support for User-Defined Functions</a>), user-defined aggregates receive an arbitrary number of RDF term arguments, which are passed in as an SDO_RDF_TERM_LIST object, and return a single RDF term value, which is represented as an SDO_RDF_TERM object.</p>
<p>This scheme results in the following signatures for the PL/SQL <code class="codeph">ODCIAggregate</code> interface functions (with <span class="italic">my_aggregate_obj_type</span> representing the actual object type name):</p>
<pre dir="ltr">STATIC FUNCTION ODCIAggregateInitialize(
        sctx IN OUT <span class="italic">my_aggregate_obj_type</span>)
RETURN NUMBER
 
MEMBER FUNCTION ODCIAggregateIterate(
        self       IN OUT <span class="italic">my_aggregate_obj_type</span>
       ,value      IN MDSYS.SDO_RDF_TERM_LIST)
RETURN NUMBER
 
MEMBER FUNCTION ODCIAggregateMerge(
        self IN OUT <span class="italic">my_aggregate_obj_type</span>
       ,ctx2 IN     <span class="italic">my_aggregate_obj_type</span>)
RETURN NUMBER
 
MEMBER FUNCTION ODCIAggregateTerminate (
        self IN <span class="italic">my_aggregate_obj_type</span>
       ,return_value OUT MDSYS.SDO_RDF_TERM
       ,flags IN NUMBER)              
RETURN NUMBER
</pre></div>
</div>
<a id="RDFRM547"></a>
<div class="props_rev_3"><a id="GUID-9AF96B10-4D81-4CB8-8FB4-D4FAB29D553A"></a>
<h4 id="RDFRM-GUID-9AF96B10-4D81-4CB8-8FB4-D4FAB29D553A" class="sect4"><span class="enumeration_section">9.2.3.2</span> Invoking User-Defined Aggregates</h4>
<div>
<p>After a user-defined aggregate is implemented in PL/SQL, it can be invoked from a SPARQL query by referring to an aggregate URI constructed from the prefix <code class="codeph">&lt;http://xmlns.oracle.com/rdf/aggExtensions/&gt;</code> followed by <span class="italic"><code class="codeph">schema_name.aggregate_name</code></span>. The following is an example aggregate URI:</p>
<pre dir="ltr">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.my_aggregate&gt;(arg_1, &hellip;, arg_n)
</pre>
<p>The DISTINCT modifier can be used with user-defined aggregates, as in the following example:</p>
<pre dir="ltr">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.my_aggregate&gt;(DISTINCT arg_1)
</pre>
<p>In this case, only distinct argument values are passed to the aggregate. Note, however, that the DISTINCT modifier can only be used with aggregates that have exactly one argument.</p>
</div>
</div>
<a id="RDFRM549"></a><a id="RDFRM553"></a><a id="RDFRM554"></a><a id="RDFRM548"></a>
<div class="props_rev_3"><a id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A"></a>
<h4 id="RDFRM-GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A" class="sect4"><span class="enumeration_section">9.2.3.3</span> User-Defined Aggregate Examples</h4>
<div>
<p>This section presents examples of implementing and using a user-defined aggregate. For the examples, assume that the following data, presented here in N-triple format, exists inside a model called <code class="codeph">MYMODEL</code>:</p>
<pre dir="ltr">&lt;a&gt;  &lt;p&gt;  &#34;1.0&#34;^^xsd:double .
&lt;b&gt;  &lt;p&gt;  &#34;1.5&#34;^^xsd:float .
&lt;c&gt;  &lt;p&gt;  &#34;3&#34;^^xsd:decimal .
&lt;c&gt;  &lt;p&gt;  &#34;4&#34;^^xsd:decimal .
&lt;d&gt;  &lt;p&gt;  &#34;4&#34;^^xsd:string .
</pre>
<div class="example" id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">
<p class="titleinexample">Example 9-5 User-Defined Aggregate Implementation</p>
<p><a href="user-defined-inf.htm#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">Example 9-5</a> shows the implementation of a simple user-defined aggregate (<code class="codeph">countSameType</code>). This aggregate has two arguments: the first is any RDF term, and the second is a constant data type URI. The aggregate counts how many RDF terms from the first argument position have a data type equal to the second argument.</p>
<pre dir="ltr">-- Aggregate type creation
CREATE OR REPLACE TYPE countSameType authid current_user AS OBJECT(
 
count NUMBER, &ndash;- Variable to store the number of same-type terms.
 
&ndash;- Mandatory Functions for aggregates 
STATIC FUNCTION ODCIAggregateInitialize(
        sctx IN OUT countSameType)
RETURN NUMBER,
 
MEMBER FUNCTION ODCIAggregateIterate(
         self       IN OUT countSameType
       , value      IN MDSYS.SDO_RDF_TERM_LIST)
RETURN NUMBER,
 
MEMBER FUNCTION ODCIAggregateMerge(
        self IN OUT countSameType
       ,ctx2 IN     countSameType)
RETURN NUMBER,
 
MEMBER FUNCTION ODCIAggregateTerminate (
        self IN countSameType
       ,return_value OUT MDSYS.SDO_RDF_TERM
       ,flags IN NUMBER)              
RETURN NUMBER
);
/
SHOW ERRORS;
 
&ndash;- Interface function for the user-defined aggregate
CREATE OR REPLACE FUNCTION countSameAs (input MDSYS.SDO_RDF_TERM_LIST) RETURN MDSYS.SDO_RDF_TERM
PARALLEL_ENABLE AGGREGATE USING countSameType;
/
show errors;
 
&ndash;- User-defined aggregate body
CREATE OR REPLACE TYPE BODY countSameType IS
 
STATIC FUNCTION ODCIAggregateInitialize(
         sctx            IN OUT countSameType)
RETURN NUMBER IS
BEGIN
  sctx := countSameType (0); &ndash;- Aggregate initialization
  RETURN ODCIConst.Success;
END;
 
MEMBER FUNCTION ODCIAggregateIterate(
         self           IN OUT countSameType
       , value          IN MDSYS.SDO_RDF_TERM_LIST )
RETURN NUMBER IS
BEGIN
  -- Increment count if the first argument has a literal type
  -- URI equal to the value of the second argument
  IF (value(1).literal_type = value(2).value_name) THEN
    self.count := self.count + 1;
  END IF;                                    
  RETURN ODCIConst.Success;
END;   
 
MEMBER FUNCTION ODCIAggregateMerge(
         self            IN OUT countSameType
        ,ctx2            IN countSameType)
RETURN NUMBER IS
BEGIN
  &ndash;- Sum count to merge parallel threads.
  self.count := self.count + ctx2.count;   
  RETURN ODCIConst.Success;
END;
 
MEMBER FUNCTION ODCIAggregateTerminate(
         self            IN countSameType
        ,return_value    OUT MDSYS.SDO_RDF_TERM
        ,flags           IN NUMBER)              
RETURN NUMBER IS
BEGIN
   -- Set the return value
   return_value := MDSYS.SDO_RDF_TERM(&#39;LIT&#39;,to_char(self.count),
     &#39;http://www.w3.org/2001/XMLSchema#decimal&#39;,NULL,NULL); RETURN  ODCIConst.Success;
END;
 
END;
/
SHOW ERRORS;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDIAJJI">
<p class="titleinexample">Example 9-6 User-Defined Aggregate Used Without a GROUP BY Clause</p>
<p><a href="user-defined-inf.htm#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDIAJJI">Example 9-6</a> shows the <code class="codeph">countSameType</code> aggregate (from <a href="user-defined-inf.htm#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">Example 9-5</a>) used over an entire query result group.</p>
<pre dir="ltr">FROM o
from table(sem_match(
&#39;SELECT 
 (<span class="bold">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.countSameType&gt;(?o,xsd:decimal)</span> 
  AS ?o)
 WHERE { ?s ?p ?o }&#39;,
sem_models(&#39;MYMODEL&#39;),null,null,null,null,&#39;&#39;));
</pre>
<p>The query in <a href="user-defined-inf.htm#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDIAJJI">Example 9-6</a> returns the following result:</p>
<pre dir="ltr">o                    
-------------------- 
2                    
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDHFBHJ">
<p class="titleinexample">Example 9-7 User-Defined Aggregate Used With a GROUP BY Clause</p>
<p><a href="user-defined-inf.htm#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDHFBHJ">Example 9-7</a> shows the <code class="codeph">countSameType</code> aggregate (from <a href="user-defined-inf.htm#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">Example 9-5</a>) used over a set of groups formed from a GROUP BY clause.</p>
<pre dir="ltr">select s, o
from table(sem_match(
&#39;SELECT ?s
 (<span class="bold">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.countSameType&gt;(?o,xsd:decimal)</span> 
  AS ?o)
 WHERE { ?s ?p ?o } <span class="bold">GROUP BY ?s&#39;</span>,
sem_models(&#39;MYMODEL&#39;),null,null,null,null,&#39;&#39;));
</pre>
<p>The query in <a href="user-defined-inf.htm#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDHFBHJ">Example 9-7</a> returns the following result:</p>
<pre dir="ltr">s                    o                    
-------------------- -------------------- 
a                    0
b                    0
c                    2                    
d                    0
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4500">
<tr>
<td class="cellalignment4507">
<table class="cellalignment4505">
<tr>
<td class="cellalignment4504"><a href="rdf-sesame.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4504"><a href="rdf-views.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4509">
<table class="cellalignment4503">
<tr>
<td class="cellalignment4504"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4504"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4504"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4504"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4504"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4504"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>