<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-133"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Data%20Interface%20for%20Persistent%20LOBs"></a><title>Data Interface for Persistent LOBs</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="INSERT statements, binds of greater than 4000 bytes, UPDATE statements, binds of greater than 4000 bytes, binds, See also INSERT statements and UPDATE statements, restrictions, binds of more than 4000 bytes, parallel DML support, data interface for persistent LOBs, multibyte charactersets, charactersets, multibyte, LONG and LOB datatypes, multibyte character sets, using with the data interface for LOBs, LOBs, data interface in Java, data interface in Java, LOBs, data interface for remote, data interface for remote LOBs"/>
<meta name="dcterms.created" content="2017-03-16T22:27:47Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SecureFiles and Large Objects Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17605-12"/>
<meta name="dcterms.isVersionOf" content="ADLOB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2015, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="adlob_creating.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adlob_bfile_ops.htm" title="Next" type="text/html"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-4BFDD493-F3FE-451C-9B03-21669D635586"></a> <span id="PAGE" style="display:none;">29/34</span> <!-- End Header -->
<a id="ADLOB1300"></a>
<h1 id="ADLOB-GUID-4BFDD493-F3FE-451C-9B03-21669D635586" class="sect1"><span class="enumeration_chapter">20</span> Data Interface for Persistent LOBs</h1>
<div>
<p><a id="d75409e61" class="indexterm-anchor"></a>Data interface is a generic term referring to whichever interface is in use, to query the database or to update the database.</p>
<p>Topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC">Overview of the Data Interface for Persistent LOBs</a></p>
</li>
<li>
<p><a href="adlob_data_interface.htm#GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F">Benefits of Using the Data Interface for Persistent LOBs</a></p>
</li>
<li>
<p><a href="adlob_data_interface.htm#GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3">Using the Data Interface for Persistent LOBs in PL/SQL</a></p>
</li>
<li>
<p><a href="adlob_data_interface.htm#GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26">The Data Interface Used for Persistent LOBs in OCI</a></p>
</li>
<li>
<p><a href="adlob_data_interface.htm#GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339">The Data Interface Used with Persistent LOBs in Java</a></p>
</li>
<li>
<p><a href="adlob_data_interface.htm#GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB">The Data Interface Used with Remote LOBs</a></p>
</li>
</ul>
</div>
<a id="ADLOB45643"></a><a id="ADLOB45644"></a><a id="ADLOB45642"></a>
<div class="props_rev_3"><a id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC"></a>
<h2 id="ADLOB-GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC" class="sect2">Overview of the Data Interface for Persistent LOBs</h2>
<div>
<p>The data interface for persistent LOBs includes a set of Java, PL/SQL, and OCI APIs that are extended to work with LOB data types.</p>
<p>These APIs, originally designed for use with legacy data types such as <code class="codeph">LONG</code>, <code class="codeph">LONG</code> <code class="codeph">RAW</code>, and <code class="codeph">VARCHAR2</code>, can also be used with the corresponding LOB data types shown in <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="This table is described in the preceding text">Table 20-1</a> and <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="This table is described in the preceding text">Table 20-2</a>. These tables show the legacy data types in the <span class="italic">bind or define type</span> column and the corresponding supported LOB data type in the <span class="italic">LOB column type</span> column. You can use the data interface for LOBs to store and manipulate character data and binary data in a LOB column just as if it were stored in the corresponding legacy data type.</p>
<div class="infobox-note" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__GUID-0960EE0F-D2C1-44AC-83DA-9593491DD1DC">
<p class="notep1">Note:</p>
<p>The data interface works for LOB columns and LOBs that are attributes of objects. In this chapter <span class="italic">LOB columns</span> means LOB columns and LOB attributes.</p>
<p>You can use array bind and define interfaces to insert and select multiple rows in one round-trip.</p>
</div>
<p>While most of this discussion focuses on character data types, the same concepts apply to the full set of character and binary data types listed in <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="This table is described in the preceding text">Table 20-1</a> and <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="This table is described in the preceding text">Table 20-2</a>. <code class="codeph">CLOB</code> also means <code class="codeph">NCLOB</code> in these tables.</p>
<div class="tblformal" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364">
<p class="titleintable">Table 20-1 Corresponding LONG and LOB Data Types in SQL and PL/SQL</p>
<table class="cellalignment2789" title="Corresponding LONG and LOB Data Types in SQL and PL/SQL" summary="This table is described in the preceding text">
<thead>
<tr class="cellalignment2783">
<th class="cellalignment2838" id="d75409e231">Bind or Define Type</th>
<th class="cellalignment2838" id="d75409e234">LOB Column Type</th>
<th class="cellalignment2838" id="d75409e237">Used For Storing</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e242" headers="d75409e231">
<p><code class="codeph">CHAR</code></p>
</td>
<td class="cellalignment2839" headers="d75409e242 d75409e234">
<p><code class="codeph">CLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e242 d75409e237">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e254" headers="d75409e231">
<p><code class="codeph">LONG</code></p>
</td>
<td class="cellalignment2839" headers="d75409e254 d75409e234">
<p><code class="codeph">CLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e254 d75409e237">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e266" headers="d75409e231">
<p><code class="codeph">VARCHAR2</code></p>
</td>
<td class="cellalignment2839" headers="d75409e266 d75409e234">
<p><code class="codeph">CLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e266 d75409e237">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e278" headers="d75409e231">
<p><code class="codeph">LONG RAW</code></p>
</td>
<td class="cellalignment2839" headers="d75409e278 d75409e234">
<p><code class="codeph">BLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e278 d75409e237">
<p>Binary data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e290" headers="d75409e231">
<p><code class="codeph">RAW</code></p>
</td>
<td class="cellalignment2839" headers="d75409e290 d75409e234">
<p><code class="codeph">BLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e290 d75409e237">
<p>Binary data</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="tblformal" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324">
<p class="titleintable">Table 20-2 Corresponding LONG and LOB Data Types in OCI</p>
<table class="cellalignment2789" title="Corresponding LONG and LOB Data Types in OCI" summary="This table is described in the preceding text">
<thead>
<tr class="cellalignment2783">
<th class="cellalignment2838" id="d75409e312">Bind or Define Type</th>
<th class="cellalignment2838" id="d75409e315">LOB Column Type</th>
<th class="cellalignment2838" id="d75409e318">Used For Storing</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e323" headers="d75409e312">
<p><code class="codeph">SQLT_AFC(n)</code></p>
</td>
<td class="cellalignment2839" headers="d75409e323 d75409e315">
<p><code class="codeph">CLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e323 d75409e318">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e335" headers="d75409e312">
<p><code class="codeph">SQLT_CHR</code></p>
</td>
<td class="cellalignment2839" headers="d75409e335 d75409e315">
<p><code class="codeph">CLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e335 d75409e318">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e347" headers="d75409e312">
<p><code class="codeph">SQLT_LNG</code></p>
</td>
<td class="cellalignment2839" headers="d75409e347 d75409e315">
<p><code class="codeph">CLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e347 d75409e318">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e359" headers="d75409e312">
<p><code class="codeph">SQLT_VCS</code></p>
</td>
<td class="cellalignment2839" headers="d75409e359 d75409e315">
<p><code class="codeph">CLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e359 d75409e318">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e371" headers="d75409e312">
<p><code class="codeph">SQLT_BIN</code></p>
</td>
<td class="cellalignment2839" headers="d75409e371 d75409e315">
<p><code class="codeph">BLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e371 d75409e318">
<p>Binary data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e383" headers="d75409e312">
<p><code class="codeph">SQLT_LBI</code></p>
</td>
<td class="cellalignment2839" headers="d75409e383 d75409e315">
<p><code class="codeph">BLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e383 d75409e318">
<p>Binary data</p>
</td>
</tr>
<tr class="cellalignment2783">
<td class="cellalignment2839" id="d75409e395" headers="d75409e312">
<p><code class="codeph">SQLT_LVB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e395 d75409e315">
<p><code class="codeph">BLOB</code></p>
</td>
<td class="cellalignment2839" headers="d75409e395 d75409e318">
<p>Binary data</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADLOB45645"></a>
<div class="props_rev_3"><a id="GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F"></a>
<h2 id="ADLOB-GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F" class="sect2">Benefits of Using the Data Interface for Persistent LOBs</h2>
<div>
<p>Using the data interface for persistent LOBs has the following benefits:</p>
<ul style="list-style-type: disc;">
<li>
<p>If your application uses <code class="codeph">LONG</code> data types, then you can use the same application with LOB data types with little or no modification of your existing application required. To do so, just convert <code class="codeph">LONG</code> audiotape columns in your tables to LOB audiotape columns as discussed in <a href="adlob_long_lob.htm#GUID-C6FC4583-4E71-4BDA-97CB-709EBC707773">Migrating Columns from LONGs to LOBs</a>.</p>
</li>
<li>
<p>Performance is better for OCI applications that use sequential access techniques. A piecewise <code class="codeph">INSERT</code> or fetch using the data interface has comparable performance to using OCI functions like <code class="codeph">OCILobRead2()</code> and <code class="codeph">OCILobWrite2()</code>. Because the data interface allows more than 4K bytes of data to be inserted into a LOB in a single OCI call, a round-trip to the server is saved.</p>
</li>
<li>
<p>You can read LOB data in one <code class="codeph">OCIStmtFetch()</code> call, instead of fetching the LOB locator first and then calling <code class="codeph">OCILobRead2()</code>. This improves performance when you want to read LOB data starting at the beginning.</p>
</li>
<li>
<p>You can use array bind and define interfaces to insert and select multiple rows with LOBs in one round trip.</p>
</li>
</ul>
</div>
</div>
<a id="ADLOB45646"></a>
<div class="props_rev_3"><a id="GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3"></a>
<h2 id="ADLOB-GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3" class="sect2">Using the Data Interface for Persistent LOBs in PL/SQL</h2>
<div>
<p>The data interface enables you to use <code class="codeph">LONG</code> and LOB data types listed in <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="This table is described in the preceding text">Table 20-1</a> to perform the following operations in PL/SQL:</p>
</div>
<div class="props_rev_3"><a id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068"></a>
<h3 id="ADLOB-GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068" class="sect3">About Using the Data Interface for Persistent LOBs in PL/SQL</h3>
<div>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> character data stored in datatypes such as <code class="codeph">VARCHAR2</code>, <code class="codeph">CHAR</code>, or <code class="codeph">LONG</code> into a <code class="codeph">CLOB</code> column.</p>
</li>
<li>
<p><code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> binary data stored in datatypes such as <code class="codeph">RAW</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> into a <code class="codeph">BLOB</code> column.</p>
</li>
<li>
<p>Use the <code class="codeph">SELECT</code> statement on <code class="codeph">CLOB</code> columns to select data into a character buffer variable such as <code class="codeph">CHAR</code>, <code class="codeph">LONG</code>, or <code class="codeph">VARCHAR2</code>.</p>
</li>
<li>
<p>Use the <code class="codeph">SELECT</code> statement on <code class="codeph">BLOB</code> columns to select data into a binary buffer variable such as <code class="codeph">RAW</code> and <code class="codeph">LONG</code> <code class="codeph">RAW</code>.</p>
</li>
<li>
<p>Make cross-type assignments (implicit type conversions) between <code class="codeph">CLOB</code> and <code class="codeph">VARCHAR2</code>, <code class="codeph">CHAR</code>, or <code class="codeph">LONG</code> variables.</p>
</li>
<li>
<p>Make cross-type assignments (implicit type conversions) between <code class="codeph">BLOB</code> and <code class="codeph">RAW</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> variables.</p>
</li>
<li>
<p>Pass LOB datatypes to functions defined to accept <code class="codeph">LONG</code> datatypes or pass <code class="codeph">LONG</code> datatypes to functions defined to accept LOB datatypes. For example, you can pass a <code class="codeph">CLOB</code> instance to a function defined to accept another character type, such as <code class="codeph">VARCHAR2</code>, <code class="codeph">CHAR</code>, or <code class="codeph">LONG</code>.</p>
</li>
<li>
<p>Use <code class="codeph">CLOB</code>s with other PL/SQL functions and operators that accept <code class="codeph">VARCHAR2</code> arguments such as <code class="codeph">INSTR</code> and <code class="codeph">SUBSTR</code>. See <span class="q">&#34;<a href="adlob_data_interface.htm#GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60">Passing CLOBs to SQL and PL/SQL Built-In Functions</a>&#34;</span> for a complete list.</p>
<div class="infobox-note" id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068__GUID-B2A1391C-F028-4EF5-9C13-38A92A7E7713">
<p class="notep1">Note:</p>
<p>When using the data interface for LOBs with the <code class="codeph">SELECT</code> statement in PL/SQL, you cannot specify the amount you want to read. You can only specify the buffer length of your buffer. If your buffer length is smaller than the LOB data length, then the database throws an exception.</p>
</div>
<div class="infoboxnotealso" id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068__GUID-A1D4A9EE-3785-4DDA-BBC7-55A2511AFDE8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="adlob_sql_semantics.htm#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="Various SQL semantics are supported for LOBs.">SQL Semantics and LOBs</a> for details on LOB support in SQL statements</p>
</li>
<li>
<p><span class="q">&#34;<a href="adlob_long_lob.htm#GUID-97D40D64-B271-45F3-96F6-AD1D20B478A9">Some Implicit Conversions Are Not Supported for LOB Data Types</a>&#34;</span></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<a id="ADLOB45647"></a>
<div class="props_rev_3"><a id="GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F"></a>
<h3 id="ADLOB-GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F" class="sect3">Guidelines for Accessing LOB Columns Using the Data Interface in SQL and PL/SQL</h3>
<div>
<p>This section describes techniques you use to access LOB columns or attributes using the data interface for persistent LOBs.</p>
<p>Data from <code class="codeph">CLOB</code> and <code class="codeph">BLOB</code> columns or attributes can be referenced by regular SQL statements, such as <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">SELECT</code>.</p>
<p>There is no piecewise <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or fetch routine in PL/SQL. Therefore, the amount of data that can be accessed from a LOB column or attribute is limited by the maximum character buffer size. PL/SQL supports character buffer sizes up to 32KB - 1 (32767 bytes). For this reason, only LOBs less than 32K bytes in size can be accessed by PL/SQL applications using the data interface for persistent LOBs.</p>
<p>If you must access more than 32KB -1 using the data interface, then you must make OCI calls from the PL/SQL code to use the APIs for piece-wise insert and fetch.</p>
<p>Use the following guidelines for using the data interface to access LOB columns or attributes:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">INSERT</code> operations</p>
<p>You can <code class="codeph">INSERT</code> into tables containing LOB columns or attributes using regular <code class="codeph">INSERT</code> statements in the <code class="codeph">VALUES</code> clause. The field of the LOB column can be a literal, a character datatype, a binary datatype, or a LOB locator.</p>
</li>
<li>
<p><code class="codeph">UPDATE</code> operations</p>
<p>LOB columns or attributes can be updated as a whole by <code class="codeph">UPDATE</code>... <code class="codeph">SET</code> statements. In the <code class="codeph">SET</code> clause, the new value can be a literal, a character datatype, a binary datatype, or a LOB locator.</p>
</li>
<li>
<p>4000 byte limit on hexadecimal to raw and raw to hexadecimal conversions</p>
<p>The database does not do implicit hexadecimal to <code class="codeph">RAW</code> or <code class="codeph">RAW</code> to hexadecimal conversions on data that is more than 4000 bytes in size. You cannot bind a buffer of character data to a binary datatype column, and you cannot bind a buffer of binary data to a character datatype column if the buffer is over 4000 bytes in size. Attempting to do so results in your column data being truncated at 4000 bytes.</p>
<p>For example, you cannot bind a <code class="codeph">VARCHAR2</code> buffer to a <code class="codeph">LONG</code> <code class="codeph">RAW</code> or a <code class="codeph">BLOB</code> column if the buffer is more than 4000 bytes in size. Similarly, you cannot bind a <code class="codeph">RAW</code> buffer to a <code class="codeph">LONG</code> or a <code class="codeph">CLOB</code> column if the buffer is more than 4000 bytes in size.</p>
</li>
<li>
<p><code class="codeph">SELECT</code> operations</p>
<p>LOB columns or attributes can be selected into character or binary buffers in PL/SQL. If the LOB column or attribute is longer than the buffer size, then an exception is raised without filling the buffer with any data. LOB columns or attributes can also be selected into LOB locators.</p>
</li>
</ul>
</div>
</div>
<a id="ADLOB45648"></a>
<div class="props_rev_3"><a id="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30"></a>
<h3 id="ADLOB-GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30" class="sect3">Implicit Assignment and Parameter Passing</h3>
<div>
<p><a id="d75409e1048" class="indexterm-anchor"></a>Implicit assignment and parameter passing are supported for LOB columns.</p>
<p>For the data types listed in <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="This table is described in the preceding text">Table 20-1</a> and <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="This table is described in the preceding text">Table 20-2</a>, you can pass or assign: any character type to any other character type, or any binary type to any other binary type using the data interface for persistent LOBs.</p>
<p>Implicit assignment works for variables declared explicitly and for variables declared by referencing an existing column type using the <code class="codeph">%TYPE</code> attribute as show in the following example. This example assumes that column <code class="codeph">long_col</code> in table <code class="codeph">t</code> has been migrated from a <code class="codeph">LONG</code> to a <code class="codeph">CLOB</code> column.</p>
<pre dir="ltr">CREATE TABLE t (long_col LONG); -- Alter this table to change LONG column to LOB
DECLARE
   a VARCHAR2(100);
   b t.long_col%type; -- This variable changes from LONG to CLOB
BEGIN
   SELECT * INTO b FROM t;
   a := b;  -- This changes from &#34;VARCHAR2 := LONG to VARCHAR2 := CLOB
   b := a;  -- This changes from &#34;LONG := VARCHAR2 to CLOB := VARCHAR2 
END;
</pre>
<p>Implicit parameter passing is allowed between functions and procedures. For example, you can pass a <code class="codeph">CLOB</code> to a function or procedure where the formal parameter is defined as a <code class="codeph">VARCHAR2</code>.</p>
<div class="infobox-note" id="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30__GUID-15CEBD8A-E573-4DF7-B10C-2AA19CCDE46D">
<p class="notep1">Note:</p>
<p>The assigning a <code class="codeph">VARCHAR2</code> buffer to a LOB variable is somewhat less efficient than assigning a <code class="codeph">VARCHAR2</code> to a <code class="codeph">LONG</code> variable because the former involves creating a temporary LOB. Therefore, PL/SQL users experience a slight deterioration in the performance of their applications.</p>
</div>
</div>
</div>
<a id="ADLOB45649"></a>
<div class="props_rev_3"><a id="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60"></a>
<h3 id="ADLOB-GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60" class="sect3">Passing CLOBs to SQL and PL/SQL Built-In Functions</h3>
<div>
<p>Implicit parameter passing is also supported for built-in PL/SQL functions that accept character data. For example, <code class="codeph">INSTR</code> can accept a <code class="codeph">CLOB</code> and other character data.</p>
<p>Any SQL or PL/SQL built-in function that accepts a <code class="codeph">VARCHAR2</code> can accept a <code class="codeph">CLOB</code> as an argument. Similarly, a <code class="codeph">VARCHAR2</code> variable can be passed to any <code class="codeph">DBMS_LOB</code> API for any parameter that takes a LOB locator.</p>
<div class="infoboxnotealso" id="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60__GUID-DAE4EAA9-B69B-4075-AEF0-774942D3A36B">
<p class="notep1">See Also:</p>
<p><a href="adlob_sql_semantics.htm#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="Various SQL semantics are supported for LOBs.">SQL Semantics and LOBs</a></p>
</div>
</div>
</div>
<a id="ADLOB45650"></a>
<div class="props_rev_3"><a id="GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50"></a>
<h3 id="ADLOB-GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50" class="sect3">Explicit Conversion Functions</h3>
<div>
<p>In PL/SQL, these explicit conversion functions convert other data types to <code class="codeph">CLOB</code> and <code class="codeph">BLOB</code> datatypes as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">TO_CLOB()</code> converts <code class="codeph">LONG</code>, <code class="codeph">VARCHAR2</code>, and <code class="codeph">CHAR</code> to <code class="codeph">CLOB</code></p>
</li>
<li>
<p><code class="codeph">TO_BLOB()</code> converts <code class="codeph">LONG RAW</code> and <code class="codeph">RAW</code> to <code class="codeph">BLOB</code></p>
</li>
</ul>
<p>Also note that the conversion function <code class="codeph">TO_CHAR()</code> can convert a <code class="codeph">CLOB</code> to a <code class="codeph">CHAR</code> type.</p>
</div>
</div>
<a id="ADLOB45651"></a>
<div class="props_rev_3"><a id="GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2"></a>
<h3 id="ADLOB-GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2" class="sect3">Calling PL/SQL and C Procedures from SQL</h3>
<div>
<p>When a PL/SQL or C procedure is called from SQL, buffers with more than 4000 bytes of data are not allowed.</p>
</div>
</div>
<a id="ADLOB45652"></a>
<div class="props_rev_3"><a id="GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760"></a>
<h3 id="ADLOB-GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760" class="sect3">Calling PL/SQL and C Procedures from PL/SQL</h3>
<div>
<div class="section">
<p>You can call a PL/SQL or C procedure from PL/SQL. You can pass a <code class="codeph">CLOB</code> as an actual parameter where <code class="codeph">CHR</code> is the formal parameter, or vice versa. The same holds for <code class="codeph">BLOB</code>s and <code class="codeph">RAW</code>s.</p>
<p>One example of when these cases can arise is when either the formal or the actual parameter is an anchored type, that is, the variable is declared using the <span class="italic"><code class="codeph">table_name.column_name</code></span><code class="codeph">%type</code> syntax.</p>
<p>PL/SQL procedures or functions can accept a <code class="codeph">CLOB</code> or a <code class="codeph">VARCHAR2</code> as a formal parameter. For example the PL/SQL procedure could be one of the following:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>When the formal parameter is a <code class="codeph">CLOB</code>:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE get_lob(table_name IN VARCHAR2, lob INOUT
CLOB) AS
   ...
BEGIN
  ...
END;
/
</pre></li>
<li>
<p>When the formal parameter is a <code class="codeph">VARCHAR2</code>:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE get_lob(table_name IN VARCHAR2, lob INOUT
VARCHAR2) AS
   ...
BEGIN
  ...
END;
/
</pre></li>
</ul>
<p>The calling function could be of any of the following types:</p>
<ul style="list-style-type: disc;">
<li>
<p>When the actual parameter is a CHR:</p>
<pre dir="ltr">create procedure ...
declare 
c VARCHAR2[200];
BEGIN
  get_lob(&#39;table_name&#39;, c);
END;
 
</pre></li>
<li>
<p>When the actual parameter is a <code class="codeph">CLOB</code>:</p>
<pre dir="ltr">create procedure ...
declare 
c CLOB; 
BEGIN
  get_lob(&#39;table_name&#39;, c);
END;
</pre></li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45653"></a>
<div class="props_rev_3"><a id="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7"></a>
<h3 id="ADLOB-GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7" class="sect3">Binds of All Sizes in INSERT and UPDATE Operations</h3>
<div>
<p>Binds of all sizes are supported for <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations on LOB columns. Multiple binds of any size are allowed in a single <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> statement.</p>
<div class="infobox-note" id="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7__GUID-E423B9EE-938F-4BB1-B79C-DEAFDE3F09C0">
<p class="notep1">Note:</p>
<p>When you create a table, the length of the default value you specify for any LOB column is restricted to 4000 bytes.</p>
</div>
</div>
</div>
<a id="ADLOB45654"></a>
<div class="props_rev_3"><a id="GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D"></a>
<h3 id="ADLOB-GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D" class="sect3">4000 Byte Limit on Results of a SQL Operator</h3>
<div>
<p>If you bind more than 4000 bytes of data to a <code class="codeph">BLOB</code> or a <code class="codeph">CLOB</code>, and the data consists of a SQL operator, then Oracle Database limits the size of the result to at most 4000 bytes.</p>
<p>The following statement inserts only 4000 bytes because the result of <code class="codeph">LPAD</code> is limited to 4000 bytes:</p>
<pre dir="ltr">INSERT INTO print_media (ad_sourcetext) VALUES (lpad(&#39;a&#39;, 5000, &#39;a&#39;));
</pre>
<p>The following statement inserts only 2000 bytes because the result of <code class="codeph">LPAD</code> is limited to 4000 bytes, and the implicit hexadecimal to raw conversion converts it to 2000 bytes of <code class="codeph">RAW</code> data:</p>
<pre dir="ltr">INSERT INTO print_media (ad_photo) VALUES (lpad(&#39;a&#39;, 5000, &#39;a&#39;));  
</pre></div>
</div>
<a id="ADLOB45655"></a>
<div class="props_rev_3"><a id="GUID-D0C584EC-CA94-4166-99ED-F630EB655A76"></a>
<h3 id="ADLOB-GUID-D0C584EC-CA94-4166-99ED-F630EB655A76" class="sect3">Example of 4000 Byte Result Limit of a SQL Operator</h3>
<div>
<p>This example illustrates how the result for SQL operators is limited to 4000 bytes.</p>
<pre dir="ltr">/* The following command inserts only 4000 bytes because the result of
 * LPAD is limited to 4000 bytes */
INSERT INTO print_media(product_id, ad_id, ad_sourcetext)
  VALUES (2004, 5, lpad(&#39;a&#39;, 5000, &#39;a&#39;));
SELECT LENGTH(ad_sourcetext) FROM print_media 
  WHERE product_id=2004 AND ad_id=5;
ROLLBACK;

/* The following command inserts only 2000 bytes because the result of
 * LPAD is limited to 4000 bytes, and the implicit hex to raw conversion
 * converts it to 2000 bytes of RAW data. */
INSERT INTO print_media(product_id, ad_id, ad_composite)
  VALUES (2004, 5, lpad(&#39;a&#39;, 5000, &#39;a&#39;));
SELECT LENGTH(ad_composite) from print_media 
  WHERE product_id=2004 AND ad_id=5;
ROLLBAACK;
</pre></div>
</div>
<a id="ADLOB45656"></a>
<div class="props_rev_3"><a id="GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01"></a>
<h3 id="ADLOB-GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01" class="sect3">Restrictions on Binds of More Than 4000 Bytes</h3>
<div>
<p>There are restrictions for binds of more than 4000 bytes:</p>
<ul style="list-style-type: disc;">
<li>
<p>If a table has both <code class="codeph">LONG</code> and LOB columns, then you can bind more than 4000 bytes of data to either the <code class="codeph">LONG</code> or LOB columns, but not both in the same statement.</p>
</li>
<li>
<p>In an <code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> operation, binding of any length data to LOB columns is not allowed.</p>
</li>
</ul>
</div>
</div>
<a id="ADLOB1306"></a>
<div class="props_rev_3"><a id="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2"></a>
<h3 id="ADLOB-GUID-6011EE96-FE71-46C1-9914-70412A98C2E2" class="sect3">Parallel DML (PDML) Support for LOBs</h3>
<div>
<p>Oracle supports parallel execution of most of the following DML operations when performed on partitioned tables with SecureFiles LOBs or BasicFiles LOBs, and non-partitioned tables with SecureFiles LOBs only:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">INSERT</code></p>
</li>
<li>
<p><code class="codeph">INSERT AS SELECT</code></p>
</li>
<li>
<p><code class="codeph">CREATE TABLE AS SELECT</code></p>
</li>
<li>
<p><code class="codeph">DELETE</code></p>
</li>
<li>
<p><code class="codeph">UPDATE</code></p>
</li>
<li>
<p><code class="codeph">MERGE</code> (conditional <code class="codeph">UPDATE</code> and <code class="codeph">INSERT</code>)</p>
</li>
<li>
<p>Multi-table <code class="codeph">INSERT</code></p>
</li>
<li>
<p>SQL Loader</p>
</li>
<li>
<p>Import/Export</p>
</li>
</ul>
<p>Starting with release 12<span class="italic">c</span>, enhanced support for parallel DML includes the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>LOB columns stored as SecureFiles LOBs in non-partitioned tables. (Previous releases already included partitioned tables)</p>
</li>
<li>
<p>Direct load support for SecureFiles LOB columns that have context index defined on them.</p>
</li>
</ul>
<p><span class="bold">Restrictions</span></p>
<ul style="list-style-type: disc;">
<li>
<p>Parallel insert direct load (PIDL) is disabled if a table also has a BasicFiles LOB column, in addition to a SecureFiles LOB column.</p>
</li>
<li>
<p>Some domain index implementations may limit load distribution and degrade performance due to their design.</p>
</li>
<li>
<p>Parallelism must be specified only for top-level non-partitioned tables.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2__GUID-A4CF8295-988F-40E7-BBB7-446F86957C39">
<p class="notep1">See Also:</p>
<p><a class="olink ADMIN11186" target="_blank" href="../ADMIN/manproc.htm#ADMIN11186"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> section &#34;Managing Processes for Parallel SQL Execution&#34;</p>
</div>
</div>
</div>
<a id="ADLOB45657"></a>
<div class="props_rev_3"><a id="GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D"></a>
<h3 id="ADLOB-GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D" class="sect3">Example: PL/SQL - Using Binds of More Than 4000 Bytes in INSERT and UPDATE</h3>
<div>
<div class="section">
<p>This example demonstrates using binds larger than 4000 bytes in <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations.</p>
<pre dir="ltr">DECLARE
  bigtext VARCHAR2(32767);
  smalltext VARCHAR2(2000);
  bigraw RAW (32767);
BEGIN
  bigtext := LPAD(&#39;a&#39;, 32767, &#39;a&#39;);
  smalltext := LPAD(&#39;a&#39;, 2000, &#39;a&#39;);
  bigraw := utl_raw.cast_to_raw (bigtext);

  /* Multiple long binds for LOB columns are allowed for INSERT: */
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext, ad_composite)
    VALUES (2004, 1, bigtext, bigraw);

  /* Single long bind for LOB columns is allowed for INSERT: */
  INSERT INTO print_media (product_id, ad_id, ad_sourcetext)
    VALUES (2005, 2, smalltext);  

  bigtext := LPAD(&#39;b&#39;, 32767, &#39;b&#39;);
  smalltext := LPAD(&#39;b&#39;, 20, &#39;a&#39;);
  bigraw := utl_raw.cast_to_raw (bigtext);

  /* Multiple long binds for LOB columns are allowed for UPDATE: */
  UPDATE print_media SET ad_sourcetext = bigtext, ad_composite = bigraw,
    ad_finaltext = smalltext;

  /* Single long bind for LOB columns is allowed for UPDATE: */
  UPDATE print_media SET ad_sourcetext = smalltext, ad_finaltext = bigtext;

  /* The following is NOT allowed because we are trying to insert more than
     4000 bytes of data in a LONG and a LOB column: */
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext, press_release)
    VALUES (2030, 3, bigtext, bigtext);
  
  /* Insert of data into LOB attribute is allowed */
  INSERT INTO print_media(product_id, ad_id, ad_header)
     VALUES (2049, 4, adheader_typ(null, null, null, bigraw));

  /* The following is not allowed because we try to perform INSERT AS
     SELECT data INTO LOB */
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext)
    SELECT 2056, 5, bigtext FROM dual;

END;
/
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45658"></a>
<div class="props_rev_3"><a id="GUID-F808592E-C7AA-44C7-8178-8359F21C6814"></a>
<h3 id="ADLOB-GUID-F808592E-C7AA-44C7-8178-8359F21C6814" class="sect3">Using the Data Interface for LOBs with INSERT, UPDATE, and SELECT Operations</h3>
<div>
<div class="section">
<p><code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> statements on LOBs are used in the same way as on <code class="codeph">LONG</code>s. For example:</p>
<pre dir="ltr">DECLARE
  ad_buffer VARCHAR2(100);
BEGIN
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext)
    VALUES(2004, 5, &#39;Source for advertisement 1&#39;);
  UPDATE print_media SET ad_sourcetext= &#39;Source for advertisement 2&#39;
    WHERE product_id=2004 AND ad_id=5;
  /* This retrieves the LOB column if it is up to 100 bytes, otherwise it
   * raises an exception */
  SELECT ad_sourcetext INTO ad_buffer FROM print_media 
    WHERE product_id=2004 AND ad_id=5;
END;
/
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45659"></a>
<div class="props_rev_3"><a id="GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B"></a>
<h3 id="ADLOB-GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B" class="sect3">Using the Data Interface for LOBs in Assignments and Parameter Passing</h3>
<div>
<div class="section">
<p>The data interface for LOBs enables implicit assignment and parameter passing as shown in the following example:</p>
<pre dir="ltr">CREATE TABLE t (clob_col CLOB, blob_col BLOB);
INSERT INTO t VALUES(&#39;abcdefg&#39;, &#39;aaaaaa&#39;);

DECLARE
  var_buf VARCHAR2(100);
  clob_buf CLOB;
  raw_buf RAW(100);
  blob_buf BLOB;
BEGIN
  SELECT * INTO clob_buf, blob_buf FROM t;
  var_buf := clob_buf;
  clob_buf:= var_buf;
  raw_buf := blob_buf;
  blob_buf := raw_buf;
END;
/

CREATE OR REPLACE PROCEDURE FOO ( a IN OUT CLOB) IS
BEGIN
  -- Any procedure body
  a := &#39;abc&#39;;
END;
/

CREATE OR REPLACE PROCEDURE BAR (b IN OUT VARCHAR2) IS
BEGIN
  -- Any procedure body
  b := &#39;xyz&#39;;
END;
/

DECLARE
  a VARCHAR2(100) := &#39;1234567&#39;;
  b CLOB;
BEGIN
  FOO(a);
  SELECT clob_col INTO b FROM t;
  BAR(b);
END;
/
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45660"></a>
<div class="props_rev_3"><a id="GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C"></a>
<h3 id="ADLOB-GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C" class="sect3">Using the Data Interface for LOBs with PL/SQL Built-In Functions</h3>
<div>
<div class="section">
<p>This example illustrates the use of <code class="codeph">CLOB</code>s in PL/SQL built-in functions, using the data interface for LOBs:</p>
<pre dir="ltr">DECLARE
  my_ad CLOB;
  revised_ad CLOB;
  myGist VARCHAR2(100):= &#39;This is my gist.&#39;;
  revisedGist VARCHAR2(100);
BEGIN
  INSERT INTO print_media (product_id, ad_id, ad_sourcetext)
    VALUES (2004, 5, &#39;Source for advertisement 1&#39;);  

  -- select a CLOB column into a CLOB variable
  SELECT ad_sourcetext INTO my_ad FROM print_media 
    WHERE product_id=2004 AND ad_id=5;

  -- perform VARCHAR2 operations on a CLOB variable
  revised_ad := UPPER(SUBSTR(my_ad, 1, 20));
 
  -- revised_ad is a temporary LOB
  -- Concat a VARCHAR2 at the end of a CLOB
  revised_ad := revised_ad || myGist;

  -- The following statement raises an error if my_ad is
  -- longer than 100 bytes
  myGist := my_ad;
END;
/
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADLOB45661"></a>
<div class="props_rev_3"><a id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26"></a>
<h2 id="ADLOB-GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26" class="sect2">The Data Interface Used for Persistent LOBs in OCI</h2>
<div>
<p>This section discusses OCI functions included in the data interface for persistent LOBs. These OCI functions work for LOB datatypes exactly the same way as they do for <code class="codeph">LONG</code> datatypes. Using these functions, you can perform <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, fetch, bind, and define operations in OCI on LOBs using the same techniques you would use on other datatypes that store character or binary data.</p>
<div class="infobox-note" id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26__GUID-72B9F551-C82D-46E2-9383-5ABE7FC4AA7A">
<p class="notep1">Note:</p>
<p>You can use array bind and define interfaces to insert and select multiple rows with LOBs in one round trip.</p>
</div>
<div class="infoboxnotealso" id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26__GUID-F4746FFA-C968-4645-BAF6-D96A31C2B22E">
<p class="notep1">See Also:</p>
<p><a class="olink LNOCI059" target="_blank" href="../LNOCI/oci05bnd.htm#LNOCI059"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a><span class="italic">,</span> section &#34;Runtime Data Allocation and Piecewise Operations in OCI&#34;</p>
</div>
</div>
<a id="ADLOB45662"></a>
<div class="props_rev_3"><a id="GUID-440FBDD9-016D-482E-B4E2-D94753709D9B"></a>
<h3 id="ADLOB-GUID-440FBDD9-016D-482E-B4E2-D94753709D9B" class="sect3">LOB Data Types Bound in OCI</h3>
<div>
<p>You can bind LOB datatypes in the following operations:</p>
<ul style="list-style-type: disc;">
<li>
<p>Regular, piecewise, and callback binds for <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations</p>
</li>
<li>
<p>Array binds for <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations</p>
</li>
<li>
<p>Parameter passing across PL/SQL and OCI boundaries</p>
</li>
</ul>
<p>Piecewise operations can be performed by polling or by providing a callback. To support these operations, the following OCI functions accept the <code class="codeph">LONG</code> and LOB data types listed in <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="This table is described in the preceding text">Table 20-2</a>.</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIBindByName()</code> and <code class="codeph">OCIBindByPos()</code></p>
<p>These functions create an association between a program variable and a placeholder in the SQL statement or a PL/SQL block for <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations.</p>
</li>
<li>
<p><code class="codeph">OCIBindDynamic()</code></p>
<p>You use this call to register callbacks for dynamic data allocation for <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations</p>
</li>
<li>
<p><code class="codeph">OCIStmtGetPieceInfo()</code> and <code class="codeph">OCIStmtSetPieceInfo()</code></p>
<p>These calls are used to get or set piece information for piecewise operations.</p>
</li>
</ul>
</div>
</div>
<a id="ADLOB45663"></a>
<div class="props_rev_3"><a id="GUID-1D08A343-F384-4C17-8468-0B50AB4869A9"></a>
<h3 id="ADLOB-GUID-1D08A343-F384-4C17-8468-0B50AB4869A9" class="sect3">LOB Data Types Defined in OCI</h3>
<div>
<p>The data interface for persistent LOBs allows the following OCI functions to accept the LONG and LOB data types listed in <a href="adlob_data_interface.htm#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="This table is described in the preceding text">Table 20-2</a>.</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIDefineByPos()</code></p>
<p>This call associates an item in a <code class="codeph">SELECT</code> list with the type and output data buffer.</p>
</li>
<li>
<p><code class="codeph">OCIDefineDynamic()</code></p>
<p>This call registers user callbacks for <code class="codeph">SELECT</code> operations if the <code class="codeph">OCI_DYNAMIC_FETCH</code> mode was selected in <code class="codeph">OCIDefineByPos()</code> function call.</p>
</li>
</ul>
<p>When you use these functions with LOB types, the LOB data, and not the locator, is selected into your buffer. Note that in OCI, you cannot specify the amount you want to read using the data interface for LOBs. You can only specify the buffer length of your buffer. The database only reads whatever amount fits into your buffer and the data is truncated.</p>
</div>
</div>
<a id="ADLOB45664"></a>
<div class="props_rev_3"><a id="GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1"></a>
<h3 id="ADLOB-GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1" class="sect3">Multibyte Character Sets Used in OCI with the Data Interface for LOBs</h3>
<div>
<p>When the client character set is in a multibyte format, functions included in the data interface operate the same way with LOB datatypes as they do for LONG datatypes as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>For a <span class="italic">piecewise</span> fetch in a multibyte character set, a multibyte character could be cut in the middle, with some bytes at the end of one buffer and remaining bytes in the next buffer.</p>
</li>
<li>
<p>For a <span class="italic">regular</span> fetch, if the buffer cannot hold all bytes of the last character, then Oracle returns as many bytes as fit into the buffer, hence returning partial characters.</p>
</li>
</ul>
</div>
</div>
<a id="ADLOB45665"></a>
<div class="props_rev_3"><a id="GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E"></a>
<h3 id="ADLOB-GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E" class="sect3">OCI Functions Used to Perform INSERT or UPDATE on LOB Columns</h3>
<div>
<p>This section discusses the various techniques you can use to perform <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operations on LOB columns or attributes using the data interface. The operations described in this section assume that you have initialized the OCI environment and allocated all necessary handles.</p>
</div>
<a id="ADLOB45666"></a>
<div class="props_rev_3"><a id="GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24"></a>
<h4 id="ADLOB-GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24" class="sect4">Performing Simple INSERTs or UPDATEs in One Piece</h4>
<div>
<div class="section">
<p>To perform simple <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operations in one piece using the data interface for persistent LOBs, perform the following steps:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Call <code class="codeph">OCIStmtPrepare()</code> to prepare the statement in <code class="codeph">OCI_DEFAULT</code> mode.</span></li>
<li><span>Call <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindbyPos()</code> in <code class="codeph">OCI_DEFAULT</code> mode to bind a placeholder for LOB as character data or binary data.</span></li>
<li><span>Call <code class="codeph">OCIStmtExecute()</code> to do the actual <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operation.</span></li>
</ol>
</div>
</div>
<a id="ADLOB45667"></a>
<div class="props_rev_3"><a id="GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311"></a>
<h4 id="ADLOB-GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311" class="sect4">Using Piecewise INSERTs and UPDATEs with Polling</h4>
<div>
<div class="section">
<p>To perform piecewise <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operations with polling using the data interface for persistent LOBs, do the following steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtPrepare()</code> to prepare the statement in <code class="codeph">OCI_DEFAULT</code> mode.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindbyPos()</code> in <code class="codeph">OCI_DATA_AT_EXEC</code> mode to bind a LOB as character data or binary data.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtExecute()</code> in default mode. Do each of the following in a loop while the value returned from <code class="codeph">OCIStmtExecute()</code> is <code class="codeph">OCI_NEED_DATA</code>. Terminate your loop when the value returned from <code class="codeph">OCIStmtExecute()</code> is <code class="codeph">OCI_SUCCESS</code>.</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p>Call <code class="codeph">OCIStmtGetPieceInfo()</code> to retrieve information about the piece to be inserted.</p>
</li>
<li>
<p>Call <code class="codeph">OCIStmtSetPieceInfo()</code> to set information about piece to be inserted.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<a id="ADLOB45668"></a>
<div class="props_rev_3"><a id="GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327"></a>
<h4 id="ADLOB-GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327" class="sect4">Performing Piecewise INSERTs and UPDATEs with Callback</h4>
<div>
<div class="section">
<p>To perform piecewise <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operations with callback using the data interface for persistent LOBs, do the following steps:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Call <code class="codeph">OCIStmtPrepare()</code> to prepare the statement in <code class="codeph">OCI_DEFAULT</code> mode.</span></li>
<li><span>Call <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindbyPos()</code> in <code class="codeph">OCI_DATA_AT_EXEC</code> mode to bind a placeholder for the LOB column as character data or binary data.</span></li>
<li><span>Call <code class="codeph">OCIBindDynamic()</code> to specify the callback.</span></li>
<li><span>Call <code class="codeph">OCIStmtExecute()</code> in default mode.</span></li>
</ol>
</div>
</div>
<a id="ADLOB45669"></a>
<div class="props_rev_3"><a id="GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB"></a>
<h4 id="ADLOB-GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB" class="sect4">Array INSERT and UPDATE Operations</h4>
<div>
<div class="section">
<p>To perform array <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operations using the data interface for persistent LOBs, use any of the techniques discussed in this section in conjunction with <code class="codeph">OCIBindArrayOfStruct()</code>, or by specifying the number of iterations (<span class="italic"><code class="codeph">iter</code></span>), with <span class="italic"><code class="codeph">iter</code></span> value greater than 1, in the <code class="codeph">OCIStmtExecute()</code> call.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADLOB45670"></a>
<div class="props_rev_3"><a id="GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF"></a>
<h3 id="ADLOB-GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF" class="sect3">The Data Interface Used to Fetch LOB Data in OCI</h3>
<div>
<p>This section discusses techniques you can use to fetch data from LOB columns or attributes in OCI using the data interface for persistent LOBs.</p>
</div>
<a id="ADLOB45671"></a>
<div class="props_rev_3"><a id="GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7"></a>
<h4 id="ADLOB-GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7" class="sect4">Simple Fetch in One Piece</h4>
<div>
<div class="section">
<p>To perform a simple fetch operation on LOBs in one piece using the data interface for persistent LOBs, do the following:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Call <code class="codeph">OCIStmtPrepare()</code> to prepare the <code class="codeph">SELECT</code> statement in <code class="codeph">OCI_DEFAULT</code> mode.</span></li>
<li><span>Call <code class="codeph">OCIDefineByPos()</code> to define a select list position in <code class="codeph">OCI_DEFAULT</code> mode to define a LOB as character data or binary data.</span></li>
<li><span>Call <code class="codeph">OCIStmtExecute()</code> to run the <code class="codeph">SELECT</code> statement.</span></li>
<li><span>Call <code class="codeph">OCIStmtFetch()</code> to do the actual fetch.</span></li>
</ol>
</div>
</div>
<a id="ADLOB45672"></a>
<div class="props_rev_3"><a id="GUID-254F3A11-F9CC-4DC2-B855-333C508D6622"></a>
<h4 id="ADLOB-GUID-254F3A11-F9CC-4DC2-B855-333C508D6622" class="sect4">Performing a Piecewise Fetch with Polling</h4>
<div>
<div class="section">
<p>To perform a piecewise fetch operation on a LOB column with polling using the data interface for LOBs, do the following steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtPrepare()</code> to prepare the <code class="codeph">SELECT</code> statement in <code class="codeph">OCI_DEFAULT</code> mode.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIDefinebyPos()</code> to define a select list position in <code class="codeph">OCI_DYNAMIC_FETCH</code> mode to define the LOB column as character data or binary data.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtExecute()</code> to run the <code class="codeph">SELECT</code> statement.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtFetch()</code> in default mode. Do each of the following in a loop while the value returned from <code class="codeph">OCIStmtFetch()</code> is <code class="codeph">OCI_NEED_DATA.</code> Terminate your loop when the value returned from <code class="codeph">OCIStmtFetch()</code> is <code class="codeph">OCI_SUCCESS</code>.</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p>Call <code class="codeph">OCIStmtGetPieceInfo()</code> to retrieve information about the piece to be fetched.</p>
</li>
<li>
<p>Call <code class="codeph">OCIStmtSetPieceInfo()</code> to set information about piece to be fetched.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<a id="ADLOB45673"></a>
<div class="props_rev_3"><a id="GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140"></a>
<h4 id="ADLOB-GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140" class="sect4">Performing a Piecewise with Callback</h4>
<div>
<div class="section">
<p>To perform a piecewise fetch operation on a LOB column with callback using the data interface for persistent LOBs, do the following:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Call <code class="codeph">OCIStmtPrepare()</code> to prepare the statement in <code class="codeph">OCI_DEFAULT</code> mode.</span></li>
<li><span>Call <code class="codeph">OCIDefinebyPos()</code> to define a select list position in <code class="codeph">OCI_DYNAMIC_FETCH</code> mode to define the LOB column as character data or binary data.</span></li>
<li><span>Call <code class="codeph">OCIStmtExecute()</code> to run the <code class="codeph">SELECT</code> statement.</span></li>
<li><span>Call <code class="codeph">OCIDefineDynamic()</code> to specify the callback.</span></li>
<li><span>Call <code class="codeph">OCIStmtFetch()</code> in default mode.</span></li>
</ol>
</div>
</div>
<a id="ADLOB45674"></a>
<div class="props_rev_3"><a id="GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5"></a>
<h4 id="ADLOB-GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5" class="sect4">Array Fetch</h4>
<div>
<div class="section">
<p>To perform an array fetch in OCI using the data interface for persistent LOBs, use any of the techniques discussed in this section in conjunction with <code class="codeph">OCIDefineArrayOfStruct()</code>, or by specifying the number of iterations (<span class="italic"><code class="codeph">iter</code></span>), with the value of <span class="italic"><code class="codeph">iter</code></span> greater than 1, in the <code class="codeph">OCIStmtExecute()</code> call.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADLOB45675"></a>
<div class="props_rev_3"><a id="GUID-34D56682-00EB-42DD-869A-9C5C4E288423"></a>
<h3 id="ADLOB-GUID-34D56682-00EB-42DD-869A-9C5C4E288423" class="sect3">PL/SQL and C Binds from OCI</h3>
<div>
<div class="section">
<p>When you call a PL/SQL procedure from OCI, and have an <code class="codeph">IN</code> or <code class="codeph">OUT</code> or <code class="codeph">IN OUT</code> bind, you should be able to:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Bind a variable as <code class="codeph">SQLT_CHR</code> or <code class="codeph">SQLT_LNG</code> where the formal parameter of the PL/SQL procedure is <code class="codeph">SQLT_CLOB</code>, or</p>
</li>
<li>
<p>Bind a variable as <code class="codeph">SQLT_BIN</code> or <code class="codeph">SQLT_LBI</code> where the formal parameter is <code class="codeph">SQLT_BLOB</code></p>
</li>
</ul>
<p>The following two cases work:</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Calling PL/SQL Out-binds in the &#34;begin foo(:1); end;&#34; Manner</p>
<p>Here is an example of calling PL/SQL out-binds in the &#34;begin foo(:1); end;&#34; Manner:</p>
<pre dir="ltr">text *sqlstmt = (text *)&#34;BEGIN get_lob(:c); END; &#34; ;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Calling PL/SQL Out-binds in the &#34;call foo(:1);&#34; Manner</p>
<p>Here is an example of calling PL/SQL out-binds in the &#34;call foo(:1);&#34; manner:</p>
<pre dir="ltr">text *sqlstmt = (text *)&#34;CALL get_lob(:c);&#34; ;
</pre>
<p>In both these cases, the rest of the program has these statements:</p>
<pre dir="ltr">OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
               (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   curlen = 0;
OCIBindByName(stmthp, &amp;bndhp[3], errhp,
        (text *) &#34;:c&#34;, (sb4) strlen((char *) &#34;:c&#34;),
        (dvoid *) buf5, (sb4) LONGLEN, SQLT_CHR,
        (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
        (ub4) 1, (ub4 *) &amp;curlen, (ub4) OCI_DATA_AT_EXEC);
</pre>
<p>The PL/SQL procedure, <code class="codeph">get_lob()</code>, is as follows:</p>
<pre dir="ltr">procedure get_lob(c INOUT CLOB) is  -- This might have been column%type 
  BEGIN
  ... /* The procedure body could be in PL/SQL or C*/
  END;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45678"></a>
<div class="props_rev_3"><a id="GUID-28B40747-D702-44FB-BF19-F7DC46C67722"></a>
<h3 id="ADLOB-GUID-28B40747-D702-44FB-BF19-F7DC46C67722" class="sect3">Example: C (OCI) - Binds of More than 4000 Bytes for INSERT and UPDATE</h3>
<div>
<div class="section">
<p>You can use binds of more than 4000 byes for <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations.</p>
<pre dir="ltr">void insert3() 
{ 
/* Insert of data into LOB attributes is allowed. */
   ub1 buffer[8000]; 
   text *insert_sql = (text *)&#34;INSERT INTO Print_media (ad_header) \
               VALUES (adheader_typ(NULL, NULL, NULL,:1))&#34;; 
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),  
            (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT); 
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (dvoid *)buffer, 2000,  
             SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT); 
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (const OCISnapshot*) 0, 
                  (OCISnapshot*)0, OCI_DEFAULT); 
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45679"></a>
<div class="props_rev_3"><a id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6"></a>
<h3 id="ADLOB-GUID-67A21099-37E9-4400-9D75-D86A106A4FC6" class="sect3">Using the Data Interface for LOBs in PL/SQL Binds from OCI on LOBs</h3>
<div>
<div class="section">
<p>The data interface for LOBs allows LOB PL/SQL binds from OCI to work. When you call a PL/SQL procedure from OCI, and have an <code class="codeph">IN</code> or <code class="codeph">OUT</code> or <code class="codeph">IN OUT</code> bind, you should be able to bind a variable as <code class="codeph">SQLT_CHR</code>, where the formal parameter of the PL/SQL procedure is <code class="codeph">SQLT_CLOB</code>.</p>
<div class="infobox-note" id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6__GUID-09184C69-A045-4A00-AA79-8EC4A232E6E6">
<p class="notep1">Note:</p>
<p>C procedures are wrapped inside a PL/SQL stub, so the OCI application always calls the PL/SQL stub.</p>
</div>
<p>For the OCI calling program, the following are likely cases:</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Calling PL/SQL Out-binds in the &#34;begin foo(:1); end;&#34; Manner</p>
<p>For example:</p>
<pre dir="ltr">text *sqlstmt = (text *)&#34;BEGIN PKG1.P5 (:c); END; &#34; ;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Calling PL/SQL Out-binds in the &#34;call foo(:1);&#34; Manner</p>
<p>For example:</p>
<pre dir="ltr">text *sqlstmt = (text *)&#34;CALL PKG1.P5( :c );&#34; ;
</pre>
<p>In both these cases, the rest of the program is as follows:</p>
<pre dir="ltr">   OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
            (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   curlen = 0;

   OCIBindByName(stmthp, &amp;bndhp[3], errhp,
            (text *) &#34;:c4&#34;, (sb4) strlen((char *) &#34;:c&#34;),
            (dvoid *) buf5, (sb4) LONGLEN, SQLT_CHR,
            (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
            (ub4) 1, (ub4 *) &amp;curlen, (ub4) OCI_DATA_AT_EXEC);

    OCIStmtExecute(svchp, stmthp, errhp,(ub4) 0,(ub4) 0, (const OCISnapshot*) 0,
            (OCISnapshot*) 0,(ub4) OCI_DEFAULT);
</pre>
<p>The PL/SQL procedure <code class="codeph">PKG1.P5</code> is as follows:</p>
<pre dir="ltr">   CREATE OR REPLACE PACKAGE BODY pkg1 AS
     ...
   procedure p5 (c OUT CLOB) is
     -- This might have been table%rowtype (so it   is CLOB now)
   BEGIN
     ...
   END p5;

END pkg1;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45682"></a>
<div class="props_rev_3"><a id="GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED"></a>
<h3 id="ADLOB-GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED" class="sect3">Binding LONG Data for LOB Columns in Binds Greater Than 4000 Bytes</h3>
<div>
<div class="section">
<p>This example illustrates binding character data for a LOB column:</p>
<pre dir="ltr">void simple_insert()
{
  word buflen;
  text buf[5000];
  text *insstmt = (text *) &#34;INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (2004, 1, :SRCTXT)&#34;;
 
  OCIStmtPrepare(stmthp, errhp, insstmt, (ub4)strlen((char *)insstmt), 
                (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  
  OCIBindByName(stmthp, &amp;bndhp[0], errhp,
                (text *) &#34;:SRCTXT&#34;, (sb4) strlen((char *) &#34;:SRCTXT&#34;),
                (dvoid *) buf, (sb4) sizeof(buf), SQLT_CHR,
                (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  memset((void *)buf, (int)&#39;A&#39;, (size_t)5000);
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT);
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45683"></a>
<div class="props_rev_3"><a id="GUID-4F79C855-71C0-4307-BD72-114889A9DFDE"></a>
<h3 id="ADLOB-GUID-4F79C855-71C0-4307-BD72-114889A9DFDE" class="sect3">Binding LONG Data to LOB Columns Using Piecewise INSERT with Polling</h3>
<div>
<div class="section">
<p>This example illustrates using piecewise <code class="codeph">INSERT</code> with polling using the data interface for LOBs.</p>
<pre dir="ltr">void piecewise_insert()
{
  text *sqlstmt = (text *)&#34;INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (:1, :2, :3)&#34;;
  ub2 rcode;
  ub1 piece, i;
  word product_id = 2004;
  word ad_id = 2;
  ub4 buflen;
  char buf[5000];
 
  OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt), 
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[0], errhp, (ub4) 1,
               (dvoid *) &amp;product_id, (sb4) sizeof(product_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[1], errhp, (ub4) 2,
               (dvoid *) &amp;ad_id, (sb4) sizeof(ad_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[2], errhp, (ub4) 3,
               (dvoid *) 0, (sb4) 15000, SQLT_LNG,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC);
 
  i = 0;
  while (1)
  {
    i++;
    retval = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                            (CONST OCISnapshot*) 0, (OCISnapshot*) 0,
                            (ub4) OCI_DEFAULT);
    switch(retval)
    {
    case OCI_NEED_DATA:
      memset((void *)buf, (int)&#39;A&#39;+i, (size_t)5000);
      buflen = 5000;
      if (i == 1) piece = OCI_FIRST_PIECE;
      else if (i == 3) piece = OCI_LAST_PIECE;
      else piece = OCI_NEXT_PIECE;
 
      if (OCIStmtSetPieceInfo((dvoid *)bndhp[2],
                              (ub4)OCI_HTYPE_BIND, errhp, (dvoid *)buf,
                              &amp;buflen, piece, (dvoid *) 0, &amp;rcode))
        {
          printf(&#34;ERROR: OCIStmtSetPieceInfo: %d \n&#34;, retval);
          break;
        }
      
      break;
    case OCI_SUCCESS:
      break;
    default:
      printf( &#34;oci exec returned %d \n&#34;, retval);
      report_error(errhp);
      retval = OCI_SUCCESS;
    } /* end switch */
    if (retval == OCI_SUCCESS) 
      break;
  } /* end while(1) */
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45684"></a>
<div class="props_rev_3"><a id="GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871"></a>
<h3 id="ADLOB-GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871" class="sect3">Binding LONG Data to LOB Columns Using Piecewise INSERT with Callback</h3>
<div>
<div class="section">
<p>This example illustrates binding <code class="codeph">LONG</code> data to LOB columns using a piecewise <code class="codeph">INSERT</code> with callback:</p>
<pre dir="ltr">void callback_insert()
{
  word buflen = 15000;
  word product_id = 2004;
  word ad_id = 3;
  text *sqlstmt = (text *) &#34;INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (:1, :2, :3)&#34;;
  word pos = 3;
 
  OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT)
 
  OCIBindByPos(stmthp, &amp;bndhp[0], errhp, (ub4) 1,
               (dvoid *) &amp;product_id, (sb4) sizeof(product_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[1], errhp, (ub4) 2,
               (dvoid *) &amp;ad_id, (sb4) sizeof(ad_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[2], errhp, (ub4) 3,
               (dvoid *) 0, (sb4) buflen, SQLT_CHR,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC);
 
  OCIBindDynamic(bndhp[2], errhp, (dvoid *) (dvoid *) &amp;pos,
                 insert_cbk, (dvoid *) 0, (OCICallbackOutBind) 0);
 
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0,
                 (ub4) OCI_DEFAULT);
} /* end insert_data() */
 
/* Inbind callback to specify input data. */
static sb4 insert_cbk(dvoid *ctxp, OCIBind *bindp, ub4 iter, ub4 index,
                       dvoid **bufpp, ub4 *alenpp, ub1 *piecep, dvoid **indpp)
{
  static int a = 0;
  word   j;
  ub4    inpos = *((ub4 *)ctxp);
  char   buf[5000];
 
  switch(inpos)
  {
  case 3:
    memset((void *)buf, (int) &#39;A&#39;+a, (size_t) 5000);
    *bufpp = (dvoid *) buf;
    *alenpp = 5000 ;
    a++;
    break;
  default: printf(&#34;ERROR: invalid position number: %d\n&#34;, inpos);
  }
 
  *indpp = (dvoid *) 0;
  *piecep = OCI_ONE_PIECE;
  if (inpos == 3)
  {
    if (a&lt;=1)
    {
      *piecep = OCI_FIRST_PIECE;
      printf(&#34;Insert callback: 1st piece\n&#34;);
    }
    else if (a&lt;3)
    {
      *piecep = OCI_NEXT_PIECE;
      printf(&#34;Insert callback: %d&#39;th piece\n&#34;, a);
    }
    else {
      *piecep = OCI_LAST_PIECE;
      printf(&#34;Insert callback: %d&#39;th piece\n&#34;, a);
      a = 0;
    }
  }
  return OCI_CONTINUE;
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45685"></a>
<div class="props_rev_3"><a id="GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE"></a>
<h3 id="ADLOB-GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE" class="sect3">Binding LONG Data to LOB Columns Using an Array INSERT</h3>
<div>
<div class="section">
<p>This example illustrates binding character data for LOB columns using an array <code class="codeph">INSERT</code> operation:</p>
<pre dir="ltr">void array_insert()
{
  ub4 i;
  word buflen;
  word arrbuf1[5];
  word arrbuf2[5];
  text arrbuf3[5][5000];
  text *insstmt = (text *)&#34;INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (:PID, :AID, :SRCTXT)&#34;;
 
  OCIStmtPrepare(stmthp, errhp, insstmt,
                 (ub4)strlen((char *)insstmt), (ub4) OCI_NTV_SYNTAX,
                 (ub4) OCI_DEFAULT);
 
  OCIBindByName(stmthp, &amp;bndhp[0], errhp,
                (text *) &#34;:PID&#34;, (sb4) strlen((char *) &#34;:PID&#34;),
                (dvoid *) &amp;arrbuf1[0], (sb4) sizeof(arrbuf1[0]), SQLT_INT,
                (dvoid *) 0, (ub2 *)0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  OCIBindByName(stmthp, &amp;bndhp[1], errhp,
                (text *) &#34;:AID&#34;, (sb4) strlen((char *) &#34;:AID&#34;),
                (dvoid *) &amp;arrbuf2[0], (sb4) sizeof(arrbuf2[0]), SQLT_INT,
                (dvoid *) 0, (ub2 *)0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  OCIBindByName(stmthp, &amp;bndhp[2], errhp,
                (text *) &#34;:SRCTXT&#34;, (sb4) strlen((char *) &#34;:SRCTXT&#34;),
                (dvoid *) arrbuf3[0], (sb4) sizeof(arrbuf3[0]), SQLT_CHR,
                (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  OCIBindArrayOfStruct(bndhp[0], errhp sizeof(arrbuf1[0]),
                       indsk, rlsk, rcsk);
  OCIBindArrayOfStruct(bndhp[1], errhp, sizeof(arrbuf2[0]),
                       indsk, rlsk, rcsk);
  OCIBindArrayOfStruct(bndhp[2], errhp, sizeof(arrbuf3[0]),
                       indsk, rlsk, rcsk);
 
  for (i=0; i&lt;5; i++)
  {
    arrbuf1[i] = 2004;
    arrbuf2[i] = i+4;
    memset((void *)arrbuf3[i], (int)&#39;A&#39;+i, (size_t)5000);
  }
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 5, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0,
                 (ub4) OCI_DEFAULT);
 
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45686"></a>
<div class="props_rev_3"><a id="GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98"></a>
<h3 id="ADLOB-GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98" class="sect3">Selecting a LOB Column into a LONG Buffer Using a Simple Fetch</h3>
<div>
<div class="section">
<p>This example illustrates selecting a LOB column using a simple fetch:</p>
<pre dir="ltr">void simple_fetch()
{
  word retval;
  text buf[15000];
  text *selstmt = (text *) &#34;SELECT Ad_sourcetext FROM Print_media WHERE\
                  Product_id = 2004&#34;;
 
  OCIStmtPrepare(stmthp, errhp, selstmt, (ub4)strlen((char *)selstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
 
  retval = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 0, (ub4) 0,
                          (const OCISnapshot*) 0, (OCISnapshot*) 0,
                          (ub4) OCI_DEFAULT);
  while (retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO)
  {
    OCIDefineByPos(stmthp, &amp;defhp, errhp, (ub4) 1, (dvoid *) buf,
                   (sb4) sizeof(buf), (ub2) SQLT_CHR, (dvoid *) 0,
                   (ub2 *) 0, (ub2 *) 0, (ub4) OCI_DEFAULT);
    retval = OCIStmtFetch(stmthp, errhp, (ub4) 1,
                          (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
    if (retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO)
      printf(&#34;buf = %.*s\n&#34;, 15000, buf);
  }
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45687"></a>
<div class="props_rev_3"><a id="GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250"></a>
<h3 id="ADLOB-GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250" class="sect3">Selecting a LOB Column into a LONG Buffer Using Piecewise Fetch with Polling</h3>
<div>
<div class="section">
<p>This example illustrates selecting a LOB column into a <code class="codeph">LONG</code> buffer using a piecewise fetch with polling:</p>
<pre dir="ltr">void piecewise_fetch()
{
  text buf[15000];
  ub4 buflen=5000;
  word retval;
  text *selstmt = (text *) &#34;SELECT Ad_sourcetext FROM Print_media
                  WHERE Product_id = 2004 AND Ad_id = 2&#34;;
 
  OCIStmtPrepare(stmthp, errhp, selstmt,
                 (ub4) strlen((char *)selstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
 
  OCIDefineByPos(stmthp, &amp;dfnhp, errhp, (ub4) 1,
                 (dvoid *) NULL, (sb4) 100000, SQLT_LNG,
                 (dvoid *) 0, (ub2 *) 0,
                 (ub2 *) 0, (ub4) OCI_DYNAMIC_FETCH);
 
  retval = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 0, (ub4) 0,
                          (CONST OCISnapshot*) 0, (OCISnapshot*) 0,
                          (ub4) OCI_DEFAULT);
 
  retval = OCIStmtFetch(stmthp, errhp, (ub4) 1 ,
                        (ub2) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
 
  while (retval != OCI_NO_DATA &amp;&amp; retval != OCI_SUCCESS)
  {
    ub1 piece;
    ub4 iter;
    ub4 idx;
  
    genclr((void *)buf, 5000);
    switch(retval)
    {
    case OCI_NEED_DATA:
      OCIStmtGetPieceInfo(stmthp, errhp, &amp;hdlptr, &amp;hdltype,
                          &amp;in_out, &amp;iter, &amp;idx, &amp;piece);
      buflen = 5000;
      OCIStmtSetPieceInfo(hdlptr, hdltype, errhp,
                          (dvoid *) buf, &amp;buflen, piece,
                          (CONST dvoid *) &amp;indp1, (ub2 *) 0);
      retval = OCI_NEED_DATA;
      break;
    default:
      printf(&#34;ERROR: piece-wise fetching, %d\n&#34;, retval);
      return;
    } /* end switch */
    retval = OCIStmtFetch(stmthp, errhp, (ub4) 1 ,
                          (ub2) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
    printf(&#34;Data : %.5000s\n&#34;, buf);
  } /* end while */
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45688"></a>
<div class="props_rev_3"><a id="GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D"></a>
<h3 id="ADLOB-GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D" class="sect3">Selecting a LOB Column into a LONG Buffer Using Piecewise Fetch with Callback</h3>
<div>
<div class="section">
<p>This example illustrates selecting a <code class="codeph">LONG</code> column into a LOB buffer when using a piecewise fetch with callback:</p>
<pre dir="ltr">char buf[5000];
void callback_fetch()
{
  word outpos = 1;
  text *sqlstmt = (text *) &#34;SELECT Ad_sourcetext FROM Print_media WHERE
                  Product_id = 2004 AND Ad_id = 3&#34;;
  
  OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  OCIDefineByPos(stmthp, &amp;dfnhp[0], errhp, (ub4) 1,
                 (dvoid *) 0, (sb4)3 * sizeof(buf), SQLT_CHR,
                 (dvoid *) 0, (ub2 *)0, (ub2 *)0,
                 (ub4) OCI_DYNAMIC_FETCH);
  
  OCIDefineDynamic(dfnhp[0], errhp, (dvoid *) &amp;outpos,
                   (OCICallbackDefine) fetch_cbk);
 
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0,
                 (ub4) OCI_DEFAULT);
  buf[ 4999 ] = &#39;\0&#39;;
  printf(&#34;Select callback: Last piece: %s\n&#34;, buf);
}
 
/* -------------------------------------------------------------- */
/* Fetch callback to specify buffers. */
/* -------------------------------------------------------------- */
static sb4 fetch_cbk(dvoid *ctxp, OCIDefine *dfnhp, ub4 iter, dvoid **bufpp, 
                      ub4 **alenpp, ub1 *piecep, dvoid **indpp, ub2 **rcpp)
{
  static int a = 0;
  ub4 outpos = *((ub4 *)ctxp);
  ub4 len = 5000;
  switch(outpos)
  {
  case 1:
    a ++;
    *bufpp = (dvoid *) buf;
    *alenpp = &amp;len;
    break;
  default:
    *bufpp = (dvoid *) 0;
    *alenpp = (ub4 *) 0;
    printf(&#34;ERROR: invalid position number: %d\n&#34;, outpos);
  }
  *indpp = (dvoid *) 0;
  *rcpp = (ub2 *) 0;
 
  buf[len] = &#39;\0&#39;;
  if (a&lt;=1)
  {
    *piecep = OCI_FIRST_PIECE;
    printf(&#34;Select callback: 0th piece\n&#34;);
  }
  else if (a&lt;3)
  {
    *piecep = OCI_NEXT_PIECE;
    printf(&#34;Select callback: %d&#39;th piece: %s\n&#34;, a-1, buf);
  }
  else {
    *piecep = OCI_LAST_PIECE;
    printf(&#34;Select callback: %d&#39;th piece: %s\n&#34;, a-1, buf);
    a = 0;
  }
  return OCI_CONTINUE;
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADLOB45689"></a>
<div class="props_rev_3"><a id="GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075"></a>
<h3 id="ADLOB-GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075" class="sect3">Selecting a LOB Column into a LONG Buffer Using an Array Fetch</h3>
<div>
<div class="section">
<p>This example illustrates selecting a LOB column into a <code class="codeph">LONG</code> buffer using an array fetch:</p>
<pre dir="ltr">void array_fetch()
{
  word i;
  text arrbuf[5][5000];
  text *selstmt = (text *) &#34;SELECT Ad_sourcetext FROM Print_media WHERE
                  Product_id = 2004 AND Ad_id &gt;=4&#34;;
 
  OCIStmtPrepare(stmthp, errhp, selstmt, (ub4)strlen((char *)selstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
 
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 0, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT);
 
  OCIDefineByPos(stmthp, &amp;defhp1, errhp, (ub4) 1,
                   (dvoid *) arrbuf[0], (sb4) sizeof(arrbuf[0]),
                   (ub2) SQLT_CHR, (dvoid *) 0,
                   (ub2 *) 0, (ub2 *) 0, (ub4) OCI_DEFAULT);
 
  OCIDefineArrayOfStruct(dfnhp1, errhp, sizeof(arrbuf[0]), indsk,
                         rlsk, rcsk);
 
  retval = OCIStmtFetch(stmthp, errhp, (ub4) 5,
                        (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
  if (retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO)
  {
     printf(&#34;%.5000s\n&#34;, arrbuf[0]);
     printf(&#34;%.5000s\n&#34;, arrbuf[1]);
     printf(&#34;%.5000s\n&#34;, arrbuf[2]);
     printf(&#34;%.5000s\n&#34;, arrbuf[3]);
     printf(&#34;%.5000s\n&#34;, arrbuf[4]);
  }
}
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADLOB45690"></a>
<div class="props_rev_3"><a id="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339"></a>
<h2 id="ADLOB-GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339" class="sect2">The Data Interface Used with Persistent LOBs in Java</h2>
<div>
<div class="section">
<p>You can also read and write <code class="codeph">CLOB</code> and <code class="codeph">BLOB</code> data using the same streaming mechanism as for <code class="codeph">LONG</code> and <code class="codeph">LONG</code> <code class="codeph">RAW</code> data.</p>
<p>To read, use <code class="codeph">defineColumnType(nn, Types.LONGVARCHAR)</code> or <code class="codeph">defineColumnType(nn, Types.LONGVARBINARY)</code>on the column. This produces a direct stream on the data as if it is a <code class="codeph">LONG</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> column. For input in a <code class="codeph">PreparedStatement</code>, you may use <code class="codeph">setBinaryStream()</code>, <code class="codeph">setCharacterStream()</code>, or <code class="codeph">setAsciiStream()</code> for a parameter which is a <code class="codeph">BLOB</code> or <code class="codeph">CLOB</code>. These methods use the stream interface to create a LOB in the database from the data in the stream. If the length of the data is known, for better performance, use the versions of <span class="apiname">setBinaryStream()</span> or <span class="apiname">setCharacterStream</span> functions which accept the length parameter. Both of these techniques reduce database round trips and may result in improved performance in some cases. See the Javadoc on stream data for the significant restrictions which apply, at <a href="http://www.oracle.com/technology/" target="_blank"><code class="codeph">http://www.oracle.com/technology/</code></a>.</p>
<p>Refer to the following in the <span class="italic">JDBC Developer&#39;s Guide and Reference</span>:</p>
<div class="infoboxnotealso" id="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339__GUID-289B2555-8963-4A41-8EC1-8908F6358229">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink JJDBC28534" target="_blank" href="../JJDBC/oralob.htm#JJDBC28534"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a>, &#34;Working with LOBs and BFILEs&#34;, section &#34;Data Interface for LOBs&#34;</p>
</li>
<li>
<p><a class="olink JJDBC28082" target="_blank" href="../JJDBC/jdbcvers.htm#JJDBC28082"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a>, &#34;JDBC Standards Support&#34;</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADLOB1323"></a>
<div class="sect2"><a id="GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB"></a>
<h2 id="ADLOB-GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB" class="sect2">The Data Interface Used with Remote LOBs</h2>
<div>
<p>The data interface for insert, update, and select of remote LOBs (access over a <code class="codeph">dblink</code>) is supported after Oracle Database 10<span class="italic">g</span> Release 2.</p>
</div>
<div class="props_rev_3"><a id="GUID-23097695-09B0-4107-9720-FBE4D8283C0F"></a>
<h3 id="ADLOB-GUID-23097695-09B0-4107-9720-FBE4D8283C0F" class="sect3">About the Data Interface with Remote LOBs</h3>
<div>
<p>The examples discussed use the <code class="codeph">print_media</code> table created in two schemas: <code class="codeph">dbs1</code> and <code class="codeph">dbs2</code>. The <code class="codeph">CLOB</code> column of that table used in the examples shown is <code class="codeph">ad_finaltext</code>. The examples to be given for PL/SQL, OCI, and Java use binds and defines for this one column, but multiple columns can also be accessed. Here is the functionality supported and its limitations:</p>
<ul style="list-style-type: disc;">
<li>
<p>You can define a <code class="codeph">CLOB</code> as <code class="codeph">CHAR</code> or <code class="codeph">NCHAR</code> and an <code class="codeph">NCLOB</code> as <span>CHAR or NCHAR</span>. <code class="codeph">CLOB</code> and <code class="codeph">NCLOB</code> can be defined as a <code class="codeph">LONG</code>. A <code class="codeph">BLOB</code> can be defined as a <code class="codeph">RAW</code> or a <code class="codeph">LONG</code> <code class="codeph">RAW</code>.</p>
</li>
<li>
<p>Array binds and defines are supported.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-23097695-09B0-4107-9720-FBE4D8283C0F__GUID-0742C293-8B42-47CC-9D30-ECADB24003F6">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adlob_data_interface.htm#GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33">Remote Data Interface Example in PL/SQL</a>&#34;</span> and the sections following it.</p>
</div>
</div>
</div>
<a id="ADLOB45691"></a>
<div class="props_rev_3"><a id="GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E"></a>
<h3 id="ADLOB-GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E" class="sect3">Non-Supported Syntax</h3>
<div>
<p>Certain syntax is not supported for remote LOBs.</p>
<ul style="list-style-type: disc;">
<li>
<p>Queries involving more than one database are not supported:</p>
<pre dir="ltr">SELECT t1.lobcol, a2.lobcol FROM t1, t2.lobcol@dbs2 a2 WHERE 
LENGTH(t1.lobcol) = LENGTH(a2.lobcol);
</pre>
<p>Neither is this query (in a PL/SQL block):</p>
<pre dir="ltr">SELECT t1.lobcol INTO varchar_buf1 FROM t1@dbs1
UNION ALL
SELECT t2.lobcol INTO varchar_buf2 FROM t2@dbs2;
</pre></li>
<li>
<p>Only binds and defines for data going into remote persistent LOB columns are supported, so that parameter passing in PL/SQL where <code class="codeph">CHAR</code> data is bound or defined for remote LOBs is not allowed because this could produce a remote temporary LOB, which are not supported. These statements all produce errors:</p>
<pre dir="ltr">SELECT foo() INTO varchar_buf FROM table1@dbs2; -- foo returns a LOB

SELECT foo()@dbs INTO char_val FROM DUAL; -- foo returns a LOB

SELECT XMLType().getclobval INTO varchar_buf FROM table1@dbs2;
</pre></li>
<li>
<p>If the remote object is a view such as</p>
<pre dir="ltr">CREATE VIEW v AS SELECT foo() a FROM ... ; -- foo returns a LOB
/* The local database then tries to get the CLOB data and returns an error */
SELECT a INTO varchar_buf FROM v@dbs2;
</pre>
<p>This returns an error because it produces a remote temporary LOB, which is not supported.</p>
</li>
<li>
<p><code class="codeph">RETURNING</code> <code class="codeph">INTO</code> does not support implicit conversions between <code class="codeph">CHAR</code> and <code class="codeph">CLOB</code>.</p>
</li>
<li>
<p>PL/SQL parameter passing is not allowed where the actual argument is a LOB type and the remote argument is a <code class="codeph">VARCHAR2</code>, <code class="codeph">NVARCHAR2</code>, <code class="codeph">CHAR</code>, <code class="codeph">NCHAR</code>, or <code class="codeph">RAW</code>.</p>
</li>
</ul>
</div>
</div>
<a id="ADLOB45692"></a>
<div class="props_rev_3"><a id="GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33"></a>
<h3 id="ADLOB-GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33" class="sect3">Remote Data Interface Example in PL/SQL</h3>
<div>
<p>The data interface only supports data of size less than 32KB in PL/SQL. The following snippet shows a PL/SQL example:</p>
<pre dir="ltr">CONNECT pm
declare
  my_ad <span class="bold">varchar(6000)</span> := lpad(&#39;b&#39;, 6000, &#39;b&#39;);
BEGIN
  INSERT INTO <span class="bold">print_media@dbs2</span>(product_id, ad_id, ad_finaltext) 
       VALUES (10000, 10, my_ad);
  -- Reset the buffer value
  my_ad := &#39;a&#39;;
  SELECT ad_finaltext INTO my_ad FROM <span class="bold">print_media@dbs2</span> 
       WHERE product_id = 10000;
END;
/
</pre>
<p>If <code class="codeph">ad_finaltext</code> were a <code class="codeph">BLOB</code> column instead of a <code class="codeph">CLOB</code>, <code class="codeph">my_ad</code> has to be of type <code class="codeph">RAW</code>. If the LOB is greater than 32KB - 1 in size, then PL/SQL raises a truncation error and the contents of the buffer are undefined.</p>
</div>
</div>
<a id="ADLOB45693"></a>
<div class="props_rev_3"><a id="GUID-0E65F171-0B92-4AC4-8929-B348481C7209"></a>
<h3 id="ADLOB-GUID-0E65F171-0B92-4AC4-8929-B348481C7209" class="sect3">Remote Data Interface Example in OCI</h3>
<div>
<p>The data interface only supports data of size less than <code class="codeph">2 GBytes</code> (the maximum value possible of a variable declared as <code class="codeph">sb4</code>) for OCI. The following pseudocode can be enhanced to be a part of an OCI program:</p>
<pre dir="ltr">...
text *sql = (text *)&#34;insert into <span class="bold">print_media@dbs2</span>
                    (product_id, ad_id, ad_finaltext) 
                    values (:1, :2, :3)&#34;;
OCIStmtPrepare(...);
OCIBindByPos(...); /* Bind data for positions 1 and 2
                     * which are independent of LOB */
OCIBindByPos(stmthp, &amp;bndhp[2], errhp, (ub4) 3, 
             (dvoid *) charbuf1, (sb4) len_charbuf1, <span class="bold">SQLT_CHR</span>, 
             (dvoid *) 0, (ub2 *)0, (ub2 *)0, 0, 0, OCI_DEFAULT);
OCIStmtExecute(...);

...

text *sql = (text *)&#34;select ad_finaltext from <span class="bold">print_media@dbs2</span>
                    where product_id = 10000&#34;;
OCIStmtPrepare(...);
OCIDefineByPos(stmthp, &amp;dfnhp[2], errhp, (ub4) 1, 
             (dvoid *) charbuf2, (sb4) len_charbuf2, <span class="bold">SQLT_CHR</span>, 
             (dvoid *) 0, (ub2 *)0, (ub2 *)0, OCI_DEFAULT);
OCIStmtExecute(...);
...
</pre>
<p>If <code class="codeph">ad_finaltext</code> were a <code class="codeph">BLOB</code> instead of a <code class="codeph">CLOB</code>, then you bind and define using type <code class="codeph">SQLT_BIN</code>. If the LOB is greater than 2GB - 1 in size, then OCI raises a truncation error and the contents of the buffer are undefined.</p>
</div>
</div>
<a id="ADLOB45694"></a>
<div class="props_rev_3"><a id="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB"></a>
<h3 id="ADLOB-GUID-7C8CA747-6873-4679-A316-EA3F078D34AB" class="sect3">Remote Data Interface Examples in JDBC</h3>
<div>
<p>The following code snippets works with all three JDBC drivers (OCI, Thin, and <code class="codeph">kprb</code> in the database):</p>
<p><span class="bold">Bind:</span></p>
<p>This is for the non-streaming mode:</p>
<pre dir="ltr">...
String sql = &#34;insert into <span class="bold">print_media@dbs2</span> (product_id, ad_id, ad_final_text)&#34; +
             &#34; values (:1, :2, :3)&#34;;
    PreparedStatement pstmt = conn.prepareStatement(sql);
    pstmt.setInt( 1, 2 );
    pstmt.setInt( 2, 20);
    <span class="bold">pstmt.setString( 3, &#34;Java string&#34; );</span>
    int rows = pstmt.executeUpdate();
...
</pre>
<p>For the streaming mode, the same code as the preceding works, except that the <code class="codeph">setString()</code> statement is replaced by one of the following:</p>
<pre dir="ltr">pstmt.setCharacterStream( 3, new LabeledReader(), 1000000 );
pstmt.setAsciiStream( 3, new LabeledAsciiInputStream(), 1000000 );
</pre>
<p>Here, <code class="codeph">LabeledReader()</code> and <code class="codeph">LabeledAsciiInputStream()</code> produce character and ASCII streams respectively. If <code class="codeph">ad_finaltext</code> were a <code class="codeph">BLOB</code> column instead of a <code class="codeph">CLOB</code>, then the preceding example works if the bind is of type <code class="codeph">RAW</code>:</p>
<pre dir="ltr">pstmt.setBytes( 3, &lt;some byte[] array&gt; );

pstmt.setBinaryStream( 3, new LabeledInputStream(), 1000000 );
</pre>
<p>Here, <code class="codeph">LabeledInputStream()</code> produces a binary stream.</p>
<p><span class="bold">Define:</span></p>
<p>For non-streaming mode:</p>
<pre dir="ltr">OracleStatement stmt = (OracleStatement)(conn.createStatement());
  stmt.defineColumnType( 1, Types.<span class="bold">VARCHAR</span> );
  ResultSet rst = stmt.executeQuery(&#34;select ad_finaltext from print_media@dbs2&#34; );
  while( rst.next() )
     {
       String s = rst.getString( 1 );
       System.out.println( s );
     }
</pre>
<p>For streaming mode:</p>
<pre dir="ltr">OracleStatement stmt = (OracleStatement)(conn.createStatement());
  stmt.defineColumnType( 1, Types.<span class="bold">LONGVARCHAR</span> );
  ResultSet rst = stmt.executeQuery(&#34;select ad_finaltext from print_media@dbs2&#34; );
  while( rst.next() )
     {
       Reader reader = rst.getCharacterStream( 1 );
       while( reader.ready() )
       {
         System.out.print( (char)(reader.next()) );
       }
       System.out.println();
     }
</pre>
<p>If <code class="codeph">ad_finaltext</code> were a <code class="codeph">BLOB</code> column instead of a <code class="codeph">CLOB</code>, then the preceding examples work if the define is of type <code class="codeph">LONGVARBINARY</code>:</p>
<pre dir="ltr">...
   OracleStatement stmt = (OracleStatement)conn.createStatement();
 
   stmt.defineColumnType( 1, Types.INTEGER );
   stmt.defineColumnType( 2, Types.LONGVARBINARY );
 
   ResultSet rset = stmt.executeQuery(&#34;SELECT ID, LOBCOL FROM LOBTAB@MYSELF&#34;);
 
   while(rset.next())
    {
     /* using getBytes() */
     /*
     byte[] b = rset.getBytes(&#34;LOBCOL&#34;);
     System.out.println(&#34;ID: &#34; + rset.getInt(&#34;ID&#34;) + &#34;  length: &#34; + b.length);
     */
 
        /* using getBinaryStream() */
        InputStream byte_stream = rset.getBinaryStream(&#34;LOBCOL&#34;);
        byte [] b = new byte [100000];
        int b_len = byte_stream.read(b);
        System.out.println(&#34;ID: &#34; + rset.getInt(&#34;ID&#34;) + &#34;  length: &#34; + b_len);
 
        byte_stream.close();
    }
...
</pre>
<div class="infoboxnotealso" id="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB__GUID-2EA17AA0-FC07-4D20-A18F-F949168714A8">
<p class="notep1">See Also:</p>
<p><a class="olink JJDBC15000" target="_blank" href="../JJDBC/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></p>
</div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2782">
<tr>
<td class="cellalignment2794">
<table class="cellalignment2787">
<tr>
<td class="cellalignment2786"><a href="adlob_creating.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2786"><a href="adlob_bfile_ops.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2015, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2796">
<table class="cellalignment2785">
<tr>
<td class="cellalignment2786"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2786"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2786"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2786"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2786"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2786"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>