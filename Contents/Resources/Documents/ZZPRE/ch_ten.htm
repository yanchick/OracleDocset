<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114758"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Using%20Dynamic%20SQL"></a><title>Using Dynamic SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T18:44:39Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Programmer&#39;s Guide to the Oracle Precompilers"/>
<meta name="dcterms.identifier" content="E53283-01"/>
<meta name="dcterms.isVersionOf" content="ZZPRE"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ch_nine.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch_eleven.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53283-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/20</span> <!-- End Header -->
<div id="ZZPRE869" class="chapter"><a id="CHDEFGBC"></a>
<h1 class="chapter"><span class="secnum">10</span> Using Dynamic SQL</h1>
<p>This chapter describes the following sections:</p>
<ul>
<li>
<p><a href="#BCEBBIBA">What Is Dynamic SQL?</a></p>
</li>
<li>
<p><a href="#BCEDIFGB">Advantages and Disadvantages of Dynamic SQL</a></p>
</li>
<li>
<p><a href="#BCEIDECC">When to Use Dynamic SQL</a></p>
</li>
<li>
<p><a href="#BCEDAAEH">Requirements for Dynamic SQL Statements</a></p>
</li>
<li>
<p><a href="#BCEGFFAJ">How Dynamic SQL Statements Are Processed</a></p>
</li>
<li>
<p><a href="#BCEGACEH">Methods for Using Dynamic SQL</a></p>
</li>
<li>
<p><a href="#BCEEEGCA">Using Method 1</a></p>
</li>
<li>
<p><a href="#BCEEGAEB">Using Method 2</a></p>
</li>
<li>
<p><a href="#BCEHIBEF">Using Method 3</a></p>
</li>
<li>
<p><a href="#BCEDGGHH">Using Method 4</a></p>
</li>
<li>
<p><a href="#BCEEEDJI">Using the DECLARE STATEMENT Statement</a></p>
</li>
<li>
<p><a href="#BCEHGACD">Using PL/SQL</a></p>
</li>
</ul>
<p>This chapter shows you how to use dynamic SQL, an advanced programming technique that adds flexibility and functionality to your applications. After weighing the advantages and disadvantages of dynamic SQL, you learn four methods from simple to complex for writing programs that accept and process SQL statements &#34;on the fly&#34; at run time. You learn the requirements and limitations of each method and how to choose the right method for a given job.</p>
<a id="BCEBBIBA"></a>
<div id="ZZPRE870" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">What Is Dynamic SQL?</h2>
<p><a id="sthref1263"></a><a id="sthref1264"></a>Most database applications do a specific job. For example, a simple program might prompt the user for an employee number, then update rows in the EMP and DEPT tables. In this case, you know the makeup of the <code>UPDATE</code> statement at precompile time. That is, you know which tables might be changed, the constraints defined for each table and column, which columns might be updated, and the datatype of each column.</p>
<p>However, some applications must accept (or build) and process a variety of SQL statements at run time. For example, a general-purpose report writer must build different <code>SELECT</code> statements for the various reports it generates. In this case, the statement&#39;s makeup is unknown until run time. Such statements can, and probably will, change from execution to execution. They are aptly called <span class="italic">dynamic</span> SQL statements.</p>
<p>Unlike static SQL statements, dynamic SQL statements are not embedded in your source program. Instead, they are stored in character strings input to or built by the program at run time. They can be entered interactively or read from a file.</p>
</div>
<!-- class="sect1" -->
<a id="BCEDIFGB"></a>
<div id="ZZPRE871" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Advantages and Disadvantages of Dynamic SQL</h2>
<p><a id="sthref1265"></a>Host programs that accept and process dynamically defined SQL statements are more versatile than plain embedded SQL programs. Dynamic SQL statements can be built interactively with input from users having little or no knowledge of SQL.</p>
<p>For example, your program might simply prompt users for a search condition to be used in the <code>WHERE</code> clause of a <code>SELECT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement. A more complex program might allow users to choose from menus listing SQL operations, table and view names, column names, and so on. Thus, dynamic SQL lets you write highly flexible applications.</p>
<p>However, some dynamic queries require complex coding, the use of special data structures, and more run-time processing. While you might not notice the added processing time, you might find the coding difficult unless you fully understand dynamic SQL concepts and methods.</p>
</div>
<!-- class="sect1" -->
<a id="BCEIDECC"></a>
<div id="ZZPRE872" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">When to Use Dynamic SQL</h2>
<p>In practice, static SQL will meet nearly all your programming needs. Use dynamic SQL only if you need its open-ended flexibility. Its use is suggested when one or more of the following items is unknown at precompile time:<a id="sthref1266"></a></p>
<ul>
<li>
<p>Text Of The Sql Statement (Commands, Clauses, And So On)</p>
</li>
<li>
<p>The Number Of Host Variables</p>
</li>
<li>
<p>The Datatypes Of Host Variables</p>
</li>
<li>
<p>References To Database Objects Such As Columns, Indexes, Sequences, Tables, Usernames, And Views</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BCEDAAEH"></a>
<div id="ZZPRE873" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Requirements for Dynamic SQL Statements</h2>
<p><a id="sthref1267"></a>To represent a dynamic SQL statement, a character string must contain the text of a valid SQL statement, but <span class="italic">not</span> contain the EXEC SQL clause, host-language delimiters or statement terminator, or any of the following embedded SQL commands:</p>
<ul>
<li>
<p><code>CLOSE</code></p>
</li>
<li>
<p><code>DECLARE</code></p>
</li>
<li>
<p><code>DESCRIBE</code></p>
</li>
<li>
<p><code>EXECUTE</code></p>
</li>
<li>
<p><code>FETCH</code></p>
</li>
<li>
<p><code>INCLUDE</code></p>
</li>
<li>
<p><code>OPEN</code></p>
</li>
<li>
<p><code>PREPARE</code></p>
</li>
<li>
<p><code>WHENEVER</code></p>
</li>
</ul>
<p><a id="sthref1268"></a>In most cases, the character string can contain <span class="italic"><a id="sthref1269"></a>dummy</span> host variables. They hold places in the SQL statement for actual host variables. Because dummy host variables are just <a id="sthref1270"></a><a id="sthref1271"></a>placeholders, you do not declare them and can name them anything you like. For example, Oracle makes no distinction between the following two strings:</p>
<pre>&#39;DELETE FROM EMP WHERE MGR = :mgr_number AND JOB = :job_title&#39;
&#39;DELETE FROM EMP WHERE MGR = :m AND JOB = :j&#39;
</pre></div>
<!-- class="sect1" -->
<a id="BCEGFFAJ"></a>
<div id="ZZPRE874" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">How Dynamic SQL Statements Are Processed</h2>
<p><a id="sthref1272"></a><a id="sthref1273"></a>Typically, an application program prompts the user for the text of a SQL statement and the values of host variables used in the statement. Then Oracle <span class="italic">parses</span> the SQL statement. That is, Oracle examines the SQL statement to make sure it follows syntax rules and refers to valid database objects. Parsing also involves checking database access rights, reserving needed resources, and finding the optimal access path.</p>
<p><a id="sthref1274"></a><a id="sthref1275"></a>Next, Oracle <span class="italic">binds</span> the host variables to the SQL statement. That is, Oracle gets the addresses of the host variables so that it can read or write their values.</p>
<p>Then Oracle <span class="italic">executes</span> the SQL statement. That is, Oracle does what the SQL statement requested, such as deleting rows from a table.</p>
<p>The SQL statement can be executed repeatedly using new values for the host variables.</p>
</div>
<!-- class="sect1" -->
<a id="BCEGACEH"></a>
<div id="ZZPRE875" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Methods for Using Dynamic SQL</h2>
<p>This section introduces four methods you can use to define dynamic SQL statements. It briefly describes the capabilities and limitations of each method, then offers guidelines for choosing the right method. Later sections describe how to use the methods. In addition, you can find sample host-language programs in your supplement to this Guide.</p>
<p>The four methods are increasingly general. That is, Method 2 encompasses Method 1, Method 3 encompasses Methods 1 and 2, and so on. However, each method is most useful for handling a certain kind of SQL statement, as <a href="#BCEGIJJC">Table 10-1</a> shows.</p>
<div id="ZZPRE876" class="tblformal">
<p class="titleintable"><a id="sthref1276"></a><a id="BCEGIJJC"></a>Table 10-1 Dynamic SQL Method Applicability</p>
<table class="cellalignment3250" title="Dynamic SQL Method Applicability" summary="methods for using dynamic sql" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t2">Method</th>
<th class="cellalignment3246" id="r1c2-t2">Kind of SQL Statement</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t2" headers="r1c1-t2">
<p>1</p>
</td>
<td class="cellalignment3247" headers="r2c1-t2 r1c2-t2">
<p>nonquery without input host variables</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t2" headers="r1c1-t2">
<p>2</p>
</td>
<td class="cellalignment3247" headers="r3c1-t2 r1c2-t2">
<p>nonquery with known number of input host variables</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t2" headers="r1c1-t2">
<p>3</p>
</td>
<td class="cellalignment3247" headers="r4c1-t2 r1c2-t2">
<p>query with known number of select-list items and input host variables</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t2" headers="r1c1-t2">
<p>4</p>
</td>
<td class="cellalignment3247" headers="r5c1-t2 r1c2-t2">
<p>query with unknown number of select-list items or input host variables</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The term <span class="italic">select-list item</span> includes column names and expressions.</p>
<div id="ZZPRE877" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1277"></a>
<h3 class="sect2">Method 1</h3>
<p>This method lets your program accept or build a dynamic SQL statement, then immediately execute it using the <code>EXECUTE</code> <code>IMMEDIATE</code> command. The SQL statement must not be a query (<code>SELECT</code> statement) and must not contain any placeholders for input host variables. For example, the following host strings qualify:</p>
<pre>&#39;DELETE FROM EMP WHERE DEPTNO = 20&#39;
&#39;GRANT SELECT ON EMP TO scott&#39;
</pre>
<p>With Method 1, the SQL statement is parsed every time it is executed (unless you specify <code>HOLD_CURSOR</code>=<code>YES</code>).</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE878" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1278"></a>
<h3 class="sect2">Method 2</h3>
<p>This method lets your program accept or build a dynamic SQL statement, then process it using the <code><a id="sthref1279"></a><a id="sthref1280"></a>PREPARE</code> and <code><a id="sthref1281"></a>EXECUTE</code> commands<a id="sthref1282"></a> .The SQL statement must not be a query. The number of placeholders for input host variables and the datatypes of the input host variables must be known at precompile time. For example, the following host strings fall into this category:</p>
<pre>&#39;INSERT INTO EMP (ENAME, JOB) VALUES (:emp_name, :job_title)&#39;
&#39;DELETE FROM EMP WHERE EMPNO = :emp_number&#39;
</pre>
<p>With Method 2, the SQL statement is parsed just once (unless you specify <code>RELEASE_CURSOR</code>=<code>YES</code>), but it can be executed many times with different values for the host variables. SQL data definition statements such as <code>CREATE</code> are executed when they are <code>PREPARE</code>d.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE879" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1283"></a>
<h3 class="sect2">Method 3</h3>
<p>This method lets your program accept or build a dynamic query, then process it using the PREPARE command with the <code>DECLARE</code>, <code>OPEN</code>, <code>FETCH</code>, and <code>CLOSE</code> cursor commands. The number of select-list items, the number of placeholders for input host variables, and the datatypes of the input host variables must be known at precompile time. For example, the following host strings qualify:</p>
<pre>&#39;SELECT DEPTNO, MIN(SAL), MAX(SAL) FROM EMP GROUP BY DEPTNO&#39;
&#39;SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO = :dept_number&#39;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE880" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1284"></a>
<h3 class="sect2">Method 4</h3>
<p>This method lets your program accept or build a dynamic SQL statement, then process it using descriptors (discussed in &#34;Using Method 4&#34;). The number of select-list items, the number of placeholders for input host variables, and the datatypes of the input host variables can be unknown until run time. For example, the following host strings fall into this category:</p>
<pre>&#39;INSERT INTO EMP (&lt;unknown&gt;) VALUES (&lt;unknown&gt;)&#39;
&#39;SELECT &lt;unknown&gt; FROM EMP WHERE DEPTNO = 20&#39;
</pre>
<p>Method 4 is required for dynamic SQL statements that contain an unknown number of select-list items or input host variables.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE881" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1285"></a>
<h3 class="sect2">Guidelines</h3>
<p><a id="sthref1286"></a><a id="sthref1287"></a>With all four methods, you must store the dynamic SQL statement in a character string, which must be a host variable or quoted literal. When you store the SQL statement in the string, omit the keywords EXEC SQL and the statement terminator.</p>
<p><a id="sthref1288"></a>With Methods 2 and 3, the number of placeholders for input host variables and the datatypes of the input host variables must be known at precompile time.</p>
<p>Each succeeding method imposes fewer constraints on your application, but is more difficult to code. As a rule, use the simplest method you can. However, if a dynamic SQL statement is to be executed repeatedly by Method 1, use Method 2 instead to avoid reparsing for each execution.</p>
<p>Method 4 provides maximum flexibility, but requires complex coding and a full understanding of dynamic SQL concepts. In general, use Method 4 only if you cannot use Methods 1, 2, or 3. The decision logic in <a href="#CHDJHDJA">Figure 10-1</a> will help you choose the correct method.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE882" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1289"></a>
<h3 class="sect2">Avoiding Common Errors</h3>
<p>If you use a character array to store the dynamic SQL statement, blank-pad the array before storing the SQL statement. That way, you clear extraneous characters. This is especially important when you reuse the array for different SQL statements. As a rule, always initialize (or reinitialize) the host string before storing the SQL statement.</p>
<p>Do not null-terminate the host string. Oracle does not recognize the null terminator as an end-of-string sentinel. Instead, Oracle treats it as part of the SQL statement.</p>
<p>If you use a <code>VARCHAR</code> variable to store the dynamic SQL statement, make sure the length of the <code>VARCHAR</code> is set (or reset) correctly before you execute the PREPARE or <code>EXECUTE</code> <code>IMMEDIATE</code> statement.</p>
<p><code>EXECUTE</code> resets the SQLWARN warning flags in the SQLCA. So, to catch mistakes such as an unconditional update (caused by omitting a <code>WHERE</code> clause), check the SQLWARN flags after executing the <code>PREPARE</code> statement but before executing the <code>EXECUTE</code> statement.</p>
<div id="ZZPRE883" class="figure">
<p class="titleinfigure"><a id="CHDJHDJA"></a>Figure 10-1 Choosing the Right Method</p>
<img width="536" height="650" src="img/image013.gif" alt="Choosing the right method"/><br/>
<a id="sthref1290" href="img_text/image013.htm">Description of &#34;Figure 10-1 Choosing the Right Method&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BCEEEGCA"></a>
<div id="ZZPRE884" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Method 1</h2>
<p><a id="sthref1291"></a>The simplest kind of dynamic SQL statement results only in &#34;success&#34; or &#34;failure&#34; and uses no host variables. Some examples follow:</p>
<pre>&#39;DELETE FROM table_name WHERE column_name = constant&#39;
&#39;CREATE TABLE table_name ...&#39;
&#39;DROP INDEX index_name&#39;
&#39;UPDATE table_name SET column_name = constant&#39;
&#39;GRANT SELECT ON table_name TO username&#39;
&#39;REVOKE RESOURCE FROM username&#39;
</pre>
<div id="ZZPRE885" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1292"></a>
<h3 class="sect2">The EXECUTE IMMEDIATE Statement</h3>
<p><a id="sthref1293"></a> Method 1 parses, then immediately executes the SQL statement using the <code>EXECUTE</code> <code>IMMEDIATE</code> command. The command is followed by a character string (host variable or literal) containing the SQL statement to be executed, which cannot be a query.</p>
<p><a id="sthref1294"></a>The syntax of the <code>EXECUTE</code> <code>IMMEDIATE</code> statement follows:</p>
<pre>EXEC SQL EXECUTE IMMEDIATE { :host_string | string_literal };
</pre>
<p><a id="sthref1295"></a>In the following example, you use the host variable <span class="italic">sql_stmt</span> to store SQL statements input by the user:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 ...
 sql_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
...
LOOP
 display &#39;Enter SQL statement: &#39;;
 read sql_stmt;
 IF sql_stmt is empty THEN
 exit loop;
 ENDIF;
 -- sql_stmt now contains the text of a SQL statement
 EXEC SQL EXECUTE IMMEDIATE :sql_stmt;
ENDLOOP;
</pre>
<p>You can also use string literals, as the following example shows:</p>
<pre>EXEC SQL EXECUTE IMMEDIATE &#39;REVOKE RESOURCE FROM MILLER&#39;;
</pre>
<p>Because EXECUTE IMMEDIATE parses the input SQL statement before every execution, Method 1 is best for statements that are executed only once. Data definition statements usually fall into this category.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE886" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1296"></a>
<h3 class="sect2">An Example</h3>
<p><a id="sthref1297"></a>The following program prompts the user for a search condition to be used in the <code>WHERE</code> clause of an <code>UPDATE</code> statement, then executes the statement using Method 1:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 update_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
 search_cond CHARACTER(40);
EXEC SQL INCLUDE SQLCA;
display &#39;Username? &#39;;
read username;
display &#39;Password? &#39;;
read password;
EXEC SQL WHENEVER SQLERROR GOTO sql_error;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display &#39;Connected to Oracle&#39;;
set update_stmt = &#39;UPDATE EMP SET COMM = 500 WHERE &#39;;
display &#39;Enter a search condition for the following statement:&#39;;
display update_stmt;
read search_cond;
concatenate update_stmt, search_cond;
EXEC SQL EXECUTE IMMEDIATE :update_stmt;
EXEC SQL COMMIT WORK RELEASE;
exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display &#39;Processing error&#39;;
 exit program with an error;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BCEEGAEB"></a>
<div id="ZZPRE887" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Method 2<a id="sthref1298"></a></h2>
<p><a id="sthref1299"></a>What Method 1 does in one step, Method 2 does in two. The dynamic SQL statement, <a id="sthref1300"></a>which cannot be a query, is first <code>PREPARE</code>d (named and parsed), then executed.</p>
<p><a id="sthref1301"></a>With Method 2, the SQL statement can contain <a id="sthref1302"></a>placeholders for input host variables and indicator variables. You can <code>PREPARE</code> the SQL statement once, then <code>EXECUTE</code> it repeatedly using different values of the host variables. Also, you need <span class="italic">not</span> rePREPARE the SQL statement after a <code>COMMIT</code> or <code>ROLLBACK</code> (unless you log off and reconnect).</p>
<p>Note that you can use <code>EXECUTE</code> for nonqueries with Method 4.</p>
<p>The syntax of the <code>PREPARE</code> statement follows:</p>
<pre>EXEC SQL PREPARE statement_name
 FROM { :host_string | string_literal };
</pre>
<p><code>PREPARE</code> parses the SQL statement and gives it a name.</p>
<p>The <span class="italic">statement_name</span> is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be declared in the Declare Section. It simply designates the <code>PREPAREd</code> statement you want to <code>EXECUTE</code>.</p>
<p>The syntax of the <code>EXECUTE</code> statement is</p>
<pre>EXEC SQL EXECUTE statement_name [USING host_variable_list];
</pre>
<p>where <span class="italic">host_variable_list</span> stands for the following syntax:</p>
<pre>:host_variable1[:indicator1] [, host_variable2[:indicator2], ...]
</pre>
<p><code>EXECUTE</code> executes the parsed SQL statement, using the values supplied for each input host variable. In the following example, the input SQL statement contains the placeholder <span class="italic">n</span>:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 ...
 emp_number INTEGER;
 delete_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
 search_cond CHARACTER(40);
...
set delete_stmt = &#39;DELETE FROM EMP WHERE EMPNO = :n AND &#39;;
display &#39;Complete the following statement&#39;s search condition:&#39;;
display delete_stmt;
read search_cond;
concatenate delete_stmt, search_cond;
EXEC SQL PREPARE sql_stmt FROM :delete_stmt;
LOOP
 display &#39;Enter employee number: &#39;;
 read emp_number;
 IF emp_number = 0 THEN
 exit loop;
 EXEC SQL EXECUTE sql_stmt USING :emp_number;
ENDLOOP;
</pre>
<p>With Method 2, you must know the datatypes of input host variables at precompile time. In the last example, <span class="italic">emp_number</span> was declared as type <code>INTEGER</code>. It could also have been declared as type <code>CHARACTER</code> or <code>REAL</code>, because Oracle supports all these datatype conversions to the <code>NUMBER</code> datatype.</p>
<div id="ZZPRE888" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1303"></a>
<h3 class="sect2">The <a id="sthref1304"></a>USING Clause</h3>
<p>When the SQL statement is <code>EXECUTEd</code>, input host variables in the <code>USING</code> clause replace corresponding placeholders in the <code>PREPAREd</code> dynamic SQL statement.</p>
<p>Every placeholder in the PREPAREd dynamic SQL statement must correspond to a host variable in the <code>USING</code> clause. So, if the same placeholder appears two or more times in the <code>PREPAREd</code> statement, each appearance must correspond to a host variable in the <code>USING</code> clause. If one of the host variables in the <code>USING</code> clause is an array, all must be arrays.</p>
<p><a id="sthref1305"></a>The names of the placeholders need not match the names of the host variables. However, the order of the placeholders in the <code>PREPAREd</code> dynamic SQL statement must match the order of corresponding host variables in the <code>USING</code> clause.</p>
<p><a id="sthref1306"></a>To specify nulls, you can associate indicator variables with host variables in the <code>USING</code> clause. For more information, refer to <a href="ch_four.htm#BABCFFHH">&#34;Using Indicator Variables&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE889" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1307"></a>
<h3 class="sect2">An Example</h3>
<p><a id="sthref1308"></a>The following program prompts the user for a search condition to be used in the <code>WHERE</code> clause of an <code>UPDATE</code> statement, then prepares and executes the statement using Method 2. Notice that the <code>SET</code> clause of the <code>UPDATE</code> statement contains a placeholder (<span class="italic">c</span>).</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 sql_stmt CHARACTER(80);
 empno INTEGER VALUE 1234;
 deptno1 INTEGER VALUE 97;
 deptno2 INTEGER VALUE 99;
EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE SQLCA;
EXEC ORACLE OPTION (ORACA=YES);
EXEC SQL WHENEVER SQLERROR GOTO sql_error;
display &#39;Username? &#39;;
read username;
display &#39;Password? &#39;;
read password;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display &#39;Connected to Oracle&#39;;
set sql_stmt = 
 &#39;INSERT INTO EMP (EMPNO, DEPTNO) VALUES (:v1, :v2)&#39;;
display &#34;V1 = &#34;, empno, &#34;V2 = &#34;, deptno1;
EXEC SQL PREPARE S FROM :sql_stmt;
EXEC SQL EXECUTE S USING :empno, :deptno1;
set empno = empno + 1;
display &#34;V1 = &#34;, empno, &#34;V2 = &#34;, deptno2;
EXEC SQL EXECUTE S USING :empno, :deptno2;
set sql_stmt = 
 &#39;DELETE FROM EMP WHERE DEPTNO = :v1 OR DEPTNO = :v2&#34;)&#39;;
display &#34;V1 = &#34;, deptno1, &#34;V2 = &#34;, deptno2;
EXEC SQL PREPARE S FROM :sql_stmt;
EXEC SQL EXECUTE S USING :deptno1, :deptno2;
EXEC SQL COMMIT WORK RELEASE;
exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 display &#39;Processing error&#39;;
 EXEC SQL ROLLBACK WORK RELEASE;
 exit program with an error;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BCEHIBEF"></a>
<div id="ZZPRE890" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Method 3</h2>
<p><a id="sthref1309"></a>Method 3 is similar to Method 2<a id="sthref1310"></a> but combines the <code>PREPARE</code> statement with the statements needed to define and manipulate a cursor. This allows your program to accept and process queries. In fact, if the dynamic SQL statement is a query, you <span class="italic">must</span> use Method 3 or 4.</p>
<p><a id="sthref1311"></a>For Method 3, the number of columns in the query select list and the number of placeholders for input host variables must be known at precompile time. However, the names of database objects such as tables and columns need not be specified until run time (they cannot duplicate the names of host variables). Clauses that limit, group, and sort query results (such as <code>WHERE</code>, <code>GROUP</code> <code>BY</code>, and <code>ORDER</code> <code>BY</code>) can also be specified at run time.</p>
<p>With Method 3, you use the following sequence of embedded SQL statements:</p>
<pre>PREPARE statement_name FROM { :host_string | string_literal };
DECLARE cursor_name CURSOR FOR statement_name;
OPEN cursor_name [USING host_variable_list];
FETCH cursor_name INTO host_variable_list;
CLOSE cursor_name;
</pre>
<p>Now let us look at what each statement does.</p>
<div id="ZZPRE891" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1312"></a>
<h3 class="sect2"><a id="sthref1313"></a>PREPARE</h3>
<p><a id="sthref1314"></a><code>PREPARE</code> parses the dynamic SQL statement and gives it a name. In the following example, <code>PREPARE</code> parses the query stored in the character string <span class="italic">select_stmt</span> and gives it the name <span class="italic">sql_stmt</span>:</p>
<pre>set select_stmt = &#39;SELECT MGR, JOB FROM EMP WHERE SAL &lt; :salary&#39;;
EXEC SQL PREPARE sql_stmt FROM :select_stmt;
</pre>
<p>Commonly, the query <code>WHERE</code> clause is input from a terminal at run time or is generated by the application.</p>
<p>The identifier <span class="italic">sql_stmt</span> is <span class="italic">not</span> a host or program variable, but must be unique. It designates a particular dynamic SQL statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE892" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1315"></a>
<h3 class="sect2">DECLARE</h3>
<p><code><a id="sthref1316"></a><a id="sthref1317"></a>DECLARE</code> defines a cursor by giving it a name and associating it with a specific query. The cursor declaration is local to its precompilation unit. Continuing our example, <code>DECLARE</code> defines a cursor named <span class="italic">emp_cursor</span> and associates it with <span class="italic">sql_stmt</span>, as follows:</p>
<pre><a id="sthref1318"></a>EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
</pre>
<p>The identifiers <span class="italic">sql_stmt</span> and <span class="italic">emp_cursor</span> are <span class="italic">not</span> host or program variables, but must be unique. If you declare two cursors using the same statement name, the precompiler considers the two cursor names synonymous. For example, if you execute the statements</p>
<pre>EXEC SQL PREPARE sql_stmt FROM :select_stmt;
EXEC SQL DECLARE emp_cursor FOR sql_stmt;
EXEC SQL PREPARE sql_stmt FROM :delete_stmt;
EXEC SQL DECLARE dept_cursor FOR sql_stmt;
</pre>
<p>when you OPEN <span class="italic">emp_cursor</span>, you will process the dynamic SQL statement stored in <span class="italic">delete_stmt</span>, not the one stored in <span class="italic">select_stmt.</span></p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE893" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1319"></a>
<h3 class="sect2"><a id="sthref1320"></a>OPEN</h3>
<p><a id="sthref1321"></a><code>OPEN</code> allocates an Oracle cursor, binds input host variables, and executes the query, identifying its active set. OPEN also positions the cursor on the first row in the active set and zeroes the rows-processed count kept by the third element of SQLERRD in the SQLCA. Input host variables in the USING clause replace corresponding placeholders in the <code>PREPAREd</code> dynamic SQL statement.</p>
<p>In our example, <code>OPEN</code> allocates <span class="italic">emp_cursor</span> and assigns the host variable <span class="italic">salary</span> to the <code>WHERE</code> clause, as follows:</p>
<pre>EXEC SQL OPEN emp_cursor USING :salary;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE894" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1322"></a>
<h3 class="sect2">FETCH</h3>
<p><code><a id="sthref1323"></a>FETCH</code> returns a row from the active set, assigns column values in the select list to corresponding host variables in the <code>INTO</code> clause, and advances the cursor to the next row. When no more rows are found, <code>FETCH</code> returns the &#34;no data found&#34; Oracle error code to SQLCODE in the SQLCA.</p>
<p><a id="sthref1324"></a> In our example, FETCH returns a row from the active set and assigns the values of columns MGR and JOB to host variables <span class="italic">mgr_number</span> and <span class="italic">job_title</span>, as follows:</p>
<pre>EXEC SQL FETCH emp_cursor INTO :mgr_number, :job_title;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE895" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1325"></a>
<h3 class="sect2">CLOSE</h3>
<p><code>CLOSE</code> disables the cursor. After you <code>CLOSE</code> a cursor, you can no longer <code>FETCH</code> from it. In our example, the <code>CLOSE</code> statement disables <span class="italic">emp_cursor</span>, as follows:</p>
<pre>EXEC SQL CLOSE emp_cursor;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE896" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1326"></a>
<h3 class="sect2">An Example</h3>
<p><a id="sthref1327"></a>The following program prompts the user for a search condition to be used in the <code>WHERE</code> clause of a query, then prepares and executes the query using Method 3.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 dept_number INTEGER;
 emp_name CHARACTER(10);
 salary REAL;
 select_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
 search_cond CHARACTER(40);
EXEC SQL INCLUDE SQLCA;
display &#39;Username? &#39;;
read username;
display &#39;Password? &#39;;
read password;
EXEC SQL WHENEVER SQLERROR GOTO sql_error;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display &#39;Connected to Oracle&#39;;
set select_stmt = &#39;SELECT ENAME,SAL FROM EMP WHERE &#39;;
display &#39;Enter a search condition for the following statement:&#39;;
display select_stmt;
read search_cond;
concatenate select_stmt, search_cond;
EXEC SQL PREPARE sql_stmt FROM :select_stmt;
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND GOTO no_more;
display &#39;Employee Salary&#39;;
display &#39;-------- ------&#39;;
LOOP
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;
 display emp_name, salary;
ENDLOOP;
no_more:
 EXEC SQL CLOSE emp_cursor;
 EXEC SQL COMMIT WORK RELEASE;
 exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 exit program with an error;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BCEDGGHH"></a>
<div id="ZZPRE897" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using <a id="sthref1328"></a>Method 4</h2>
<p><a id="sthref1329"></a>The implementation of Method 4 is very language-dependent. Therefore, this section only gives an overview. For details, see your host-language supplement.</p>
<p>There is a kind of dynamic SQL statement that your program cannot process using Method 3. When the number of select-list items or placeholders for input host variables is unknown until run time, your program must use a descriptor. A <a id="sthref1330"></a><span class="italic">descriptor</span> is an area of memory used by your program and Oracle to hold a complete description of the variables in a dynamic SQL statement.</p>
<p><a id="sthref1331"></a>Recall that for a multirow query, you <code>FETCH</code> selected column values <code>INTO</code> a list of declared output host variables. If the select list is unknown, the host-variable list cannot be established at precompile time by the <code>INTO</code> clause. For example, you know the following query returns two column values:</p>
<pre>SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO = :dept_number;
</pre>
<p>However, if you let the user define the select list, you might not know how many column values the query will return.</p>
<div id="ZZPRE898" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1332"></a>
<h3 class="sect2">Need for the SQLDA</h3>
<p><a id="sthref1333"></a>To process this kind of dynamic query, your program must issue the <code>DESCRIBE</code> <code>SELECT</code> <code>LIST</code> command and declare a data structure called the SQL Descriptor Area <a id="sthref1334"></a>(SQLDA). Because it holds descriptions of columns in the query select list, this structure is also called a <span class="italic">select descriptor</span>.</p>
<p>Likewise, if a dynamic SQL statement contains an unknown number of placeholders for input host variables, the host-variable list cannot be established at precompile time by the <code>USING</code> clause.</p>
<p><a id="sthref1335"></a>To process the dynamic SQL statement, your program must issue the <code>DESCRIBE</code> <code>BIND</code> <code>VARIABLES</code> command and declare another kind of SQLDA called a <span class="italic">bind <a id="sthref1336"></a>descriptor</span> to hold descriptions of the placeholders for the input host variables. (Input host variables are also called <span class="italic">bind variables</span>.)</p>
<p>If your program has more than one active SQL statement (it might have OPENed two or more cursors, for example), each statement must have its own SQLDA(s). However, non-concurrent cursors can reuse SQLDAs. There is no set limit on the number of SQLDAs in a program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE899" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1337"></a>
<h3 class="sect2">The DESCRIBE Statement</h3>
<p><a id="sthref1338"></a>DESCRIBE initializes a descriptor to hold descriptions of select-list items or input host variables.<a id="sthref1339"></a></p>
<p>If you supply a select descriptor, the <code>DESCRIBE</code> <code>SELECT</code> <code>LIST</code> statement examines each select-list item in a <code>PREPAREd</code> dynamic query to determine its name, datatype, constraints, length, scale, and precision. It then stores this information in the select descriptor.</p>
<p>If you supply a bind descriptor, the <code>DESCRIBE</code> <code>BIND</code> <code>VARIABLES</code> statement examines each placeholder in a <code>PREPAREd</code> dynamic SQL statement to determine its name, length, and the datatype of its associated input host variable. It then stores this information in the bind descriptor for your use. For example, you might use placeholder names to prompt the user for the values of input host variables.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE900" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1340"></a>
<h3 class="sect2">What Is a SQLDA?</h3>
<p>A SQLDA is a host-program data structure that holds descriptions of select-list items or input host variables.</p>
<p>SQLDA variables are <span class="italic">not</span> defined in the Declare Section.</p>
<p>Though SQLDAs differ among host languages, a generic select SQLDA contains the following information about a query select list:</p>
<ul>
<li>
<p>Maximum number of columns that can be described</p>
</li>
<li>
<p>Actual number of columns found by describe</p>
</li>
<li>
<p>Addresses of buffers to store column values</p>
</li>
<li>
<p>Lengths of column values</p>
</li>
<li>
<p>Datatypes of column values</p>
</li>
<li>
<p>addresses of indicator-variable values</p>
</li>
<li>
<p>Addresses of buffers to store column names</p>
</li>
<li>
<p>Sizes of buffers to store column names</p>
</li>
<li>
<p>Current lengths of column names</p>
</li>
</ul>
<p>A generic bind SQLDA contains the following information about the input host variables in a SQL statement:</p>
<ul>
<li>
<p>Maximum number of placeholders that can be described</p>
</li>
<li>
<p>Actual number of placeholders found by describe</p>
</li>
<li>
<p>Addresses of input host variables</p>
</li>
<li>
<p>Lengths of input host variables</p>
</li>
<li>
<p>Datatypes of input host variables</p>
</li>
<li>
<p>Addresses of indicator variables</p>
</li>
<li>
<p>Addresses of buffers to store placeholder names</p>
</li>
<li>
<p>Sizes of buffers to store placeholder names</p>
</li>
<li>
<p>Current lengths of placeholder names</p>
</li>
<li>
<p>Addresses of buffers to store indicator-variable names</p>
</li>
<li>
<p>Sizes of buffers to store indicator-variable names</p>
</li>
<li>
<p>Current lengths of indicator-variable names</p>
</li>
</ul>
<p>To see the SQLDA structure and variable names in a particular host language, refer to your host-language supplement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE901" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1341"></a>
<h3 class="sect2">Implementing Method 4</h3>
<p>With Method 4, you generally use the following sequence of embedded SQL statements:</p>
<pre>EXEC SQL PREPARE statement_name
 FROM { :host_string | string_literal };
EXEC SQL DECLARE cursor_name CURSOR FOR statement_name;
EXEC SQL DESCRIBE BIND VARIABLES FOR statement_name
 INTO bind_descriptor_name;
EXEC SQL OPEN cursor_name
 [USING DESCRIPTOR bind_descriptor_name];
EXEC SQL DESCRIBE [SELECT LIST FOR] statement_name
 INTO select_descriptor_name;
EXEC SQL FETCH cursor_name
 USING DESCRIPTOR select_descriptor_name;
EXEC SQL CLOSE cursor_name;
</pre>
<p>Select and bind descriptors need not work in tandem. If the number of columns in a query select list is known, but the number of placeholders for input host variables is unknown, you can use the Method 4 <code>OPEN</code> statement with the following Method 3 <code>FETCH</code> statement:</p>
<pre>EXEC SQL FETCH emp_cursor INTO host_variable_list;
</pre>
<p>Conversely, if the number of placeholders for input host variables is known, but the number of columns in the select list is unknown, you can use the following Method 3 <code>OPEN</code> statement with the Method 4 <code>FETCH</code> statement:</p>
<pre>EXEC SQL OPEN cursor_name [USING host_variable_list];
</pre>
<p>Note that <code>EXECUTE</code> can be used for nonqueries with Method 4.</p>
<p>To learn how these statements allow your program to process dynamic SQL statements using descriptors, see your host-language supplement.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BCEEEDJI"></a>
<div id="ZZPRE902" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the DECLARE STATEMENT Statement</h2>
<p><a id="sthref1342"></a>With Methods 2, 3, and 4, you might need to use the statement</p>
<pre>EXEC SQL [AT db_name] DECLARE statement_name STATEMENT;
</pre>
<p>where <span class="italic">db_name</span> and <span class="italic">statement_name</span> are identifiers used by the precompiler, <span class="italic">not</span> host or program variables.</p>
<p><code>DECLARE</code> <code>STATEMENT</code> declares the name of a dynamic SQL statement so that the statement can be referenced by <code>PREPARE</code>, <code>EXECUTE</code>, <code>DECLARE</code> <code>CURSOR</code>, and <code>DESCRIBE</code>. It is <a id="sthref1343"></a>required if you want to execute the dynamic SQL statement at a nondefault database. An example using Method 2 follows:</p>
<pre>EXEC SQL AT remote_db DECLARE sql_stmt STATEMENT;
EXEC SQL PREPARE sql_stmt FROM :sql_string;
EXEC SQL EXECUTE sql_stmt;
</pre>
<p>In the example, <span class="italic">remote_db</span> tells Oracle where to <code>EXECUTE</code> the SQL statement.</p>
<p><a id="sthref1344"></a>With Methods <a id="sthref1345"></a>3 and <a id="sthref1346"></a>4, <code>DECLARE</code> <code>STATEMENT</code> is also required if the DECLARE <code>CURSOR</code> statement precedes the PREPARE statement, as shown in the following example:</p>
<pre>EXEC SQL DECLARE sql_stmt STATEMENT;
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
EXEC SQL PREPARE sql_stmt FROM :sql_string;
</pre>
<p>The usual sequence of statements is</p>
<pre>EXEC SQL PREPARE sql_stmt FROM :sql_string;
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
</pre>
<div id="ZZPRE903" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1347"></a>
<h3 class="sect2">Usage of Host Arrays</h3>
<p><a id="sthref1348"></a><a id="sthref1349"></a>Usage of host arrays in static and dynamic SQL is similar. For example, to use input host arrays with dynamic SQL Method 2, use the syntax</p>
<pre>EXEC SQL EXECUTE statement_name USING host_array_list;
</pre>
<p>where <span class="italic">host_array_list</span> contains one or more host arrays. With Method 3, use the following syntax:</p>
<pre>OPEN cursor_name USING host_array_list;
</pre>
<p>To use output host arrays with Method 3, use the following syntax:</p>
<pre>FETCH cursor_name INTO host_array_list;
</pre>
<p>With Method 4, you must use the optional FOR clause to tell Oracle the size of your input or output host array. To learn how this is done, see your host-language supplement.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BCEHGACD"></a>
<div id="ZZPRE904" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using PL/SQL</h2>
<p><a id="sthref1350"></a>The Oracle Precompilers treat a PL/SQL block like a single SQL statement. So, like a <a id="sthref1351"></a>SQL statement, a PL/SQL block can be stored in a string host variable or literal. When you store the PL/SQL block in the string, omit the keywords EXEC SQL <code>EXECUTE</code>, the keyword END-EXEC, and the statement terminator.</p>
<p>However, there are two differences in the way the precompiler handles SQL and PL/SQL:</p>
<ul>
<li>
<p>The precompiler treats all PL/SQL host variables as <span class="italic">input</span> host variables whether they serve as input or output host variables (or both) inside the PL/SQL block.</p>
</li>
<li>
<p>You cannot FETCH from a PL/SQL block because it might contain any number of SQL statements.</p>
</li>
</ul>
<div id="ZZPRE905" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1352"></a>
<h3 class="sect2">With Method 1</h3>
<p><a id="sthref1353"></a>If the PL/SQL block contains no host variables, you can use Method 1 to <code>EXECUTE</code> the PL/SQL string in the usual way.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE906" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1354"></a>
<h3 class="sect2">With Method 2</h3>
<p><a id="sthref1355"></a>If the PL/SQL block contains a known number of input and output host variables, you can use Method 2 to <code>PREPARE</code> and <code>EXECUTE</code> the PL/SQL string in the usual way.</p>
<p>You must put <span class="italic">all</span> host variables in the USING clause. When the PL/SQL string is <code>EXECUTEd</code>, host variables in the USING clause replace corresponding placeholders in the <code>PREPAREd</code> string. Though the precompiler treats all PL/SQL host variables as input host variables, values are assigned correctly. Input (program) values are assigned to input host variables, and output (column) values are assigned to output host variables.</p>
<p>Every placeholder in the <code>PREPAREd</code> PL/SQL string must correspond to a host variable in the <code>USING</code> clause. So, if the same placeholder appears two or more times in the <code>PREPAREd</code> string, each appearance must correspond to a host variable in the USING clause.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE907" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1356"></a>
<h3 class="sect2">With Method 3</h3>
<p><a id="sthref1357"></a>Methods 2 and 3 are the same except that Method 3 allows <code>FETCHing</code>. Since you cannot <code>FETCH</code> from a PL/SQL block, use Method 2 instead.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE908" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1358"></a>
<h3 class="sect2">With Method 4</h3>
<p><a id="sthref1359"></a>If the PL/SQL block contains an unknown number of input or output host variables, you must use Method 4.</p>
<p>To use Method 4, you set up one bind descriptor for all the input and output host variables. Executing <code>DESCRIBE</code> <code>BIND</code> <code>VARIABLES</code> stores information about input <span class="italic">and</span> output host variables in the bind descriptor. Because the precompiler treats all PL/SQL host variables as input host variables, executing <code>DESCRIBE</code> <code>SELECT</code> <code>LIST</code> has no effect.</p>
<p>The use of bind descriptors with Method 4 is detailed in your host-language supplement.</p>
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
In dynamic SQL Method 4, a host array cannot be bound to a PL/SQL procedure with a parameter of type &#34;table.&#34;</div>
</div>
<!-- class="sect2" -->
<div id="ZZPRE909" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1360"></a>
<h3 class="sect2">Caution</h3>
<p><a id="sthref1361"></a>Do not use ANSI-style comments (- - ...) in a PL/SQL block that will be processed dynamically because end-of-line characters are ignored. As a result, ANSI-style comments extend to the end of the block, not just to the end of a line. Instead, use C-style comments (/* ... */).</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3238">
<tr>
<td class="cellalignment3247">
<table class="cellalignment3243">
<tr>
<td class="cellalignment3242"><a href="ch_nine.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3242"><a href="ch_eleven.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3249">
<table class="cellalignment3241">
<tr>
<td class="cellalignment3242"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3242"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3242"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3242"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3242"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3242"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>