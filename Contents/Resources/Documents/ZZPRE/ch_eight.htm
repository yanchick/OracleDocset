<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114750"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Error%20Handling%20and%20Diagnostics"></a><title>Error Handling and Diagnostics</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T18:44:39Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Programmer&#39;s Guide to the Oracle Precompilers"/>
<meta name="dcterms.identifier" content="E53283-01"/>
<meta name="dcterms.isVersionOf" content="ZZPRE"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ch_seven.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch_nine.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53283-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/20</span> <!-- End Header -->
<div id="ZZPRE754" class="chapter"><a id="BABJDJGJ"></a>
<h1 class="chapter"><span class="secnum">8</span> Error Handling and Diagnostics</h1>
<ul>
<li>
<p><a href="#CEGBFFEF">The Need for Error Handling</a></p>
</li>
<li>
<p><a href="#CEGJICIG">Error Handling Alternatives</a></p>
</li>
<li>
<p><a href="#CEGJDGDH">Using Status Variables when MODE={ANSI|ANSI14}</a></p>
</li>
<li>
<p><a href="#BABIGBFF">Using the SQL Communications Area</a></p>
</li>
<li>
<p><a href="#CEGJHAHF">Using the Oracle Communications Area</a></p>
</li>
</ul>
<p>An application program must anticipate run-time errors and attempt to recover from them. This chapter provides an in-depth discussion of error reporting and recovery. You learn how to handle warnings and errors using the status variables SQLCODE, SQLSTATE, SQLCA (SQL Communications Area), and the <code>WHENEVER</code> statement. You also learn how to diagnose problems by using the status variable ORACA (Oracle Communications Area). The following topics are discussed:</p>
<ul>
<li>
<p>The need for error handling</p>
</li>
<li>
<p>Error handling alternatives</p>
</li>
<li>
<p>Using status variables when MODE={ANSI|ANSI14}</p>
</li>
<li>
<p>Using the SQL Communications Area</p>
</li>
<li>
<p>Using the Oracle Communications Area</p>
</li>
</ul>
<a id="CEGBFFEF"></a>
<div id="ZZPRE755" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The Need for Error Handling</h2>
<p><a id="sthref983"></a>A significant part of every application program must be devoted to error handling. The main benefit of error handling is that it allows your program to continue operating in the presence of errors. Errors arise from design faults, coding mistakes, hardware failures, invalid user input, and many other sources</p>
<p>You cannot anticipate all possible errors, but you can plan to handle certain kinds of errors meaningful to your program. For the Oracle Precompilers, error handling means detecting and recovering from SQL statement execution errors.</p>
<p>You can also prepare to handle warnings such as &#34;value truncated&#34; and status changes such as &#34;end of data.&#34; It is especially important to check for error and warning conditions after every data manipulation statement, because an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement might fail before processing all eligible rows in a table.</p>
</div>
<!-- class="sect1" -->
<a id="CEGJICIG"></a>
<div id="ZZPRE756" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Error Handling Alternatives<a id="sthref984"></a></h2>
<p>The Oracle Precompilers provide four status variables that serve as error handling mechanisms:</p>
<ul>
<li>
<p>SQLCODE (SQLCOD in Pro*FORTRAN)</p>
</li>
<li>
<p><a id="sthref985"></a>SQLSTATE (SQLSTA in Pro*FORTRAN)</p>
</li>
<li>
<p>SQLCA (using the WHENEVER statement)</p>
</li>
<li>
<p>ORACA</p>
</li>
</ul>
<p>The MODE option (described ) governs ANSI/ISO compliance. The availability of the SQLCODE, SQLSTATE, and SQLCA variables depends on the MODE setting. You can declare and use the ORACA variable regardless of the MODE setting. For more information, refer to <a href="#CEGJHAHF">Using the Oracle Communications Area</a> .</p>
<p>When <code>MODE={ORACLE|ANSI13}</code>, you must declare the SQLCA status variable. SQLCODE and SQLSTATE declarations are accepted (not recommended) but are not recognized as status variables. For more information, refer to <a href="#BABIGBFF">Using the SQL Communications Area</a>.</p>
<p>When <code>MODE={ANSI|ANSI14}</code>, you can use any one, two, or all three of the SQLCODE, SQLSTATE, and SQLCA variables. To determine which variable (or variable combination) is best for your application, refer to <a href="#CEGJDGDH">Using Status Variables when MODE={ANSI|ANSI14}</a>&#34; .</p>
<a id="CEGDFHIJ"></a>
<div id="ZZPRE757" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQLCODE and SQLSTATE</h3>
<p>With Release 1.5 of the Oracle Precompilers, the SQLCODE status variable was introduced as the SQL89 standard ANSI/ISO error reporting mechanism. The SQL92 standard listed SQLCODE as a <a id="sthref986"></a>deprecated feature and defined a new status variable, SQLSTATE (introduced with Release 1.6 of the Oracle Precompilers), as the preferred ANSI/ISO error reporting mechanism.</p>
<p>SQLCODE stores error codes and the &#34;not found&#34; condition. It is retained only for compatibility with SQL89 and is likely to be removed from future versions of the standard.</p>
<p>Unlike SQLCODE, SQLSTATE stores error and warning codes and uses a standardized coding scheme. After executing a SQL statement, the Oracle server returns a status code to the SQLSTATE variable currently in scope. The status code indicates whether a SQL statement executed successfully or raised an exception (error or warning condition). To promote <span class="italic">interoperability</span> (the ability of systems to exchange information easily), SQL92 predefines all the common SQL exceptions.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE758" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref987"></a>
<h3 class="sect2">SQLCA</h3>
<p><a id="sthref988"></a>The SQLCA is a record-like, host-language data structure. Oracle updates the SQLCA after every <span class="italic">executable</span> SQL statement. (SQLCA values are undefined after a declarative statement.) By checking Oracle return codes stored in the SQLCA, your program can <a id="sthref989"></a>determine the outcome of a SQL statement. This can be done in two ways:</p>
<ul>
<li>
<p>Implicit checking with the WHENEVER statement</p>
</li>
<li>
<p>Explicit checking of SQLCA variables</p>
</li>
</ul>
<p>You can use <code>WHENEVER</code> statements, code explicit checks on SQLCA variables, or do both. Generally, using <code>WHENEVER</code> statements is preferable because it is easier, more portable, and ANSI-compliant.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE759" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref990"></a>
<h3 class="sect2">ORACA</h3>
<p>When more information is needed about run-time errors than the SQLCA provides, you can use the ORACA, which contains cursor statistics, SQL statement data, option settings, and system statistics.</p>
<p>The ORACA is optional and can be declared regardless of the MODE setting. For more information about the ORACA status variable, refer to &#34;<a href="#CEGJHAHF">Using the Oracle Communications Area</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGJDGDH"></a>
<div id="ZZPRE760" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Status Variables when MODE={ANSI|ANSI14}</h2>
<p>When <code>MODE={ANSI|ANSI14},</code> you must declare at least one -- you may declare two or all three -- of the following status variables:</p>
<ul>
<li>
<p><a id="sthref991"></a><a id="sthref992"></a>SQLCODE</p>
</li>
<li>
<p><a id="sthref993"></a>SQLSTATE</p>
</li>
<li>
<p>SQLCA</p>
</li>
</ul>
<p>In Pro*COBOL, you cannot declare SQLCODE if SQLCA is declared. Likewise, you cannot declare SQLCA if SQLCODE is declared. The field in the SQLCA data structure that stores the error code for Pro*COBOL is also called SQLCODE, so errors will occur if both status variables are declared.</p>
<p>Your program can get the outcome of the most recent executable SQL statement by checking SQLCODE and SQLSTATE, SQLCODE or SQLSTATE explicitly with your own code after executable SQL and PL/SQL statements. Your program can also check SQLCA implicitly (with the <code>WHENEVER</code> SQLERROR and <code>WHENEVER</code> SQLWARNING statements) or it can check the SQLCA variables explicitly.</p>
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
When <code>MODE={ORACLE|ANSI13},</code> you must declare the SQLCA status variable. For more information, refer to <a href="#BABIGBFF">Using the SQL Communications Area</a>&#34;.</div>
<div id="ZZPRE761" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref994"></a>
<h3 class="sect2">Some Historical Information</h3>
<p>The treatment of status variables and variable combinations by the Oracle Precompilers has evolved beginning with Release 1.5.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE762" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref995"></a>
<h3 class="sect2">Release 1.5</h3>
<p>The Oracle Precompiler, Release 1.5, presumed there was a status variable SQLCODE whether it was declared in a Declare Section; in fact, the precompiler never bothered to note whether there was a declaration for SQLCODE or not -- it just presumed that the declaration exists. SQLCA would be used as a status variable only if there was an <code>INCLUDE</code> of the SQLCA.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE763" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref996"></a>
<h3 class="sect2">Release 1.6</h3>
<p>Beginning with Oracle Precompilers, Release 1.6, the precompilers no longer presume that there is a SQLCODE status variable and it is not required. The precompiler requires that <span class="italic">at least</span> one of SQLCA, SQLCODE, or SQLSTATE be declared.</p>
<p>SQLCODE is recognized as a status variable if and only if at least one of the following criteria is satisfied:</p>
<ul>
<li>
<p>It is declared in a Declare Section with <span class="italic">exactly</span> the correct datatype.</p>
</li>
<li>
<p>The precompiler finds no other status variable.</p>
</li>
</ul>
<p>If the precompiler finds a SQLSTATE declaration (of <span class="italic">exactly</span> the correct type of course) in a Declare Section or finds an <code>INCLUDE</code> of the SQLCA, it will <span class="italic">not</span> presume SQLCODE is declared.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE764" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref997"></a>
<h3 class="sect2">Release 1.7</h3>
<p>Because Release 1.5 of the Oracle Precompilers allowed the SQLCODE variable to be declared outside a Declare Section while declaring SQLCA at the same time, precompilers Release 1.6 and greater are presented with a compatibility problem. A new option, <code>ASSUME_SQLCODE={YES|NO}</code> (default NO), was added to fix this in Release 1.6.7 and is documented as a new feature in Release 1.7.</p>
<p>When A<code>SSUME_SQLCODE=YES,</code> and when SQLSTATE or SQLCA (Pro*FORTRAN only) are declared as status variables, the precompiler presumes SQLCODE is declared irrepsective of whether it is declared in a Declare Section or of the proper type. This causes Releases 1.6.7 and later to act like Release 1.5 in this regard. For information about the precompiler option ASSUME_SQLCODE, refer to &#34;ASSUME_SQLCODE&#34; .</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE765" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref998"></a>
<h3 class="sect2">Declaring Status Variables</h3>
<p><a id="sthref999"></a>This section describes how to declare SQLCODE and SQLSTATE. For information about declaring the SQLCA status variable, refer to <a href="#CEGDCCFE">&#34;Declaring the SQLCA&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CEGICGDB"></a>
<div id="ZZPRE766" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Declaring SQLCODE</h3>
<p>SQLCODE (SQLCOD in Pro*FORTRAN) must be declared as a 4-byte integer variable either <span class="italic">inside</span> or <span class="italic">outside</span> the Declare Section, as shown in <a href="#CEGHADBF">Table 8-1</a>.</p>
<div id="ZZPRE767" class="tblformal">
<p class="titleintable"><a id="sthref1000"></a><a id="CEGHADBF"></a>Table 8-1 SQLCODE Declarations</p>
<table class="cellalignment3250" title="SQLCODE Declarations" summary="declaring sql code" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t3">Language</th>
<th class="cellalignment3246" id="r1c2-t3">SQLCODE Declaration</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t3" headers="r1c1-t3">
<p>COBOL</p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p>SQLCODE PIC S9(9) COMP.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t3" headers="r1c1-t3">
<p>FORTRAN</p>
</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">
<p>INTEGER*4 SQLCOD</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a id="sthref1001"></a>If declared outside the Declare Section, SQLCODE is recognized as a status variable only if ASSUME_SQLCODE=YES. SQLCODE declarations are ignored when <code>MODE={ORACLE|ANSI13}</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">Warning:</p>
In Pro*COBOL source files, <span class="italic">do</span><span class="italic">not</span> declare SQLCODE if SQLCA is declared. Likewise, <span class="italic">do</span><span class="italic">not</span> declare SQLCA if SQLCODE is declared. The status variable declared by the SQLCA structure is also called SQLCODE, so errors will occur if both error-reporting mechanisms are used.</div>
<p>By using host languages that allow both local and global declarations, you can declare more than one SQLCODE variable. Access to a local SQLCODE is limited by its scope within your program. After every SQL operation, Oracle returns a status code to the SQLCODE currently in scope. So, your program can learn the outcome of the most recent SQL operation by checking SQLCODE explicitly, or implicitly with the <code>WHENEVER</code> statement.</p>
<p>When you declare SQLCODE instead of the SQLCA in a particular compilation unit, the precompiler allocates an internal SQLCA for that unit. Your host program cannot access the internal SQLCA. If you declare the SQLCA <span class="italic">and</span> SQLCODE (not supported in Pro*COBOL), Oracle returns the same status code to both after every SQL operation.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE768" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1002"></a>
<h3 class="sect2">Declaring SQLSTATE</h3>
<p>SQLSTATE (SQLSTA in Pro*FORTRAN) must be declared as a five-character alphanumeric string inside the Declare Section, as shown in<a href="#CEGFGJBC">Table 8-2</a>. Declaring the SQLCA is optional.</p>
<div id="ZZPRE769" class="tblformal">
<p class="titleintable"><a id="sthref1003"></a><a id="CEGFGJBC"></a>Table 8-2 SQLSTATE Declarations</p>
<table class="cellalignment3250" title="SQLSTATE Declarations" summary="declaring sql state" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t5">Language</th>
<th class="cellalignment3246" id="r1c2-t5">SQLSTATE Declaration</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t5" headers="r1c1-t5">
<p>COBOL</p>
</td>
<td class="cellalignment3247" headers="r2c1-t5 r1c2-t5">
<p>SQLSTATE PIC X(5).</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t5" headers="r1c1-t5">
<p>FORTRAN</p>
</td>
<td class="cellalignment3247" headers="r3c1-t5 r1c2-t5">
<p>CHARACTER*5 SQLSTA</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a id="sthref1004"></a>When MODE={ORACLE|ANSI13}, declarations of the SQLSTATE variable are ignored.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE770" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1005"></a>
<h3 class="sect2">Status Variable Combinations</h3>
<p>When <code>MODE={ANSI|ANSI14}</code>, the behavior of the status variables depends on the following:</p>
<ul>
<li>
<p>Which variables are declared</p>
</li>
<li>
<p>Declaration placement (<span class="italic">inside</span> or <span class="italic">outside</span> the Declare Section)</p>
</li>
<li>
<p>ASSUME_SQLCODE setting</p>
</li>
</ul>
<p><a href="#CEGFJGAC">Table 8-3</a> and <a href="#CEGFHDFC">Table 8-4</a> describe the resulting behavior of each status variable combination when ASSUME_SQLCODE=NO and when ASSUME_SQLCODE=YES, respectively.</p>
<div id="ZZPRE771" class="tblformal">
<p class="titleintable"><a id="sthref1006"></a><a id="CEGFJGAC"></a>Table 8-3 Status Variable Combinations - SQLCODE = NO</p>
<table class="cellalignment3250" title="Status Variable Combinations - SQLCODE = NO" summary="status variable combinations" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t6" colspan="3">Declare Section (IN/OUT/ --)</th>
<th class="cellalignment3246" id="r1c2-t6">Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t6" headers="r1c1-t6">
<p><span class="bold">SQLCODE</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t6 r1c1-t6 r1c2-t6">
<p><span class="bold">SQLSTATE</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t6 r1c1-t6">
<p><span class="bold">SQLCA</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t6">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r3c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r3c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r3c1-t6">
<p>SQLCODE is declared and is presumed to be a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r4c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r4c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r4c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCA is declared as a status variable, and SQLCODE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r5c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r5c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r5c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r6c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r6c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r6c1-t6">
<p>SQLCODE is declared and is presumed to be a status variable, and SQLSTATE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r7c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r7c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r7c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCA is declared as a status variable, and SQLCODE and SQLSTATE are declared but are not recognized as status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r8c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r8c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r8c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r9c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r9c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r9c1-t6">
<p>SQLSTATE is declared as a status variable, and SQLCODE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r10c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r10c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r10c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLSTATE and SQLCA are declared as status variables, and SQLCODE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t6" headers="r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r11c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r11c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r11c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r12c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r12c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r12c1-t6">
<p>SQLCODE is declared as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r13c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r13c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r13c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCODE and SQLCA are declared as a status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r14c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r14c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r14c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r15c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r15c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r15c1-t6">
<p>SQLCODE is declared as a status variable, and SQLSTATE is declared but not as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r16c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r16c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r16c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCODE and SQLCA are declared as a status variables, and SQLSTATE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r17c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r17c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r17c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r18c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r18c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r18c1-t6">
<p>SQLCODE and SQLSTATE are declared as a status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r19c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r19c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r19c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCODE, SQLSTATE, and SQLCA are declared as a status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t6" headers="r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r20c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r20c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r20c1-t6">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r21c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r21c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r21c1-t6">
<p>This status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r22c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r22c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r22c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r22c1-t6">
<p>SQLCA is declared as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r23c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r23c1-t6 r1c1-t6 r1c2-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r23c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r23c1-t6">
<p>In Pro*COBOL, SQLCA is declared as a status host variable. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r24c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r24c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r24c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r24c1-t6">
<p>This status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r25c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r25c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r25c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r25c1-t6">
<p>SQLCA is declared as a status variable, and SQLSTATE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r26c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r26c1-t6 r1c1-t6 r1c2-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r26c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r26c1-t6">
<p>In Pro*COBOL, SQLCA is declared as a status host variable, and SQLSTATE is declared but is not recognized as a status variable. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r27c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r27c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r27c1-t6 r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r27c1-t6">
<p>SQLSTATE is declared as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r28c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r28c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r28c1-t6 r1c1-t6">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r28c1-t6">
<p>SQLSTATE and SQLCA are declared as status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r29c1-t6" headers="r1c1-t6">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r29c1-t6 r1c1-t6 r1c2-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r29c1-t6 r1c1-t6">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r29c1-t6">
<p>In Pro*COBOL, SQLSTATE and SQLCA are declared as status host variables. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="ZZPRE772" class="tblformal">
<p class="titleintable"><a id="sthref1007"></a><a id="CEGFHDFC"></a>Table 8-4 Status Variable Combinations - SQLCODE = YES</p>
<table class="cellalignment3250" title="Status Variable Combinations - SQLCODE = YES" summary="status variable behaviour" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t7" colspan="3">Declare Section (IN/OUT/ --)</th>
<th class="cellalignment3246" id="r1c2-t7">Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t7" headers="r1c1-t7">
<p><span class="bold">SQLCODE</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t7 r1c1-t7 r1c2-t7">
<p><span class="bold">SQLSTATE</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t7 r1c1-t7">
<p><span class="bold">SQLCA</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t7">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r3c1-t7 r1c1-t7 r1c2-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r3c1-t7 r1c1-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r3c1-t7">
<p>SQLCODE is declared and is presumed to be a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r4c1-t7 r1c1-t7 r1c2-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r4c1-t7 r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r4c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCA is declared as a status variable, and SQLCODE is declared and is presumed to be a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r5c1-t7 r1c1-t7 r1c2-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r5c1-t7 r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r5c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r6c1-t7 r1c1-t7 r1c2-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r6c1-t7 r1c1-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r6c1-t7">
<p>SQLCODE is declared and is presumed to be a status variable, and SQLSTATE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r7c1-t7 r1c1-t7 r1c2-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r7c1-t7 r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r7c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCA is declared as a status variable, SQLCODE is declared and is presumed to be a status variable, and SQLSTATE is declared but is not recognized as status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r8c1-t7 r1c1-t7 r1c2-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r8c1-t7 r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r8c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r9c1-t7 r1c1-t7 r1c2-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r9c1-t7 r1c1-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r9c1-t7">
<p>SQLSTATE is declared as a status variable, and SQLCODE is declared and is presumed to be a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r10c1-t7 r1c1-t7 r1c2-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r10c1-t7 r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r10c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLSTATE and SQLCA are declared as status variables, and SQLCODE is declared and is presumed to be a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t7" headers="r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r11c1-t7 r1c1-t7 r1c2-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r11c1-t7 r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r11c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r12c1-t7 r1c1-t7 r1c2-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r12c1-t7 r1c1-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r12c1-t7">
<p>SQLCODE is declared as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r13c1-t7 r1c1-t7 r1c2-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r13c1-t7 r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r13c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCODE and SQLCA are declared as a status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r14c1-t7 r1c1-t7 r1c2-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r14c1-t7 r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r14c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r15c1-t7 r1c1-t7 r1c2-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r15c1-t7 r1c1-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r15c1-t7">
<p>SQLCODE is declared as a status variable, and SQLSTATE is declared but not as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r16c1-t7 r1c1-t7 r1c2-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r16c1-t7 r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r16c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCODE and SQLCA are declared as a status variables, and SQLSTATE is declared but is not recognized as a status variable.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r17c1-t7 r1c1-t7 r1c2-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r17c1-t7 r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r17c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r18c1-t7 r1c1-t7 r1c2-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r18c1-t7 r1c1-t7">
<p>--</p>
</td>
<td class="cellalignment3247" headers="r18c1-t7">
<p>SQLCODE and SQLSTATE are declared as a status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r19c1-t7 r1c1-t7 r1c2-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r19c1-t7 r1c1-t7">
<p>OUT</p>
</td>
<td class="cellalignment3247" headers="r19c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, SQLCODE, SQLSTATE, and SQLCA are declared as a status variables.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t7" headers="r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r20c1-t7 r1c1-t7 r1c2-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r20c1-t7 r1c1-t7">
<p>IN</p>
</td>
<td class="cellalignment3247" headers="r20c1-t7">
<p>In Pro*COBOL, this status variable configuration is not supported. In Pro*FORTRAN, this status variable configuration is not supported.</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t7" headers="r1c1-t7">
<p>-- -- -- -- -- -- -- -- --</p>
</td>
<td class="cellalignment3247" headers="r21c1-t7 r1c1-t7 r1c2-t7">
<p>-- -- -- OUT OUT OUT IN IN IN</p>
</td>
<td class="cellalignment3247" headers="r21c1-t7 r1c1-t7">
<p>-- OUT IN -- OUT IN -- OUT IN</p>
</td>
<td class="cellalignment3247" headers="r21c1-t7">
<p>These status variable configurations are not supported. SQLCODE must be declared either inside or outside the Declare Section when ASSUME_SQLCODE=YES.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="ZZPRE773" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1008"></a>
<h3 class="sect2">Status Variable Values</h3>
<p>This section describes the values for the SQLCODE and SQLSTATE status variables. For information about the SQLCA status variable, refer to <a href="#CEGEGIDG">&#34;Key Components of Error Reporting&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE774" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1009"></a>
<h3 class="sect2"><a id="sthref1010"></a>SQLCODE Values</h3>
<p>After every SQL operation, Oracle returns a status code to the SQLCODE variable currently in scope. The status code, which indicates the outcome of the SQL operation, can be any of the following numbers:</p>
<p>0</p>
<p>Oracle executed the SQL statement without detecting an error or exception.</p>
<p>&gt; 0</p>
<p>Oracle executed the statement but detected an exception. This occurs when Oracle cannot find a row that meets the condition in your <code>WHERE</code> clause or when a <code>SELECT</code> <code>INTO</code> or <code>FETCH</code> returns no rows.</p>
<p><a id="sthref1011"></a>When <code>MODE={ANSI|ANSI14|ANSI13}, +100</code> is returned to SQLCODE after an <code>INSERT</code> of no rows. This can happen when a subquery returns no rows to process.</p>
<p>&lt; 0</p>
<p>Oracle did not execute the statement because of a database, system, network, or application error. Such errors are irrecoverable. When they occur, the current transaction should, in most cases, be rolled back. Negative return codes correspond to error codes listed in <a class="olink ERRMG" href="../ERRMG/toc.htm"><span class="italic">Oracle Database Error Messages</span></a>.</p>
<p>You can learn the outcome of the most recent SQL operation by checking SQLCODE explicitly with your own code or implicitly with the <code>WHENEVER</code> statement.</p>
<p>When you declare SQLCODE instead of the SQLCA in a particular precompilation unit, the precompiler allocates an internal SQLCA for that unit. Your host program cannot access the internal SQLCA. If you declare the SQLCA <span class="italic">and</span> SQLCODE (Pro*FORTRAN only), Oracle returns the same status code to both after every SQL operation.</p>
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
When <code>MODE={ORACLE|ANSI13},</code> declarations of SQLCODE are ignored.</div>
</div>
<!-- class="sect2" -->
<div id="ZZPRE775" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1012"></a>
<h3 class="sect2">SQLSTATE Values</h3>
<p><a id="sthref1013"></a><a id="sthref1014"></a>SQLSTATE status codes consist of a two-character <span class="italic">class code</span> followed by a three-character <span class="italic">subclass code</span>. Aside from class code 00 (successful completion), the class code denotes a category of exceptions. Aside from subclass code 000 (not applicable), the subclass code denotes a specific exception within that category. For <a id="sthref1015"></a>example, the SQLSTATE value `22012&#39; consists of class code 22 (data exception) and subclass code 012 (division by zero).</p>
<p><a id="sthref1016"></a>Each of the five characters in a SQLSTATE value is a digit (0..9) or an uppercase Latin letter (A..Z). Class codes that begin with a digit in the range 0..4 or a letter in the range A..H are reserved for predefined conditions (those defined in SQL92). All other class codes are reserved for implementation-defined conditions. Within predefined classes, subclass codes that begin with a digit in the range 0..4 or a letter in the range A..H are reserved for predefined subconditions. All other subclass codes are reserved for implementation-defined subconditions. <a href="#BCECJICI">Figure 8-1</a> shows the coding scheme.</p>
<div id="ZZPRE776" class="figure">
<p class="titleinfigure"><a id="BCECJICI"></a>Figure 8-1 SQLSTATE Coding Scheme</p>
<img width="536" height="293" src="img/image010.gif" alt="SQLSTATE Coding Scheme"/><br/>
<a id="sthref1017" href="img_text/image010.htm">Description of &#34;Figure 8-1 SQLSTATE Coding Scheme&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a href="#BABBBEFC">Table 8-5</a> shows the classes predefined by SQL92.</p>
<div id="ZZPRE777" class="tblformal">
<p class="titleintable"><a id="sthref1018"></a><a id="BABBBEFC"></a>Table 8-5 Predefined SQL92 Classes</p>
<table class="cellalignment3250" title="Predefined SQL92 Classes" summary="classes predefined by sql" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t9">Class</th>
<th class="cellalignment3246" id="r1c2-t9">Condition</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t9" headers="r1c1-t9">
<p>00</p>
</td>
<td class="cellalignment3247" headers="r2c1-t9 r1c2-t9">
<p>successful completion</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t9" headers="r1c1-t9">
<p>01</p>
</td>
<td class="cellalignment3247" headers="r3c1-t9 r1c2-t9">
<p>warning</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t9" headers="r1c1-t9">
<p>02</p>
</td>
<td class="cellalignment3247" headers="r4c1-t9 r1c2-t9">
<p>no data</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t9" headers="r1c1-t9">
<p>07</p>
</td>
<td class="cellalignment3247" headers="r5c1-t9 r1c2-t9">
<p>dynamic SQL error</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t9" headers="r1c1-t9">
<p>08</p>
</td>
<td class="cellalignment3247" headers="r6c1-t9 r1c2-t9">
<p>connection exception</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t9" headers="r1c1-t9">
<p>0A</p>
</td>
<td class="cellalignment3247" headers="r7c1-t9 r1c2-t9">
<p>feature not supported</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t9" headers="r1c1-t9">
<p>21</p>
</td>
<td class="cellalignment3247" headers="r8c1-t9 r1c2-t9">
<p>cardinality violation</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t9" headers="r1c1-t9">
<p>22</p>
</td>
<td class="cellalignment3247" headers="r9c1-t9 r1c2-t9">
<p>data exception</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t9" headers="r1c1-t9">
<p>23</p>
</td>
<td class="cellalignment3247" headers="r10c1-t9 r1c2-t9">
<p>integrity constraint violation</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t9" headers="r1c1-t9">
<p>24</p>
</td>
<td class="cellalignment3247" headers="r11c1-t9 r1c2-t9">
<p>invalid cursor state</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t9" headers="r1c1-t9">
<p>25</p>
</td>
<td class="cellalignment3247" headers="r12c1-t9 r1c2-t9">
<p>invalid transaction state</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t9" headers="r1c1-t9">
<p>26</p>
</td>
<td class="cellalignment3247" headers="r13c1-t9 r1c2-t9">
<p>invalid SQL statement name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t9" headers="r1c1-t9">
<p>27</p>
</td>
<td class="cellalignment3247" headers="r14c1-t9 r1c2-t9">
<p>triggered data change violation</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t9" headers="r1c1-t9">
<p>28</p>
</td>
<td class="cellalignment3247" headers="r15c1-t9 r1c2-t9">
<p>invalid authorization specification</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t9" headers="r1c1-t9">
<p>2A</p>
</td>
<td class="cellalignment3247" headers="r16c1-t9 r1c2-t9">
<p>direct SQL syntax error or access rule violation</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t9" headers="r1c1-t9">
<p>2B</p>
</td>
<td class="cellalignment3247" headers="r17c1-t9 r1c2-t9">
<p>dependent privilege descriptors still exist</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t9" headers="r1c1-t9">
<p>2C</p>
</td>
<td class="cellalignment3247" headers="r18c1-t9 r1c2-t9">
<p>invalid character set name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t9" headers="r1c1-t9">
<p>2D</p>
</td>
<td class="cellalignment3247" headers="r19c1-t9 r1c2-t9">
<p>invalid transaction termination</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t9" headers="r1c1-t9">
<p>2E</p>
</td>
<td class="cellalignment3247" headers="r20c1-t9 r1c2-t9">
<p>invalid connection name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t9" headers="r1c1-t9">
<p>33</p>
</td>
<td class="cellalignment3247" headers="r21c1-t9 r1c2-t9">
<p>invalid SQL descriptor name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r22c1-t9" headers="r1c1-t9">
<p>34</p>
</td>
<td class="cellalignment3247" headers="r22c1-t9 r1c2-t9">
<p>invalid cursor name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r23c1-t9" headers="r1c1-t9">
<p>35</p>
</td>
<td class="cellalignment3247" headers="r23c1-t9 r1c2-t9">
<p>invalid condition number</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r24c1-t9" headers="r1c1-t9">
<p>37</p>
</td>
<td class="cellalignment3247" headers="r24c1-t9 r1c2-t9">
<p>dynamic SQL syntax error or access rule violation</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r25c1-t9" headers="r1c1-t9">
<p>3C</p>
</td>
<td class="cellalignment3247" headers="r25c1-t9 r1c2-t9">
<p>ambiguous cursor name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r26c1-t9" headers="r1c1-t9">
<p>3D</p>
</td>
<td class="cellalignment3247" headers="r26c1-t9 r1c2-t9">
<p>invalid catalog name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r27c1-t9" headers="r1c1-t9">
<p>3F</p>
</td>
<td class="cellalignment3247" headers="r27c1-t9 r1c2-t9">
<p>invalid schema name</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r28c1-t9" headers="r1c1-t9">
<p>40</p>
</td>
<td class="cellalignment3247" headers="r28c1-t9 r1c2-t9">
<p>transaction rollback</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r29c1-t9" headers="r1c1-t9">
<p>42</p>
</td>
<td class="cellalignment3247" headers="r29c1-t9 r1c2-t9">
<p>syntax error or access rule violation</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r30c1-t9" headers="r1c1-t9">
<p>44</p>
</td>
<td class="cellalignment3247" headers="r30c1-t9 r1c2-t9">
<p>with check option violation</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r31c1-t9" headers="r1c1-t9">
<p>HZ</p>
</td>
<td class="cellalignment3247" headers="r31c1-t9 r1c2-t9">
<p>remote database access</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
The class code HZ is reserved for conditions defined in International Standard ISO/IEC DIS 9579-2, <span class="italic">Remote Database Access</span>.</div>
<p><a id="sthref1019"></a><a href="#CEGDHEGI">Table 8-6</a> shows how Oracle errors map to SQLSTATE status codes. In some cases, several Oracle errors map to the status code. In other cases, no Oracle error maps to the status code (so the last column is empty). Status codes in the range 60000 .. 99999 are implementation-defined.</p>
<div id="ZZPRE778" class="tblformal">
<p class="titleintable"><a id="sthref1020"></a><a id="CEGDHEGI"></a>Table 8-6 Oracle Error Mapping to SQLSTATE Status</p>
<table class="cellalignment3250" title="Oracle Error Mapping to SQLSTATE Status" summary="code" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t11">Code</th>
<th class="cellalignment3246" id="r1c2-t11">Condition</th>
<th class="cellalignment3246" id="r1c3-t11">Oracle Error</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t11" headers="r1c1-t11">
<p>00000</p>
</td>
<td class="cellalignment3247" headers="r2c1-t11 r1c2-t11">
<p>successful completion</p>
</td>
<td class="cellalignment3247" headers="r2c1-t11 r1c3-t11">
<p>ORA-00000</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t11" headers="r1c1-t11">
<p>01000</p>
</td>
<td class="cellalignment3247" headers="r3c1-t11 r1c2-t11">
<p>warning</p>
</td>
<td class="cellalignment3247" headers="r3c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t11" headers="r1c1-t11">
<p>01001</p>
</td>
<td class="cellalignment3247" headers="r4c1-t11 r1c2-t11">
<p>cursor operation conflict</p>
</td>
<td class="cellalignment3247" headers="r4c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t11" headers="r1c1-t11">
<p>01002</p>
</td>
<td class="cellalignment3247" headers="r5c1-t11 r1c2-t11">
<p>disconnect error</p>
</td>
<td class="cellalignment3247" headers="r5c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t11" headers="r1c1-t11">
<p>01003</p>
</td>
<td class="cellalignment3247" headers="r6c1-t11 r1c2-t11">
<p>null value eliminated in set function</p>
</td>
<td class="cellalignment3247" headers="r6c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t11" headers="r1c1-t11">
<p>01004</p>
</td>
<td class="cellalignment3247" headers="r7c1-t11 r1c2-t11">
<p>string data - right truncation</p>
</td>
<td class="cellalignment3247" headers="r7c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t11" headers="r1c1-t11">
<p>01005</p>
</td>
<td class="cellalignment3247" headers="r8c1-t11 r1c2-t11">
<p>insufficient item descriptor areas</p>
</td>
<td class="cellalignment3247" headers="r8c1-t11 r1c3-t11">
<p>SQL-02142</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t11" headers="r1c1-t11">
<p>01006</p>
</td>
<td class="cellalignment3247" headers="r9c1-t11 r1c2-t11">
<p>privilege not revoked</p>
</td>
<td class="cellalignment3247" headers="r9c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t11" headers="r1c1-t11">
<p>01007</p>
</td>
<td class="cellalignment3247" headers="r10c1-t11 r1c2-t11">
<p>privilege not granted</p>
</td>
<td class="cellalignment3247" headers="r10c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t11" headers="r1c1-t11">
<p>01008</p>
</td>
<td class="cellalignment3247" headers="r11c1-t11 r1c2-t11">
<p>implicit zero-bit padding</p>
</td>
<td class="cellalignment3247" headers="r11c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t11" headers="r1c1-t11">
<p>01009</p>
</td>
<td class="cellalignment3247" headers="r12c1-t11 r1c2-t11">
<p>search condition too long for info schema</p>
</td>
<td class="cellalignment3247" headers="r12c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t11" headers="r1c1-t11">
<p>0100A</p>
</td>
<td class="cellalignment3247" headers="r13c1-t11 r1c2-t11">
<p>query expression too long for info schema</p>
</td>
<td class="cellalignment3247" headers="r13c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t11" headers="r1c1-t11">
<p>02000</p>
</td>
<td class="cellalignment3247" headers="r14c1-t11 r1c2-t11">
<p>no data</p>
</td>
<td class="cellalignment3247" headers="r14c1-t11 r1c3-t11">
<p>ORA-01095 ORA-01403 ORA-0100</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t11" headers="r1c1-t11">
<p>07000</p>
</td>
<td class="cellalignment3247" headers="r15c1-t11 r1c2-t11">
<p>dynamic SQL error</p>
</td>
<td class="cellalignment3247" headers="r15c1-t11 r1c3-t11">
<p>SQL-02137 SQL-02139</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t11" headers="r1c1-t11">
<p>07001</p>
</td>
<td class="cellalignment3247" headers="r16c1-t11 r1c2-t11">
<p>using clause does not match parameter specs</p>
</td>
<td class="cellalignment3247" headers="r16c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t11" headers="r1c1-t11">
<p>07002</p>
</td>
<td class="cellalignment3247" headers="r17c1-t11 r1c2-t11">
<p>using clause does not match target specs</p>
</td>
<td class="cellalignment3247" headers="r17c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t11" headers="r1c1-t11">
<p>07003</p>
</td>
<td class="cellalignment3247" headers="r18c1-t11 r1c2-t11">
<p>cursor specification cannot be executed</p>
</td>
<td class="cellalignment3247" headers="r18c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t11" headers="r1c1-t11">
<p>07004</p>
</td>
<td class="cellalignment3247" headers="r19c1-t11 r1c2-t11">
<p>using clause required for dynamic parameters</p>
</td>
<td class="cellalignment3247" headers="r19c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t11" headers="r1c1-t11">
<p>07005</p>
</td>
<td class="cellalignment3247" headers="r20c1-t11 r1c2-t11">
<p>prepared statement not a cursor specification</p>
</td>
<td class="cellalignment3247" headers="r20c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t11" headers="r1c1-t11">
<p>07006</p>
</td>
<td class="cellalignment3247" headers="r21c1-t11 r1c2-t11">
<p>restricted datatype attribute violation</p>
</td>
<td class="cellalignment3247" headers="r21c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r22c1-t11" headers="r1c1-t11">
<p>07007</p>
</td>
<td class="cellalignment3247" headers="r22c1-t11 r1c2-t11">
<p>using clause required for result fields</p>
</td>
<td class="cellalignment3247" headers="r22c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r23c1-t11" headers="r1c1-t11">
<p>07008</p>
</td>
<td class="cellalignment3247" headers="r23c1-t11 r1c2-t11">
<p>invalid descriptor count</p>
</td>
<td class="cellalignment3247" headers="r23c1-t11 r1c3-t11">
<p>SQL-02126 SQL-02141</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r24c1-t11" headers="r1c1-t11">
<p>07009</p>
</td>
<td class="cellalignment3247" headers="r24c1-t11 r1c2-t11">
<p>invalid descriptor index</p>
</td>
<td class="cellalignment3247" headers="r24c1-t11 r1c3-t11">
<p>SQL-02140</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r25c1-t11" headers="r1c1-t11">
<p>08000</p>
</td>
<td class="cellalignment3247" headers="r25c1-t11 r1c2-t11">
<p>connection exception</p>
</td>
<td class="cellalignment3247" headers="r25c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r26c1-t11" headers="r1c1-t11">
<p>08001</p>
</td>
<td class="cellalignment3247" headers="r26c1-t11 r1c2-t11">
<p>SQL client unable to establish SQL connection</p>
</td>
<td class="cellalignment3247" headers="r26c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r27c1-t11" headers="r1c1-t11">
<p>08002</p>
</td>
<td class="cellalignment3247" headers="r27c1-t11 r1c2-t11">
<p>connection name in use</p>
</td>
<td class="cellalignment3247" headers="r27c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r28c1-t11" headers="r1c1-t11">
<p>08003</p>
</td>
<td class="cellalignment3247" headers="r28c1-t11 r1c2-t11">
<p>connection does not exist</p>
</td>
<td class="cellalignment3247" headers="r28c1-t11 r1c3-t11">
<p>SQL-02121</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r29c1-t11" headers="r1c1-t11">
<p>08004</p>
</td>
<td class="cellalignment3247" headers="r29c1-t11 r1c2-t11">
<p>SQL server rejected SQL connection</p>
</td>
<td class="cellalignment3247" headers="r29c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r30c1-t11" headers="r1c1-t11">
<p>08006</p>
</td>
<td class="cellalignment3247" headers="r30c1-t11 r1c2-t11">
<p>connection failure</p>
</td>
<td class="cellalignment3247" headers="r30c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r31c1-t11" headers="r1c1-t11">
<p>08007</p>
</td>
<td class="cellalignment3247" headers="r31c1-t11 r1c2-t11">
<p>transaction resolution unknown</p>
</td>
<td class="cellalignment3247" headers="r31c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r32c1-t11" headers="r1c1-t11">
<p>0A000</p>
</td>
<td class="cellalignment3247" headers="r32c1-t11 r1c2-t11">
<p>feature not supported</p>
</td>
<td class="cellalignment3247" headers="r32c1-t11 r1c3-t11">
<p>ORA-03000 .. 03099</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r33c1-t11" headers="r1c1-t11">
<p>0A001</p>
</td>
<td class="cellalignment3247" headers="r33c1-t11 r1c2-t11">
<p>multiple server transactions</p>
</td>
<td class="cellalignment3247" headers="r33c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r34c1-t11" headers="r1c1-t11">
<p>21000</p>
</td>
<td class="cellalignment3247" headers="r34c1-t11 r1c2-t11">
<p>cardinality violation</p>
</td>
<td class="cellalignment3247" headers="r34c1-t11 r1c3-t11">
<p>ORA-01427 SQL-02112 ORA-01422</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r35c1-t11" headers="r1c1-t11">
<p>22000</p>
</td>
<td class="cellalignment3247" headers="r35c1-t11 r1c2-t11">
<p>data exception</p>
</td>
<td class="cellalignment3247" headers="r35c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r36c1-t11" headers="r1c1-t11">
<p>22001</p>
</td>
<td class="cellalignment3247" headers="r36c1-t11 r1c2-t11">
<p>string data - right truncation</p>
</td>
<td class="cellalignment3247" headers="r36c1-t11 r1c3-t11">
<p>ORA-01401 ORA-01406 ORA-12899</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r37c1-t11" headers="r1c1-t11">
<p>22002</p>
</td>
<td class="cellalignment3247" headers="r37c1-t11 r1c2-t11">
<p>null value - no indicator parameter</p>
</td>
<td class="cellalignment3247" headers="r37c1-t11 r1c3-t11">
<p>ORA-01405 SQL-02124</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r38c1-t11" headers="r1c1-t11">
<p>22003</p>
</td>
<td class="cellalignment3247" headers="r38c1-t11 r1c2-t11">
<p>numeric value out of range</p>
</td>
<td class="cellalignment3247" headers="r38c1-t11 r1c3-t11">
<p>ORA-01426 ORA-01438 ORA-01455 ORA-01457</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r39c1-t11" headers="r1c1-t11">
<p>22005</p>
</td>
<td class="cellalignment3247" headers="r39c1-t11 r1c2-t11">
<p>error in assignment</p>
</td>
<td class="cellalignment3247" headers="r39c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r40c1-t11" headers="r1c1-t11">
<p>22007</p>
</td>
<td class="cellalignment3247" headers="r40c1-t11 r1c2-t11">
<p>invalid datetime format</p>
</td>
<td class="cellalignment3247" headers="r40c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r41c1-t11" headers="r1c1-t11">
<p>22008</p>
</td>
<td class="cellalignment3247" headers="r41c1-t11 r1c2-t11">
<p>datetime field overflow</p>
</td>
<td class="cellalignment3247" headers="r41c1-t11 r1c3-t11">
<p>ORA-01800 .. 01899</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r42c1-t11" headers="r1c1-t11">
<p>22009</p>
</td>
<td class="cellalignment3247" headers="r42c1-t11 r1c2-t11">
<p>invalid time zone displacement value</p>
</td>
<td class="cellalignment3247" headers="r42c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r43c1-t11" headers="r1c1-t11">
<p>22011</p>
</td>
<td class="cellalignment3247" headers="r43c1-t11 r1c2-t11">
<p>substring error</p>
</td>
<td class="cellalignment3247" headers="r43c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r44c1-t11" headers="r1c1-t11">
<p>22012</p>
</td>
<td class="cellalignment3247" headers="r44c1-t11 r1c2-t11">
<p>division by zero</p>
</td>
<td class="cellalignment3247" headers="r44c1-t11 r1c3-t11">
<p>ORA-01476</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r45c1-t11" headers="r1c1-t11">
<p>22015</p>
</td>
<td class="cellalignment3247" headers="r45c1-t11 r1c2-t11">
<p>interval field overflow</p>
</td>
<td class="cellalignment3247" headers="r45c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r46c1-t11" headers="r1c1-t11">
<p>22018</p>
</td>
<td class="cellalignment3247" headers="r46c1-t11 r1c2-t11">
<p>invalid character value for cast</p>
</td>
<td class="cellalignment3247" headers="r46c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r47c1-t11" headers="r1c1-t11">
<p>22019</p>
</td>
<td class="cellalignment3247" headers="r47c1-t11 r1c2-t11">
<p>invalid escape character</p>
</td>
<td class="cellalignment3247" headers="r47c1-t11 r1c3-t11">
<p>ORA-00911 ORA-01425</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r48c1-t11" headers="r1c1-t11">
<p>22021</p>
</td>
<td class="cellalignment3247" headers="r48c1-t11 r1c2-t11">
<p>character not in repertoire</p>
</td>
<td class="cellalignment3247" headers="r48c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r49c1-t11" headers="r1c1-t11">
<p>22022</p>
</td>
<td class="cellalignment3247" headers="r49c1-t11 r1c2-t11">
<p>indicator overflow</p>
</td>
<td class="cellalignment3247" headers="r49c1-t11 r1c3-t11">
<p>ORA-01411</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r50c1-t11" headers="r1c1-t11">
<p>22023</p>
</td>
<td class="cellalignment3247" headers="r50c1-t11 r1c2-t11">
<p>invalid parameter value</p>
</td>
<td class="cellalignment3247" headers="r50c1-t11 r1c3-t11">
<p>ORA-01025 ORA-01488 ORA-04000 .. 04019</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r51c1-t11" headers="r1c1-t11">
<p>22024</p>
</td>
<td class="cellalignment3247" headers="r51c1-t11 r1c2-t11">
<p>unterminated C string</p>
</td>
<td class="cellalignment3247" headers="r51c1-t11 r1c3-t11">
<p>ORA-01479 .. 01480</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r52c1-t11" headers="r1c1-t11">
<p>22025</p>
</td>
<td class="cellalignment3247" headers="r52c1-t11 r1c2-t11">
<p>invalid escape sequence</p>
</td>
<td class="cellalignment3247" headers="r52c1-t11 r1c3-t11">
<p>ORA-01424</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r53c1-t11" headers="r1c1-t11">
<p>22026</p>
</td>
<td class="cellalignment3247" headers="r53c1-t11 r1c2-t11">
<p>string data - length mismatch</p>
</td>
<td class="cellalignment3247" headers="r53c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r54c1-t11" headers="r1c1-t11">
<p>22027</p>
</td>
<td class="cellalignment3247" headers="r54c1-t11 r1c2-t11">
<p>trim error</p>
</td>
<td class="cellalignment3247" headers="r54c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r55c1-t11" headers="r1c1-t11">
<p>23000</p>
</td>
<td class="cellalignment3247" headers="r55c1-t11 r1c2-t11">
<p>integrity constraint violation</p>
</td>
<td class="cellalignment3247" headers="r55c1-t11 r1c3-t11">
<p>ORA-00001 ORA-01400 ORA-02290 .. 02299</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r56c1-t11" headers="r1c1-t11">
<p>24000</p>
</td>
<td class="cellalignment3247" headers="r56c1-t11 r1c2-t11">
<p>invalid cursor state</p>
</td>
<td class="cellalignment3247" headers="r56c1-t11 r1c3-t11">
<p>ORA-01001 .. 01003 ORA-01410 ORA-06511 ORA-08006 SQL-02114 SQL-02117 SQL-02118 SQL-02122</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r57c1-t11" headers="r1c1-t11">
<p>25000</p>
</td>
<td class="cellalignment3247" headers="r57c1-t11 r1c2-t11">
<p>invalid transaction state</p>
</td>
<td class="cellalignment3247" headers="r57c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r58c1-t11" headers="r1c1-t11">
<p>26000</p>
</td>
<td class="cellalignment3247" headers="r58c1-t11 r1c2-t11">
<p>invalid SQL statement name</p>
</td>
<td class="cellalignment3247" headers="r58c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r59c1-t11" headers="r1c1-t11">
<p>27000</p>
</td>
<td class="cellalignment3247" headers="r59c1-t11 r1c2-t11">
<p>triggered data change violation</p>
</td>
<td class="cellalignment3247" headers="r59c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r60c1-t11" headers="r1c1-t11">
<p>28000</p>
</td>
<td class="cellalignment3247" headers="r60c1-t11 r1c2-t11">
<p>invalid authorization specification</p>
</td>
<td class="cellalignment3247" headers="r60c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r61c1-t11" headers="r1c1-t11">
<p>2A000</p>
</td>
<td class="cellalignment3247" headers="r61c1-t11 r1c2-t11">
<p>direct SQL syntax error or access rule violation</p>
</td>
<td class="cellalignment3247" headers="r61c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r62c1-t11" headers="r1c1-t11">
<p>2B000</p>
</td>
<td class="cellalignment3247" headers="r62c1-t11 r1c2-t11">
<p>dependent privilege descriptors still exist</p>
</td>
<td class="cellalignment3247" headers="r62c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r63c1-t11" headers="r1c1-t11">
<p>2C000</p>
</td>
<td class="cellalignment3247" headers="r63c1-t11 r1c2-t11">
<p>invalid character set name</p>
</td>
<td class="cellalignment3247" headers="r63c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r64c1-t11" headers="r1c1-t11">
<p>2D000</p>
</td>
<td class="cellalignment3247" headers="r64c1-t11 r1c2-t11">
<p>invalid transaction termination</p>
</td>
<td class="cellalignment3247" headers="r64c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r65c1-t11" headers="r1c1-t11">
<p>2E000</p>
</td>
<td class="cellalignment3247" headers="r65c1-t11 r1c2-t11">
<p>invalid connection name</p>
</td>
<td class="cellalignment3247" headers="r65c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r66c1-t11" headers="r1c1-t11">
<p>33000</p>
</td>
<td class="cellalignment3247" headers="r66c1-t11 r1c2-t11">
<p>invalid SQL descriptor name</p>
</td>
<td class="cellalignment3247" headers="r66c1-t11 r1c3-t11">
<p>SQL-02138</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r67c1-t11" headers="r1c1-t11">
<p>34000</p>
</td>
<td class="cellalignment3247" headers="r67c1-t11 r1c2-t11">
<p>invalid cursor name</p>
</td>
<td class="cellalignment3247" headers="r67c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r68c1-t11" headers="r1c1-t11">
<p>35000</p>
</td>
<td class="cellalignment3247" headers="r68c1-t11 r1c2-t11">
<p>invalid condition number</p>
</td>
<td class="cellalignment3247" headers="r68c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r69c1-t11" headers="r1c1-t11">
<p>37000</p>
</td>
<td class="cellalignment3247" headers="r69c1-t11 r1c2-t11">
<p>dynamic SQL syntax error or access rule violation</p>
</td>
<td class="cellalignment3247" headers="r69c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r70c1-t11" headers="r1c1-t11">
<p>3C000</p>
</td>
<td class="cellalignment3247" headers="r70c1-t11 r1c2-t11">
<p>ambiguous cursor name</p>
</td>
<td class="cellalignment3247" headers="r70c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r71c1-t11" headers="r1c1-t11">
<p>3D000</p>
</td>
<td class="cellalignment3247" headers="r71c1-t11 r1c2-t11">
<p>invalid catalog name</p>
</td>
<td class="cellalignment3247" headers="r71c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r72c1-t11" headers="r1c1-t11">
<p>3F000</p>
</td>
<td class="cellalignment3247" headers="r72c1-t11 r1c2-t11">
<p>invalid schema name</p>
</td>
<td class="cellalignment3247" headers="r72c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r73c1-t11" headers="r1c1-t11">
<p>40000</p>
</td>
<td class="cellalignment3247" headers="r73c1-t11 r1c2-t11">
<p>transaction rollback</p>
</td>
<td class="cellalignment3247" headers="r73c1-t11 r1c3-t11">
<p>ORA-02091 .. 02092</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r74c1-t11" headers="r1c1-t11">
<p>40001</p>
</td>
<td class="cellalignment3247" headers="r74c1-t11 r1c2-t11">
<p>serialization failure</p>
</td>
<td class="cellalignment3247" headers="r74c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r75c1-t11" headers="r1c1-t11">
<p>40002</p>
</td>
<td class="cellalignment3247" headers="r75c1-t11 r1c2-t11">
<p>integrity constraint violation</p>
</td>
<td class="cellalignment3247" headers="r75c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r76c1-t11" headers="r1c1-t11">
<p>40003</p>
</td>
<td class="cellalignment3247" headers="r76c1-t11 r1c2-t11">
<p>statement completion unknown</p>
</td>
<td class="cellalignment3247" headers="r76c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r77c1-t11" headers="r1c1-t11">
<p>42000</p>
</td>
<td class="cellalignment3247" headers="r77c1-t11 r1c2-t11">
<p>syntax error or access rule violation</p>
</td>
<td class="cellalignment3247" headers="r77c1-t11 r1c3-t11">
<p>ORA-00022 ORA-00251 ORA-00900 .. 00999 ORA-01031 ORA-01490 .. 01493 ORA-01700 .. 01799 ORA-01900 .. 02099 ORA-02140 .. 02289 ORA-02420 .. 02424 ORA-02450 .. 02499 ORA-03276 .. 03299 ORA-04040 .. 04059 ORA-04070 .. 04099</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r78c1-t11" headers="r1c1-t11">
<p>44000</p>
</td>
<td class="cellalignment3247" headers="r78c1-t11 r1c2-t11">
<p>with check option violation</p>
</td>
<td class="cellalignment3247" headers="r78c1-t11 r1c3-t11">
<p>ORA-01402</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r79c1-t11" headers="r1c1-t11">
<p>60000</p>
</td>
<td class="cellalignment3247" headers="r79c1-t11 r1c2-t11">
<p>system errors</p>
</td>
<td class="cellalignment3247" headers="r79c1-t11 r1c3-t11">
<p>ORA-00370 .. 00429 ORA-00600 .. 00899 ORA-06430 .. 06449 ORA-07200 .. 07999 ORA-09700 .. 09999</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r80c1-t11" headers="r1c1-t11">
<p>61000</p>
</td>
<td class="cellalignment3247" headers="r80c1-t11 r1c2-t11">
<p>resource error</p>
</td>
<td class="cellalignment3247" headers="r80c1-t11 r1c3-t11">
<p>ORA-00018 .. 00035 ORA-00050 .. 00068 ORA-02376 .. 02399 ORA-04020 .. 04039</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r81c1-t11" headers="r1c1-t11">
<p>62000</p>
</td>
<td class="cellalignment3247" headers="r81c1-t11 r1c2-t11">
<p>shared server and detached process errors</p>
</td>
<td class="cellalignment3247" headers="r81c1-t11 r1c3-t11">
<p>ORA-00101 .. 00120 ORA-00440 .. 00569</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r82c1-t11" headers="r1c1-t11">
<p>63000</p>
</td>
<td class="cellalignment3247" headers="r82c1-t11 r1c2-t11">
<p>Oracle*XA and two-task interface errors</p>
</td>
<td class="cellalignment3247" headers="r82c1-t11 r1c3-t11">
<p>ORA-00150 .. 00159 SQL-02128 ORA-02700 .. 02899 ORA-03100 .. 03199 ORA-06200 .. 06249 SQL-02128</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r83c1-t11" headers="r1c1-t11">
<p>64000</p>
</td>
<td class="cellalignment3247" headers="r83c1-t11 r1c2-t11">
<p>control file, database file, and redo file errors; archival and media recovery errors</p>
</td>
<td class="cellalignment3247" headers="r83c1-t11 r1c3-t11">
<p>ORA-00200 .. 00369 ORA-01100 .. 01250</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r84c1-t11" headers="r1c1-t11">
<p>65000</p>
</td>
<td class="cellalignment3247" headers="r84c1-t11 r1c2-t11">
<p>PL/SQL errors</p>
</td>
<td class="cellalignment3247" headers="r84c1-t11 r1c3-t11">
<p>ORA-06500 .. 06599</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r85c1-t11" headers="r1c1-t11">
<p>66000</p>
</td>
<td class="cellalignment3247" headers="r85c1-t11 r1c2-t11">
<p>SQL*Net driver errors</p>
</td>
<td class="cellalignment3247" headers="r85c1-t11 r1c3-t11">
<p>ORA-06000 .. 06149 ORA-06250 .. 06429 ORA-06600 .. 06999 ORA-12100 .. 12299 ORA-12500 .. 12599</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r86c1-t11" headers="r1c1-t11">
<p>67000</p>
</td>
<td class="cellalignment3247" headers="r86c1-t11 r1c2-t11">
<p>licensing errors</p>
</td>
<td class="cellalignment3247" headers="r86c1-t11 r1c3-t11">
<p>ORA-00430 .. 00439</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r87c1-t11" headers="r1c1-t11">
<p>69000</p>
</td>
<td class="cellalignment3247" headers="r87c1-t11 r1c2-t11">
<p>SQL*Connect errors</p>
</td>
<td class="cellalignment3247" headers="r87c1-t11 r1c3-t11">
<p>ORA-00570 .. 00599 ORA-07000 .. 07199</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r88c1-t11" headers="r1c1-t11">
<p>72000</p>
</td>
<td class="cellalignment3247" headers="r88c1-t11 r1c2-t11">
<p>SQL execute phase errors</p>
</td>
<td class="cellalignment3247" headers="r88c1-t11 r1c3-t11">
<p>ORA-01000 .. 01099 ORA-01400 .. 01489 ORA-01495 .. 01499 ORA-01500 .. 01699 ORA-02400 .. 02419 ORA-02425 .. 02449 ORA-04060 .. 04069 ORA-08000 .. 08190 ORA-12000 .. 12019 ORA-12300 .. 12499 ORA-12700 .. 21999</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r89c1-t11" headers="r1c1-t11">
<p>82100</p>
</td>
<td class="cellalignment3247" headers="r89c1-t11 r1c2-t11">
<p>out of memory (could not allocate)</p>
</td>
<td class="cellalignment3247" headers="r89c1-t11 r1c3-t11">
<p>SQL-02100</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r90c1-t11" headers="r1c1-t11">
<p>82101</p>
</td>
<td class="cellalignment3247" headers="r90c1-t11 r1c2-t11">
<p>inconsistent cursor cache: unit cursor/global cursor mismatch</p>
</td>
<td class="cellalignment3247" headers="r90c1-t11 r1c3-t11">
<p>SQL-02101</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r91c1-t11" headers="r1c1-t11">
<p>82102</p>
</td>
<td class="cellalignment3247" headers="r91c1-t11 r1c2-t11">
<p>inconsistent cursor cache: no global cursor entry</p>
</td>
<td class="cellalignment3247" headers="r91c1-t11 r1c3-t11">
<p>SQL-02102</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r92c1-t11" headers="r1c1-t11">
<p>82103</p>
</td>
<td class="cellalignment3247" headers="r92c1-t11 r1c2-t11">
<p>inconsistent cursor cache: out of range cursor cache reference</p>
</td>
<td class="cellalignment3247" headers="r92c1-t11 r1c3-t11">
<p>SQL-02103</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r93c1-t11" headers="r1c1-t11">
<p>82104</p>
</td>
<td class="cellalignment3247" headers="r93c1-t11 r1c2-t11">
<p>inconsistent host cache: no cursor cache available</p>
</td>
<td class="cellalignment3247" headers="r93c1-t11 r1c3-t11">
<p>SQL-02104</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r94c1-t11" headers="r1c1-t11">
<p>82105</p>
</td>
<td class="cellalignment3247" headers="r94c1-t11 r1c2-t11">
<p>inconsistent cursor cache: global cursor not found</p>
</td>
<td class="cellalignment3247" headers="r94c1-t11 r1c3-t11">
<p>SQL-02105</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r95c1-t11" headers="r1c1-t11">
<p>82106</p>
</td>
<td class="cellalignment3247" headers="r95c1-t11 r1c2-t11">
<p>inconsistent cursor cache: invalid Oracle cursor number</p>
</td>
<td class="cellalignment3247" headers="r95c1-t11 r1c3-t11">
<p>SQL-02106</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r96c1-t11" headers="r1c1-t11">
<p>82107</p>
</td>
<td class="cellalignment3247" headers="r96c1-t11 r1c2-t11">
<p>program too old for run-time library</p>
</td>
<td class="cellalignment3247" headers="r96c1-t11 r1c3-t11">
<p>SQL-02107</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r97c1-t11" headers="r1c1-t11">
<p>82108</p>
</td>
<td class="cellalignment3247" headers="r97c1-t11 r1c2-t11">
<p>invalid descriptor passed to run-time library</p>
</td>
<td class="cellalignment3247" headers="r97c1-t11 r1c3-t11">
<p>SQL-02108</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r98c1-t11" headers="r1c1-t11">
<p>82109</p>
</td>
<td class="cellalignment3247" headers="r98c1-t11 r1c2-t11">
<p>inconsistent host cache: host reference is out of range</p>
</td>
<td class="cellalignment3247" headers="r98c1-t11 r1c3-t11">
<p>SQL-02109</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r99c1-t11" headers="r1c1-t11">
<p>82110</p>
</td>
<td class="cellalignment3247" headers="r99c1-t11 r1c2-t11">
<p>inconsistent host cache: invalid host cache entry type</p>
</td>
<td class="cellalignment3247" headers="r99c1-t11 r1c3-t11">
<p>SQL-02110</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r100c1-t11" headers="r1c1-t11">
<p>82111</p>
</td>
<td class="cellalignment3247" headers="r100c1-t11 r1c2-t11">
<p>heap consistency error</p>
</td>
<td class="cellalignment3247" headers="r100c1-t11 r1c3-t11">
<p>SQL-02111</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r101c1-t11" headers="r1c1-t11">
<p>82112</p>
</td>
<td class="cellalignment3247" headers="r101c1-t11 r1c2-t11">
<p>unable to open message file</p>
</td>
<td class="cellalignment3247" headers="r101c1-t11 r1c3-t11">
<p>SQL-02113</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r102c1-t11" headers="r1c1-t11">
<p>82113</p>
</td>
<td class="cellalignment3247" headers="r102c1-t11 r1c2-t11">
<p>code generation internal consistency failed</p>
</td>
<td class="cellalignment3247" headers="r102c1-t11 r1c3-t11">
<p>SQL-02115</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r103c1-t11" headers="r1c1-t11">
<p>82114</p>
</td>
<td class="cellalignment3247" headers="r103c1-t11 r1c2-t11">
<p>reentrant code generator gave invalid context</p>
</td>
<td class="cellalignment3247" headers="r103c1-t11 r1c3-t11">
<p>SQL-02116</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r104c1-t11" headers="r1c1-t11">
<p>82115</p>
</td>
<td class="cellalignment3247" headers="r104c1-t11 r1c2-t11">
<p>invalid hstdef argument</p>
</td>
<td class="cellalignment3247" headers="r104c1-t11 r1c3-t11">
<p>SQL-02119</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r105c1-t11" headers="r1c1-t11">
<p>82116</p>
</td>
<td class="cellalignment3247" headers="r105c1-t11 r1c2-t11">
<p>first and second arguments to sqlrcn both null</p>
</td>
<td class="cellalignment3247" headers="r105c1-t11 r1c3-t11">
<p>SQL-02120</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r106c1-t11" headers="r1c1-t11">
<p>82117</p>
</td>
<td class="cellalignment3247" headers="r106c1-t11 r1c2-t11">
<p>invalid OPEN or PREPARE for this connection</p>
</td>
<td class="cellalignment3247" headers="r106c1-t11 r1c3-t11">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r107c1-t11" headers="r1c1-t11">
<p>82118</p>
</td>
<td class="cellalignment3247" headers="r107c1-t11 r1c2-t11">
<p>application context not found</p>
</td>
<td class="cellalignment3247" headers="r107c1-t11 r1c3-t11">
<p>SQL-02123</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r108c1-t11" headers="r1c1-t11">
<p>82119</p>
</td>
<td class="cellalignment3247" headers="r108c1-t11 r1c2-t11">
<p>connect error; can&#39;t get error text</p>
</td>
<td class="cellalignment3247" headers="r108c1-t11 r1c3-t11">
<p>SQL-02125</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r109c1-t11" headers="r1c1-t11">
<p>82120</p>
</td>
<td class="cellalignment3247" headers="r109c1-t11 r1c2-t11">
<p>precompiler/SQLLIB version mismatch.</p>
</td>
<td class="cellalignment3247" headers="r109c1-t11 r1c3-t11">
<p>SQL-02127</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r110c1-t11" headers="r1c1-t11">
<p>82121</p>
</td>
<td class="cellalignment3247" headers="r110c1-t11 r1c2-t11">
<p>FETCHed number of bytes is odd</p>
</td>
<td class="cellalignment3247" headers="r110c1-t11 r1c3-t11">
<p>SQL-02129</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r111c1-t11" headers="r1c1-t11">
<p>82122</p>
</td>
<td class="cellalignment3247" headers="r111c1-t11 r1c2-t11">
<p>EXEC TOOLS interface is not available</p>
</td>
<td class="cellalignment3247" headers="r111c1-t11 r1c3-t11">
<p>SQL-02130</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r112c1-t11" headers="r1c1-t11">
<p>82123</p>
</td>
<td class="cellalignment3247" headers="r112c1-t11 r1c2-t11">
<p>run-time context in use</p>
</td>
<td class="cellalignment3247" headers="r112c1-t11 r1c3-t11">
<p>SQL-02131</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r113c1-t11" headers="r1c1-t11">
<p>82124</p>
</td>
<td class="cellalignment3247" headers="r113c1-t11 r1c2-t11">
<p>unable to allocate run-time context</p>
</td>
<td class="cellalignment3247" headers="r113c1-t11 r1c3-t11">
<p>ORA-01422 SQL-02132</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r114c1-t11" headers="r1c1-t11">
<p>82125</p>
</td>
<td class="cellalignment3247" headers="r114c1-t11 r1c2-t11">
<p>unable to initialize process for use with threads</p>
</td>
<td class="cellalignment3247" headers="r114c1-t11 r1c3-t11">
<p>SQL-02133</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r115c1-t11" headers="r1c1-t11">
<p>82126</p>
</td>
<td class="cellalignment3247" headers="r115c1-t11 r1c2-t11">
<p>invalid run-time context</p>
</td>
<td class="cellalignment3247" headers="r115c1-t11 r1c3-t11">
<p>SQL-02134</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r116c1-t11" headers="r1c1-t11">
<p>90000</p>
</td>
<td class="cellalignment3247" headers="r116c1-t11 r1c2-t11">
<p>debug events</p>
</td>
<td class="cellalignment3247" headers="r116c1-t11 r1c3-t11">
<p>ORA-10000 .. 10999</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r117c1-t11" headers="r1c1-t11">
<p>99999</p>
</td>
<td class="cellalignment3247" headers="r117c1-t11 r1c2-t11">
<p>catch all</p>
</td>
<td class="cellalignment3247" headers="r117c1-t11 r1c3-t11">
<p>all others</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r118c1-t11" headers="r1c1-t11">
<p>HZ000</p>
</td>
<td class="cellalignment3247" headers="r118c1-t11 r1c2-t11">
<p>remote database access</p>
</td>
<td class="cellalignment3247" headers="r118c1-t11 r1c3-t11">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIGBFF"></a>
<div id="ZZPRE779" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the <a id="sthref1021"></a><a id="sthref1022"></a>SQL Communications Area</h2>
<p>The SQL Communications area (<a id="sthref1023"></a>SQLCA) is a record-like data structure. Its fields contain error, warning, and status information updated by Oracle whenever a SQL <a id="sthref1024"></a>statement is executed. Thus, the SQLCA always reflects the outcome of the most recent SQL operation. To determine the outcome, you can check variables in the SQLCA.</p>
<p>In host languages that allow both local and global declarations, your program can have more than one SQLCA. For example, it might have one global SQLCA and several local ones. Access to a local SQLCA is limited by its scope within the program. Oracle returns information only to the &#34;active&#34; SQLCA.</p>
<p>Also note that, when your application uses <a id="sthref1025"></a>SQL*Net to access a combination of local and remote databases concurrently, all the databases write to one SQLCA. There is <span class="italic">no</span> different SQLCA for each database. For more information, refer to &#34;<a href="ch_three.htm#BABCBHAA">Concurrent Logons</a>&#34; .</p>
<p>When <code>MODE={ORACLE|ANSI13}</code>, the SQLCA is required; if the SQLCA is not declared, compile-time errors will occur. The SQLCA is optional when <code>MODE={ANSI|ANSI14}</code>, but you cannot use the <code>WHENEVER</code> SQLWARNING statement without declaring SQLCA. So, if you want to use the <code>WHENEVER</code> SQLWARNING statement, you must declare the SQLCA.</p>
<p>If you declare SQLCODE instead of the SQLCA in a particular compilation unit, the precompiler allocates an internal SQLCA for that unit. Your host program cannot access the internal SQLCA. If you declare the SQLCA <span class="italic">and</span> SQLCODE (Pro*FORTRAN only), Oracle returns the same status code to both after every SQL operation.</p>
<p>When <code>MODE={ANSI|ANSI14}</code>, you must declare either SQLSTATE (refer to <a href="#CEGDFHIJ">SQLCODE and SQLSTATE</a> The SQLSTATE status variable supports the SQLSTATE status variable specified by the SQL92 standard. You can use the SQLSTATE status variable with or without SQLCODE. refer to <a href="#CEGFJGAC">Table 8-3</a> and <a href="#CEGFHDFC">Table 8-4</a>for more information.</p>
<a id="CEGDCCFE"></a>
<div id="ZZPRE780" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1026"></a>Declaring the SQLCA</h3>
<p>To declare the SQLCA, simply include it (using an EXEC SQL <code>INCLUDE</code> statement<a id="sthref1027"></a>) in your host-language source file as follows:</p>
<pre>* Include the Oracle Communications Area (ORACA).
 EXEC SQL INCLUDE ORACA
EXEC SQL INCLUDE SQLCA;
</pre>
<p>The SQLCA is used if and only if there is an <code>INCLUDE</code> of the SQLCA.</p>
<p>When you precompile your program, the <code>INCLUDE</code> SQLCA statement is replaced by several variable declarations that allow Oracle to communicate with the program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE781" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1028"></a>
<h3 class="sect2">Declaring the SQLCA in Pro*COBOL</h3>
<p>In Pro*COBOL, it makes no difference whether the <code>INCLUDE</code> is <span class="italic">inside</span> or <span class="italic">outside</span> of a Declare Section. For more information about declaring the SQLCA in Pro*COBOL, refer to <a class="olink LNPCB" href="../LNPCB/toc.htm"><span class="italic">Pro*COBOL Programmer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE782" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1029"></a>
<h3 class="sect2">Declaring the SQLCA in Pro*FORTRAN</h3>
<p>In Pro*FORTRAN, the SQLCA must be declared <span class="italic">outside</span> the Declare Section, because it is a COMMON block. Furthermore, the SQLCA must come before the <code>CONNECT</code> statement and the first executable FORTRAN statement.</p>
<p>You must declare the SQLCA in each subroutine and function that contains SQL statements. Every time a SQL statement in one of the subroutines or functions is executed, Oracle updates the SQLCA held in the COMMON block.</p>
<p>Ordinarily, only the order and datatypes of variables in a COMMON-list matter, not their names. However, you cannot rename the SQLCA variables because the precompiler generates code that refers to them. Thus, all declarations of the SQLCA must be identical. For more information about declaring the SQLCA in Pro*FORTRAN, refer to <a class="olink ZZFOR" href="../ZZFOR/toc.htm"><span class="italic">Pro*FORTRAN Supplement to the Oracle Precompilers Guide</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE783" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1030"></a>
<h3 class="sect2">What&#39;s in the SQLCA?</h3>
<p>The SQLCA contains the following run-time information about the outcome of SQL statements:</p>
<ul>
<li>
<p>Oracle error codes</p>
</li>
<li>
<p>Warning flags</p>
</li>
<li>
<p>Event information</p>
</li>
<li>
<p>Rows-processed count</p>
</li>
<li>
<p>Diagnostics</p>
</li>
</ul>
<p><a href="#BABGCIID">Figure 8-2</a> shows all the variables in the SQLCA. To see the SQLCA structure and variable names in a particular host language, refer to your supplement to this Guide.</p>
<div id="ZZPRE784" class="figure">
<p class="titleinfigure"><a id="BABGCIID"></a>Figure 8-2 SQLCA Variables</p>
<img width="536" height="420" src="img/image011.gif" alt="SQLCA variables"/><br/>
<a id="sthref1031" href="img_text/image011.htm">Description of &#34;Figure 8-2 SQLCA Variables&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="CEGEGIDG"></a>
<div id="ZZPRE785" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Key Components of Error Reporting</h3>
<p><a id="sthref1032"></a>Error reporting depends on variables in the SQLCA. This section highlights the key <a id="sthref1033"></a>components of error reporting. The next section takes a close look at the SQLCA.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE786" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1034"></a>
<h3 class="sect2">Status Codes</h3>
<p><a id="sthref1035"></a>Every executable SQL statement returns a <a id="sthref1036"></a>status code to the SQLCA variable SQLCODE, which you can check implicitly with the <code>WHENEVER</code> statement or explicitly with your own code.</p>
<p>Status codes can be zero, less than zero, or greater than zero. Refer to <a href="#CEGICGDB">Declaring SQLCODE</a>&#34; for complete SQLCODE descriptions.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE787" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1037"></a>
<h3 class="sect2"><a id="sthref1038"></a>Warning<a id="sthref1039"></a> Flags</h3>
<p><a id="sthref1040"></a>Warning flags are returned in the SQLCA variables SQLWARN(0) through SQLWARN(7), which you can check implicitly or explicitly. These warning flags are useful for run-time conditions not considered errors by Oracle.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE788" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1041"></a>
<h3 class="sect2"><a id="sthref1042"></a>Rows-Processed<a id="sthref1043"></a> Count</h3>
<p><a id="sthref1044"></a>The number of rows processed by the most recently executed SQL statement is returned in the SQLCA variable SQLERRD(3), which you can check explicitly.</p>
<p>Speaking strictly, this variable is not for error reporting, but it can help you avoid mistakes. For example, suppose you expect to delete about ten rows from a table. After the deletion, you check SQLERRD(3) and find that 75 rows were processed. To be safe, you might want to roll back the deletion and examine the search condition in your <code>WHERE</code> clause.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE789" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1045"></a>
<h3 class="sect2"><a id="sthref1046"></a>Parse Error Offset</h3>
<p><a id="sthref1047"></a>Before executing a SQL statement, Oracle must <span class="italic">parse</span> it, that is, examine it to make sure it follows syntax rules and refers to valid database objects. If Oracle finds an error, an offset is stored in the SQLCA variable SQLERRD(5), which you can check explicitly. The offset specifies the character position in the SQL statement at which the parse error begins. The first character occupies position zero. For example, if the offset is 9, the parse error begins at the tenth character.</p>
<p>By default, static SQL statements are checked for syntactic errors at precompile time. So, SQLERRD(5) is most useful for debugging dynamic SQL statements, which your program accepts or builds at run time.</p>
<p>Parse errors arise from missing, misplaced, or misspelled keywords, invalid options, nonexistent tables, and the like. For example, the dynamic SQL statement</p>
<pre>UPDATE EMP SET JIB = :job_title WHERE EMPNO = :emp_number
</pre>
<p>causes the parse error</p>
<pre>ORA-00904: invalid column name
</pre>
<p>because the column name JOB is misspelled. The value of SQLERRD(5) is 15 because the erroneous column name JIB begins at the sixteenth character.</p>
<p>If your SQL statement does not cause a parse error, Oracle sets SQLERRD(5) to zero. Oracle also sets SQLERRD(5) to zero if a parse error begins at the first character (which occupies position zero). So, check SQLERRD(5) only if SQLCODE is negative, which means that an error has occurred.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE790" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1048"></a>
<h3 class="sect2">Error Message Text</h3>
<p><a id="sthref1049"></a>The error code and message for Oracle errors are available in the SQLCA variable SQLERRMC. At most, the first 70 characters of text are stored. To get the full text of messages longer than 70 characters, you use the SQLGLM function. Refer to <a href="#CEGIEJFH">&#34;Getting the Full Text of Error Messages&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE791" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1050"></a>
<h3 class="sect2">SQLCA <a id="sthref1051"></a>Structure</h3>
<p><a id="sthref1052"></a>This section describes the structure of the SQLCA, its fields, and the values they can store.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE792" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1053"></a>
<h3 class="sect2"><a id="sthref1054"></a>SQLCAID</h3>
<p>This string field is initialized to &#34;SQLCA&#34; to identify the SQL Communications Area.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE793" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1055"></a>
<h3 class="sect2"><a id="sthref1056"></a>SQLCABC</h3>
<p>This integer field holds the length, in bytes, of the SQLCA structure.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE794" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1057"></a>
<h3 class="sect2"><a id="sthref1058"></a>SQLCODE</h3>
<p>This integer field holds the status code of the most recently executed SQL statement. The status code, which indicates the outcome of the SQL operation, can be any of the following numbers:</p>
<p>0</p>
<p>Oracle executed the statement without detecting an error or exception.</p>
<p>&gt; 0</p>
<p>Oracle executed the statement but detected an exception. This occurs when Oracle cannot find a row that meets your <code>WHERE</code>-clause search condition or when a <code>SELECT</code> <code>INTO</code> or <code>FETCH</code> returns no rows.</p>
<p>&lt; 0</p>
<p>When <code>MODE={ANSI|ANSI14|ANSI13}, +100</code> is returned to SQLCODE after an <a id="sthref1059"></a>INSERT of no rows. This can happen when a subquery returns no rows to process.</p>
<p>Oracle did not execute the statement because of a database, system, network, or application error. Such errors are irrecoverable. When they occur, the current transaction should, in most cases, be rolled back.</p>
<p>Negative return codes correspond to error codes listed in <a class="olink ERRMG" href="../ERRMG/toc.htm"><span class="italic">Oracle Database Error Messages</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE795" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1060"></a>
<h3 class="sect2">SQLERRM</h3>
<p>This subrecord contains the following two fields:</p>
<p><a id="sthref1061"></a>SQLERRML</p>
<p>This integer field holds the length of the message text stored in SQLERRMC.</p>
<p><a id="sthref1062"></a>SQLERRMC</p>
<p>This string field holds the message text for the error code stored in SQLCODE and can store up to 70 characters. For the full text of messages longer than 70 characters, use the SQLGLM function.</p>
<p>Verify SQLCODE is negative</p>
<p><span class="italic">before</span> you reference SQLERRMC. If you reference SQLERRMC when SQLCODE is zero, you get the message text associated with a prior SQL statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE796" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1063"></a>
<h3 class="sect2">SQLERRP</h3>
<p>This string field is reserved for future use.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE797" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1064"></a>
<h3 class="sect2"><a id="sthref1065"></a>SQLERRD</h3>
<p>This array of binary integers has six elements. Descriptions of the fields in SQLERRD (called SQLERD in FORTRAN) follow:</p>
<p>SQLERRD(1)</p>
<p>This field is reserved for future use.</p>
<p>SQLERRD(2)</p>
<p>This field is reserved for future use.</p>
<p>SQLERRD(3)</p>
<p>This field holds the number of rows processed by the most recently executed SQL statement. However, if the SQL statement failed, the value of SQLERRD(3) is undefined, with one exception. If the error occurred during an array operation, processing stops at the row that caused the error, so SQLERRD(3) gives the number of rows processed successfully.</p>
<p>The <a id="sthref1066"></a>rows-processed count is zeroed after an <code>OPEN</code> statement and incremented after a <code>FETCH</code> statement. For the <code>EXECUTE</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code> <code>INTO</code> statements, the count reflects the number of rows processed successfully. The count does <a id="sthref1067"></a><span class="italic">not</span> include rows processed by an update or <a id="sthref1068"></a>delete cascade. For example, if 20 rows are deleted because they meet WHERE-clause criteria, and 5 more rows are deleted because they now (after the primary delete) violate column constraints, the count is 20 not 25.</p>
<p>SQLERRD(4)</p>
<p>This field is reserved for future use.</p>
<p><a id="sthref1069"></a>SQLERRD(5)</p>
<p>This field holds an offset that specifies the character position at which a parse error begins in the most recently executed SQL statement. The first character occupies position zero.</p>
<p>SQLERRD(6)</p>
<p>This field is reserved for future use.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE798" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1070"></a>
<h3 class="sect2"><a id="sthref1071"></a>SQLWARN</h3>
<p>This array of single characters has eight elements. They are used as warning flags. Oracle sets a flag by assigning it a &#34;W&#34; (for warning) character value. The flags warn of exceptional conditions.</p>
<p>For example, a warning flag is set when Oracle assigns a truncated column value to an output host variable.</p>
<p>Also note that, while <a href="#BABGCIID">Figure 8-2</a> illustrates SQLWARN as an array, it is implemented in Pro*COBOL as a group item with elementary PIC X items named SQLWARN0 through SQLWARN7. The Pro*FORTRAN implementation is composed of the LOGICAL variables, SQLWN0 through SQLWN7.</p>
<p>Descriptions of the fields in <a id="sthref1072"></a>SQLWARN follow:</p>
<p>SQLWARN(0)</p>
<p>This flag is set if another warning flag is set.</p>
<p>SQLWARN(1)</p>
<p>This flag is set if a truncated column value was assigned to an output host variable. This applies only to character data. Oracle truncates certain numeric data without setting a warning or returning a negative SQLCODE value.</p>
<p>To find out if a column value was truncated and by how much, check the indicator variable associated with the output host variable. The (positive) integer returned by an indicator variable is the original length of the column value. You can increase the length of the host variable accordingly.</p>
<p>SQLWARN(2)</p>
<p>This flag is set if one or more nulls were ignored in the evaluation of a SQL group function such as AVG, COUNT, or MAX. This behavior is expected because, except for COUNT(*), all group functions ignore nulls. If necessary, you can use the SQL function NVL to temporarily assign values (zeros, for example) to the null column entries.</p>
<p>SQLWARN(3)</p>
<p>This flag is set if the number of columns in a query select list does not equal the number of host variables in the <code>INTO</code> clause of the <code>SELECT</code> or <code>FETCH</code> statement. The number of items returned is the lesser of the two.</p>
<p>SQLWARN(4)</p>
<p><a id="sthref1073"></a>This flag is set if every row in a table was processed by an <code>UPDATE</code> or <code>DELETE</code> statement without a WHERE clause. An update or deletion is called <span class="italic">unconditional</span> if no search condition restricts the number of rows processed. Such updates and deletions are unusual, so Oracle sets this warning flag. That way, you can roll back the transaction if necessary</p>
<p>SQLWARN(5)</p>
<p>This flag is set when an EXEC SQL CREATE {PROCEDURE|FUNCTION|PACKAGE|PACKAGE BODY} statement fails because of a PL/SQL compilation error.</p>
<p>SQLWARN(6)</p>
<p>This flag is no longer in use.</p>
<p>SQLWARN(7)</p>
<p>This flag is no longer in use.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE799" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1074"></a>
<h3 class="sect2">SQLEXT</h3>
<p>This string field is reserved for future use.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE800" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1075"></a>
<h3 class="sect2"><a id="sthref1076"></a>PL/SQL <a id="sthref1077"></a>Considerations</h3>
<p>When your precompiler program executes an embedded PL/SQL block, not all fields in the SQLCA are set. For example, if the block fetches several rows, the rows-processed count, SQLERRD(3), is set to 1, <span class="italic">not</span> the actual number of rows fetched. So, you should rely only on the SQLCODE and SQLERRM fields in the SQLCA after executing a PL/SQL block.</p>
</div>
<!-- class="sect2" -->
<a id="CEGIEJFH"></a>
<div id="ZZPRE801" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Getting the Full Text of Error Messages</h3>
<p>The SQLCA can accommodate error messages up to 70 characters long. To get the full text of longer (or nested) error messages, you need the <a id="sthref1078"></a>SQLGLM function. If connected to Oracle, you can call <a id="sthref1079"></a>SQLGLM using the syntax</p>
<pre><a id="sthref1080"></a>SQLGLM(message_buffer, buffer_size, message_length);
</pre>
<p>where:</p>
<p>message_buffer</p>
<p>is the text buffer in which you want Oracle to store the error message (Oracle blank-pads to the end of this buffer).</p>
<p>buffer_size</p>
<p>is an integer variable that specifies the maximum size of the buffer in bytes.</p>
<p><a id="sthref1081"></a>message_length</p>
<p>is an integer variable in which Oracle stores the actual length of the error message.</p>
<p>The maximum length of an Oracle error message is 512 characters including the error code, nested messages, and message inserts such as table and column names. The maximum length of an error message returned by SQLGLM depends on the value you specify for <span class="italic">buffer_size</span>.</p>
<p><a id="sthref1082"></a>In the following example, you call SQLGLM to get an error message of up to 100 characters in length:</p>
<pre>-- declare variables for function call
msg_buffer CHARACTER(100);
buf_size INTEGER;
msg_length INTEGER;
set buf_size = 100;
EXEC SQL WHENEVER SQLERROR DO sql_error;
-- other statements
ROUTINE sql_error
BEGIN
 -- get full text of error message
 SQLGLM(msg_buffer, buf_size, msg_length);
 display contents of msg_buffer;
 exit program with an error
END sql_error;
</pre>
<p>Notice that SQLGLM is called only when a SQL error has occurred. Always make sure SQLCODE is negative <span class="italic">before</span> calling SQLGLM. If you call SQLGLM when SQLCODE is zero, you get the message text associated with a prior SQL statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE802" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1083"></a>
<h3 class="sect2">Using the <a id="sthref1084"></a>WHENEVER Statement</h3>
<p>By default, precompiled programs ignore Oracle error and warning conditions and continue processing if possible. To perform automatic condition checking and <a id="sthref1085"></a>error handling, use the <code>WHENEVER<a id="sthref1086"></a></code> statement.</p>
<p>With the <code>WHENEVER</code> statement, you can specify actions to be taken when Oracle detects an error, warning condition, or &#34;not found&#34; condition. These actions include continuing with the next statement, calling a routine, branching to a labeled statement, or stopping.</p>
<p>You code the <code>WHENEVER</code> statement by using the following syntax:</p>
<pre>EXEC SQL WHENEVER &lt;condition&gt; &lt;action&gt;;
</pre>
<p><a id="sthref1087"></a>You can have Oracle automatically check the SQLCA for any of the following conditions.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE803" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1088"></a>
<h3 class="sect2"><a id="sthref1089"></a><a id="sthref1090"></a>SQLWARNING</h3>
<p>SQLWARN(0) is set because Oracle returned a warning (one of the warning flags, SQLWARN(1) through SQLWARN(7), is also set) or SQLCODE has a positive value other than +1403. For example, SQLWARN(1) is set when Oracle assigns a truncated column value to an output host variable.</p>
<p>Declaring the SQLCA is optional when MODE={ANSI|ANSI14}. To use WHENEVER SQLWARNING, however, you <span class="italic">must</span> declare the SQLCA.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE804" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1091"></a>
<h3 class="sect2"><a id="sthref1092"></a><a id="sthref1093"></a>SQLERROR</h3>
<p>SQLCODE has a negative value because Oracle returned an error.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE805" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1094"></a>
<h3 class="sect2"><a id="sthref1095"></a>NOT FOUND</h3>
<p>SQLCODE has a value of +1403 (+100 when <code>MODE={ANSI|ANSI14| ANSI13}</code>), because Oracle could not find a row that meets the search condition of a <code>WHERE</code> clause, or a <code>SELECT INTO</code> or <code>FETCH</code> returned no rows. When <code>MODE={ANSI|ANSI14|ANSI13}, +100</code> is returned to SQLCODE after an <code>INSERT</code> of no rows.</p>
<p>When Oracle detects one of the preceding <span class="italic">conditions</span>, you can have your program take any of the following actions.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE806" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1096"></a>
<h3 class="sect2"><a id="sthref1097"></a>CONTINUE</h3>
<p><a id="sthref1098"></a>Your program continues to run with the next statement if possible. This is the default action, equivalent to not using the <code>WHENEVER</code> statement. You can use it to &#34;turn off&#34; condition checking.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE807" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1099"></a>
<h3 class="sect2"><a id="sthref1100"></a>DO</h3>
<p><a id="sthref1101"></a>Your program transfers control to an internal routine. When the end of the routine is reached, control transfers to the statement that follows the failed SQL statement.</p>
<p>A <span class="italic">routine</span> is any functional program unit that can be invoked, such as a COBOL paragraph or <code>FORTRAN</code> subroutine. In this context, separately compiled programs, such as <code>COBOL</code> subroutines, are <span class="italic">not</span> routines.</p>
<p>The usual rules for entering and exiting a routine apply. However, passing parameters to the routine is <span class="italic">not</span> allowed. Furthermore, the routine must <span class="italic">not</span> return a value.</p>
<p>The parameter <span class="italic">routine_call</span> is a host language invocation, as in</p>
<pre>EXEC SQL -- COBOL
 WHENEVER &lt;condition&gt; DO PERFORM &lt;paragraph_name&gt; -- COBOL
END-EXEC. -- COBOL
</pre>
<p>or</p>
<pre>EXEC SQL -- FORTRAN
 WHENEVER &lt;condition&gt; DO CALL &lt;subroutine_name&gt; -- FORTRAN
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE808" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1102"></a>
<h3 class="sect2"><a id="sthref1103"></a>GOTO</h3>
<p><a id="sthref1104"></a>Your program branches to a labeled statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE809" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1105"></a>
<h3 class="sect2"><a id="sthref1106"></a><a id="sthref1107"></a>STOP</h3>
<p>Your program stops running and uncommitted work is rolled back.</p>
<p>Be careful. The <code>STOP</code> action displays no messages before logging off Oracle. In Pascal, the <code>STOP</code> action is illegal because Pascal has no equivalent command.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE810" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1108"></a>
<h3 class="sect2">Some <a id="sthref1109"></a>Examples</h3>
<p>If you want your program to</p>
<ul>
<li>
<p>go to <span class="italic">close_cursor</span> if a &#34;no data found&#34; condition occurs,</p>
</li>
<li>
<p>continue with the next statement if a warning occurs, and</p>
</li>
<li>
<p>go to <span class="italic">error_handler</span> if an error occurs</p>
</li>
</ul>
<p>simply code the following <code>WHENEVER</code> statements before the first executable SQL statement:</p>
<pre>EXEC SQL WHENEVER NOT FOUND GOTO close_cursor;
EXEC SQL WHENEVER SQLWARNING CONTINUE;
EXEC SQL WHENEVER SQLERROR GOTO error_handler;
</pre>
<p>The following Pro*C example uses <code>WHENEVER</code>...<code>DO</code> statements to handle specific errors:</p>
<pre>EXEC SQL WHENEVER SQLERROR DO handle_insert_error;
EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO)
 VALUES (:emp_number, :emp_name, :dept_number);
EXEC SQL WHENEVER SQLERROR DO handle_delete_error;
EXEC SQL DELETE FROM DEPT WHERE DEPTNO = :dept_number;
...
ROUTINE handle_insert_error;
 BEGIN
 IF sqlca.sqlcode = -1 THEN -- duplicate key value
 ...
 ELSEIF sqlca.sqlcode = -1401 THEN -- value too large
 ...
 ENDIF;
 ...
 END;
ROUTINE handle_delete_error;
 BEGIN
 IF sqlca.sqlerrd(3) = 0 THEN -- no rows deleted
 ...
 ELSE
 ...
 ENDIF;
 ...
 END;
...
</pre>
<p>Notice how the procedures check variables in the SQLCA to determine a course of action.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE811" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1110"></a>
<h3 class="sect2"><a id="sthref1111"></a>Scope</h3>
<p><a id="sthref1112"></a>Because <code>WHENEVER</code> is a declarative statement, its scope is positional, not logical. It tests all executable SQL statements that follow it in the source file, not in the flow of program logic. Therefore, you should code the <code>WHENEVER</code> statement before the first executable SQL statement you want to test.</p>
<p>A <code>WHENEVER</code> statement stays in effect until superseded by another <code>WHENEVER</code> statement checking for the same condition.</p>
<p>In the example , the first <code>WHENEVER</code> SQLERROR statement is superseded by a second, and so applies only to the <code>CONNECT</code> statement. The second <code>WHENEVER</code> SQLERROR statement applies to both the UPDATE and DROP statements, despite the flow of control from <span class="italic">step1</span> to <span class="italic">step3</span>.</p>
<pre>step1:
EXEC SQL WHENEVER SQLERROR STOP;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
 ...
 GOTO step3;
step2:
EXEC SQL WHENEVER SQLERROR CONTINUE;
EXEC SQL UPDATE EMP SET SAL = SAL * 1.10; 
 ...
step3:
 EXEC SQL DROP INDEX EMP_INDEX;
 ...
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE812" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1113"></a>
<h3 class="sect2"><a id="sthref1114"></a>Guidelines</h3>
<p><a id="sthref1115"></a>The following guidelines will help you avoid some common pitfalls.</p>
<p><a id="sthref1116"></a><span class="bold">Placing the Statements.</span> In general, code a <code>WHENEVER</code> statement before the first executable SQL statement in your program. This ensures that all ensuing errors are trapped because WHENEVER statements stay in effect to the end of a file.</p>
<p><span class="bold"><a id="sthref1117"></a>Handling End-of-Data Conditions.</span> Your program should be prepared to handle an end-of-data condition when using a cursor to fetch rows. If a <code>FETCH</code> returns no data, the program should branch to a labeled section of code where a <code>CLOSE</code> command is issued, as follows:</p>
<pre>SQL WHENEVER NOT FOUND GOTO no_more;
...
no_more:
 ...
 EXEC SQL CLOSE my_cursor;
 ...
</pre>
<p><span class="bold">Avoiding Infinite Loops.</span> If a <code>WHENEVER</code> SQLERROR <code>GOTO</code> statement branches to an error handling routine that includes an executable SQL statement, your program might enter an infinite loop if the SQL statement fails with an error. You can avoid this by coding <code>WHENEVER</code> SQLERROR <code>CONTINUE</code> before the SQL statement, as shown in the following example:</p>
<pre>EXEC SQL WHENEVER SQLERROR GOTO sql_error;
...
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 ...
</pre>
<p>Without the <code>WHENEVER</code> SQLERROR <code>CONTINUE</code> statement, a <code>ROLLBACK</code> error would invoke the routine again, starting an infinite loop.</p>
<p>Careless use of <code>WHENEVER</code> can cause problems. For example, the following code enters an infinite loop if the <code>DELETE</code> statement sets <code>NOT</code> <code>FOUND</code> because no rows meet the search condition:</p>
<pre>-- improper use of WHENEVER
...
EXEC SQL WHENEVER NOT FOUND GOTO no_more;
LOOP
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;
 ...
ENDLOOP;
no_more:
 EXEC SQL DELETE FROM EMP WHERE EMPNO = :emp_number;
 ...
</pre>
<p>In the next example, you handle the <code>NOT FOUND</code> condition properly by resetting the <code>GOTO</code> target:</p>
<pre>-- proper use of WHENEVER
...
EXEC SQL WHENEVER NOT FOUND GOTO no_more;
LOOP
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;
 ...
ENDLOOP;
no_more:
 EXEC SQL WHENEVER NOT FOUND GOTO no_match;
 EXEC SQL DELETE FROM EMP WHERE EMPNO = :emp_number;
 ...
no_match:
 ...
</pre>
<p><span class="bold"><a id="sthref1118"></a>Maintaining Addressability.</span> With host languages that allow local and global identifiers, make sure all SQL statements governed by a <code>WHENEVER</code> <code>GOTO</code> statement can branch to the <code>GOTO</code> label. The following code results in a compile-time error because <span class="italic">labelA</span> in FUNC1 is not within the scope of the INSERT statement in FUNC2:</p>
<pre>FUNC1
 BEGIN
 EXEC SQL WHENEVER SQLERROR GOTO labelA;
 EXEC SQL DELETE FROM EMP WHERE DEPTNO = :dept_number;
 ...
 labelA:
 ...
 END;
FUNC2
 BEGIN
 EXEC SQL INSERT INTO EMP (JOB) VALUES (:job_title); 
 ...
 END;
</pre>
<p>The label to which a <code>WHENEVER GOTO</code> statement branches must be in the same precompilation file as the statement.</p>
<p><span class="bold">Returning after an Error.</span> If your program must return after handling an error, use the <code>DO</code> <span class="italic">routine_call</span> action. Alternatively, you can test the value of SQLCODE, as shown in the following example:</p>
<pre>EXEC SQL UPDATE EMP SET SAL = SAL * 1.10;
IF sqlca.sqlcode &lt; 0 THEN
 -- handle error
EXEC SQL DROP INDEX EMP_INDEX;
...
</pre>
<p>Just make sure no <code>WHENEVER</code> <code>GOTO</code> or <code>WHENEVER</code> <code>STOP</code> statement is active.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE813" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1119"></a>
<h3 class="sect2">Getting the Text of SQL Statements</h3>
<p><a id="sthref1120"></a>In many precompiler applications, it is convenient to know the text of the statement being processed, its length, and the SQL command (such as <code>INSERT</code> or <code>SELECT</code>) that it contains. This is especially true for applications that use dynamic SQL.</p>
<p><a id="sthref1121"></a>The routine SQLGLS, which is part of the SQLLIB run-time library, returns the following information:</p>
<ul>
<li>
<p>The text of the most recently parsed SQL statement</p>
</li>
<li>
<p>The Length of the statement</p>
</li>
<li>
<p>A Function code (refer to <a href="#CEGFFCHD">Table 8-8</a> for the SQL command used in the statement</p>
</li>
</ul>
<p>You can call SQLGLS after issuing a static SQL statement. With dynamic SQL Method 1, you can call SQLGLS after the SQL statement is executed. With dynamic SQL Method 2, 3, or 4, you can call SQLGLS after the statement is prepared.</p>
<p><a id="sthref1122"></a>To call SQLGLS, you use the following syntax:</p>
<pre>SQLGLS(SQLSTM, STMLEN, SQLFC)
</pre>
<p><a href="#CEGEHHCJ">Table 8-7</a> shows the host-language datatypes available for the parameters in the SQLGLS argument list.</p>
<div id="ZZPRE814" class="tblformal">
<p class="titleintable"><a id="sthref1123"></a><a id="CEGEHHCJ"></a>Table 8-7 SQLGLS Parameter Datatypes</p>
<table class="cellalignment3250" title="SQLGLS Parameter Datatypes" summary="language data types" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t12">Parameter</th>
<th class="cellalignment3246" id="r1c2-t12">Language</th>
<th class="cellalignment3246" id="r1c3-t12">Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t12" headers="r1c1-t12">
<p><a id="sthref1124"></a>SQLSTM</p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c2-t12">
<p>COBOL</p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c3-t12">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t12" headers="r1c1-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c2-t12">
<p>FORTRAN</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c3-t12">
<p>CHARACTER*<span class="italic">n</span></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t12" headers="r1c1-t12">
<p>STMLEN, SQLFC</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c2-t12">
<p>COBOL</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c3-t12">
<p>PIC S9(9) COMP</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t12" headers="r1c1-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c2-t12">
<p>FORTRAN</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c3-t12">
<p>INTEGER*4</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>All parameters must be passed by reference. This is usually the default parameter passing convention; you need not take special action.</p>
<p>The parameter SQLSTM is a blank-padded (not null-terminated) character buffer that holds the returned text of the SQL statement. Your program must statically declare the buffer or dynamically allocate memory for it.</p>
<p><a id="sthref1125"></a>The length parameter <a id="sthref1126"></a>STMLEN is a four-byte integer. Before calling SQLGLS, set this parameter to the actual size (in bytes) of the SQLSTM buffer. When SQLGLS returns, the SQLSTM buffer contains the SQL statement text blank padded to the length of the buffer. STMLEN returns the actual number of bytes in the returned statement text, not counting the blank padding. However, STMLEN returns a zero if an error occurred.</p>
<p>Some possible errors follow:</p>
<ul>
<li>
<p>No SQL statement was parsed.</p>
</li>
<li>
<p>You passed an invalid parameter (for example, a negative length value).</p>
</li>
<li>
<p>An internal exception occurred in SQLLIB.</p>
</li>
</ul>
<p><a id="sthref1127"></a>T<a id="sthref1128"></a>he parameter <a id="sthref1129"></a>SQLFC is a four-byte integer that returns the SQL function code for the SQL command in the statement. <a href="#CEGFFCHD">Table 8-8</a> shows the function code for each SQL command.</p>
<p><a id="sthref1130"></a>SQLGLS does not return statements that contain the following commands:</p>
<ul>
<li>
<p>CONNECT</p>
</li>
<li>
<p>COMMIT</p>
</li>
<li>
<p>ROLLBACK</p>
</li>
<li>
<p>RELEASE</p>
</li>
<li>
<p>FETCH</p>
</li>
</ul>
<p>There are no SQL function codes for these statements.</p>
<div id="ZZPRE815" class="tblformal">
<p class="titleintable"><a id="sthref1131"></a><a id="CEGFFCHD"></a>Table 8-8 SQL Command Function Codes</p>
<table class="cellalignment3250" title="SQL Command Function Codes" summary="sql functional codes" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t13">Co<span class="bold">de</span></th>
<th class="cellalignment3246" id="r1c2-t13">SQL Function</th>
<th class="cellalignment3246" id="r1c3-t13">Code</th>
<th class="cellalignment3246" id="r1c4-t13">SQL Function</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t13" headers="r1c1-t13">
<p>01</p>
</td>
<td class="cellalignment3247" headers="r2c1-t13 r1c2-t13">
<p>CREATE TABLE</p>
</td>
<td class="cellalignment3247" headers="r2c1-t13 r1c3-t13">
<p>39</p>
</td>
<td class="cellalignment3247" headers="r2c1-t13 r1c4-t13">
<p>AUDIT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t13" headers="r1c1-t13">
<p>02</p>
</td>
<td class="cellalignment3247" headers="r3c1-t13 r1c2-t13">
<p>SET ROLE</p>
</td>
<td class="cellalignment3247" headers="r3c1-t13 r1c3-t13">
<p>40</p>
</td>
<td class="cellalignment3247" headers="r3c1-t13 r1c4-t13">
<p>NOAUDIT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t13" headers="r1c1-t13">
<p>03</p>
</td>
<td class="cellalignment3247" headers="r4c1-t13 r1c2-t13">
<p>INSERT</p>
</td>
<td class="cellalignment3247" headers="r4c1-t13 r1c3-t13">
<p>41</p>
</td>
<td class="cellalignment3247" headers="r4c1-t13 r1c4-t13">
<p>ALTER INDEX</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t13" headers="r1c1-t13">
<p>04</p>
</td>
<td class="cellalignment3247" headers="r5c1-t13 r1c2-t13">
<p>SELECT</p>
</td>
<td class="cellalignment3247" headers="r5c1-t13 r1c3-t13">
<p>42</p>
</td>
<td class="cellalignment3247" headers="r5c1-t13 r1c4-t13">
<p>CREATE EXTERNAL DATABASE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t13" headers="r1c1-t13">
<p>05</p>
</td>
<td class="cellalignment3247" headers="r6c1-t13 r1c2-t13">
<p>UPDATE</p>
</td>
<td class="cellalignment3247" headers="r6c1-t13 r1c3-t13">
<p>43</p>
</td>
<td class="cellalignment3247" headers="r6c1-t13 r1c4-t13">
<p>DROP EXTERNAL DATABASE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t13" headers="r1c1-t13">
<p>06</p>
</td>
<td class="cellalignment3247" headers="r7c1-t13 r1c2-t13">
<p>DROP ROLE</p>
</td>
<td class="cellalignment3247" headers="r7c1-t13 r1c3-t13">
<p>44</p>
</td>
<td class="cellalignment3247" headers="r7c1-t13 r1c4-t13">
<p>CREATE DATABASE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t13" headers="r1c1-t13">
<p>07</p>
</td>
<td class="cellalignment3247" headers="r8c1-t13 r1c2-t13">
<p>DROP VIEW</p>
</td>
<td class="cellalignment3247" headers="r8c1-t13 r1c3-t13">
<p>45</p>
</td>
<td class="cellalignment3247" headers="r8c1-t13 r1c4-t13">
<p>ALTER DATABASE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t13" headers="r1c1-t13">
<p>08</p>
</td>
<td class="cellalignment3247" headers="r9c1-t13 r1c2-t13">
<p>DROP TABLE</p>
</td>
<td class="cellalignment3247" headers="r9c1-t13 r1c3-t13">
<p>46</p>
</td>
<td class="cellalignment3247" headers="r9c1-t13 r1c4-t13">
<p>CREATE ROLLBACK SEGMENT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t13" headers="r1c1-t13">
<p>09</p>
</td>
<td class="cellalignment3247" headers="r10c1-t13 r1c2-t13">
<p>DELETE</p>
</td>
<td class="cellalignment3247" headers="r10c1-t13 r1c3-t13">
<p>47</p>
</td>
<td class="cellalignment3247" headers="r10c1-t13 r1c4-t13">
<p>ALTER ROLLBACK SEGMENT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t13" headers="r1c1-t13">
<p>10</p>
</td>
<td class="cellalignment3247" headers="r11c1-t13 r1c2-t13">
<p>CREATE VIEW</p>
</td>
<td class="cellalignment3247" headers="r11c1-t13 r1c3-t13">
<p>48</p>
</td>
<td class="cellalignment3247" headers="r11c1-t13 r1c4-t13">
<p>DROP ROLLBACK SEGMENT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t13" headers="r1c1-t13">
<p>11</p>
</td>
<td class="cellalignment3247" headers="r12c1-t13 r1c2-t13">
<p>DROP USER</p>
</td>
<td class="cellalignment3247" headers="r12c1-t13 r1c3-t13">
<p>49</p>
</td>
<td class="cellalignment3247" headers="r12c1-t13 r1c4-t13">
<p>CREATE TABLESPACE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t13" headers="r1c1-t13">
<p>12</p>
</td>
<td class="cellalignment3247" headers="r13c1-t13 r1c2-t13">
<p>CREATE ROLE</p>
</td>
<td class="cellalignment3247" headers="r13c1-t13 r1c3-t13">
<p>50</p>
</td>
<td class="cellalignment3247" headers="r13c1-t13 r1c4-t13">
<p>ALTER TABLESPACE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t13" headers="r1c1-t13">
<p>13</p>
</td>
<td class="cellalignment3247" headers="r14c1-t13 r1c2-t13">
<p>CREATE SEQUENCE</p>
</td>
<td class="cellalignment3247" headers="r14c1-t13 r1c3-t13">
<p>51</p>
</td>
<td class="cellalignment3247" headers="r14c1-t13 r1c4-t13">
<p>DROP TABLESPACE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t13" headers="r1c1-t13">
<p>14</p>
</td>
<td class="cellalignment3247" headers="r15c1-t13 r1c2-t13">
<p>ALTER SEQUENCE</p>
</td>
<td class="cellalignment3247" headers="r15c1-t13 r1c3-t13">
<p>52</p>
</td>
<td class="cellalignment3247" headers="r15c1-t13 r1c4-t13">
<p>ALTER SESSION</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t13" headers="r1c1-t13">
<p>15</p>
</td>
<td class="cellalignment3247" headers="r16c1-t13 r1c2-t13">
<p>(not used)</p>
</td>
<td class="cellalignment3247" headers="r16c1-t13 r1c3-t13">
<p>53</p>
</td>
<td class="cellalignment3247" headers="r16c1-t13 r1c4-t13">
<p>ALTER USER</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t13" headers="r1c1-t13">
<p>16</p>
</td>
<td class="cellalignment3247" headers="r17c1-t13 r1c2-t13">
<p>DROP SEQUENCE</p>
</td>
<td class="cellalignment3247" headers="r17c1-t13 r1c3-t13">
<p>54</p>
</td>
<td class="cellalignment3247" headers="r17c1-t13 r1c4-t13">
<p>COMMIT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t13" headers="r1c1-t13">
<p>17</p>
</td>
<td class="cellalignment3247" headers="r18c1-t13 r1c2-t13">
<p>CREATE SCHEMA</p>
</td>
<td class="cellalignment3247" headers="r18c1-t13 r1c3-t13">
<p>55</p>
</td>
<td class="cellalignment3247" headers="r18c1-t13 r1c4-t13">
<p>ROLLBACK</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t13" headers="r1c1-t13">
<p>18</p>
</td>
<td class="cellalignment3247" headers="r19c1-t13 r1c2-t13">
<p>CREATE CLUSTER</p>
</td>
<td class="cellalignment3247" headers="r19c1-t13 r1c3-t13">
<p>56</p>
</td>
<td class="cellalignment3247" headers="r19c1-t13 r1c4-t13">
<p>SAVEPOINT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t13" headers="r1c1-t13">
<p>19</p>
</td>
<td class="cellalignment3247" headers="r20c1-t13 r1c2-t13">
<p>CREATE USER</p>
</td>
<td class="cellalignment3247" headers="r20c1-t13 r1c3-t13">
<p>57</p>
</td>
<td class="cellalignment3247" headers="r20c1-t13 r1c4-t13">
<p>CREATE CONTROL FILE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t13" headers="r1c1-t13">
<p>20</p>
</td>
<td class="cellalignment3247" headers="r21c1-t13 r1c2-t13">
<p>CREATE INDEX</p>
</td>
<td class="cellalignment3247" headers="r21c1-t13 r1c3-t13">
<p>58</p>
</td>
<td class="cellalignment3247" headers="r21c1-t13 r1c4-t13">
<p>ALTER TRACING</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r22c1-t13" headers="r1c1-t13">
<p>21</p>
</td>
<td class="cellalignment3247" headers="r22c1-t13 r1c2-t13">
<p>DROP INDEX</p>
</td>
<td class="cellalignment3247" headers="r22c1-t13 r1c3-t13">
<p>59</p>
</td>
<td class="cellalignment3247" headers="r22c1-t13 r1c4-t13">
<p>CREATE TRIGGER</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r23c1-t13" headers="r1c1-t13">
<p>22</p>
</td>
<td class="cellalignment3247" headers="r23c1-t13 r1c2-t13">
<p>DROP CLUSTER</p>
</td>
<td class="cellalignment3247" headers="r23c1-t13 r1c3-t13">
<p>60</p>
</td>
<td class="cellalignment3247" headers="r23c1-t13 r1c4-t13">
<p>ALTER TRIGGER</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r24c1-t13" headers="r1c1-t13">
<p>23</p>
</td>
<td class="cellalignment3247" headers="r24c1-t13 r1c2-t13">
<p>VALIDATE INDEX</p>
</td>
<td class="cellalignment3247" headers="r24c1-t13 r1c3-t13">
<p>61</p>
</td>
<td class="cellalignment3247" headers="r24c1-t13 r1c4-t13">
<p>DROP TRIGGER</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r25c1-t13" headers="r1c1-t13">
<p>24</p>
</td>
<td class="cellalignment3247" headers="r25c1-t13 r1c2-t13">
<p>CREATE PROCEDURE</p>
</td>
<td class="cellalignment3247" headers="r25c1-t13 r1c3-t13">
<p>62</p>
</td>
<td class="cellalignment3247" headers="r25c1-t13 r1c4-t13">
<p>ANALYZE TABLE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r26c1-t13" headers="r1c1-t13">
<p>25</p>
</td>
<td class="cellalignment3247" headers="r26c1-t13 r1c2-t13">
<p>ALTER PROCEDURE</p>
</td>
<td class="cellalignment3247" headers="r26c1-t13 r1c3-t13">
<p>63</p>
</td>
<td class="cellalignment3247" headers="r26c1-t13 r1c4-t13">
<p>ANALYZE INDEX</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r27c1-t13" headers="r1c1-t13">
<p>26</p>
</td>
<td class="cellalignment3247" headers="r27c1-t13 r1c2-t13">
<p>ALTER TABLE</p>
</td>
<td class="cellalignment3247" headers="r27c1-t13 r1c3-t13">
<p>64</p>
</td>
<td class="cellalignment3247" headers="r27c1-t13 r1c4-t13">
<p>ANALYZE CLUSTER</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r28c1-t13" headers="r1c1-t13">
<p>27</p>
</td>
<td class="cellalignment3247" headers="r28c1-t13 r1c2-t13">
<p>EXPLAIN</p>
</td>
<td class="cellalignment3247" headers="r28c1-t13 r1c3-t13">
<p>65</p>
</td>
<td class="cellalignment3247" headers="r28c1-t13 r1c4-t13">
<p>CREATE PROFILE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r29c1-t13" headers="r1c1-t13">
<p>28</p>
</td>
<td class="cellalignment3247" headers="r29c1-t13 r1c2-t13">
<p>GRANT</p>
</td>
<td class="cellalignment3247" headers="r29c1-t13 r1c3-t13">
<p>66</p>
</td>
<td class="cellalignment3247" headers="r29c1-t13 r1c4-t13">
<p>DROP PROFILE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r30c1-t13" headers="r1c1-t13">
<p>29</p>
</td>
<td class="cellalignment3247" headers="r30c1-t13 r1c2-t13">
<p>REVOKE</p>
</td>
<td class="cellalignment3247" headers="r30c1-t13 r1c3-t13">
<p>67</p>
</td>
<td class="cellalignment3247" headers="r30c1-t13 r1c4-t13">
<p>ALTER PROFILE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r31c1-t13" headers="r1c1-t13">
<p>30</p>
</td>
<td class="cellalignment3247" headers="r31c1-t13 r1c2-t13">
<p>CREATE SYNONYM</p>
</td>
<td class="cellalignment3247" headers="r31c1-t13 r1c3-t13">
<p>68</p>
</td>
<td class="cellalignment3247" headers="r31c1-t13 r1c4-t13">
<p>DROP PROCEDURE</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r32c1-t13" headers="r1c1-t13">
<p>31</p>
</td>
<td class="cellalignment3247" headers="r32c1-t13 r1c2-t13">
<p>DROP SYNONYM</p>
</td>
<td class="cellalignment3247" headers="r32c1-t13 r1c3-t13">
<p>69</p>
</td>
<td class="cellalignment3247" headers="r32c1-t13 r1c4-t13">
<p>(not used)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r33c1-t13" headers="r1c1-t13">
<p>32</p>
</td>
<td class="cellalignment3247" headers="r33c1-t13 r1c2-t13">
<p>ALTER SYSTEM SWITCH LOG</p>
</td>
<td class="cellalignment3247" headers="r33c1-t13 r1c3-t13">
<p>70</p>
</td>
<td class="cellalignment3247" headers="r33c1-t13 r1c4-t13">
<p>ALTER RESOURCE COST</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r34c1-t13" headers="r1c1-t13">
<p>33</p>
</td>
<td class="cellalignment3247" headers="r34c1-t13 r1c2-t13">
<p>SET TRANSACTION</p>
</td>
<td class="cellalignment3247" headers="r34c1-t13 r1c3-t13">
<p>71</p>
</td>
<td class="cellalignment3247" headers="r34c1-t13 r1c4-t13">
<p>CREATE SNAPSHOT LOG</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r35c1-t13" headers="r1c1-t13">
<p>34</p>
</td>
<td class="cellalignment3247" headers="r35c1-t13 r1c2-t13">
<p>PL/SQL EXECUTE</p>
</td>
<td class="cellalignment3247" headers="r35c1-t13 r1c3-t13">
<p>72</p>
</td>
<td class="cellalignment3247" headers="r35c1-t13 r1c4-t13">
<p>ALTER SNAPSHOT LOG</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r36c1-t13" headers="r1c1-t13">
<p>35</p>
</td>
<td class="cellalignment3247" headers="r36c1-t13 r1c2-t13">
<p>LOCK TABLE</p>
</td>
<td class="cellalignment3247" headers="r36c1-t13 r1c3-t13">
<p>73</p>
</td>
<td class="cellalignment3247" headers="r36c1-t13 r1c4-t13">
<p>DROP SNAPSHOT LOG</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r37c1-t13" headers="r1c1-t13">
<p>36</p>
</td>
<td class="cellalignment3247" headers="r37c1-t13 r1c2-t13">
<p>(not used)</p>
</td>
<td class="cellalignment3247" headers="r37c1-t13 r1c3-t13">
<p>74</p>
</td>
<td class="cellalignment3247" headers="r37c1-t13 r1c4-t13">
<p>CREATE SNAPSHOT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r38c1-t13" headers="r1c1-t13">
<p>37</p>
</td>
<td class="cellalignment3247" headers="r38c1-t13 r1c2-t13">
<p>RENAME</p>
</td>
<td class="cellalignment3247" headers="r38c1-t13 r1c3-t13">
<p>75</p>
</td>
<td class="cellalignment3247" headers="r38c1-t13 r1c4-t13">
<p>ALTER SNAPSHOT</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r39c1-t13" headers="r1c1-t13">
<p>38</p>
</td>
<td class="cellalignment3247" headers="r39c1-t13 r1c2-t13">
<p>COMMENT</p>
</td>
<td class="cellalignment3247" headers="r39c1-t13 r1c3-t13">
<p>76</p>
</td>
<td class="cellalignment3247" headers="r39c1-t13 r1c4-t13">
<p>DROP SNAPSHOT</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGJHAHF"></a>
<div id="ZZPRE816" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the <a id="sthref1132"></a><a id="sthref1133"></a>Oracle Communications Area</h2>
<p>In the same way the SQLCA handles standard SQL communications; the Oracle Communications Area (<a id="sthref1134"></a>ORACA) handles Oracle communications. When you need more information about run-time errors and status changes than the SQLCA provides, use the ORACA. It contains an extended set of diagnostic tools. However, use of the ORACA is optional because it adds to run-time overhead.</p>
<p>Besides helping you to diagnose problems, the ORACA lets you monitor your program&#39;s use of Oracle resources such as the SQL Statement Executor and the cursor cache.</p>
<p><a id="sthref1135"></a>In host languages that allow local and global declarations, your program can have more than one ORACA. For example, it might have one global ORACA and several local ones. Access to a local ORACA is limited by its scope within the program. Oracle returns information only to the &#34;active&#34; ORACA. The information is available only after a commit or rollback.</p>
<div id="ZZPRE817" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1136"></a>
<h3 class="sect2">Declaring the <a id="sthref1137"></a>ORACA</h3>
<p><a id="sthref1138"></a>To declare the ORACA, simply include it (using an EXEC SQL <code>INCLUDE<a id="sthref1139"></a></code> statement) in your host-language source file as follows:</p>
<pre>* Include the Oracle Communications Area (ORACA).
 EXEC SQL INCLUDE ORACA
</pre>
<p>The ORACA must be declared <span class="italic">outside</span> the Declare Section.</p>
<p>When you precompile your program, the <code>INCLUDE</code> ORACA statement is replaced by several program variable declarations. These declarations allow Oracle to communicate with your program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE818" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1140"></a>
<h3 class="sect2">Enabling the <a id="sthref1141"></a>ORACA</h3>
<p>To enable the ORACA, you must specify the ORACA option, either on the command line with</p>
<pre>ORACA=YES
</pre>
<p>or inline with</p>
<pre>EXEC ORACLE OPTION (ORACA=YES);
</pre>
<p>Then, you must choose appropriate run-time options by setting flags in the ORACA.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE819" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1142"></a>
<h3 class="sect2">What&#39;s in the ORACA?</h3>
<p>The ORACA contains option settings, system statistics, and extended diagnostics such as</p>
<ul>
<li>
<p>SQL statement text (you can specify when to save the text)</p>
</li>
<li>
<p>name of the file in which an error occurred</p>
</li>
<li>
<p>location of the error in a file</p>
</li>
<li>
<p>cursor cache errors and statistics</p>
</li>
</ul>
<p><a href="#BABHBBED">Figure 8-3</a> shows all the variables in the ORACA. To see the ORACA structure and variable names in a particular host language, refer to your supplement to this Guide.</p>
<div id="ZZPRE820" class="figure">
<p class="titleinfigure"><a id="BABHBBED"></a>Figure 8-3 ORACA Variables</p>
<img width="536" height="340" src="img/image012.gif" alt="ORACA variables"/><br/>
<a id="sthref1143" href="img_text/image012.htm">Description of &#34;Figure 8-3 ORACA Variables&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ZZPRE821" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1144"></a>
<h3 class="sect2">Choosing Run-time Options</h3>
<p><a id="sthref1145"></a>The ORACA includes several option flags. Setting these flags by assigning them nonzero values enables</p>
<ul>
<li>
<p>Save the text of SQL statements</p>
</li>
<li>
<p>Enable DEBUG operations</p>
</li>
<li>
<p>Check cursor cache consistency (the <span class="italic">cursor cache</span> is a continuously updated area of memory used for cursor management)</p>
</li>
<li>
<p>Check heap consistency (the <a id="sthref1146"></a><span class="italic">heap</span> is an area of memory reserved for dynamic variables)</p>
</li>
<li>
<p>Gather cursor statistics</p>
</li>
</ul>
<p>The descriptions will help you choose the options you need.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE822" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1147"></a>
<h3 class="sect2">ORACA Structure</h3>
<p>This section describes the structure of the ORACA, its <a id="sthref1148"></a>fields, and the values they can store.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE823" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1149"></a>
<h3 class="sect2"><a id="sthref1150"></a><a id="sthref1151"></a>ORACAID</h3>
<p>This string field is initialized to &#34;ORACA&#34; to identify the Oracle Communications Area.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE824" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1152"></a>
<h3 class="sect2"><a id="sthref1153"></a><a id="sthref1154"></a>ORACABC</h3>
<p>This integer field holds the length, expressed in bytes, of the ORACA data structure.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE825" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1155"></a>
<h3 class="sect2"><a id="sthref1156"></a><a id="sthref1157"></a>ORACCHF</h3>
<p>If the master DEBUG flag (ORADBGF) is set, this flag lets you check the cursor cache for consistency before every cursor operation.</p>
<p>The Oracle run-time library does the consistency checking and might issue error messages, which are listed in <a class="olink ERRMG" href="../ERRMG/toc.htm"><span class="italic">Oracle Database Error Messages</span></a>. They are returned to the SQLCA just like Oracle error messages.</p>
<p>This flag has the following settings:</p>
<p>0</p>
<p>Disable cache consistency checking (the default).</p>
<p>1</p>
<p>Enable cache consistency checking.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE826" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1158"></a>
<h3 class="sect2"><a id="sthref1159"></a><a id="sthref1160"></a>ORADBGF</h3>
<p>This master flag lets you choose all the DEBUG options. It has the following settings:</p>
<p>0</p>
<p>Disable all DEBUG operations (the default).</p>
<p>1</p>
<p>Enable all DEBUG operations.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE827" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1161"></a>
<h3 class="sect2"><a id="sthref1162"></a><a id="sthref1163"></a>ORAHCHF</h3>
<p>If the master DEBUG flag (ORADBGF) is set, this flag tells the Oracle run-time library to check the heap for consistency every time the precompiler dynamically allocates or frees memory. This is useful for detecting program bugs that upset memory.</p>
<p>This flag must be set before the <code>CONNECT</code> command is issued and, once set, cannot be cleared; subsequent change requests are ignored. It has the following settings:</p>
<p>0</p>
<p>Disable heap consistency checking (the default).</p>
<p>1</p>
<p>Enable heap consistency checking.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE828" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1164"></a>
<h3 class="sect2"><a id="sthref1165"></a><a id="sthref1166"></a>ORASTXTF</h3>
<p>This flag lets you specify when the text of the current SQL statement is saved. It has the following settings:</p>
<p>0</p>
<p>Never save the SQL statement text (the default).</p>
<p>1</p>
<p>Save the SQL statement text on SQLERROR only.</p>
<p>2</p>
<p>Save the SQL statement text on SQLERROR or SQLWARNING.</p>
<p>3</p>
<p>Always save the SQL statement text.</p>
<p>The SQL statement text is saved in the ORACA subrecord named ORASTXT.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE829" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1167"></a>
<h3 class="sect2">Diagnostics</h3>
<p>The ORACA provides an enhanced set of diagnostics; the following variables help you to locate errors quickly.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE830" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1168"></a>
<h3 class="sect2">ORASTXT</h3>
<p>This subrecord helps you find faulty SQL statements. It lets you save the text of the last SQL statement parsed by Oracle. It contains the following two fields:</p>
<p><a id="sthref1169"></a><a id="sthref1170"></a>ORASTXTL</p>
<p>This integer field holds the length of the current SQL statement.</p>
<p><a id="sthref1171"></a><a id="sthref1172"></a>ORASTXTC</p>
<p>This string field holds the text of the current SQL statement. At most, the first 70 characters of text are saved.</p>
<p>Statements parsed by the precompiler, such as <code>CONNECT</code>, <code>FETCH</code>, and <code>COMMIT</code>, are <span class="italic">not</span> saved in the ORACA.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE831" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1173"></a>
<h3 class="sect2">ORASFNM</h3>
<p>This subrecord identifies the file containing the current SQL statement and so helps you find errors when multiple files are precompiled for one application. It contains the following two fields:</p>
<p><a id="sthref1174"></a><a id="sthref1175"></a>ORASFNML</p>
<p>This integer field holds the length of the filename stored in ORASFNMC.</p>
<p><a id="sthref1176"></a><a id="sthref1177"></a>ORASFNMC</p>
<p>This string field holds the filename. At most, the first 70 characters are stored.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE832" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1178"></a>
<h3 class="sect2"><a id="sthref1179"></a><a id="sthref1180"></a>ORASLNR</h3>
<p>This integer field identifies the line at (or near) which the current SQL statement can be found.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE833" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1181"></a>
<h3 class="sect2"><a id="sthref1182"></a>Cursor Cache Statistics</h3>
<p><a id="sthref1183"></a>The variables let you gather cursor cache statistics. They are automatically set by every <code>COMMIT</code> or <code>ROLLBACK</code> statement your program issues. Internally, there is a set of these variables for each <code>CONNECTed</code> database. The current values in the ORACA pertain to the database against which the last commit or rollback was executed.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE834" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1184"></a>
<h3 class="sect2"><a id="sthref1185"></a><a id="sthref1186"></a>ORAHOC</h3>
<p>This integer field records the highest value to which <code>MAXOPENCURSORS</code> was set during program execution.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE835" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1187"></a>
<h3 class="sect2"><a id="sthref1188"></a><a id="sthref1189"></a>ORAMOC</h3>
<p>This integer field records the maximum number of open Oracle cursors required by your program. This number can be higher than ORAHOC if <code>MAXOPENCURSORS</code> was set too low, which forced the precompiler to extend the cursor cache.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE836" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1190"></a>
<h3 class="sect2"><a id="sthref1191"></a><a id="sthref1192"></a>ORACOC</h3>
<p>This integer field records the current number of open Oracle cursors required by your program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE837" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1193"></a>
<h3 class="sect2"><a id="sthref1194"></a><a id="sthref1195"></a>ORANOR</h3>
<p>This integer field records the number of cursor cache reassignments required by your program. This number shows the degree of &#34;thrashing&#34; in the cursor cache and should be kept as low as possible.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE838" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1196"></a>
<h3 class="sect2"><a id="sthref1197"></a><a id="sthref1198"></a>ORANPR</h3>
<p>This integer field records the number of SQL statement parses required by your program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE839" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1199"></a>
<h3 class="sect2"><a id="sthref1200"></a><a id="sthref1201"></a>ORANEX</h3>
<p>This integer field records the number of SQL statement executions required by your program. The ratio of this number to the <code>ORANPR</code> number should be kept as high as possible. In other words, avoid unnecessary reparsing. For help, refer to <a href="appc.htm#BABCHGDI">Appendix C, &#34;Performance Tuning&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE840" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1202"></a>
<h3 class="sect2">An <a id="sthref1203"></a>Example</h3>
<p>The following program prompts for a department number, inserts the name and salary of each employee in that department into one of two tables, then displays diagnostic information from the ORACA:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION; 
 username CHARACTER(20);
 password CHARACTER(20);
 emp_name INTEGER;
 dept_number INTEGER;
 salary REAL;
EXEC SQL END DECLARE SECTION; 
EXEC SQL INCLUDE SQLCA;
EXEC SQL INCLUDE ORACA;
display &#39;Username? &#39;;
read username;
display &#39;Password? &#39;;
read password;
EXEC SQL WHENEVER SQLERROR DO sql_error;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display &#39;Connected to Oracle&#39;;
EXEC ORACLE OPTION (ORACA=YES);
-- set flags in the ORACA
set oraca.oradbgf = 1; -- enable debug operations
set oraca.oracchf = 1; -- enable cursor cache consistency check
set oraca.orastxtf = 3; -- always save the SQL statement
display &#39;Department number? &#39;;
read dept_number;
EXEC SQL DECLARE emp_cursor CURSOR FOR
 SELECT ENAME, SAL + NVL(COMM,0)
 FROM EMP
 WHERE DEPTNO = :dept_number;
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND DO no_more; 
rLOOP
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;
 IF salary &lt; 2500 THEN
 EXEC SQL INSERT INTO PAY1 VALUES (:emp_name, :salary);
 ELSE
 EXEC SQL INSERT INTO PAY2 VALUES (:emp_name, :salary);
 ENDIF;
ENDLOOP;
ROUTINE no_more
BEGIN
 EXEC SQL CLOSE emp_cursor;
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL COMMIT WORK RELEASE;
 display &#39;Last SQL statement: &#39;, oraca.orastxt.orastxtc;
 display &#39;... at or near line number: &#39;, oraca.oraslnr;
 display
 display &#39; Cursor Cache Statistics&#39;;
 display &#39;-------------------------------------------&#39;;
 display &#39;Maximum value of MAXOPENCURSORS &#39;, oraca.orahoc;
 display &#39;Maximum open cursors required: &#39;, oraca.oramoc;
 display &#39;Current number of open cursors: &#39;, oraca.oracoc;
 display &#39;Number of cache reassignments: &#39;, oraca.oranor;
 display &#39;Number of SQL statement parses: &#39;, oraca.oranpr;
 display &#39;Number of SQL statement executions: &#39;, oraca.oranex;
 exit program;
END no_more;
ROUTINE sql_error
BEGIN
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display &#39;Last SQL statement: &#39;, oraca.orastxt.orastxtc;
 display &#39;... at or near line number: &#39;, oraca.oraslnr;
 display
 display &#39; Cursor Cache Statistics&#39;;
 display &#39;-------------------------------------------&#39;;
 display &#39;Maximum value of MAXOPENCURSORS &#39;, oraca.orahoc;
 display &#39;Maximum open cursors required: &#39;, oraca.oramoc;
 display &#39;Current number of open cursors: &#39;, oraca.oracoc;
 display &#39;Number of cache reassignments: &#39;, oraca.oranor;
 display &#39;Number of SQL statement parses: &#39;, oraca.oranpr;
 display &#39;Number of SQL statement executions: &#39;, oraca.oranex;
 exit program with an error;
END sql_error;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3238">
<tr>
<td class="cellalignment3247">
<table class="cellalignment3243">
<tr>
<td class="cellalignment3242"><a href="ch_seven.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3242"><a href="ch_nine.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3249">
<table class="cellalignment3241">
<tr>
<td class="cellalignment3242"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3242"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3242"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3242"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3242"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3242"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>