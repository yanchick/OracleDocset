<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114759"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Meeting%20Program%20Requirements"></a><title>Meeting Program Requirements</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T18:44:38Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Programmer&#39;s Guide to the Oracle Precompilers"/>
<meta name="dcterms.identifier" content="E53283-01"/>
<meta name="dcterms.isVersionOf" content="ZZPRE"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ch_two.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch_four.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53283-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">6/20</span> <!-- End Header -->
<div id="ZZPRE163" class="chapter"><a id="BABCBCDA"></a>
<h1 class="chapter"><span class="secnum">3</span> <a id="sthref85"></a> <a id="sthref86"></a>Meeting Program Requirements</h1>
<p>This chapter explains the following:</p>
<ul>
<li>
<p><a href="#BABHGJGD">The Declare Section</a></p>
</li>
<li>
<p><a href="#BABJIICJ">INCLUDE Statements</a></p>
</li>
<li>
<p><a href="#BABFBJDA">The SQLCA</a></p>
</li>
<li>
<p><a href="#BABGGBIE">Oracle Datatypes</a></p>
</li>
<li>
<p><a href="#BABBABJE">Datatype Conversion</a></p>
</li>
<li>
<p><a href="#BABJJBGE">Declaring and Referencing Host Variables</a></p>
</li>
<li>
<p><a href="#BABDDAAA">Declaring and Referencing Indicator Variables</a></p>
</li>
<li>
<p><a href="#BABJGGIF">Datatype Equivalencing</a></p>
</li>
<li>
<p><a href="#BABIBCHC">Globalization Support</a></p>
</li>
<li>
<p><a href="#BABIDCJI">Multibyte Globalization Support Character Sets</a></p>
</li>
<li>
<p><a href="#BABCBHAA">Concurrent Logons</a></p>
</li>
<li>
<p><a href="#BABCBJGA">Embedding OCI (Oracle Call Interface) Calls</a></p>
</li>
<li>
<p><a href="#BABHCFEE">Developing X/Open Applications</a></p>
</li>
</ul>
<p>Passing data between Oracle and your application program requires host variables, datatype conversions, event handling, and access to Oracle. This chapter shows you how to meet these requirements. You learn the embedded SQL commands that declare variables, declare communication areas, and connect to an Oracle database. You also learn about the Oracle datatypes, Globalization Support (Globalization Support), data conversion, and how to take advantage of datatype equivalencing. The final two sections show you how to embed OCI calls in your program and how to develop X/Open applications.</p>
<a id="BABHGJGD"></a>
<div id="ZZPRE164" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The Declare Section</h2>
<p>You must declare all program variables to be used in SQL statements (that is, all host variables) in the <span class="italic">Declare Section</span>. If you use an <a id="sthref87"></a>undeclared host variable in a SQL statement, the precompiler issues an error message. For a complete listing of error messages see <a class="olink ERRMG" href="../ERRMG/toc.htm"><span class="italic">Oracle Database Error Messages</span></a>.</p>
<p><a id="sthref88"></a>The Declare Section begins with the statement</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
</pre>
<p>and ends with the statement</p>
<pre>EXEC SQL END DECLARE SECTION;
</pre>
<p>In COBOL, the statement terminator is <code>END-EXEC</code>. In FORTRAN, it is a carriage return.</p>
<p>Between these two statements, only the following items are allowed:</p>
<ul>
<li>
<p>host-variable and indicator-variable declarations</p>
</li>
<li>
<p><code>EXEC SQL DECLARE</code> statements</p>
</li>
<li>
<p><code>EXEC SQL INCLUDE</code> statements</p>
</li>
<li>
<p><code>EXEC SQL VAR</code> statements</p>
</li>
<li>
<p><code>EXEC ORACLE</code> statements</p>
</li>
<li>
<p>host-language comments</p>
</li>
</ul>
<p><a id="sthref89"></a>Multiple Declare Sections are allowed in each precompiled unit. Furthermore, a host program can contain several independently precompiled units.</p>
<div id="ZZPRE165" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref90"></a>
<h3 class="sect2">An Example</h3>
<p><a id="sthref91"></a>In the following example, you declare four host variables for use later in your program.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION; 
 emp_number INTEGER; 
 emp_name CHARACTER(10); 
 salary REAL; 
 commission REAL; 
EXEC SQL END DECLARE SECTION;
</pre>
<p>For more information about declaring host variables, see <a href="#BABJJBGE">&#34;Declaring and Referencing Host Variables&#34;</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJIICJ"></a>
<div id="ZZPRE166" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">INCLUDE Statements</h2>
<p><a id="sthref92"></a>The <code>INCLUDE</code> statement lets you copy files into your host program. It is similar to the COBOL <code>COPY</code> command. An example follows:</p>
<pre>-- copy in the SQLCA file
EXEC SQL INCLUDE SQLCA;
</pre>
<p>When you precompile your program, each <code>EXEC SQL INCLUDE</code> statement is replaced by a copy of the file named in the statement.</p>
<p><a id="sthref93"></a>You can include any file. If a file contains embedded SQL, you <span class="italic">must</span> include it because only included files are precompiled. If you do not specify a file extension, the precompiler assumes the default extension for source files, which is language-dependent (see your host-language supplement to this Guide).</p>
<p>You can set a directory path for included files by specifying the precompiler option</p>
<pre>INCLUDE=&lt;path&gt;
</pre>
<p>where <span class="italic">path</span> defaults to the <a id="sthref94"></a>current directory. (In this context, <a id="sthref95"></a>a <span class="italic">directory</span> is an index of file locations.)</p>
<p>The precompiler searches first in the current directory, then in the directory specified by <code>INCLUDE</code>, and finally in a directory for standard <code>INCLUDE</code> files. So, you need not specify a directory <a id="sthref96"></a>path for standard files such as the SQLCA and ORACA. You must still use <code>INCLUDE</code> to specify a directory path for nonstandard files unless they are stored in the current directory.</p>
<p>If your operating system is case-sensitive (like UNIX for example), be sure to specify the same upper/lowercase filename under which the file is stored. The syntax for specifying a directory path is system-specific. Check your system-specific Oracle manuals.</p>
</div>
<!-- class="sect1" -->
<a id="BABFBJDA"></a>
<div id="ZZPRE167" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The <a id="sthref97"></a>SQLCA</h2>
<p>The SQLCA is a data structure that provides for diagnostic checking and event <a id="sthref98"></a>handling. At run time, the SQLCA holds status information passed to your program by Oracle. After executing a SQL statement, Oracle sets SQLCA variables to indicate the outcome, as illustrated in <a href="#BACEFBCE">Figure 3-1</a>.</p>
<div id="ZZPRE168" class="figure">
<p class="titleinfigure"><a id="BACEFBCE"></a>Figure 3-1 Updating the SQLCA</p>
<img width="536" height="481" src="img/image006.gif" alt="Updating SQLCA"/><br/>
<a id="sthref99" href="img_text/image006.htm">Description of &#34;Figure 3-1 Updating the SQLCA&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Thus, you can verify if an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement succeeded and if so, how many rows were affected. Or, if the statement failed, you can get more information about what happened.</p>
<p>When <code>MODE={ANSI13|ORACLE}</code>, you must declare the SQLCA by hardcoding it or by copying it into your program with the <code>INCLUDE</code> statement. <a href="ch_eight.htm#BABIGBFF">&#34;Using the SQL Communications Area&#34;</a> shows you how to declare and use the SQLCA.</p>
</div>
<!-- class="sect1" -->
<a id="BABGGBIE"></a>
<div id="ZZPRE169" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Oracle Datatypes</h2>
<p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. <a id="sthref100"></a>Internal datatypes specify how Oracle stores data in database columns. Oracle also uses internal datatypes to represent database pseudocolumns. An external datatype specifies how data is stored in a host variable.</p>
<p>At precompile time, each host variable in the Declare Section is associated with an external datatype code. At run time, the datatype code of every host variable used in a SQL statement is passed to Oracle. Oracle uses the codes to convert between internal and external datatypes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can override default datatype conversions by using dynamic SQL Method 4 or datatype equivalencing. For information about dynamic SQL Method 4, see <a href="ch_ten.htm#BCEDGGHH">&#34;Using Method 4&#34;</a>. For information about datatype equivalencing, see <a href="#BABJGGIF">&#34;Datatype Equivalencing&#34;</a>.</div>
<div id="ZZPRE170" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref101"></a>
<h3 class="sect2">Internal Datatypes<a id="sthref102"></a></h3>
<p><a href="#BABBHADA">Table 3-1</a> lists the internal datatypes that Oracle uses for database columns and pseudocolumns.</p>
<div id="ZZPRE171" class="tblformal">
<p class="titleintable"><a id="sthref103"></a><a id="BABBHADA"></a>Table 3-1 Column and Pseudo Column Datatypes</p>
<table class="cellalignment3250" title="Column and Pseudo Column Datatypes" summary="internal datatypes" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t3">Name</th>
<th class="cellalignment3246" id="r1c2-t3">Code</th>
<th class="cellalignment3246" id="r1c3-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t3" headers="r1c1-t3">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p>96</p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c3-t3">
<p>&lt;= 255-byte, fixed-length string</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t3" headers="r1c1-t3">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">
<p>12</p>
</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c3-t3">
<p>7-byte, fixed-length date/time value</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t3" headers="r1c1-t3">
<p><code>LONG</code></p>
</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">
<p>8</p>
</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c3-t3">
<p>&lt;= 2147483647-byte, variable-length string</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t3" headers="r1c1-t3">
<p><code>LONG</code> <code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">
<p>24</p>
</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c3-t3">
<p>&lt;= 2147483647-byte, variable-length binary data</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t3" headers="r1c1-t3">
<p><code>MLSLABEL</code></p>
</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">
<p>105</p>
</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c3-t3">
<p>&lt;= 5-byte, variable-length binary label</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t3" headers="r1c1-t3">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">
<p>2</p>
</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c3-t3">
<p>fixed or floating point number</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t3" headers="r1c1-t3">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">
<p>23</p>
</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c3-t3">
<p>&lt;= 255-byte, variable-length binary data</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t3" headers="r1c1-t3">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">
<p>11</p>
</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c3-t3">
<p>fixed-length binary value</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t3" headers="r1c1-t3">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">
<p>1</p>
</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c3-t3">
<p>&lt;= 2000-byte, variable-length string</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>These internal datatypes can be quite different from host-language datatypes. For example, the <code>NUMBER</code> datatype was designed for portability, precision (no rounding error), and correct collating. No host language has an equivalent datatype.</p>
<p>Brief descriptions of the internal datatypes follow. For more information, see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE172" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref104"></a>
<h3 class="sect2">CHAR<a id="sthref105"></a></h3>
<p><a id="sthref106"></a>You <a id="sthref107"></a>use the <code>CHAR</code> datatype to store fixed-length character data. How the data is represented internally depends on the database character set. The <code>CHAR</code> datatype takes an optional parameter that lets you specify a maximum width up to 255 bytes. The syntax follows:</p>
<pre><a id="sthref108"></a>CHAR[(maximum_width)]
</pre>
<p>You cannot use a constant or variable to specify the maximum width; you must use an integer literal. If you do not specify the maximum width, it defaults to 1. Remember, you specify the maximum width of a <code>CHAR</code>(<span class="italic">n</span>) column in bytes, not characters. So, if a <code>CHAR</code>(<span class="italic">n</span>) column stores multibyte (2-byte) characters, its maximum width is less than <span class="italic">n</span>/2 characters.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE173" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref109"></a>
<h3 class="sect2">DATE<a id="sthref110"></a></h3>
<p><a id="sthref111"></a>You use the<a id="sthref112"></a> <code>DATE</code> datatype to store dates and times in 7-byte, fixed-length fields. The date portion defaults to the first day of the current month; the time portion defaults to midnight.</p>
<p><a id="sthref113"></a>Internally, <code>DATE</code>s are stored in a binary format. When converting a <code>DATE</code> column value to a character string in your program, Oracle uses the default format mask for your session. If you need other date/time information such as the date in <a id="sthref114"></a>Julian days, use the <code>TO_CHAR</code> function with a format mask. Always convert <code>DATE</code> column values to and from character strings using (external<a id="sthref115"></a>) character datatypes such as <code>VARCHAR2</code> or <code>STRING</code>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE174" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref116"></a>
<h3 class="sect2">LONG<a id="sthref117"></a><a id="sthref118"></a></h3>
<p><a id="sthref119"></a>You use the <code>LONG</code> datatype to store variable-length character strings. <code>LONG</code> columns can store text, arrays of characters, or even short documents. The <code>LONG</code> datatype is like the <code>VARCHAR2</code> datatype, except the maximum width of a <code>LONG</code> column is 2147483647 bytes or two gigabytes.</p>
<p>You can use <code>LONG</code> columns in <code>UPDATE</code>, <code>INSERT</code>, and (most) <code>SELECT</code> statements, but <a id="sthref120"></a>not in expressions, function calls, or SQL clauses such as <code>WHERE</code>, <code>GROUP</code> <code>BY</code>, and <code>CONNECT</code> <code>BY</code>. Only one <code>LONG</code> column is allowed in each database table and that column cannot be indexed.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE175" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref121"></a>
<h3 class="sect2">LONG RAW</h3>
<p><a id="sthref122"></a>You use the <code>LONG</code> <code>RAW</code> datatype to store variable-length binary data or byte strings. The <a id="sthref123"></a>maximum width of a <code>LONG</code> <code>RAW</code> column is 2147483647 bytes or two gigabytes.</p>
<p><a id="sthref124"></a><code>LONG</code> <code>RAW</code> data is like <code>LONG</code> data, except that Oracle assumes nothing about the meaning of <code>LONG</code> <code>RAW</code> data and does no character set conversions when you transmit <code>LONG</code> <code>RAW</code> data from one system to another. The restrictions that apply to <code>LONG</code> data also apply to <code>LONG</code> <code>RAW</code> data.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE176" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref125"></a>
<h3 class="sect2">MLSLABEL<a id="sthref126"></a></h3>
<p><a id="sthref127"></a>You use the <code>MLSLABEL</code> datatype to store variable-length, binary operating system labels. Oracle uses labels to control access to data. For more information, see the <a class="olink ADMIN" href="../ADMIN/toc.htm"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a>.</p>
<p>You can use the <code>MLSLABEL</code> datatype to define a database column. You can insert any valid operating system label into a column of type <code>MLSLABEL</code>. If the label is in text format, Oracle converts it to a binary value automatically. The text string can be up to 255 bytes long. However, the internal length of an <code>MLSLABEL</code> value is between 2 and 5 bytes.</p>
<p>You can also select values from a <code>MLSLABEL</code> column into a character variable. Oracle converts the internal binary value to a <code>VARCHAR2</code> value automatically.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE177" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref128"></a>
<h3 class="sect2">NUMBER<a id="sthref129"></a></h3>
<p>You use the <a id="sthref130"></a><code>NUMBER</code> datatype to store fixed or floating point numbers of virtually any size. You can specify <span class="italic"><a id="sthref131"></a>precision</span>, which is the total number of digits, and <a id="sthref132"></a><span class="italic">scale</span>, which determines where rounding occurs.</p>
<p>The maximum precision of a <code>NUMBER</code> value is 38; the magnitude range is 1.0E-129 to 9.99E125. Scale can range from -84 to 127. For example, a scale of -3 means the number is rounded to the nearest thousand (3456 becomes 3000). A scale of 2 means the value is rounded to the nearest hundredth (3.456 becomes 3.46).</p>
<p>When you specify precision and scale, Oracle does extra integrity checks before storing the data. If a value exceeds the precision, Oracle issues an error message; if a value exceeds the scale, Oracle rounds the value.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE178" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref133"></a>
<h3 class="sect2"><a id="sthref134"></a>RAW<a id="sthref135"></a></h3>
<p>You use the <code>RAW</code> datatype to store binary data or byte strings (a sequence of graphics characters, for example). <code>RAW</code> data is not interpreted by Oracle.</p>
<p><a id="sthref136"></a>The <code>RAW</code> datatype takes a required parameter that lets you specify a maximum width up to 255 bytes. The syntax follows:</p>
<pre>RAW(maximum_width)
</pre>
<p>You cannot use a constant or variable to specify the maximum width; you must use an integer literal.</p>
<p><a id="sthref137"></a><a id="sthref138"></a><code>RAW</code> data is like <code>CHAR</code> data, except that Oracle assumes nothing about the meaning of <code>RAW</code> data and does no character set conversions (from 7-bit ASCII to EBCDIC Code Page 500 for example) when you transmit <code>RAW</code> data from one system to another.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE179" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref139"></a>
<h3 class="sect2"><a id="sthref140"></a>ROWID<a id="sthref141"></a></h3>
<p>Internally, every table in an Oracle database has a pseudocolumn named <code>ROWID</code>, which stores binary values called <span class="italic">rowids</span>. <code>ROWID</code>s uniquely identify rows and provide the fastest way to access particular rows.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE180" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref142"></a>
<h3 class="sect2">VARCHAR2<a id="sthref143"></a></h3>
<p><a id="sthref144"></a>You use the <code>VARCHAR2</code> datatype to store variable-length character strings. How the strings are represented internally depends on the database character set, which might be 7-bit ASCII or EBCDIC Code Page 500 for example.</p>
<p>The maximum width of a <code>VARCHAR2</code> database column is 2000 bytes. To define a <code>VARCHAR2</code> column, you use the syntax</p>
<pre>VARCHAR2(maximum_width)
</pre>
<p>where <span class="italic">maximum_width</span> is an integer literal in the range 1 .. 2000.</p>
<p><a id="sthref145"></a>You specify the maximum width of a <code>VARCHAR2</code>(<span class="italic">n</span>) column in bytes, not characters. So, if a <code>VARCHAR2</code>(<span class="italic">n</span>) column stores multibyte (2-byte) characters, its maximum width is less than <span class="italic">n</span>/2 characters.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE181" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref146"></a>
<h3 class="sect2">SQL <a id="sthref147"></a>Pseudocolumns and Functions</h3>
<p>SQL recognizes the pseudocolumns in <a href="#BABGBJED">Table 3-2</a>, which return specific data items:</p>
<div id="ZZPRE182" class="tblformal">
<p class="titleintable"><a id="sthref148"></a><a id="BABGBJED"></a>Table 3-2 Pseudo Column Datatypes</p>
<table class="cellalignment3250" title="Pseudo Column Datatypes" summary="sql psuedocloumns" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t4">Pseudocolumn</th>
<th class="cellalignment3246" id="r1c2-t4">Internal Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t4" headers="r1c1-t4">
<p><code>CURRVAL</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t4 r1c2-t4">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t4" headers="r1c1-t4">
<p><code>LEVEL</code></p>
</td>
<td class="cellalignment3247" headers="r3c1-t4 r1c2-t4">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t4" headers="r1c1-t4">
<p><code>NEXTVAL</code></p>
</td>
<td class="cellalignment3247" headers="r4c1-t4 r1c2-t4">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t4" headers="r1c1-t4">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r5c1-t4 r1c2-t4">
<p><code>ROWID</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t4" headers="r1c1-t4">
<p><code>ROWLABEL</code></p>
</td>
<td class="cellalignment3247" headers="r6c1-t4 r1c2-t4">
<p><code>MLSLABEL</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t4" headers="r1c1-t4">
<p><code>ROWNUM</code></p>
</td>
<td class="cellalignment3247" headers="r7c1-t4 r1c2-t4">
<p><code>NUMBER</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Pseudocolumns are not actual columns in a table. However, pseudocolumns are treated like columns, so their values must be SELECTed from a table. Sometimes it is convenient to select pseudocolumn values from a dummy table.</p>
<p>In addition, SQL recognizes the parameterless functions in <a href="#BABCGFDG">Table 3-3</a>, which also return specific data items.</p>
<div id="ZZPRE183" class="tblformal">
<p class="titleintable"><a id="sthref149"></a><a id="BABCGFDG"></a>Table 3-3 Parameterless Function Datatypes</p>
<table class="cellalignment3250" title="Parameterless Function Datatypes" summary="functions and internal datatypes" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t5">Function</th>
<th class="cellalignment3246" id="r1c2-t5">Internal Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t5" headers="r1c1-t5">
<p><code>SYSDATE</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t5 r1c2-t5">
<p><code>DATE</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t5" headers="r1c1-t5">
<p><code>UID</code></p>
</td>
<td class="cellalignment3247" headers="r3c1-t5 r1c2-t5">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t5" headers="r1c1-t5">
<p><code>USER</code></p>
</td>
<td class="cellalignment3247" headers="r4c1-t5 r1c2-t5">
<p><code>VARCHAR2</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>You can refer to SQL pseudocolumns and functions in <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements. In the following example, you use <code>SYSDATE</code> to compute the number of months since an employee was hired:</p>
<pre>EXEC SQL SELECT MONTHS_BETWEEN(SYSDATE, HIREDATE)
 INTO :months_of_service
 FROM EMP
 WHERE EMPNO = :emp_number;
</pre>
<p>Brief descriptions of the SQL pseudocolumns and functions follow. For details, see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p><a id="sthref150"></a><span class="bold"><a id="sthref151"></a>CURRVAL</span> returns the current number in a specified sequence. Before you can reference <code>CURRVAL</code>, you must use <code>NEXTVAL</code> to generate a sequence number.</p>
<p><span class="bold"><a id="sthref152"></a>LEVEL<a id="sthref153"></a></span> returns the level number of a node in a tree structure. The root is level 1, children of the root are level 2, grandchildren are level 3, and so on.</p>
<p><code>LEVEL</code> is used in the <code>SELECT</code> <code>CONNECT</code> <code>BY</code> statement to incorporate some or all the rows of a table into a tree structure. In an <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code> clause, <code>LEVEL</code> segregates the data at each level in the tree.</p>
<p>You specify the direction in which the query walks the tree (down from the root or up from the branches) with the PRIOR operator. In the <code>START</code> <code>WITH</code> clause, you specify a condition that identifies the root of the tree.</p>
<p><a id="sthref154"></a><span class="bold"><a id="sthref155"></a>NEXTVAL</span> returns the next number in a specified sequence. After creating a sequence, you can use it to generate unique sequence numbers for transaction processing. In the following example, you use the sequence named <span class="italic">partno</span> to assign part numbers:</p>
<pre>EXEC SQL INSERT INTO PARTS
 VALUES (partno.NEXTVAL, :description, :quantity, :price);
</pre>
<p>If a transaction generates a sequence number, the sequence is incremented when you commit or rollback the transaction. A reference to <code>NEXTVAL</code> stores the current sequence number in <code>CURRVAL</code>.</p>
<p><span class="bold"><a id="sthref156"></a><a id="sthref157"></a>ROWID</span> returns a row address in hexadecimal.</p>
<p><span class="bold"><a id="sthref158"></a><a id="sthref159"></a>ROWNUM</span> returns a number indicating the sequence in which a row was selected from a table. The first row selected has a <code>ROWNUM</code> of 1, the second row has a <code>ROWNUM</code> of 2, and so on. If a <code>SELECT</code> statement includes an <code>ORDER</code> <code>BY</code> clause, <code>ROWNUM</code>s are assigned to the selected rows <span class="italic">before</span> the sort is done.</p>
<p>You can use <code>ROWNUM</code> to limit the number of rows returned by a <code>SELECT</code> statement. Also, you can use <code>ROWNUM</code> in an <code>UPDATE</code> statement to assign unique values to each row in a table. Using <code>ROWNUM</code> in the <code>WHERE</code> clause does not stop the processing of a <code>SELECT</code> statement; it just limits the number of rows retrieved. The only meaningful use of <code>ROWNUM</code> in a WHERE clause is</p>
<pre>... WHERE ROWNUM &lt; constant;
</pre>
<p>because the value of <code>ROWNUM</code> increases only when a row is retrieved. The following search condition can never be met because the first four rows are not retrieved:</p>
<pre>... WHERE ROWNUM = 5;
</pre>
<p><a id="sthref160"></a><span class="bold"><a id="sthref161"></a>SYSDATE</span> returns the current date and time.</p>
<p><span class="bold"><a id="sthref162"></a><a id="sthref163"></a>UID</span> returns the unique ID number assigned to an Oracle user.</p>
<p><span class="bold"><a id="sthref164"></a><a id="sthref165"></a>USER</span> returns the username of the current Oracle user.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE184" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref166"></a>
<h3 class="sect2"><a id="sthref167"></a>ROWLABEL Column</h3>
<p>SQL also recognizes the special column <code>ROWLABEL</code>, which Oracle creates for every database table. Like other columns, <code>ROWLABEL</code> can be referenced in SQL statements. <code>ROWLABEL</code> returns the operating system label for a row.</p>
<p><a id="sthref168"></a>A common use of <code>ROWLABEL</code> is to filter query results. For example, the following statement counts only those rows with a security level higher than &#34;unclassified&#34;:</p>
<pre>EXEC SQL SELECT COUNT(*) INTO :head_count FROM EMP
 WHERE ROWLABEL &gt; &#39;UNCLASSIFIED&#39;;
</pre>
<p>For more information about the <code>ROWLABEL</code> column, see the <a class="olink ADMIN" href="../ADMIN/toc.htm"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE185" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref169"></a>
<h3 class="sect2">External <a id="sthref170"></a>Datatypes</h3>
<p>As <a href="#BABJJJBB">Table 3-4</a> shows, the external datatypes include all the internal datatypes plus several datatypes found in other supported host languages. For example, the <code>STRING</code> external datatype refers to a C null-terminated string, and the <code>DECIMAL</code> datatype refers to COBOL packed decimals. You use the datatype names in datatype equivalencing, and you use the datatype codes in dynamic SQL Method 4.</p>
<div id="ZZPRE186" class="tblformal">
<p class="titleintable"><a id="sthref171"></a><a id="BABJJJBB"></a>Table 3-4 External Datatypes</p>
<table class="cellalignment3250" title="External Datatypes" summary="external datatypes" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t6">Name</th>
<th class="cellalignment3246" id="r1c2-t6">Code</th>
<th class="cellalignment3246" id="r1c3-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t6" headers="r1c1-t6">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t6 r1c2-t6">
<p>1 96</p>
</td>
<td class="cellalignment3247" headers="r2c1-t6 r1c3-t6">
<p>&lt;= 65535-byte, variable-length character string<br/>
&lt;=65535-byte, fixed-length character string<br/>
(see note 1)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t6" headers="r1c1-t6">
<p><code>CHARF</code></p>
</td>
<td class="cellalignment3247" headers="r3c1-t6 r1c2-t6">
<p>96</p>
</td>
<td class="cellalignment3247" headers="r3c1-t6 r1c3-t6">
<p>&lt;= 65535-byte, fixed-length character string</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t6" headers="r1c1-t6">
<p><code>CHARZ</code></p>
</td>
<td class="cellalignment3247" headers="r4c1-t6 r1c2-t6">
<p>97</p>
</td>
<td class="cellalignment3247" headers="r4c1-t6 r1c3-t6">
<p>&lt;= 65535-byte, fixed-length, null-terminated string (see note 2)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t6" headers="r1c1-t6">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3247" headers="r5c1-t6 r1c2-t6">
<p>12</p>
</td>
<td class="cellalignment3247" headers="r5c1-t6 r1c3-t6">
<p>7-byte, fixed-length date/time value</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t6" headers="r1c1-t6">
<p><code>DECIMAL</code></p>
</td>
<td class="cellalignment3247" headers="r6c1-t6 r1c2-t6">
<p>7</p>
</td>
<td class="cellalignment3247" headers="r6c1-t6 r1c3-t6">
<p>COBOL packed decimal</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t6" headers="r1c1-t6">
<p><code>DISPLAY</code></p>
</td>
<td class="cellalignment3247" headers="r7c1-t6 r1c2-t6">
<p>91</p>
</td>
<td class="cellalignment3247" headers="r7c1-t6 r1c3-t6">
<p>COBOL numeric character string</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t6" headers="r1c1-t6">
<p><code>FLOAT</code></p>
</td>
<td class="cellalignment3247" headers="r8c1-t6 r1c2-t6">
<p>4</p>
</td>
<td class="cellalignment3247" headers="r8c1-t6 r1c3-t6">
<p>4-byte or 8-byte floating-point number</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t6" headers="r1c1-t6">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment3247" headers="r9c1-t6 r1c2-t6">
<p>3</p>
</td>
<td class="cellalignment3247" headers="r9c1-t6 r1c3-t6">
<p>2-byte or 4-byte signed integer</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t6" headers="r1c1-t6">
<p><code>LONG</code></p>
</td>
<td class="cellalignment3247" headers="r10c1-t6 r1c2-t6">
<p>8</p>
</td>
<td class="cellalignment3247" headers="r10c1-t6 r1c3-t6">
<p>&lt;= 2147483647-byte, fixed-length string</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t6" headers="r1c1-t6">
<p><code>LONG</code> <code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r11c1-t6 r1c2-t6">
<p>24</p>
</td>
<td class="cellalignment3247" headers="r11c1-t6 r1c3-t6">
<p>&lt;= 217483647-byte, fixed-length binary data (see note 3)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t6" headers="r1c1-t6">
<p><code>LONG</code> <code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r12c1-t6 r1c2-t6">
<p>94</p>
</td>
<td class="cellalignment3247" headers="r12c1-t6 r1c3-t6">
<p>&lt;= 217483643-byte, variable-length string (see note 3)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t6" headers="r1c1-t6">
<p><code>LONG</code> <code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r13c1-t6 r1c2-t6">
<p>95</p>
</td>
<td class="cellalignment3247" headers="r13c1-t6 r1c3-t6">
<p>&lt;= 217483643-byte, variable-length binary data</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t6" headers="r1c1-t6">
<p><code>MLSLABEL</code></p>
</td>
<td class="cellalignment3247" headers="r14c1-t6 r1c2-t6">
<p>106</p>
</td>
<td class="cellalignment3247" headers="r14c1-t6 r1c3-t6">
<p>2..5-byte, variable-length binary data</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t6" headers="r1c1-t6">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3247" headers="r15c1-t6 r1c2-t6">
<p>2</p>
</td>
<td class="cellalignment3247" headers="r15c1-t6 r1c3-t6">
<p>integer or floating-point number</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t6" headers="r1c1-t6">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r16c1-t6 r1c2-t6">
<p>23</p>
</td>
<td class="cellalignment3247" headers="r16c1-t6 r1c3-t6">
<p>&lt;= 65535-byte, fixed-length binary data (see note 2)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t6" headers="r1c1-t6">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r17c1-t6 r1c2-t6">
<p>11</p>
</td>
<td class="cellalignment3247" headers="r17c1-t6 r1c3-t6">
<p>(typically) 13-byte, fixed-length binary value</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t6" headers="r1c1-t6">
<p><code>STRING</code></p>
</td>
<td class="cellalignment3247" headers="r18c1-t6 r1c2-t6">
<p>5</p>
</td>
<td class="cellalignment3247" headers="r18c1-t6 r1c3-t6">
<p>&lt;= 65535-byte, variable-length, null-terminated character string (see note 2)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t6" headers="r1c1-t6">
<p><code>UNSIGNED</code></p>
</td>
<td class="cellalignment3247" headers="r19c1-t6 r1c2-t6">
<p>68</p>
</td>
<td class="cellalignment3247" headers="r19c1-t6 r1c3-t6">
<p>2-byte or 4-byte unsigned integer</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t6" headers="r1c1-t6">
<p><code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r20c1-t6 r1c2-t6">
<p>9</p>
</td>
<td class="cellalignment3247" headers="r20c1-t6 r1c3-t6">
<p>&lt;= 65533-byte, variable-length character string (see note 3)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t6" headers="r1c1-t6">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3247" headers="r21c1-t6 r1c2-t6">
<p>1</p>
</td>
<td class="cellalignment3247" headers="r21c1-t6 r1c3-t6">
<p>&lt;= 65535-byte, variable-length character string (see note 2)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r22c1-t6" headers="r1c1-t6">
<p><code>VARNUM</code></p>
</td>
<td class="cellalignment3247" headers="r22c1-t6 r1c2-t6">
<p>6</p>
</td>
<td class="cellalignment3247" headers="r22c1-t6 r1c3-t6">
<p>variable-length binary number</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r23c1-t6" headers="r1c1-t6">
<p><code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r23c1-t6 r1c2-t6">
<p>15</p>
</td>
<td class="cellalignment3247" headers="r23c1-t6 r1c3-t6">
<p>&lt;= 65533-byte, variable-length binary data (see note 3)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ol>
<li>
<p><code>CHAR</code> is datatype 1 when <code>MODE={ORACLE|ANSI13|ANSI14}</code> and datatype 96 when <code>MODE=ANSI</code>.</p>
</li>
<li>
<p>Maximum size is 32767 (32K) on some platforms.</p>
</li>
<li>
<p>Do not include the n-byte length field in an <code>EXEC SQL VAR</code> statement.</p>
</li>
</ol>
</div>
</div>
<!-- class="sect2" -->
<div id="ZZPRE187" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref172"></a>
<h3 class="sect2">CHAR<a id="sthref173"></a></h3>
<p><a id="sthref174"></a>CHAR behavior depends on the settings of the options DBMS and MODE.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE188" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref175"></a>
<h3 class="sect2">CHARF<a id="sthref176"></a></h3>
<p>When MODE=ANSI, Oracle assigns the CHAR datatype to all character host variables. You use the CHAR datatype to store fixed-length character strings. On most platforms, the maximum length of a CHAR value is 65535 (64K) bytes. See <a href="ch_six.htm#BABIBIDD">Table 6-4</a> for more information about the relationship between the DBMS and MODE options.</p>
<p><span class="bold"><a id="sthref177"></a>On Input</span>. Oracle reads the number of bytes specified for the input host variable, does <span class="italic">not</span> strip trailing blanks, then stores the input value in the target database column.</p>
<p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value is all-blank, Oracle treats it like a character value.</p>
<p><span class="bold">On Output</span>. Oracle returns the number of bytes specified for the output host variable, blank-padding if necessary, then assigns the output value to the target host variable. If a null is returned, Oracle fills the host variable with blanks.</p>
<p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If an indicator variable is available, Oracle sets it to the original length of the output value.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE189" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref178"></a>
<h3 class="sect2">CHARZ<a id="sthref179"></a></h3>
<p>You use the <code>CHARZ</code> datatype to store fixed-length, null-terminated character strings. On most platforms, the maximum length of a <code>CHARZ</code> value is 65,535 bytes. You should not need this external type in Pro*COBOL or Pro*FORTRAN.</p>
<p><a id="sthref180"></a>On input, the <code>CHARZ</code> and <code>STRING</code> datatypes work the same way. You must null-terminate the input value. The null terminator serves only to delimit the string; it is not part of the data.</p>
<p>On output, the <code>CHARZ</code> and <code>CHAR</code> datatypes work the same way. Oracle appends a null terminator to the output value, which is also blank-padded if necessary.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE190" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref181"></a>
<h3 class="sect2">DATE<a id="sthref182"></a></h3>
<p>You use the <code>DATE</code> datatype to store dates and times in 7-byte, fixed-length fields. As <a href="#BABBCAAC">Table 3-5</a> shows, the century, year, month, day, hour (in 24-hour format), minute, and second are stored in that order from left to right.</p>
<div id="ZZPRE191" class="tblformalwide">
<p class="titleintable"><a id="sthref183"></a><a id="BABBCAAC"></a>Table 3-5 DATE Datatype Example</p>
<table class="cellalignment3245" title="DATE Datatype Example" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t8">Byte</th>
<th class="cellalignment3246" id="r1c2-t8">1</th>
<th class="cellalignment3246" id="r1c3-t8">2</th>
<th class="cellalignment3246" id="r1c4-t8">3</th>
<th class="cellalignment3246" id="r1c5-t8">4</th>
<th class="cellalignment3246" id="r1c6-t8">5</th>
<th class="cellalignment3246" id="r1c7-t8">6</th>
<th class="cellalignment3246" id="r1c8-t8">7</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t8" headers="r1c1-t8">
<p>Meaning</p>
</td>
<td class="cellalignment3247" headers="r2c1-t8 r1c2-t8">
<p>Century</p>
</td>
<td class="cellalignment3247" headers="r2c1-t8 r1c3-t8">
<p>Year</p>
</td>
<td class="cellalignment3247" headers="r2c1-t8 r1c4-t8">
<p>Month</p>
</td>
<td class="cellalignment3247" headers="r2c1-t8 r1c5-t8">
<p>Day</p>
</td>
<td class="cellalignment3247" headers="r2c1-t8 r1c6-t8">
<p>Hour</p>
</td>
<td class="cellalignment3247" headers="r2c1-t8 r1c7-t8">
<p>Minute</p>
</td>
<td class="cellalignment3247" headers="r2c1-t8 r1c8-t8">
<p>Second</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t8" headers="r1c1-t8">
<p>Example 17-OCT-1994 at 1:23:12 PM</p>
</td>
<td class="cellalignment3247" headers="r3c1-t8 r1c2-t8">
<p>119</p>
</td>
<td class="cellalignment3247" headers="r3c1-t8 r1c3-t8">
<p>194</p>
</td>
<td class="cellalignment3247" headers="r3c1-t8 r1c4-t8">
<p>10</p>
</td>
<td class="cellalignment3247" headers="r3c1-t8 r1c5-t8">
<p>17</p>
</td>
<td class="cellalignment3247" headers="r3c1-t8 r1c6-t8">
<p>14</p>
</td>
<td class="cellalignment3247" headers="r3c1-t8 r1c7-t8">
<p>24</p>
</td>
<td class="cellalignment3247" headers="r3c1-t8 r1c8-t8">
<p>13</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<p>The century and year bytes are in excess-100 notation. The hour, minute, and second are in excess-1 notation. Dates before the Common Era (B.C.E.) are less than 100. The epoch is January 1, 4712 B.C.E. For this date, the century byte is 53 and the year byte is 88. The hour byte ranges from 1 to 24. The minute and second bytes range from 1 to 60. The time defaults to midnight (1, 1, 1).</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE192" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref184"></a>
<h3 class="sect2">DECIMAL<a id="sthref185"></a></h3>
<p><a id="sthref186"></a>With Pro*COBOL, you use the <code>DECIMAL</code> datatype to store packed decimal numbers for calculation. In COBOL, the host variable must be a signed COMP-3 field with an implied decimal point. If significant digits are lost during data conversion, Oracle fills the host variable with asterisks.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE193" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref187"></a>
<h3 class="sect2">DISPLAY<a id="sthref188"></a></h3>
<p><a id="sthref189"></a>With Pro*COBOL, you use the <code>DISPLAY</code> datatype to store numeric character data. The <code>DISPLAY</code> datatype refers to a COBOL &#34;DISPLAY SIGN LEADING SEPARATE&#34; number, which typically requires <span class="italic">n</span> + 1 bytes of storage for PIC S9(<span class="italic">n</span>), and <span class="italic">n</span> + <span class="italic">d</span> + 1 bytes of storage for PIC S9(<span class="italic">n</span>)V9(<span class="italic">d</span>).</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE194" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref190"></a>
<h3 class="sect2">FLOAT<a id="sthref191"></a><a id="sthref192"></a></h3>
<p><a id="sthref193"></a>You use the <code>FLOAT</code> datatype to store numbers that have a fractional part or that exceed the capacity of the <code>INTEGER</code> datatype. The number is represented using the floating-point format of your computer and typically requires 4 or 8 bytes of storage. You must specify a length for input and output host variables.</p>
<p>Oracle can represent numbers with greater precision than floating point implementations because the internal format of Oracle numbers is decimal.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In SQL statements, when comparing <code>FLOAT</code> values, use the SQL function <code>ROUND</code> because <code>FLOAT</code> stores binary (not decimal) numbers; so, fractions do not convert exactly.</div>
</div>
<!-- class="sect2" -->
<div id="ZZPRE195" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref194"></a>
<h3 class="sect2">INTEGER<a id="sthref195"></a></h3>
<p>You use the <code><a id="sthref196"></a>INTEGER</code> datatype to store numbers that have no fractional part. An integer is a signed, 2- or 4-byte binary number. The order of the bytes in a word is system-dependent. You must specify a length for input and output host variables. On output, if the column value is a floating point number, Oracle truncates the fractional part.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE196" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref197"></a>
<h3 class="sect2"><a id="sthref198"></a>LONG<a id="sthref199"></a></h3>
<p>You use the <code>LONG</code> datatype to store fixed-length character strings. The <code>LONG</code> datatype is like the <code>VARCHAR2</code> datatype, except that the maximum length of a <code>LONG</code> value is 2147483647 bytes (two gigabytes).</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE197" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref200"></a>
<h3 class="sect2">LONG RAW</h3>
<p><a id="sthref201"></a>You use the <code>LONG</code> <code>RAW</code> datatype to store fixed-length, binary data or byte strings. The maximum length of a <code>LONG</code> <code>RAW</code> value is 2147483647 bytes (two gigabytes).</p>
<p><code>LONG</code> <code>RAW</code> data is like <code>LONG</code> data, except that Oracle assumes nothing about the meaning of <code>LONG</code> <code>RAW</code> data and does no character set conversions when you transmit <code>LONG</code> <code>RAW</code> data from one system to another.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE198" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref202"></a>
<h3 class="sect2">LONG VARCHAR<a id="sthref203"></a></h3>
<p><a id="sthref204"></a>You use the <code>LONG</code> <code>VARCHAR</code> datatype to store variable-length character strings. <code>LONG</code> <code>VARCHAR</code> variables have a 4-byte length field followed by a string field. The maximum length of the string field is 2147483643 bytes. In an <code>EXEC SQL VAR</code> statement, do <span class="italic">not</span> include the 4-byte length field.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE199" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref205"></a>
<h3 class="sect2">LONG VARRAW<a id="sthref206"></a></h3>
<p><a id="sthref207"></a>You use the <code>LONG VARRAW</code> datatype to store binary data or byte strings. <code>LONG</code> <code>VARRAW</code> variables have a 4-byte length field followed by a data field. The maximum length of the data field is 2147483643 bytes. In an <code>EXEC</code> <code>SQL</code> <code>VAR</code> statement, do <span class="italic">not</span> include the 4-byte length field.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE200" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref208"></a>
<h3 class="sect2">MLSLABEL<a id="sthref209"></a></h3>
<p>You use the <code>MLSLABEL</code> datatype to store variable-length, binary operating system labels. Oracle uses labels to control access to data. You can use the <code>MLSLABEL</code> datatype to define a column. You can insert any valid operating system label into a column of type <code>MLSLABEL</code>.</p>
<p><span class="bold">On Input.</span> Oracle translates the input value into a binary label, which must be a valid operating system label. If the label is invalid, Oracle issues an error message. If the label is valid, Oracle stores it in the target database column.</p>
<p><span class="bold">On Output.</span> Oracle converts the binary label to a character string, which can be of type <code>CHAR</code>, <code>CHARZ</code>, <code>STRING</code>, <code>VARCHAR</code>, or <code>VARCHAR2</code>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE201" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref210"></a>
<h3 class="sect2">NUMBER<a id="sthref211"></a></h3>
<p>You use the<a id="sthref212"></a> <code>NUMBER</code> datatype to store fixed or floating point Oracle numbers. You can specify precision and scale. The maximum precision of a <code>NUMBER</code> value is 38; the magnitude range is 1.0E-129 to 9.99E125. Scale can range from -84 to 127.</p>
<p><code>NUMBER</code> values are stored in variable-length format, starting with an exponent byte and followed by up to 20 mantissa bytes. The high-order bit of the exponent byte is a sign bit, which is set for positive numbers. The low-order 7 bits represent the exponent, which is a base-100 digit with an offset of 65.</p>
<p>Each mantissa byte is a base-100 digit in the range 1 .. 100. For positive numbers, 1 is added to the digit. For negative numbers, the digit is subtracted from 101, and, unless there are 20 mantissa bytes, a byte containing 102 is appended to the data bytes. Each mantissa byte can represent two decimal digits. The mantissa is normalized and leading zeros are not stored. You can use up to 20 data bytes for the mantissa but only 19 are guaranteed accurate. The 19 bytes, each representing a base-100 digit, allow a maximum precision of 38 digits.</p>
<p>On output, the host variable contains the number as represented internally by Oracle. To accommodate the largest possible number, the output host variable must be 21 bytes long. Only the bytes used to represent the number are returned. Oracle does not blank-pad or null-terminate the output value. If you need to know the length of the returned value, use the <code>VARNUM</code> datatype instead. Normally, there is little reason to use this datatype.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE202" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref213"></a>
<h3 class="sect2"><a id="sthref214"></a>RAW<a id="sthref215"></a></h3>
<p>You use the <code>RAW</code> datatype to store fixed-length binary data or byte strings. On most platforms, the maximum length of a <code>RAW</code> value is 65535 bytes. <code>RAW</code> data is like <code>CHAR</code> data, except that Oracle assumes nothing about the meaning of <code>RAW</code> data and does no character set conversions when you transmit RAW data from one system to another.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE203" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref216"></a>
<h3 class="sect2"><a id="sthref217"></a>ROWID<a id="sthref218"></a></h3>
<p><a id="sthref219"></a>You use the <code>ROWID</code> datatype to store binary rowids in (typically 13-byte) fixed-length fields. The field size is port-specific. So, check your system-specific Oracle manuals. You can use <code>VARCHAR2</code> host variables to store rowids in a readable format. When you select or fetch a rowid into a <code>VARCHAR2</code> host variable, Oracle converts the binary value to an 18-byte character string and returns it in the format</p>
<pre>BBBBBBBB.RRRR.FFFF
</pre>
<p>where BBBBBBBB is the block in the database file, RRRR is the row in the block (the first row is 0), and FFFF is the database file. These numbers are hexadecimal. For example, the rowid</p>
<pre>0000000E.000A.0007
</pre>
<p>points to the 11th row in the 15th block in the 7th database file.</p>
<p>Typically, you fetch a rowid into a <code>VARCHAR2</code> host variable, then compare the host variable to the <code>ROWID</code> pseudocolumn in the <code>WHERE</code> clause of an <code>UPDATE</code> or <code>DELETE</code> statement. That way, you can identify the latest row fetched by a cursor.</p>
<div class="infobox-note">
<p class="notep1">No<a id="sthref220"></a>te:</p>
If you need full portability or your application communicates with a non-Oracle database through Transparent Gateway, specify a maximum length of 256 (not 18) bytes when declaring the <code>VARCHAR2</code> host variable. If your application communicates with a non-Oracle data source through Oracle Open Gateway, specify a maximum length of 256 bytes. Though you can assume nothing about its contents, the host variable will behave normally in SQL statements.</div>
</div>
<!-- class="sect2" -->
<div id="ZZPRE204" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref221"></a>
<h3 class="sect2"><a id="sthref222"></a>STRING<a id="sthref223"></a></h3>
<p>The <code>STRING</code> datatype is like the <code>VARCHAR2</code> datatype, except that a <code>STRING</code> value is always null-terminated.</p>
<p><span class="bold">On Input.</span> Oracle uses the specified length to limit the scan for a null terminator. If a null terminator is not found, Oracle generates an error. If you do not specify a length, Oracle assumes the maximum length, which is 65535 on most platforms.</p>
<p>The minimum length of a <code>STRING</code> value is 2 bytes. If the first character is a null terminator and the specified length is 2, Oracle inserts a null unless the column is defined as <code>NOT</code> <code>NULL</code>. An all-blank or <a id="sthref224"></a>nullterminated value is stored intact.</p>
<p><span class="bold">On Output</span>. Oracle appends a null byte to the last character returned. If the string length exceeds the specified length, Oracle truncates the output value and appends a null byte.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE205" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref225"></a>
<h3 class="sect2"><a id="sthref226"></a>UNSIGNED<a id="sthref227"></a></h3>
<p>You use the <code>UNSIGNED</code> datatype to store unsigned integers. An unsigned integer is a binary number of 2 or 4 bytes. The order of the bytes in a word is system-dependent. You must specify a length for input and output host variables. On output, if the column value is a floating point number, Oracle truncates the fractional part. You should not need this external type in Pro*COBOL or Pro*FORTRAN.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE206" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref228"></a>
<h3 class="sect2"><a id="sthref229"></a>VARCHAR<a id="sthref230"></a></h3>
<p>You use the <code>VARCHAR</code> datatype to store variable-length character strings. <code>VARCHAR</code> variables have a 2-byte length field followed by a &lt;= 65533-byte string field. However, for <code>VARCHAR</code> array elements, the maximum length of the string field is 65530 bytes. When you specify the length of a <code>VARCHAR</code> variable, be sure to include 2 bytes for the length field. For longer strings, use the <code>LONG</code> <code>VARCHAR</code> datatype. In an <code>EXEC</code> <code>SQL</code> <code>VAR</code> statement, do <span class="italic">not</span> include the 2-byte length field.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE207" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref231"></a>
<h3 class="sect2">VARCHAR2<a id="sthref232"></a></h3>
<p><a id="sthref233"></a>When <code>MODE=ORACLE</code>, Oracle assigns the <code>VARCHAR2</code> datatype to all character host variables. You use the <code>VARCHAR2</code> datatype to store variable-length character strings. On most platforms, the maximum length of a <code>VARCHAR2</code> value is 65535 bytes.</p>
<p>You specify the maximum length of a <code>VARCHAR2</code>(<span class="italic">n</span>) value in bytes, not characters. So, if a <code>VARCHAR2</code>(<span class="italic">n</span>) variable stores multibyte characters, its maximum length is less than <span class="italic">n</span> characters.</p>
<p><span class="bold">On Input.</span> Oracle reads the number of bytes specified for the input host variable, strips any trailing blanks, then stores the input value in the target database column. Be careful. An uninitialized host variable can contain nulls. So, always blank-pad a character input host variable to its declared length. (COBOL PIC X(<span class="italic">n</span>) and FORTRAN CHARACTER*<span class="italic">n</span> variables do this automatically.)</p>
<p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value is all-blank, Oracle treats it like a null.</p>
<p>Oracle can convert a character value to a <code>NUMBER</code> column value if the character value represents a valid number. Otherwise, Oracle generates an error.</p>
<p><span class="bold">On Output.</span> Oracle returns the number of bytes specified for the output host variable, blank-padding if necessary, then assigns the output value to the target host variable. If a null is returned, Oracle fills the host variable with blanks.</p>
<p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If an indicator variable is available, Oracle sets it to the original length of the output value.</p>
<p>Oracle can convert <code>NUMBER</code> column values to character values. The length of the character host variable determines precision. If the host variable is too short for the number, scientific notation is used. For example, if you select the column value abcdefg89 into a host variable of length 6, Oracle returns the value &#34;1.2E08&#34; to the host variable.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE208" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref234"></a>
<h3 class="sect2"><a id="sthref235"></a>VARNUM<a id="sthref236"></a></h3>
<p>The <code>VARNUM</code> datatype is like the <code>NUMBER</code> datatype, except that the first byte of a <code>VARNUM</code> variable stores the length of the value. On input, you must set the first byte of the host variable to the length of the value. On output, the host variable contains the length followed by the number as represented internally by Oracle. To accommodate the largest possible number, the host variable must be 22 bytes long. After selecting a column value into a <code>VARNUM</code> host variable, you can check the first byte to get the length of the value.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE209" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref237"></a>
<h3 class="sect2"><a id="sthref238"></a>VARRAW<a id="sthref239"></a></h3>
<p>You use the <code>VARRAW</code> datatype to store variable-length binary data or byte strings. The <code>VARRAW</code> datatype is like the RAW datatype, except that <code>VARRAW</code> variables have a 2-byte length field followed by a &lt;=65533-byte data field. For longer strings, use the <code>LONG</code> <code>VARRAW</code> datatype. In an <code>EXEC</code> <code>SQL</code> <code>VAR</code> statement, do <span class="italic">not</span> include the 2-byte length field. To get the length of a <code>VARRAW</code> variable, simply refer to its length field.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBABJE"></a>
<div id="ZZPRE210" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Datatype Conversion</h2>
<p><a id="sthref240"></a>At precompile time, an external datatype is assigned to each host variable in the Declare Section. For example, the precompiler assigns the <code>INTEGER</code> external datatype to integer host variables. At run time, the datatype code of every host variable used in a SQL statement is passed to Oracle. Oracle uses the codes to convert between internal and external datatypes.</p>
<p>Before assigning a selected column (or pseudocolumn) value to an output host variable, if necessary, Oracle converts the internal datatype of the column to the datatype of the host variable. Likewise, before assigning or comparing the value of an input host variable to a database column, if necessary, Oracle converts the external datatype of the host variable to the internal datatype of the column.</p>
<p>However, the datatype of the host variable must be compatible with that of the database column. It is your responsibility to make sure that values are convertible. For example, if you try to convert the string value &#34;YESTERDAY&#34; to a <code>DATE</code> column value, you get an error.</p>
<p>Conversions between internal and external datatypes follow the usual data conversion rules. For instance, you can convert a <code>CHAR</code> value of &#34;1234&#34; to a 2-byte integer. But, you cannot convert a <code>CHAR</code> value of &#34;65543&#34; (number too large) or &#34;10F&#34; (number not decimal) to a 2-byte integer. Likewise, you cannot convert a string value that contains alphabetic characters to a <code>NUMBER</code> value.</p>
<p>Number conversion follows the conventions specified by Globalization Support (Globalization Support) parameters in the Oracle initialization file. For example, your system might be configured to recognize a comma (,) instead of a period (.) as the decimal character. For more information about Globalization Support, see the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>.</p>
<p><a href="#BABDHHCD">Table 3-6</a> shows the supported conversions <a id="sthref241"></a>between internal and external datatypes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Legend:
<ul>
<li>
<p>On input, host string must be in Oracle &#39;BBBBBBBB.RRRR.FFFF&#39; format.</p>
<p>I = input only On output, column value is returned in same format.</p>
<p>O = output only</p>
</li>
<li>
<p>On input, host string must be the default DATE character format.</p>
<p>I/O = input or output On output, column value is returned in same format</p>
</li>
<li>
<p>On input, host string must be in hexadecimal format. On output, column value is returned in same format.</p>
</li>
<li>
<p>On output, column value must represent a valid number.</p>
</li>
<li>
<p>On input, length must be less than or equal to 2000.</p>
</li>
<li>
<p>On input, column value is stored in hexadecimal format. On output, column value must be in hexadecimal format.</p>
</li>
<li>
<p>On input, host string must be a valid operating system label in text format. On output, column value is returned in same format.</p>
</li>
<li>
<p>On input, host string must be a valid operating system label in raw format. On output, column value is returned in same format.</p>
</li>
</ul>
</div>
<div id="ZZPRE211" class="tblformalwidemax">
<p class="titleintable"><a id="sthref242"></a><a id="BABDHHCD"></a>Table 3-6 Conversion Between Internal and External Datatypes</p>
<table class="cellalignment3245" title="Conversion Between Internal and External Datatypes" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t12">External</th>
<th class="cellalignment3246" id="r1c2-t12">Internal</th>
<th class="cellalignment3246" id="r1c3-t12"><br/></th>
<th class="cellalignment3246" id="r1c4-t12"><br/></th>
<th class="cellalignment3246" id="r1c5-t12"><br/></th>
<th class="cellalignment3246" id="r1c6-t12"><br/></th>
<th class="cellalignment3246" id="r1c7-t12"><br/></th>
<th class="cellalignment3246" id="r1c8-t12"><br/></th>
<th class="cellalignment3246" id="r1c9-t12"><br/></th>
<th class="cellalignment3246" id="r1c10-t12"><br/></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t12" headers="r1c1-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c2-t12">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c3-t12">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c4-t12">
<p><code>LONG</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c5-t12">
<p><code>LONG</code> <code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c6-t12">
<p><code>MLSLABEL</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c7-t12">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c8-t12">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c9-t12">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t12 r1c10-t12">
<p><code>VARCHAR2</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t12" headers="r1c1-t12">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r3c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t12" headers="r1c1-t12">
<p><code>CHARF</code></p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r4c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t12" headers="r1c1-t12">
<p><code>CHARZ</code></p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r5c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t12" headers="r1c1-t12">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c7-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t12" headers="r1c1-t12">
<p><code>DECIMAL</code></p>
</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t12" headers="r1c1-t12">
<p><code>DISPLAY</code></p>
</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t12" headers="r1c1-t12">
<p><code>FLOAT</code></p>
</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t12" headers="r1c1-t12">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t12" headers="r1c1-t12">
<p><code>LONG</code></p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r11c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t12" headers="r1c1-t12">
<p><code>LONG</code> <code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c2-t12">
<p>O</p>
</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c5-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c7-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t12 r1c10-t12">
<p>O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t12" headers="r1c1-t12">
<p><code>LONG</code> <code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r13c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t12" headers="r1c1-t12">
<p><code>LONG</code> <code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c5-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c7-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t12" headers="r1c1-t12">
<p><code>MLSLABEL</code></p>
</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c7-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t12" headers="r1c1-t12">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t12" headers="r1c1-t12">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c5-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c7-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t12" headers="r1c1-t12">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c2-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c7-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r18c1-t12 r1c10-t12">
<p>I</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t12" headers="r1c1-t12">
<p><code>STRING</code></p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r19c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t12" headers="r1c1-t12">
<p><code>UNSIGNED</code></p>
</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t12" headers="r1c1-t12">
<p><code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r21c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r22c1-t12" headers="r1c1-t12">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c3-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c4-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c5-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c6-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c9-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r22c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r23c1-t12" headers="r1c1-t12">
<p><code>VARNUM</code></p>
</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c5-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c7-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c8-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r23c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r24c1-t12" headers="r1c1-t12">
<p><code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c2-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c3-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c4-t12">
<p>I</p>
</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c5-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c6-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c7-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c8-t12">
<p>I/O</p>
</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c9-t12">&nbsp;</td>
<td class="cellalignment3247" headers="r24c1-t12 r1c10-t12">
<p>I/O</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwidemax" -->
<div id="ZZPRE212" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref243"></a>
<h3 class="sect2">DATE Values</h3>
<p><a id="sthref244"></a>When you select a <code>DATE</code> column value into a character host variable, Oracle must convert the internal binary value to an external character value. So, Oracle implicitly calls the SQL function <code>TO_CHAR</code>, which returns a character string in the <a id="sthref245"></a>default date format. The default is set by the Oracle initialization parameter Globalization <code>Support_<a id="sthref246"></a>DATE_FORMAT</code>. To get other information such as the time or Julian date, you must explicitly call <code>TO_CHAR</code> with a format mask.</p>
<p>A conversion is also necessary when you insert a character host value into a <code>DATE</code> column. Oracle implicitly calls the SQL function <code>TO_DATE</code>, which expects the default date format. To insert dates in other formats, you must explicitly call <code>TO_DATE</code> with a format mask.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE213" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref247"></a>
<h3 class="sect2">RAW and LONG RAW Values</h3>
<p><a id="sthref248"></a>When you select a <code>RAW</code> or <code>LONG</code> <code>RAW</code> column value into a character host variable, Oracle must convert the internal binary value to an external character value. In this case, Oracle returns each binary byte of <code>RAW</code> or <code>LONG</code> <code>RAW</code> data as a pair of characters. Each character represents the hexadecimal equivalent of a nibble (half a byte). For example, Oracle returns the binary byte 11111111 as the pair of characters &#34;FF&#34;. The SQL function <code><a id="sthref249"></a>RAWTOHEX</code> performs the same conversion.</p>
<p><a id="sthref250"></a>A conversion is also necessary when you insert a character host value into a <code>RAW</code> or <code>LONG</code> <code>RAW</code> column. Each pair of characters in the host variable must represent the hexadecimal equivalent of a binary byte. If a character does not represent the hexadecimal value of a <a id="sthref251"></a>nibble, Oracle issues the following error message:</p>
<pre>ORA-01465: invalid hex number
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJJBGE"></a>
<div id="ZZPRE214" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Declaring and Referencing Host Variables</h2>
<p><a id="sthref252"></a>Every program variable used in a SQL statement must be declared as a host variable. <a id="sthref253"></a>You declare a host variable in the Declare Section according to the rules of the host language. Normal scoping rules apply. Host variable names can be any length, but only the first 31 characters are significant. For ANSI/ISO compliance, a host variable name must be &lt;= 18 characters long, begin with a letter, and not contain consecutive or trailing underscores.</p>
<p>The external datatype of a host variable and the internal datatype of its source or target database column need not be the same, but they must be compatible. <a href="#BABDHHCD">Table 3-6</a> shows the compatible datatypes between which Oracle converts automatically when necessary.</p>
<p><a id="sthref254"></a>The Oracle <a id="sthref255"></a>Precompilers support most built-in host language datatypes. For a list of supported datatypes, see your host-language supplement. <a id="sthref256"></a>User-defined datatypes are not supported. Datatype equivalencing is discussed in the next section.</p>
<p><a id="sthref257"></a>Although references to a user-defined structure are not allowed, the Pro*COBOL Precompiler lets you reference individual elements of the structure as if they were <a id="sthref258"></a>host variables. You can use such references wherever host variables are allowed.</p>
<div id="ZZPRE215" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref259"></a>
<h3 class="sect2">Some Examples</h3>
<p><a id="sthref260"></a>In the following example, you declare three host variables, then use a <code>SELECT</code> statement to search the database for an employee number matching the value of host variable <span class="italic">emp_number</span>. When a matching row is found, Oracle sets output host variables <span class="italic">dept_number</span> and <span class="italic">emp_name</span> to the values of columns <code>DEPTNO</code> and <code>ENAME</code> in that row.</p>
<pre>-- declare host variables
EXEC SQL BEGIN DECLARE SECTION;
 emp_number INTEGER;
 emp_name CHARACTER(10);
 dept_number INTEGER;
EXEC SQL END DECLARE SECTION;
...
display &#39;Employee number? &#39;;
read emp_number;
EXEC SQL SELECT DEPTNO, ENAME INTO :dept_number, :emp_name
 FROM EMP
 WHERE EMPNO = :emp_number;
</pre>
<p>For more information about using host variables, see <a href="ch_four.htm#BABIDCGI">&#34;Using Host Variables&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE216" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref261"></a>
<h3 class="sect2"><a id="sthref262"></a>VARCHAR Variables</h3>
<p><a id="sthref263"></a>You can use the <code>VARCHAR</code> pseudotype to declare variable-length character strings. (A <a id="sthref264"></a><span class="italic">pseudotype</span> is a datatype not native to your host language.) Recall that <code>VARCHAR</code> variables have a 2-byte length field followed by a string field. For example, the Pro*COBOL Precompiler expands the <code>VARCHAR</code> declaration</p>
<pre>EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01 ENAME PIC X(20) VARYING.
 EXEC SQL END DECLARE SECTION END-EXEC.
</pre>
<p>into the following COBOL group item with array and length members:</p>
<pre>01 ENAME.
 05 ENAME-LEN PIC S9(4) COMP.
 05 ENAME-ARR PIC X(20).
</pre>
<p>To get the length of a <code>VARCHAR</code>, you simply refer to its length field. You need not use a string function or character-counting algorithm.</p>
<p>For more information about <code>VARCHAR</code>s, see your host-language supplement to this Guide.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE217" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref265"></a>
<h3 class="sect2">Host Variable Guidelines</h3>
<p>The following guidelines<a id="sthref266"></a> apply to declaring and referencing host variables. A host variable must be</p>
<ul>
<li>
<p>declared explicitly in the Declare Section</p>
</li>
<li>
<p>prefixed with a colon (:) in SQL statements and PL/SQL blocks</p>
</li>
<li>
<p>of a datatype supported by the host language</p>
</li>
<li>
<p>of a datatype compatible with that of its source or target database column</p>
</li>
</ul>
<p>A host variable must <span class="italic">not</span> be</p>
<ul>
<li>
<p>subscripted</p>
</li>
<li>
<p>prefixed with a colon in host language statements</p>
</li>
<li>
<p>used to identify a column, table, or other Oracle object</p>
</li>
<li>
<p>used in data definition statements such as ALTER and CREATE</p>
</li>
<li>
<p>an Oracle reserved word (refer to <a href="appb.htm#CJHIIICD">Appendix B</a>)</p>
</li>
</ul>
<p>A host variable can be</p>
<ul>
<li>
<p>used anywhere an expression can be used in a SQL statement</p>
</li>
<li>
<p>associated with an indicator variable</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDDAAA"></a>
<div id="ZZPRE218" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Declaring and<a id="sthref267"></a> Referencing <a id="sthref268"></a>Indicator Variables</h2>
<p><a id="sthref269"></a>You can associate every host variable with an optional indicator variable. An indicator variable must be defined in the Declare Section as a 2-byte integer and, in SQL statements, must be prefixed with a colon and must directly follows its host variable unless you use the keyword <code>INDICATOR</code>.</p>
<div id="ZZPRE219" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref270"></a>
<h3 class="sect2">INDICATOR Keyword</h3>
<p>To improve readability, you can precede any indicator variable with the optional keyword <code>INDICATOR</code>. You must still prefix the indicator variable with a colon. The correct syntax is</p>
<pre>:&lt;host_variable&gt; INDICATOR :&lt;indicator_variable&gt;
</pre>
<p>which is equivalent to</p>
<pre>:&lt;host_variable&gt;:&lt;indicator_variable&gt;
</pre>
<p>You can use both forms of expression in your host program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE220" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref271"></a>
<h3 class="sect2">An Example</h3>
<p><a id="sthref272"></a>Typically, you use indicator variables to assign nulls to input host variables and detect nulls or truncated values in output host variables. In the example, you declare three host variables and one indicator variable, then use a <code>SELECT</code> statement to search the database for an employee number matching the value of host variable <span class="italic">emp_number</span>. When a matching row is found, Oracle sets output host variables <span class="italic">salary</span> and <span class="italic">commission</span> to the values of columns <code>SAL</code> and <code>COMM</code> in that row and stores a return code in indicator variable <span class="italic">ind_comm</span>. The next statement uses <span class="italic">ind_comm</span> to select a course of action.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 emp_number INTEGER;
 salary REAL;
 commission REAL;
 ind_comm SMALLINT; -- indicator variable
EXEC SQL END DECLARE SECTION; 
 pay REAL; -- not used in a SQL statement
display &#39;Employee number? &#39;;
read emp_number;
EXEC SQL SELECT SAL, COMM
 INTO :salary, :commission:ind_comm
 FROM EMP
 WHERE EMPNO = :emp_number;
IF ind_comm = -1 THEN -- commission is null
 set pay = salary;
ELSE
 set pay = salary + commission;
ENDIF;
</pre>
<p>For more information, see <a href="ch_four.htm#BABCFFHH">&#34;Using Indicator Variables&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE221" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref273"></a>
<h3 class="sect2"><a id="sthref274"></a>Indicator Variable Guidelines</h3>
<p>The following guidelines<a id="sthref275"></a> apply to declaring and referencing indicator variables. An indicator variable must be</p>
<ul>
<li>
<p>declared explicitly in the Declare Section as a 2-byte integer</p>
</li>
<li>
<p>prefixed with a colon (:) in SQL statements</p>
</li>
<li>
<p>appended to its host variable in SQL statements and PL/SQL blocks (unless preceded by the keyword <code>INDICATOR</code>)</p>
</li>
</ul>
<p>An indicator variable must <span class="italic">not</span> be</p>
<ul>
<li>
<p>prefixed with a colon in host language statements</p>
</li>
<li>
<p>appended to its host variable in host language statements</p>
</li>
<li>
<p>an Oracle reserved word</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJGGIF"></a>
<div id="ZZPRE222" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Datatype Equivalencing</h2>
<p><a id="sthref276"></a><a id="sthref277"></a>Datatype equivalencing lets you customize the way Oracle interprets input data and the way Oracle formats output data. On a variable-by- variable basis, you can equivalence supported host language datatypes to the Oracle external datatypes.</p>
<div id="ZZPRE223" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref278"></a>
<h3 class="sect2">Why Equivalence Datatypes?</h3>
<p><a id="sthref279"></a>Datatype equivalencing is useful in several ways. For example, suppose you want to use a null-terminated host string in a COBOL program. You can declare a PIC X host variable, then equivalence it to the external datatype <code>STRING</code>, which is always null-terminated.</p>
<p>You can use datatype equivalencing when you want Oracle to store but not interpret data. For example, if you want to store an integer host array in a <code>LONG</code> <code>RAW</code> database column, you can equivalence the host array to the external datatype <code>LONG</code> <code>RAW</code>.</p>
<p>Also, you can use datatype equivalencing to override default datatype conversions. Unless Globalization Support parameters in the Oracle initialization file specify otherwise, if you select a <code>DATE</code> column value into a character host variable, Oracle returns a 9-byte string formatted as follows:</p>
<pre>DD-MON-YY
</pre>
<p>However, if you equivalence the character host variable to the <code>DATE</code> external datatype, Oracle returns a 7-byte value in the internal format.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE224" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref280"></a>
<h3 class="sect2">Host Variable Equivalencing</h3>
<p>By default, the Oracle Precompilers assign a specific external datatype to every host variable. (These default assignments are tabulated in your supplement to this Guide.) You can override the default assignments by equivalencing host variables to Oracle external datatypes in the Declare Section. This is called <span class="italic">host variable equivalencing</span>.</p>
<p><a id="sthref281"></a><a id="sthref282"></a>The syntax you use is:</p>
<pre>EXEC SQL VAR &lt;host_variable&gt;
 IS &lt;ext_type_name&gt; [({&lt;length&gt; | &lt;precision&gt;,&lt;scale&gt;})];
</pre>
<p>where, <code>host_variable</code> is an input or output host variable (or host array) declared <span class="italic">earlier</span> in the Declare Section. The <code>VARCHAR</code> and <code>VARRAW</code> external datatypes have a 2-byte length field followed by an <span class="italic">n</span>-byte data field, where <span class="italic">n</span> lies in the range 1 .. 65533. So, if <span class="italic">type_name</span> is <code>VARCHAR</code> or <code>VARRAW</code>, <span class="italic">host_variable</span> must be at least 3 bytes long.</p>
<p>The <code>LONG</code> <code>VARCHAR</code> and <code>LONG</code> <code>VARRAW</code> external datatypes have a 4-byte length field followed by an <span class="italic">n</span>-byte data field, where <span class="italic">n</span> lies in the range 1 .. 2147483643. So, if <span class="italic">type_name</span> is <code>LONG</code> <code>VARCHAR</code> or <code>LONG</code> <code>VARRAW</code>, <span class="italic">host_variable</span> must be at least 5 bytes long.</p>
<p><code>ext_type_name</code> is the name of a valid external datatype such as <code>RAW</code> or <code>STRING</code>.</p>
<p><code>length</code> is an integer literal specifying a valid length in bytes. The value of <span class="italic">length</span> must be large enough to accommodate the external datatype.</p>
<p>When <span class="italic">type_name</span> is <code>DECIMAL</code> or <code>DISPLAY</code>, you must specify <span class="italic">precision</span> and <span class="italic">scale</span> instead of <span class="italic">length</span>. When <span class="italic">type_name</span> is <code>VARNUM</code>, <code>ROWID</code>, or <code>DATE</code>, you cannot specify <span class="italic">length</span> because it is predefined. For other external datatypes, <span class="italic">length</span> is optional. It defaults to the length of <span class="italic">host_variable</span>.</p>
<p>When specifying <span class="italic">length</span>, if <span class="italic">type_name</span> is <code>VARCHAR</code>, <code>VARRAW</code>, <code>LONG</code> <code>VARCHAR</code>, or <code>LONG</code> <code>VARRAW</code>, use the maximum length of the data field. The precompiler accounts for the length field. If <span class="italic">type_name</span> is <code>LONG</code> <code>VARCHAR</code> or <code>LONG</code> <code>VARRAW</code> and the data field exceeds 65533 bytes, put &#34;-1&#34; in the <span class="italic">length</span> field.</p>
<p><span class="italic">precision</span> and <span class="italic">scal<a id="sthref283"></a>e</span> are integer literals that represent, respectively, the number of significant digits and the point at which rounding will occur. For example, a <span class="italic">scale</span> of 2 <a id="sthref284"></a>means the value is rounded to the nearest hundredth (3.456 becomes 3.46); a scale of -3 means the number is rounded to the nearest thousand (3456 becomes 3000).</p>
<p>You can specify a <span class="italic">precision</span> of 1 .. 99 and a <span class="italic">scale</span> of -84 .. 99. However, the maximum precision and scale of a database column are 38 and 127, respectively. So, if <span class="italic">precision</span> exceeds 38, you cannot insert the value of <span class="italic">host_variable</span> into a database column. However, if the scale of a column value exceeds 99, you cannot select or fetch the value into <span class="italic">host_variable</span>.</p>
<p>Specify <span class="italic">precision</span> and <span class="italic">scale</span> only when <span class="italic">type_name</span> is <code>DECIMAL</code> or <code>DISPLAY</code>.</p>
<p><a href="#BABIFBEE">Table 3-7</a> shows which parameters to use with each external datatype.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE225" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref285"></a>
<h3 class="sect2">An Example</h3>
<p><a id="sthref286"></a>Suppose you want to select employee names from the <code>EMP</code> table, then pass them to a routine that expects null-terminated strings. You need not explicitly null-terminate the names. Simply equivalence a host variable to the <code>STRING</code> external datatype, as follows:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 ...
 emp_name CHARACTER(11);
 EXEC SQL VAR emp_name IS STRING (11);
EXEC SQL END DECLARE SECTION;
</pre>
<p>The width of the <code>ENAME</code> column is 10 characters, so you allocate the new <span class="italic">emp_name</span> 11 characters to accommodate the null terminator. (Here, <span class="italic">length</span> is optional because it defaults to the length of the host variable.) When you select a value from the <code>ENAME</code> column into <span class="italic">emp_name</span>, Oracle null-terminates the value for you.</p>
<div id="ZZPRE226" class="tblformal">
<p class="titleintable"><a id="sthref287"></a><a id="BABIFBEE"></a>Table 3-7 External Datatype Parameters</p>
<table class="cellalignment3250" title="External Datatype Parameters" summary="datatype eqv" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t13">External Datatype</th>
<th class="cellalignment3246" id="r1c2-t13">Length</th>
<th class="cellalignment3246" id="r1c3-t13">Precision</th>
<th class="cellalignment3246" id="r1c4-t13">Scale</th>
<th class="cellalignment3246" id="r1c5-t13">Default Length</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t13" headers="r1c1-t13">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r2c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r2c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r2c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t13" headers="r1c1-t13">
<p><code>CHARZ</code></p>
</td>
<td class="cellalignment3247" headers="r3c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r3c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r3c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r3c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t13" headers="r1c1-t13">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3247" headers="r4c1-t13 r1c2-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r4c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r4c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r4c1-t13 r1c5-t13">
<p>7 bytes</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t13" headers="r1c1-t13">
<p><code>DECIMAL</code></p>
</td>
<td class="cellalignment3247" headers="r5c1-t13 r1c2-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r5c1-t13 r1c3-t13">
<p>required</p>
</td>
<td class="cellalignment3247" headers="r5c1-t13 r1c4-t13">
<p>required</p>
</td>
<td class="cellalignment3247" headers="r5c1-t13 r1c5-t13">
<p>none</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t13" headers="r1c1-t13">
<p><code>DISPLAY</code></p>
</td>
<td class="cellalignment3247" headers="r6c1-t13 r1c2-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r6c1-t13 r1c3-t13">
<p>required</p>
</td>
<td class="cellalignment3247" headers="r6c1-t13 r1c4-t13">
<p>required</p>
</td>
<td class="cellalignment3247" headers="r6c1-t13 r1c5-t13">
<p>none</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t13" headers="r1c1-t13">
<p><code>FLOAT</code></p>
</td>
<td class="cellalignment3247" headers="r7c1-t13 r1c2-t13">
<p>optional (4 or 8)</p>
</td>
<td class="cellalignment3247" headers="r7c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r7c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r7c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t13" headers="r1c1-t13">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment3247" headers="r8c1-t13 r1c2-t13">
<p>optional (1, 2, or 4)</p>
</td>
<td class="cellalignment3247" headers="r8c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r8c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r8c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t13" headers="r1c1-t13">
<p><code>LONG</code></p>
</td>
<td class="cellalignment3247" headers="r9c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r9c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r9c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r9c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t13" headers="r1c1-t13">
<p><code>LONG</code> <code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r10c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r10c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r10c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r10c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t13" headers="r1c1-t13">
<p><code>LONG</code> <code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r11c1-t13 r1c2-t13">
<p>required (see note 1)</p>
</td>
<td class="cellalignment3247" headers="r11c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r11c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r11c1-t13 r1c5-t13">
<p>none</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t13" headers="r1c1-t13">
<p><code>LONG</code> <code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r12c1-t13 r1c2-t13">
<p>required (see note 1)</p>
</td>
<td class="cellalignment3247" headers="r12c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r12c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r12c1-t13 r1c5-t13">
<p>none</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t13" headers="r1c1-t13">
<p><code>MLSLABEL</code></p>
</td>
<td class="cellalignment3247" headers="r13c1-t13 r1c2-t13">
<p>required</p>
</td>
<td class="cellalignment3247" headers="r13c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r13c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r13c1-t13 r1c5-t13">
<p>none</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t13" headers="r1c1-t13">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3247" headers="r14c1-t13 r1c2-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r14c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r14c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r14c1-t13 r1c5-t13">
<p>not available</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t13" headers="r1c1-t13">
<p><code>STRING</code></p>
</td>
<td class="cellalignment3247" headers="r15c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r15c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r15c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r15c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t13" headers="r1c1-t13">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r16c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r16c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r16c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r16c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t13" headers="r1c1-t13">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r17c1-t13 r1c2-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r17c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r17c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r17c1-t13 r1c5-t13">
<p>13 bytes (see note 2)</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t13" headers="r1c1-t13">
<p><code>UNSIGNED</code></p>
</td>
<td class="cellalignment3247" headers="r18c1-t13 r1c2-t13">
<p>optional (1, 2, or 4)</p>
</td>
<td class="cellalignment3247" headers="r18c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r18c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r18c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t13" headers="r1c1-t13">
<p><code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r19c1-t13 r1c2-t13">
<p>required</p>
</td>
<td class="cellalignment3247" headers="r19c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r19c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r19c1-t13 r1c5-t13">
<p>none</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t13" headers="r1c1-t13">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3247" headers="r20c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r20c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r20c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r20c1-t13 r1c5-t13">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t13" headers="r1c1-t13">
<p><code>VARNUM</code></p>
</td>
<td class="cellalignment3247" headers="r21c1-t13 r1c2-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r21c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r21c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r21c1-t13 r1c5-t13">
<p>22 bytes</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r22c1-t13" headers="r1c1-t13">
<p><code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r22c1-t13 r1c2-t13">
<p>optional</p>
</td>
<td class="cellalignment3247" headers="r22c1-t13 r1c3-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r22c1-t13 r1c4-t13">
<p>n/a</p>
</td>
<td class="cellalignment3247" headers="r22c1-t13 r1c5-t13">
<p>none</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
<ol>
<li>
<p>If the data field exceeds 65,533 bytes, pass -1.</p>
</li>
<li>
<p>This length is typical but the default is port-specific.</p>
</li>
</ol>
</div>
</div>
<!-- class="sect2" -->
<div id="ZZPRE227" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref288"></a>
<h3 class="sect2"><a id="sthref289"></a>Using the CHARF Datatype Specifier</h3>
<p><a id="sthref290"></a>You can use the datatype specifier <code><a id="sthref291"></a>CHARF</code> in <code>VAR</code> and <code>TYPE</code> statements to equivalence host-language datatypes to the fixed-length ANSI datatype <code>CHAR</code>--regardless of the DBMS setting.</p>
<p><a id="sthref292"></a>When <code>MODE=ANSI</code>, specifying the datatype <code>CHAR</code> in a <code>TYPE</code> statement equivalences the host-language datatype to the fixed-length ANSI datatype <code>CHAR</code> (Oracle external datatype code 96). However, when <code>MODE=ORACLE</code>, the host-language datatype is equivalenced to the variable-length datatype <code>VARCHAR2</code> (code 1), which might not be what you want.</p>
<p><a id="sthref293"></a>However, you can always equivalence host-language datatypes to the fixed-length ANSI datatype <code>CHAR</code>. Simply specify the datatype <code>CHARF</code> in the <code>VAR</code> statement. If you use <code>CHARF</code>, the host-language datatype is equivalenced to the fixed-length ANSI datatype <code>CHAR</code> even when <code>MODE=ORACLE</code>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE228" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref294"></a>
<h3 class="sect2">Guidelines</h3>
<p><a id="sthref295"></a><a id="sthref296"></a>To input <code>VARNUM</code> or <code>DATE</code> values, you must use the Oracle internal format. Keep in mind that Oracle uses the internal format to output <code>VARNUM</code> and <code>DATE</code> values.</p>
<p><a id="sthref297"></a>After selecting a column value into a <code>VARNUM</code> host variable, you can check the first byte to get the length of the value. <a href="#BABGEDJD">Table 3-8</a> gives some examples of returned <code>VARNUM</code> values.</p>
<div id="ZZPRE229" class="tblformal">
<p class="titleintable"><a id="sthref298"></a><a id="BABGEDJD"></a>Table 3-8 Examples of VARNUM Values Returned</p>
<table class="cellalignment3250" title="Examples of VARNUM Values Returned" summary="VARNUM" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t15">Decimal Value</th>
<th class="cellalignment3246" id="r1c2-t15" colspan="4">VARNUM Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t15" headers="r1c1-t15">&nbsp;</td>
<td class="cellalignment3247" headers="r2c1-t15 r1c2-t15">
<p><span class="bold">Length Byte</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t15 r1c2-t15">
<p><span class="bold">Exponent Byte</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t15 r1c2-t15">
<p><span class="bold">Mantissa Bytes</span></p>
</td>
<td class="cellalignment3247" headers="r2c1-t15 r1c2-t15">
<p><span class="bold">Terminator Byte</span></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t15" headers="r1c1-t15">
<p>0</p>
</td>
<td class="cellalignment3247" headers="r3c1-t15 r1c2-t15">
<p>1</p>
</td>
<td class="cellalignment3247" headers="r3c1-t15 r1c2-t15">
<p>128</p>
</td>
<td class="cellalignment3247" headers="r3c1-t15 r1c2-t15">
<p>na</p>
</td>
<td class="cellalignment3247" headers="r3c1-t15 r1c2-t15">
<p>na</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t15" headers="r1c1-t15">
<p>5</p>
</td>
<td class="cellalignment3247" headers="r4c1-t15 r1c2-t15">
<p>2</p>
</td>
<td class="cellalignment3247" headers="r4c1-t15 r1c2-t15">
<p>193</p>
</td>
<td class="cellalignment3247" headers="r4c1-t15 r1c2-t15">
<p>6</p>
</td>
<td class="cellalignment3247" headers="r4c1-t15 r1c2-t15">
<p>na</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t15" headers="r1c1-t15">
<p>-5</p>
</td>
<td class="cellalignment3247" headers="r5c1-t15 r1c2-t15">
<p>3</p>
</td>
<td class="cellalignment3247" headers="r5c1-t15 r1c2-t15">
<p>62</p>
</td>
<td class="cellalignment3247" headers="r5c1-t15 r1c2-t15">
<p>96</p>
</td>
<td class="cellalignment3247" headers="r5c1-t15 r1c2-t15">
<p>102</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t15" headers="r1c1-t15">
<p>2767</p>
</td>
<td class="cellalignment3247" headers="r6c1-t15 r1c2-t15">
<p>3</p>
</td>
<td class="cellalignment3247" headers="r6c1-t15 r1c2-t15">
<p>194</p>
</td>
<td class="cellalignment3247" headers="r6c1-t15 r1c2-t15">
<p>28, 68</p>
</td>
<td class="cellalignment3247" headers="r6c1-t15 r1c2-t15">
<p>na</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t15" headers="r1c1-t15">
<p>-2767</p>
</td>
<td class="cellalignment3247" headers="r7c1-t15 r1c2-t15">
<p>4</p>
</td>
<td class="cellalignment3247" headers="r7c1-t15 r1c2-t15">
<p>61</p>
</td>
<td class="cellalignment3247" headers="r7c1-t15 r1c2-t15">
<p>74, 34</p>
</td>
<td class="cellalignment3247" headers="r7c1-t15 r1c2-t15">
<p>102</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t15" headers="r1c1-t15">
<p>100000</p>
</td>
<td class="cellalignment3247" headers="r8c1-t15 r1c2-t15">
<p>2</p>
</td>
<td class="cellalignment3247" headers="r8c1-t15 r1c2-t15">
<p>195</p>
</td>
<td class="cellalignment3247" headers="r8c1-t15 r1c2-t15">
<p>11</p>
</td>
<td class="cellalignment3247" headers="r8c1-t15 r1c2-t15">
<p>na</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t15" headers="r1c1-t15">
<p>abcdefg</p>
</td>
<td class="cellalignment3247" headers="r9c1-t15 r1c2-t15">
<p>5</p>
</td>
<td class="cellalignment3247" headers="r9c1-t15 r1c2-t15">
<p>196</p>
</td>
<td class="cellalignment3247" headers="r9c1-t15 r1c2-t15">
<p>2, 24, 46, 68</p>
</td>
<td class="cellalignment3247" headers="r9c1-t15 r1c2-t15">
<p>na</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Convert <code>DATE</code> values to a character format such as &#34;DD-MON-YY&#34; because, normally, that is how your program outputs (displays for example) or inputs them.</p>
<p>If no Oracle external datatype suits your needs exactly, use a <code>VARCHAR2</code>-based or <code>RAW</code>-based external datatype.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIBCHC"></a>
<div id="ZZPRE230" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Globalization Support</h2>
<p><a id="sthref299"></a>Although the widely-used 7- or 8-bit ASCII and EBCDIC character sets are adequate to represent the Roman alphabet, some Asian languages, such as Japanese, contain thousands of characters. These languages require 16 bits (two bytes) to represent each character. How does Oracle deal with such dissimilar languages?</p>
<p>Oracle provides Globalization Support (Globalization Support), which lets you process single-byte and multibyte character data and convert between character sets. It also lets your applications run in different language environments. With Globalization Support, number and date formats adapt automatically to the language conventions specified for a user session. Thus, Globalization Support allows users around the world to interact with Oracle in their native languages.</p>
<p>You control the operation of language-dependent features by specifying various Globalization Support parameters. You can set default parameter values in the Oracle initialization file. <a href="#BABDFFCE">Table 3-9</a> shows what each Globalization Support parameter specifies.</p>
<div id="ZZPRE231" class="tblformal">
<p class="titleintable"><a id="sthref300"></a><a id="BABDFFCE"></a>Table 3-9 Globalization Support Parameters</p>
<table class="cellalignment3250" title="Globalization Support Parameters" summary="NLS parameters" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t16">Globalization Support Parameter</th>
<th class="cellalignment3246" id="r1c2-t16">Specifies ...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t16" headers="r1c1-t16">
<p>Globalization Support_LANGUAGE<a id="sthref301"></a></p>
</td>
<td class="cellalignment3247" headers="r2c1-t16 r1c2-t16">
<p>language-dependent conventions</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t16" headers="r1c1-t16">
<p>Globalization Support_TERRITORY<a id="sthref302"></a></p>
</td>
<td class="cellalignment3247" headers="r3c1-t16 r1c2-t16">
<p>territory-dependent conventions</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t16" headers="r1c1-t16">
<p>Globalization Support_DATE_FORMA<a id="sthref303"></a>T</p>
</td>
<td class="cellalignment3247" headers="r4c1-t16 r1c2-t16">
<p>date format</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t16" headers="r1c1-t16">
<p>Globalization Support_<a id="sthref304"></a>DATE_LANGUAGE</p>
</td>
<td class="cellalignment3247" headers="r5c1-t16 r1c2-t16">
<p>language for day and month names</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t16" headers="r1c1-t16">
<p>Globalization Support_NUMERIC_CHARACTERS<a id="sthref305"></a></p>
</td>
<td class="cellalignment3247" headers="r6c1-t16 r1c2-t16">
<p>decimal character and group separator</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t16" headers="r1c1-t16">
<p>Globalization Support_CURRENCY<a id="sthref306"></a></p>
</td>
<td class="cellalignment3247" headers="r7c1-t16 r1c2-t16">
<p>local currency symbol</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t16" headers="r1c1-t16">
<p>Globalization Support_ISO_CURRENCY<a id="sthref307"></a></p>
</td>
<td class="cellalignment3247" headers="r8c1-t16 r1c2-t16">
<p>ISO currency symbol</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t16" headers="r1c1-t16">
<p>Globalization Support_SORT<a id="sthref308"></a></p>
</td>
<td class="cellalignment3247" headers="r9c1-t16 r1c2-t16">
<p>sort sequence</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The main parameters are Globalization Support_LANGUAGE and Globalization Support_TERRITORY. Globalization Support_LANGUAGE specifies the default values for language-dependent features, which include</p>
<ul>
<li>
<p>language for Server messages</p>
</li>
<li>
<p>language for day and month names</p>
</li>
<li>
<p>sort sequence</p>
</li>
</ul>
<p>Globalization Support_TERRITORY specifies the default values for territory-dependent features, which include</p>
<ul>
<li>
<p>date format</p>
</li>
<li>
<p>decimal character</p>
</li>
<li>
<p>group separator</p>
</li>
<li>
<p>local currency symbol</p>
</li>
<li>
<p>ISO currency symbol</p>
</li>
</ul>
<p>You can control the operation of language-dependent Globalization Support features for a user session by specifying the parameter Globalization Support_LANG as follows:</p>
<pre>Globalization Support_LANG = &lt;language&gt;_&lt;territory&gt;.&lt;character set&gt;
</pre>
<p>where <span class="italic">language</span> specifies the value of Globalization Support_LANGUAGE for the user session, <span class="italic">territory</span> specifies the value of Globalization Support_TERRITORY, and <span class="italic">character set</span> specifies the encoding scheme used for the terminal. An <span class="italic"><a id="sthref309"></a>encoding scheme</span> (usually called a character set or code page) is a range of numeric codes that corresponds to the set of characters a terminal can display. It also includes codes that control communication with the terminal.</p>
<p><a id="sthref310"></a>You define Globalization Support_LANG as an environment variable (or the equivalent on your system). For example, on UNIX using the C shell, you might define Globalization Support_LANG as follows:</p>
<pre>setenv Globalization Support_LANG French_France.WE8ISO8859P1
</pre>
<p>To change the values of Globalization Support parameters during a session, you use the <code>ALTER</code> <code>SESSION</code> statement as follows:</p>
<pre>ALTER SESSION SET &lt;Globalization Support_parameter&gt; = &lt;value&gt;
</pre>
<p>The <a id="sthref311"></a>Oracle Precompilers fully support all the Globalization Support features that allow your applications to process multilingual data stored in an Oracle database. For example, you can declare foreign-language character variables and pass them to string functions such as <code>INSTRB</code>, <code>LENGTHB</code>, and <code>SUBSTRB</code>. These functions have the same syntax as the <code>INSTR</code>, <code>LENGTH</code>, and <code>SUBSTR</code> functions, respectively, but operate on a each-byte basis rather than a in each-character basis.</p>
<p>You can use the functions Globalization Support_INITCAP, Globalization Support_LOWER, and Globalization Support_UPPER to handle special instances of case conversion. And, you can use the function Globalization SupportSORT to specify WHERE-clause comparisons based on linguistic rather than binary ordering. You can even pass Globalization Support parameters to the <code>TO_CHAR</code>, <code>TO_DATE</code>, and TO_NUMBER functions. For more information about Globalization Support, see the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="BABIDCJI"></a>
<div id="ZZPRE232" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Multibyte Globalization Support Character Sets</h2>
<p><a id="sthref312"></a>The<a id="sthref313"></a> Pro*COBOL Precompiler extends support for multibyte Globalization Support character sets through</p>
<ul>
<li>
<p>recognition of multibyte character strings by the precompiler in embedded SQL statements.</p>
</li>
<li>
<p>the ANSI standard COBOL PIC N datatype declaration clause, which instructs the precompiler to interpret host character variables as strings of double-byte characters.</p>
</li>
</ul>
<p>Oracle supports multibyte strings through the precompiler run-time library, SQLLIB.</p>
<div id="ZZPRE233" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref314"></a>
<h3 class="sect2">Character Strings in Embedded SQL</h3>
<p><a id="sthref315"></a>A multibyte Globalization Support character string in an embedded SQL statement consists of a character literal that identifies the string as a multibyte string, followed by the string enclosed in single quotes.</p>
<p>For example, an embedded SQL statement like</p>
<pre>EXEC SQL
 SELECT empno INTO :emp_num FROM emp
 WHERE ename=N&#39;Kuroda&#39;
 END-EXEC.
</pre>
<p>contains a multibyte character string, since the N character literal preceding the string &#34;Kuroda&#34; identifies it as a multibyte string.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE234" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref316"></a>
<h3 class="sect2">Dynamic SQL</h3>
<p>Because dynamic SQL statements are not processed at precompile time, and Oracle does not process multibyte Globalization Support strings itself, you cannot embed multibyte Globalization Support strings in dynamic SQL statements.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE235" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref317"></a>
<h3 class="sect2">Embedded DDL</h3>
<p>Columns storing multibyte Globalization Support data cannot be used in embedded data definition language (DDL) statements. This restriction cannot be enforced when precompiling, so the use of extended column types, such as NCHAR, within embedded DDL statements results in an execution error rather than a precompile error.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE236" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref318"></a>
<h3 class="sect2">Multibyteultibyte Globalization Support Host Variables<a id="sthref319"></a></h3>
<p><a id="sthref320"></a>The Pro*COBOL Precompiler uses the ANSI standard PIC N clause to declare host variables for multibyte character data. Variables declared using the PIC N clause are recognized as string variables of double-byte characters.</p>
<ul>
<li>
<p>Globalization Support_LOCAL</p>
</li>
<li>
<p>VARCHAR</p>
</li>
</ul>
<p>For more information about these options, see <a href="ch_six.htm#BABDDACC">Chapter 6, &#34;Running the Oracle Precompilers&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE237" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref321"></a>
<h3 class="sect2">Restrictions</h3>
<p>Tables Disallowed.</p>
<p>Host variables declared using the PIC N datatype must not be tables.</p>
<p><span class="bold">No Odd Byte Widths.</span> Oracle <code>CHAR</code> columns should not be used to store multibyte Globalization Support characters. A run-time error is generated if data with an odd number of bytes is fetched from a single-byte column into a multibyte Globalization Support (PIC N) host variable.</p>
<p><span class="bold">No Host Variable Equivalencing.</span> multibyte Globalization Support character variables cannot be equivalenced using an <code>EXEC</code> <code>SQL</code> <code>VAR</code> statement.</p>
<p><span class="bold">No Dynamic SQL.</span> Dynamic SQL is not available for Globalization Support multibyte character string host variables in Pro*COBOL.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE238" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref322"></a>
<h3 class="sect2">Blank Padding</h3>
<p><a id="sthref323"></a>When a Pro*COBOL character variable is defined as a multibyte Globalization Support variable, the following blank padding and blank stripping rules apply, depending on the external datatype of the variable. See the section &#34;External Datatypes&#39;&#39; in <a class="olink LNPCB" href="../LNPCB/toc.htm"><span class="italic">Pro*COBOL Programmer&#39;s Guide</span></a>.</p>
<p><span class="bold">CHARF.</span> This is the default character type when a multibyte character string is defined. Input data is stripped of any trailing double-byte spaces. However, if a string consists only of double-byte spaces, a single double-byte space is left in the buffer to act as a sentinel.</p>
<p>Output host variables are blank padded with double-byte spaces.</p>
<p><span class="bold">VARCHAR.</span> On input, host variables are <span class="italic">not</span> stripped of trailing double-byte spaces. The length component is assumed to be the length of the data in characters, not bytes.</p>
<p>On output, the host variable is not blank padded at all. The length of the buffer is set to the length of the data in characters, not bytes.</p>
<p><span class="bold">STRING</span>/<span class="bold">LONG VARCHAR.</span> These host variables are not supported for Globalization Support data, since they can only be specified using dynamic SQL or datatype equivalencing, neither of which is supported for Globalization Support data.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE239" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref324"></a>
<h3 class="sect2"><a id="sthref325"></a>Indicator Variables</h3>
<p>You can use indicator variables with multibyte Globalization Support character variables as use you would with any other variable, except column length values are expressed in characters instead of bytes. For a list of possible values, see <a href="ch_four.htm#BABCFFHH">&#34;Using Indicator Variables&#34;</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCBHAA"></a>
<div id="ZZPRE240" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref326"></a>Concurrent Logons</h2>
<p><a id="sthref327"></a><a id="sthref328"></a>The Oracle Precompilers support distributed processing through SQL*Net. Your application can concurrently access any combination of local and remote databases or make multiple connections to the same database. In <a href="#BACHBHFC">Figure 3-2</a>, an application program communicates with one local and three remote Oracle databases. ORA2, ORA3, and ORA4 are simply logical names used in CONNECT statements.</p>
<div id="ZZPRE241" class="figure">
<p class="titleinfigure"><a id="BACHBHFC"></a>Figure 3-2 Connecting through SQL*Net</p>
<img width="536" height="396" src="img/image007.gif" alt="Conneting through SQL Net"/><br/>
<a id="sthref329" href="img_text/image007.htm">Description of &#34;Figure 3-2 Connecting through SQL*Net&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a id="sthref330"></a>B<a id="sthref331"></a>y eliminating the boundaries in a network between different machines and operating systems, SQL*Net provides a distributed processing environment for Oracle tools. This section shows you how the Oracle Precompilers support distributed processing through SQL*Net. You learn how your application can</p>
<ul>
<li>
<p>access other databases directly or indirectly</p>
</li>
<li>
<p>concurrently access any combination of local and remote databases</p>
</li>
<li>
<p>make multiple connections to the same database</p>
</li>
</ul>
<div id="ZZPRE242" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref332"></a>
<h3 class="sect2">Some Preliminaries</h3>
<p><a id="sthref333"></a>T<a id="sthref334"></a>he communicating points in a network are called <span class="italic">nodes</span>. SQL*Net lets you transmit information (SQL statements, data, and status codes) over the network from one node to another.</p>
<p><a id="sthref335"></a>A <span class="italic"><a id="sthref336"></a>protocol</span> is a set of rules for accessing a network. The rules establish such things as procedures for recovering after a failure and formats for transmitting data and checking errors.</p>
<p><a id="sthref337"></a>The SQL*Net syntax for connecting to the default database in the local domain is simply to use the service name for the database.</p>
<p>If the service name is not in the default (local) domain, you must use a global specification (all domains specified). For example:</p>
<pre>HR.US.ORACLE.COM
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE243" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref338"></a>
<h3 class="sect2">Default Databases and Connections</h3>
<p><a id="sthref339"></a> Each node has a <span class="italic">default</span> database. If you specify a node but no database in your <code>CONNECT</code> statement, you connect to the default database on the named local or remote node. If you specify no database and no node, you connect to the default database on the <span class="italic">current</span> node. Although it is unnecessary, you can specify the default database and current node in your <code>CONNECT</code> statement.</p>
<p><a id="sthref340"></a><a id="sthref341"></a>A <span class="italic">default</span> connection is made using a <code>CONNECT</code> statement without an AT clause. The connection can be to any default or nondefault database at any local or remote node. SQL statements without an AT clause are executed against the default connection. Conversely, a <span class="italic">nondefault</span> connection is made by a <code>CONNECT</code> statement that has an AT clause. A SQL statement with an AT clause is executed against the nondefault connection.</p>
<p><a id="sthref342"></a>All database names must be unique, but two or more database names can specify the same connection. That is, you can have multiple connections to any database on any node.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE244" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref343"></a>
<h3 class="sect2">Explicit Logons<a id="sthref344"></a></h3>
<p><a id="sthref345"></a>Usually, you establish a connection to Oracle as follows:</p>
<pre>EXEC SQL CONNECT :userid IDENTIFIED BY :password
</pre>
<p>Or, you might use</p>
<pre>EXEC SQL CONNECT :usr_pwd; 
</pre>
<p>where <span class="italic">usr_pwd</span> contains <span class="italic">username</span>/<span class="italic">password</span>.</p>
<p><a id="sthref346"></a>You can also log on automatically as shown. If you do not specify a database and node, you are connected to the default database at the current node. If you want to connect to a different database, you must explicitly identify that database.</p>
<p>With <span class="italic">explicit logons</span>, you connect to another database directly, giving the connection a name that will be referenced in SQL statements. You can connect to several databases at the same time and to the same database multiple times.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE245" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref347"></a>
<h3 class="sect2">Single<a id="sthref348"></a> Explicit Logons</h3>
<p>In the following example, you connect to a single nondefault database at a remote node:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a class="olink DBSEG50053" href="../DBSEG/app_devs.htm#DBSEG50053"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.</div>
<pre>-- Declare necessary host variables.
EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(10);
 password CHARACTER(10);
 db_string CHARACTER(20);
EXEC SQL END DECLARE SECTION;
set username = &#39;scott&#39;;
set password = &#39;tiger&#39;;
set db_string = &#39;d:newyork-nondef&#39;;
-- Assign a unique name to the database connection.
EXEC SQL DECLARE db_name DATABASE<span class="bold">;</span>
-- Connect to the nondefault database
EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT db_name USING :db_string;
</pre>
<p>The identifiers in this example serve the following purposes:</p>
<ul>
<li>
<p>The host variables <span class="italic">username</span> and <span class="italic">password</span> identify a valid user.</p>
</li>
<li>
<p>The host variable <span class="italic">db_string</span> contains the SQL*Net syntax for logging on to a nondefault database at a remote node using the DECnet protocol.</p>
</li>
<li>
<p>The undeclared identifier <span class="italic">db_name</span> names a nondefault connection; it is an identifier used by Oracle, <span class="italic">not</span> a host or program variable.</p>
</li>
</ul>
<p><a id="sthref349"></a>The <a id="sthref350"></a>USING clause specifies the network, computer, and database to be associated with <span class="italic">db_name</span>. Later, SQL statements using the <a id="sthref351"></a>AT clause (with <span class="italic">db_name</span>) are executed at the database specified by <span class="italic">db_string</span>.</p>
<p>Alternatively, you can use a character host variable in the AT clause, as the following example shows:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(10);
 password CHARACTER(10);
 db_name CHARACTER(10);
 db_string CHARACTER(20);
EXEC SQL END DECLARE SECTION;
set username = &#39;scott&#39;;
set password = &#39;tiger&#39;;
set db_name = &#39;oracle1&#39;;
set db_string = &#39;d:newyork-nondef&#39;;
-- connect to the nondefault database
EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT :db_name USING :db_string;
...
</pre>
<p><a id="sthref352"></a>If <span class="italic">db_name</span> is a host variable, the DECLARE DATABASE statement is not needed. Only if <span class="italic">db_name</span> is an undeclared identifier must you execute a DECLARE <span class="italic">db_name</span> DATABASE statement before executing a CONNECT ... AT <span class="italic">db_name</span> statement.</p>
<p><span class="bold">SQL Operations.</span> If granted the privilege, you can execute any SQL data manipulation statement at the nondefault connection. For example, you might execute the following sequence of statements:</p>
<pre>EXEC SQL AT db_name SELECT ...
EXEC SQL AT db_name INSERT ...
EXEC SQL AT db_name UPDATE ...
</pre>
<p>In the next example, <span class="italic">db_name</span> is a host variable:</p>
<pre>EXEC SQL AT :db_name DELETE ...
</pre>
<p>If <span class="italic">db_name</span> is a host variable, all database tables referenced by the SQL statement must be defined in DECLARE TABLE statements.</p>
<p><span class="bold"><a id="sthref353"></a><a id="sthref354"></a> Cursor Control.</span> <a id="sthref355"></a> Cursor control statements such as OPEN, FETCH, and CLOSE are exceptions--they never use an AT clause. If you want to associate a cursor with an explicitly identified database, use the AT clause in the <a id="sthref356"></a>DECLARE CURSOR statement, as follows:</p>
<pre>EXEC SQL AT :db_name DECLARE emp_cursor CURSOR FOR ...
EXEC SQL OPEN emp_cursor ...
EXEC SQL FETCH emp_cursor ...
EXEC SQL CLOSE emp_cursor;
</pre>
<p>If <span class="italic">db_name</span> is a host variable, its declaration must be within the scope of all SQL statements that refer to the declared cursor. For example, if you open the cursor in one subprogram, then fetch from it in another, you must declare <span class="italic">db_name</span> globally or pass it to each subprogram.</p>
<p>When opening, closing, or fetching from the cursor, you do not use the AT clause. The SQL statements are executed at the database named in the AT clause of the DECLARE CURSOR statement or at the default database if no AT clause is used in the cursor declaration.</p>
<p><a id="sthref357"></a>The AT :<span class="italic">host_variable</span> clause enables change the connection associated with a cursor. However, you cannot change the association while the cursor is open. Consider the following example:</p>
<pre>EXEC SQL AT :db_name DECLARE emp_cursor CURSOR FOR ...
set db_name = &#39;oracle1&#39;;
EXEC SQL OPEN emp_cursor;
EXEC SQL FETCH emp_cursor INTO ...
set db_name = &#39;oracle2&#39;;
EXEC SQL OPEN emp_cursor; -- illegal, cursor still open
EXEC SQL FETCH emp_cursor INTO ...
</pre>
<p><a id="sthref358"></a>This is illegal because <span class="italic">emp_cursor</span> is still open when you try to execute the second OPEN statement. Separate cursors are not maintained for different connections; there is only one <span class="italic">emp_cursor</span>, which must be closed before it can be reopened for another connection. To debug the last example, simply close the cursor before reopening it, as follows:</p>
<pre>EXEC SQL CLOSE emp_cursor; -- close cursor first
set db_name = &#39;oracle2&#39;;
EXEC SQL OPEN emp_cursor;
EXEC SQL FETCH emp_cursor INTO ...
</pre>
<p><span class="bold">Dynamic SQL</span>. Dynamic SQL statements are similar to cursor control statements in that some never use the AT clause. For dynamic SQL Method 1, you must use the AT clause if you want to execute the statement at a nondefault connection. An example follows:</p>
<pre><a id="sthref359"></a>EXEC SQL AT :db_name EXECUTE IMMEDIATE :sql_stmt;
</pre>
<p><a id="sthref360"></a><a id="sthref361"></a>For Methods 2, 3, and 4, you use the AT clause only in the DECLARE STATEMENT statement if you want to execute the statement at a nondefault connection. All other dynamic SQL statements such as PREPARE, DESCRIBE, OPEN, FETCH, and CLOSE never use the AT clause. The next example shows Method 2:</p>
<pre>EXEC SQL AT :db_name DECLARE sql_stmt STATEMENT;
EXEC SQL PREPARE sql_stmt FROM :sql_string;
EXEC SQL EXECUTE sql_stmt;
</pre>
<p>The following example shows Method 3:</p>
<pre>EXEC SQL AT :db_name DECLARE sql_stmt STATEMENT;
EXEC SQL PREPARE sql_stmt FROM :sql_string;
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
EXEC SQL OPEN emp_cursor ...
EXEC SQL FETCH emp_cursor INTO ...
EXEC SQL CLOSE emp_cursor;
</pre>
<p>You need not use the AT clause when connecting to a remote database unless you open two or more connections simultaneously (in which case the AT clause is needed to identify the active connection). To make the default connection to a remote database, use the following syntax:</p>
<pre>EXEC SQL CONNECT :username IDENTIFIED BY :password
 USING :db-string;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE246" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref362"></a>
<h3 class="sect2">Multiple<a id="sthref363"></a><a id="sthref364"></a> Explicit Logons</h3>
<p>You can use the AT <span class="italic">db_name</span> clause for multiple explicit logons, just as you would for a single explicit logon. In the following example, you connect to two nondefault databases <a id="sthref365"></a>concurrently:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(10);
 password CHARACTER(10);
 db_string1 CHARACTER(20);
 db_string2 CHARACTER(20);
EXEC SQL END DECLARE SECTION;
...
set username = &#39;scott&#39;;
set password = &#39;tiger&#39;;
set db_string1 = &#39;New_York&#39;;
set db_string2 = &#39;Boston&#39;;
-- give each database connection a unique name
EXEC SQL DECLARE db_name1 DATABASE;
EXEC SQL DECLARE db_name2 DATABASE;
-- connect to the two nondefault databases
EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT db_name1 USING :db_string1;
EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT db_name2 USING :db_string2;
</pre>
<p>The undeclared identifiers <span class="italic">db_name1</span> and <span class="italic">db_name2</span> are used to name the default databases at the two nondefault nodes so that later SQL statements can refer to the databases by name.</p>
<p>Alternatively, you can use a host variable in the AT clause, as the following example shows:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(10);
 password CHARACTER(10);
 db_name CHARACTER(10);
 db_string CHARACTER(20);
EXEC SQL END DECLARE SECTION;
...
set username = &#39;scott&#39;;
set password = &#39;tiger&#39;;
FOR EACH nondefault database
 -- get next database name and SQL*Net string
 display &#39;Database Name? &#39;;
 read db_name;
 display &#39;SQL*Net String? &#39;;
 read db_string;
 -- connect to the nondefault database
 EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT :db_name USING :db_string;
ENDFOR;
</pre>
<p>You can also use this method to make multiple connections to the same database, as the following example shows:</p>
<pre>set username = &#39;scott&#39;;
set password = &#39;tiger&#39;;
set db_string = &#39;d:newyork-nondef&#39;;
FOR EACH nondefault database
 -- get next database name
 display &#39;Database Name? &#39;;
 read db_name;
 -- connect to the nondefault database
 EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT :db_name USING :db_string;
ENDFOR;
</pre>
<p>You must use different database names for the connections, even if they use the same SQL*Net string.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE247" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref366"></a>
<h3 class="sect2">Implicit<a id="sthref367"></a> Logons</h3>
<p><a id="sthref368"></a>Implicit logons are supported through the Oracle distributed database option, which does not require explicit logons. For example, a distributed query allows a single SELECT statement to access data on one or more nondefault databases.</p>
<p>The distributed query facility depends on database links, which assign a name to a CONNECT statement rather than to the connection itself. At run time, the embedded SELECT statement is executed by the specified Oracle Server, which connects implicitly to the nondefault database(s) to get the required data.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE248" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref369"></a>
<h3 class="sect2">Single<a id="sthref370"></a> Implicit Logons</h3>
<p>In the next example, you connect to a single nondefault database. First, your program executes the following statement to define a <a id="sthref371"></a>database link (database links are usually established interactively by the DBA or user):</p>
<pre>EXEC SQL CREATE DATABASE LINK db_link
 CONNECT TO username IDENTIFIED BY password
 USING &#39;d:newyork-nondef&#39;;
</pre>
<p>Then, the program can query the nondefault EMP table using the database link, as follows:</p>
<pre>EXEC SQL SELECT ENAME, JOB INTO :emp_name, :job_title
 FROM emp@db_link
 WHERE DEPTNO = :dept_number;
</pre>
<p><a id="sthref372"></a>The database link is not related to the database name used in the AT clause of an embedded SQL statement. It simply tells Oracle where the nondefault database is located, the path to it, and the Oracle username and password to use. The database link is stored in the data dictionary until it is explicitly dropped.</p>
<p>In our example, the default Oracle Server logs on to the nondefault database through SQL*Net using the database link <span class="italic">db_link</span>. The query is submitted to the default server, but is &#34;forwarded&#34; to the nondefault database for execution.</p>
<p><a id="sthref373"></a>To make referencing the database link easier, you can create a synonym as follows (again, this is usually done interactively):</p>
<pre>EXEC SQL CREATE SYNONYM emp FOR emp@db_link;
</pre>
<p>Then, your program can query the nondefault EMP table, as follows:</p>
<pre>EXEC SQL SELECT ENAME, JOB INTO :emp_name, :job_title
 FROM emp
 WHERE DEPTNO = :dept_number;
</pre>
<p><a id="sthref374"></a>This provides location transparency for <span class="italic">emp</span>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE249" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref375"></a>
<h3 class="sect2">Multiple<a id="sthref376"></a> Implicit Logons</h3>
<p>In the following example, you connect to two nondefault databases concurrently. First, you execute the following sequence of statements to define two database links and create two synonyms:</p>
<pre>EXEC SQL CREATE DATABASE LINK db_link1
 CONNECT TO username1 IDENTIFIED BY password1
 USING &#39;d:newyork-nondef&#39;;
EXEC SQL CREATE DATABASE LINK db_link2
 CONNECT TO username2 IDENTIFIED BY password2
 USING &#39;d:chicago-nondef&#39;;
EXEC SQL CREATE SYNONYM emp FOR emp@db_link1;
EXEC SQL CREATE SYNONYM dept FOR dept@db_link2;
</pre>
<p>Then, your program can query the nondefault EMP and DEPT tables, as follows:</p>
<pre>EXEC SQL SELECT ENAME, JOB, SAL, LOC
 FROM emp, dept
 WHERE emp.DEPTNO = dept.DEPTNO AND DEPTNO = :dept_number;
</pre>
<p>Oracle executes the query by performing a join between the nondefault EMP table at <span class="italic">db_link1</span> and the nondefault DEPT table at <span class="italic">db_link2</span>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCBJGA"></a>
<div id="ZZPRE250" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Embedding OCI (<a id="sthref377"></a>Oracle Call Interface) Calls</h2>
<p><a id="sthref378"></a><a id="sthref379"></a>The <a id="sthref380"></a>Oracle Precompilers let you embed OCI calls in your host program. Just take the following steps:</p>
<ol>
<li>
<p>Declare the OCI Logon Data Area (<a id="sthref381"></a>LDA) outside the Declare Section.</p>
</li>
<li>
<p>Connect to Oracle using the embedded SQL statement <code>CONNECT</code>, not the OCI call <code>OLOG</code>.</p>
</li>
<li>
<p>Call the Oracle run-time library routine <code>SQLLDA</code> to store the connect information in the LDA.</p>
</li>
</ol>
<p>That way, the Oracle Precompiler and the OCI &#34;know&#34; that they are working together. However, there is no sharing of Oracle cursors.</p>
<p>You need not worry about declaring the OCI Host Data Area (HDA) because the Oracle run-time library manages connections and maintains the HDA for you.</p>
<div id="ZZPRE251" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref382"></a>
<h3 class="sect2">Setting Up the LDA<a id="sthref383"></a></h3>
<p><a id="sthref384"></a>You set up the LDA by issuing the OCI call</p>
<pre>SQLLDA(lda);
</pre>
<p>where <span class="italic">lda</span> identifies the LDA data structure. The format of this call is language-dependent. If the <code>CONNECT</code> statement fails, the <span class="italic">lda_rc</span> field in the <span class="italic">lda</span> is set to 1012 to indicate the error.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE252" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref385"></a>
<h3 class="sect2">Remote and Multiple Connections</h3>
<p>A call to SQLLDA sets up an LDA for the connection used by the most recently executed SQL statement. To set up the different LDAs needed for additional connections, just call SQLLDA with a different <span class="italic">lda</span> after each <code>CONNECT</code>. In the following example, you connect to two nondefault databases concurrently:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(10);
 password CHARACTER(10);
 db_string1 CHARACTER(20);
 db_string2 CHARACTER(20);
EXEC SQL END DECLARE SECTION;
lda1 INTEGER(32);
lda2 INTEGER(32);
set username = &#39;SCOTT&#39;;
set password = &#39;TIGER&#39;;
set db_string1 = &#39;D:NEWYORK-NONDEF1&#39;;
set db_string2 = &#39;D:CHICAGO-NONDEF2&#39;;
-- give each database connection a unique name
EXEC SQL DECLARE db_name1 DATABASE;
EXEC SQL DECLARE db_name2 DATABASE;
-- connect to first nondefault database
EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT db_name1 USING :db_string1;
-- set up first LDA for OCI use
SQLLDA(lda1);
-- connect to second nondefault database
EXEC SQL CONNECT :username IDENTIFIED BY :password
 AT db_name2 USING :db_string2;
-- set up second LDA for OCI use
SQLLDA(lda2);
</pre>
<p>Remember, do not declare <span class="italic">db_name1</span> and <span class="italic">db_name2</span> in the Declare Section because they are not host variables. You use them only to name the default databases at the two nondefault nodes so that later SQL statements can refer to the databases by name.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHCFEE"></a>
<div id="ZZPRE253" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Developing <a id="sthref386"></a>X/Open Applications</h2>
<p>X/Open applications run in a distributed transaction processing (<a id="sthref387"></a>DTP) environment. In an abstract model, an X/Open application calls on <span class="italic"><a id="sthref388"></a>resource managers</span> (RMs) to provide a variety of services. For example, a database resource manager provides access to data in a database. Resource managers interact with a <span class="italic">transaction manager</span> (TM), which controls all transactions for the application.</p>
<p><a id="sthref389"></a><a href="#BACEECHH">Figure 3-3</a> shows one way that components of the DTP model can interact to provide efficient access to data in an Oracle database. The DTP model specifies the <span class="italic">XA interface</span> between resource managers and the transaction manager. Oracle supplies an <a id="sthref390"></a>XA<a id="sthref391"></a>-compliant library, which you must link to your X/Open application. Also, you must specify the <a id="sthref392"></a><span class="italic">native interface<a id="sthref393"></a></span> between your application program and the resource managers.</p>
<div id="ZZPRE254" class="figure">
<p class="titleinfigure"><a id="BACEECHH"></a>Figure 3-3 Hypothetical DTP Model</p>
<img width="536" height="421" src="img/image008.gif" alt="Hypothetical DTP Model"/><br/>
<a id="sthref394" href="img_text/image008.htm">Description of &#34;Figure 3-3 Hypothetical DTP Model&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The DTP model that specifies how a transaction manager and resource managers interact with an application program is described in the X/Open guide <span class="italic">Distributed Transaction Processing Reference Model</span> and related publications, which you can obtain by writing to</p>
<p>X/Open Company Ltd.1010 El Camino Real, Suite 380Menlo Park, CA 94025</p>
<p>For instructions on using the XA interface, see your Transaction Processing (TP) Monitor user&#39;s guide.</p>
<div id="ZZPRE255" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref395"></a>
<h3 class="sect2">Oracle-Specific Issues</h3>
<p>You can use the Oracle Precompilers to develop applications that comply with the X/Open standards. However, you must meet the following requirements.</p>
</div>
<!-- class="sect2" -->
<a id="CIHDFJBD"></a>
<div id="ZZPRE256" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Connecting to Oracle</h3>
<p>The X/Open application does not establish and maintain connections to a database. Instead, the transaction manager and the XA interface, which is supplied by Oracle, handle database connections and disconnections transparently. So, normally an X/Open-compliant application does not execute <code>CONNECT</code> statements.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE257" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref396"></a>
<h3 class="sect2">Transaction Control</h3>
<p>The X/Open application must not execute statements such as <code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code>, and <code>SET</code> <code>TRANSACTION</code> that affect the state of global transactions. For example, the application must not execute the <code>COMMIT</code> statement because the transaction manager handles commits. Also, the application must not execute SQL data definition statements such as <code>CREATE</code>, <code>ALTER</code>, and <code>RENAME</code> because they issue an implicit commit.</p>
<p>The application can execute an internal <code>ROLLBACK</code> statement if it detects an error that prevents further SQL operations. However, this might change in later versions of the XA interface.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE258" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref397"></a>
<h3 class="sect2">OCI Calls</h3>
<p>If you want your X/Open application to issue OCI calls, you must use the run-time library routine SQLLD2, which sets up an LDA for a specified connection established through the XA interface. For a description of the SQLLD2 call, see the <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a>. Note that OCOM, OCON, OCOF, ORLON, OLON, OLOG, and OLOGOF cannot be issued by an X/Open application.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE259" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref398"></a>
<h3 class="sect2">Linking</h3>
<p>To get XA functionality, you must link the XA library to your X/Open application object modules. For instructions, see your system-specific Oracle manuals.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3238">
<tr>
<td class="cellalignment3247">
<table class="cellalignment3243">
<tr>
<td class="cellalignment3242"><a href="ch_two.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3242"><a href="ch_four.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3249">
<table class="cellalignment3241">
<tr>
<td class="cellalignment3242"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3242"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3242"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3242"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3242"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3242"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>