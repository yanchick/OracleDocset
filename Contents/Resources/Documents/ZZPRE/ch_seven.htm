<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114756"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Defining%20and%20Controlling%20Transactions"></a><title>Defining and Controlling Transactions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T18:44:39Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Programmer&#39;s Guide to the Oracle Precompilers"/>
<meta name="dcterms.identifier" content="E53283-01"/>
<meta name="dcterms.isVersionOf" content="ZZPRE"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ch_six.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch_eight.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53283-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/20</span> <!-- End Header -->
<div id="ZZPRE734" class="chapter"><a id="BABIFBDG"></a>
<h1 class="chapter"><span class="secnum">7</span> Defining and Controlling Transactions</h1>
<p>This chapter explains how to perform transaction processing. You learn the basic techniques that safeguard the consistency of your database, including how to control whether changes to Oracle data are made permanent or undone. The following topics are discussed:</p>
<ul>
<li>
<p><a href="#CEGFDHFE">Some Terms You Should Know</a></p>
</li>
<li>
<p><a href="#CEGECIDB">How Transactions Guard Your Database</a></p>
</li>
<li>
<p><a href="#CEGBGJJH">How to Begin and End Transactions</a></p>
</li>
<li>
<p><a href="#CEGFHGBG">Using the COMMIT Statement</a></p>
</li>
<li>
<p><a href="#CEGBHDED">Using the ROLLBACK Statement</a></p>
</li>
<li>
<p><a href="#CEGEDHDG">Using the SAVEPOINT Statement</a></p>
</li>
<li>
<p><a href="#CEGBFCBC">Using the RELEASE Option</a></p>
</li>
<li>
<p><a href="#CEGGBFAG">Using the SET TRANSACTION Statement</a></p>
</li>
<li>
<p><a href="#CEGFFGGH">Overriding Default Locking</a></p>
</li>
<li>
<p><a href="#CEGHDABA">Fetching Across Commits</a></p>
</li>
<li>
<p><a href="#CEGIIABG">Handling Distributed Transactions</a></p>
</li>
<li>
<p><a href="#CEGGCFHJ">Guidelines</a></p>
</li>
</ul>
<a id="CEGFDHFE"></a>
<div id="ZZPRE735" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Some Terms You Should Know</h2>
<p>Before delving into the subject of transactions, you should know the terms defined in this section.</p>
<p>The jobs or tasks that Oracle manages are called <span class="italic">sessions</span>. A <span class="italic"><a id="sthref885"></a>user <a id="sthref886"></a>session</span> is started when you run an application program or a tool such as Oracle Forms and connect to Oracle. Oracle allows user sessions to work &#34;simultaneously&#34; and share computer resources. To do this, Oracle must control <a id="sthref887"></a><span class="italic">concurrency</span>, which means many user accessing the same data. Without adequate concurrency controls, there might be a loss of <span class="italic">data integrity</span><a id="sthref888"></a>. That is, changes to data or structures might be made incorrectly.</p>
<p><a id="sthref889"></a>Oracle uses <span class="italic">locks</span> to control concurrent access to data. A lock gives you temporary ownership of a database resource such as a table or row of data. Thus, data cannot be changed by other users until you finish with it. You need never explicitly lock a resource, because default locking mechanisms protect Oracle data and structures. However, you can request <span class="italic">data locks</span> on tables or rows when it is to your advantage to override default locking. You can choose from several <a id="sthref890"></a><span class="italic">modes</span> of locking such as <span class="italic">row share</span> and <span class="italic">exclusive</span>.</p>
<p>A <span class="italic">deadlock</span><a id="sthref891"></a> can occur when two or more users try to access the same database object. For example, two users updating the same table might wait if each tries to update a row currently locked by the other. Because each user is waiting for resources held by another user, neither can continue until Oracle breaks the deadlock. Oracle signals an error to the participating transaction that had completed the least amount of work, and the &#34;deadlock detected while waiting for resource&#34; Oracle error code is returned to SQLCODE in the SQLCA.</p>
<p>When a table is being queried by one user and updated by another at the same time, Oracle generates a <span class="italic">read-consistent</span> view of the table&#39;s data for the query. That is, after a query begins and as it proceeds, the data read by the query does not change. As update activity continues, Oracle takes <span class="italic"><a id="sthref892"></a>snapshots</span> of the table&#39;s data and records changes in a <span class="italic"><a id="sthref893"></a>rollback segment</span>. Oracle uses information in the rollback segment to build <a id="sthref894"></a>read-consistent query results and to undo changes if necessary.</p>
</div>
<!-- class="sect1" -->
<a id="CEGECIDB"></a>
<div id="ZZPRE736" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">How Transactions Guard Your Database</h2>
<p>Oracle is transaction oriented; that is, it uses transactions to ensure data integrity. A <a id="sthref895"></a>transaction is a series of one or more logically related SQL statements you define to accomplish some task. Oracle treats the series of SQL statements as a unit so that all the changes brought about by the statements are either <span class="italic">committed</span> (made permanent) or <a id="sthref896"></a><span class="italic">rolled back</span> (undone) at the same time. If your application program fails in the middle of a transaction, the database is automatically restored to its former (pre-transaction) state.</p>
<p><a id="sthref897"></a>The <a id="sthref898"></a>subsequent sections show you how to define and control transactions. Specifically, you learn how to</p>
<ul>
<li>
<p>Begin and end transactions</p>
</li>
<li>
<p>Use the <code>COMMIT</code> statement to make transactions permanent</p>
</li>
<li>
<p>Use the <code>SAVEPOINT</code> statement with the <code>ROLLBACK</code> <code>TO</code> statement to undo parts of transactions</p>
</li>
<li>
<p>Use the <code>ROLLBACK</code> statement to undo whole transactions</p>
</li>
<li>
<p>Specify the <code>RELEASE</code> option to free resources and log off the database</p>
</li>
<li>
<p>Use the <code>SET</code> <code>TRANSACTION</code> statement to set read-only transactions</p>
</li>
<li>
<p>Use the <code>FOR</code> <code>UPDATE</code> clause or <code>LOCK</code> <code>TABLE</code> statement to override default locking</p>
</li>
</ul>
<p>For details about the SQL statements discussed in this chapter, see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="CEGBGJJH"></a>
<div id="ZZPRE737" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">How to Begin and End Transactions</h2>
<p><a id="sthref899"></a><a id="sthref900"></a>You begin a transaction with the first executable SQL statement (other than <code>CONNECT</code>) in your program. When one transaction ends, the next executable SQL statement automatically begins another transaction. Thus, every executable statement is part of a transaction. Because they cannot be rolled back and need not be committed, <a id="sthref901"></a>declarative SQL statements are not considered part of a transaction.</p>
<p><a id="sthref902"></a>You end a transaction in one of the following ways:</p>
<ul>
<li>
<p><a id="sthref903"></a>Code a <code>COMMIT</code> or <code>ROLLBACK</code> statement, with or without the <code>RELEASE</code> option. This <span class="italic">explicitly</span> makes permanent or undoes changes to the database.</p>
</li>
<li>
<p>Code a data definition statement (<code>ALTER</code>, <code>CREATE</code>, or <code>GRANT</code>, for example) that issues an <a id="sthref904"></a>automatic commit before <span class="italic">and</span> after executing. This <span class="italic">implicitly</span> makes permanent changes to the database.</p>
</li>
</ul>
<p><a id="sthref905"></a>A transaction also ends when there is a system failure or your user session stops unexpectedly because of software problems, hardware problems, or a forced interruption. Oracle rolls back the transaction.</p>
<p><a id="sthref906"></a>If your program fails in the middle of a transaction, Oracle detects the error and rolls back the transaction. If your operating system fails, Oracle restores the database to its former (pre-transaction) state.</p>
</div>
<!-- class="sect1" -->
<a id="CEGFHGBG"></a>
<div id="ZZPRE738" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the COMMIT Statement</h2>
<p><a id="sthref907"></a>You use the <code>COMMIT</code> statement to make changes to the database permanent. Until changes are committed, other users cannot access the changed data; they see it as it <a id="sthref908"></a>was before your transaction began. The <code>COMMIT</code> statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the <code>COMMIT</code> statement</p>
<ul>
<li>
<p><a id="sthref909"></a>Makes permanent all changes made to the database during the current transaction</p>
</li>
<li>
<p>Makes these changes visible to other users</p>
</li>
<li>
<p>Erases all savepoints (refer to <a href="#CEGBHDED">Using the ROLLBACK Statement</a>)</p>
</li>
<li>
<p>Releases all row and table locks, but not parse locks</p>
</li>
<li>
<p>Closes cursors referenced in a CURRENT OF clause or, when <code>MODE={ANSI13|ORACLE}</code>, closes <span class="italic">all</span> explicit cursors</p>
</li>
<li>
<p>Ends the transaction</p>
</li>
</ul>
<p>When <code>MODE={ANSI13|ORACLE}</code>, explicit cursors not referenced in a <code>CURRENT OF</code> clause remain open across commits. This can boost performance. For an example, refer to <a href="#CEGHDABA">&#34;Fetching Across Commits&#34;</a>.</p>
<p>Because they are part of normal processing, <code>COMMIT</code> statements should be placed inline, on the main path through your program. Before your program terminates, it must explicitly commit pending changes. Otherwise, Oracle rolls them back. In the following example, you commit your transaction and disconnect from Oracle:</p>
<pre><a id="sthref910"></a>EXEC SQL COMMIT WORK RELEASE;
</pre>
<p>The optional keyword WORK provides ANSI compatibility. The <a id="sthref911"></a><a id="sthref912"></a>RELEASE option frees all Oracle resources (locks and cursors) held by your program and logs off the database.</p>
<p><a id="sthref913"></a>You need not follow a data definition statement with a COMMIT statement because data definition statements issue an automatic commit before <span class="italic">and</span> after executing. So, whether they succeed or fail, the prior transaction is committed.</p>
</div>
<!-- class="sect1" -->
<a id="CEGBHDED"></a>
<div id="ZZPRE739" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the <a id="sthref914"></a>ROLLBACK Statement</h2>
<p><a id="sthref915"></a>You use the <code>ROLLBACK</code> statement to undo pending changes made to the database. For example, if you make a mistake such as deleting the wrong row from a table, you can use <code>ROLLBACK</code> to restore the original data. The <a id="sthref916"></a><code>ROLLBACK</code> statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the <code>ROLLBACK</code> statement</p>
<ul>
<li>
<p>Undoes all changes made to the database during the current transaction</p>
</li>
<li>
<p>Erases all savepoints</p>
</li>
<li>
<p>Ends The Transaction</p>
</li>
<li>
<p>Releases All Row And Table Locks, But Not Parse Locks</p>
</li>
<li>
<p>Closes cursors referenced in a CURRENT OF clause or, when <code>MODE={ANSI|ANSI14}</code>, closes <span class="italic">all</span> explicit cursors</p>
</li>
</ul>
<p>When <code>MODE={ANSI13|ORACLE}</code>, explicit cursors not referenced in a <code>CURRENT OF</code> clause remain open across rollbacks.</p>
<p><a id="sthref917"></a>Because they are part of exception processing, <code>ROLLBACK</code> statements should be placed in error handling routines, off the main path through your program. In the following <a id="sthref918"></a>example, you roll back your transaction and disconnect from Oracle:</p>
<pre>EXEC SQL ROLLBACK WORK RELEASE;
</pre>
<p><a id="sthref919"></a>The optional keyword <code>WORK</code> provides ANSI compatibility. The <a id="sthref920"></a><code>RELEASE</code> option frees all resources held by your program and logs off the database.</p>
<p>If a <code>WHENEVER</code> SQLERROR <code>GOTO</code> statement branches to an error handling routine that includes a <code>ROLLBACK</code> statement, your program might enter an infinite loop if the rollback fails with an error. You can avoid this by coding <code>WHENEVER</code> SQLERROR <code>CONTINUE</code> before the <code>ROLLBACK</code> statement.</p>
<p><a id="sthref921"></a>For example, consider the following:</p>
<pre><a id="sthref922"></a>EXEC SQL WHENEVER SQLERROR GOTO sql_error;
FOR EACH new employee
 display &#39;Employee number? &#39;;
 read emp_number;
 display &#39;Employee name? &#39;;
 read emp_name;
 EXEC SQL INSERT INTO EMP (EMPNO, ENAME)
 VALUES (:emp_number, :emp_name);
ENDFOR;
...
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display &#39;Processing error&#39;;
 exit program with an error;
</pre>
<p><a id="sthref923"></a><a id="sthref924"></a>Oracle rolls back transactions if your program terminates abnormally.</p>
<div id="ZZPRE740" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref925"></a>
<h3 class="sect2"><a id="sthref926"></a><a id="sthref927"></a>Statement-Level Rollbacks</h3>
<p>Before executing any SQL statement, Oracle marks an implicit savepoint (not available to you). Then, if the statement fails, Oracle rolls it back automatically and returns the applicable error code to SQLCODE in the SQLCA. For example, if an INSERT statement causes an error by trying to insert a duplicate value in a unique index, the statement is rolled back.</p>
<p>Only work started by the failed SQL statement is lost; work done before that statement in the current transaction is kept. Thus, if a data definition statement fails, the automatic commit that precedes it is not undone.</p>
<p>Note that before executing a SQL statement, Oracle must parse it, that is, examine it to make sure it follows syntax rules and refers to valid database objects. Errors detected while executing a SQL statement cause a rollback, but errors detected while parsing the statement do not.</p>
<p><a id="sthref928"></a>Oracle can also roll back single SQL statements to break deadlocks. <a id="sthref929"></a>Oracle signals an error to one of the participating transactions and rolls back the current statement in that transaction.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGEDHDG"></a>
<div id="ZZPRE741" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the <a id="sthref930"></a>SAVEPOINT Statement</h2>
<p><a id="sthref931"></a>You use the <code>SAVEPOINT</code> statement to mark and name the current point in the processing of a transaction. Each marked point is called a <span class="italic">savepoint</span>. For <a id="sthref932"></a>example, the following statement marks a savepoint named <span class="italic">start_delete</span>:</p>
<pre>EXEC SQL SAVEPOINT start_delete;
</pre>
<p><a id="sthref933"></a>Savepoints let you divide long transactions, giving you more control over complex procedures. For example, if a transaction performs several functions, you can mark a savepoint before each function. Then, if a function fails, you can easily restore the Oracle data to its former state, recover, then reexecute the function.</p>
<p><a id="sthref934"></a><a id="sthref935"></a>To undo part of a transaction, you use savepoints with the <code>ROLLBACK</code> statement and its <a id="sthref936"></a>T<code>O SAVEPOINT</code> clause. The <code>TO SAVEPOINT</code> clause lets you roll back to an intermediate statement in the current transaction, so you do not have to undo all your changes. Specifically, the <code>ROLLBACK TO SAVEPOINT</code> statement</p>
<ul>
<li>
<p>Undoes changes made to the database since the specified savepoint was marked</p>
</li>
<li>
<p>Erases all savepoints marked after the specified savepoint</p>
</li>
<li>
<p>Releases all row and table locks acquired since the specified savepoint was marked</p>
</li>
</ul>
<p>In the example, you access the table <code>MAIL_LIST</code> to insert new listings, update old <a id="sthref937"></a>listings, and delete (a few) inactive listings. After the delete, you check SQLERRD(3) in the SQLCA for the number of rows deleted. If the number is unexpectedly large, you roll back to the savepoint <span class="italic">start_delete</span>, undoing just the delete.</p>
<pre>FOR EACH new customer
 display &#39;Customer number? &#39;;
 read cust_number;
 display &#39;Customer name? &#39;;
 read cust_name;
EXEC SQL INSERT INTO MAIL_LIST (CUSTNO, CNAME, STAT)
 VALUES (:cust_number, :cust_name, &#39;ACTIVE&#39;);
ENDFOR;
FOR EACH revised status
 display &#39;Customer number? &#39;;
 read cust_number;
 display &#39;New status? &#39;;
 read new_status;
 EXEC SQL UPDATE MAIL_LIST
 SET STAT = :new_status WHERE CUSTNO = :cust_number;
ENDFOR;
-- mark savepoint
EXEC SQL SAVEPOINT start_delete;
EXEC SQL DELETE FROM MAIL_LIST WHERE STAT = &#39;INACTIVE&#39;;
IF sqlca.sqlerrd(3) &lt; 25 THEN -- check number of rows deleted
 display &#39;Number of rows deleted is &#39;, sqlca.sqlerrd(3);
ELSE
 display &#39;Undoing deletion of &#39;, sqlca.sqlerrd(3), &#39; rows&#39;;
 EXEC SQL WHENEVER SQLERROR GOTO sql_error;
 EXEC SQL ROLLBACK TO SAVEPOINT start_delete;
ENDIF;
EXEC SQL WHENEVER SQLERROR CONTINUE;
EXEC SQL COMMIT WORK RELEASE;
exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display &#39;Processing error&#39;;
 exit program with an error;
</pre>
<p><a id="sthref938"></a><a id="sthref939"></a>Note that you cannot specify the <code>RELEASE</code> option in a <code>ROLLBACK TO SAVEPOINT</code> statement.</p>
<p><a id="sthref940"></a>Rolling back to a savepoint erases any savepoints marked after that savepoint. The savepoint to which you roll back, however, is not erased. For example, if you mark five savepoints, then roll back to the third, only the fourth and fifth are erased. A <code>COMMIT</code> or <code>ROLLBACK</code> statement erases all savepoints.</p>
<p>By default, the number of active savepoints in each user session is limited to 5. An <span class="italic">active</span> savepoint is one that you marked since the last commit or rollback. Your Database Administrator (DBA) can raise the limit by increasing the value of the Oracle <a id="sthref941"></a>initialization parameter <code>SAVEPOINTS</code>. If you give two savepoints the same name, the earlier savepoint is erased.</p>
</div>
<!-- class="sect1" -->
<a id="CEGBFCBC"></a>
<div id="ZZPRE742" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the <a id="sthref942"></a>RELEASE Option</h2>
<p>Oracle rolls back changes automatically if your program terminates abnormally. Abnormal termination occurs when your program does not explicitly commit or roll back work and disconnect from Oracle using the RELEASE option.</p>
<p>Normal termination occurs when your program runs its course, closes open cursors, <a id="sthref943"></a>explicitly commits or rolls back work, disconnects from Oracle, and returns control to the user. Your program will exit gracefully if the last SQL statement it executes is either</p>
<pre>EXEC SQL COMMIT RELEASE;
</pre>
<p>or</p>
<pre>EXEC SQL ROLLBACK RELEASE;
</pre>
<p><a id="sthref944"></a>Otherwise, locks and cursors acquired by your user session are held after program termination until Oracle recognizes that the user session is no longer active. This might cause other users in a multiuser environment to wait longer than necessary for the locked resources.</p>
</div>
<!-- class="sect1" -->
<a id="CEGGBFAG"></a>
<div id="ZZPRE743" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the <a id="sthref945"></a>SET TRANSACTION Statement</h2>
<p>You use the <code>SET TRANSACTION</code> statement to begin a read-only or read/write transaction, or to assign your current transaction to a specified rollback segment. A <code>COMMIT</code>, <code>ROLLBACK</code>, or data definition statement ends a read-only transaction.</p>
<p><a id="sthref946"></a>Because they allow &#34;repeatable reads,&#34; read-only transactions are useful for running multiple queries against one or more tables while other users update the same tables. <a id="sthref947"></a>During a read-only transaction, all queries refer to the same snapshot of the database, providing a multitable, multiquery, read-consistent view. Other users can continue to query or update data as usual. An <a id="sthref948"></a>example of the <code>SET TRANSACTION</code> statement follows:</p>
<pre>EXEC SQL SET TRANSACTION READ ONLY;
</pre>
<p><a id="sthref949"></a><a id="sthref950"></a>The <code>SET TRANSACTION</code> statement must be the first SQL statement in a read-only transaction and can appear only once in a transaction. The <a id="sthref951"></a><code>READ ONLY</code> parameter is <a id="sthref952"></a>required. Its use does not affect other transactions. Only the <code>SELECT</code> (without <code>FOR</code> <code>UPDATE</code>), <code>LOCK TABLE</code>, <code>SET ROLE</code>, <code>ALTER SESSION</code>, <code>ALTER SYSTEM</code>, <code>COMMIT</code>, and <code>ROLLBACK</code> statements are allowed in a read-only transaction.</p>
<p>In the <a id="sthref953"></a>example, as a store manager, you check sales activity for the day, the past week, and the past month by using a read-only transaction to generate a summary report. The report is unaffected by other users updating the database during the transaction.</p>
<pre>EXEC SQL SET TRANSACTION READ ONLY; 
 EXEC SQL SELECT SUM(SALEAMT) INTO :daily FROM SALES 
 WHERE SALEDATE = SYSDATE; 
 EXEC SQL SELECT SUM(SALEAMT) INTO :weekly FROM SALES 
 WHERE SALEDATE &gt; SYSDATE - 7; 
 EXEC SQL SELECT SUM(SALEAMT) INTO :monthly FROM SALES 
 WHERE SALEDATE &gt; SYSDATE - 30; 
 EXEC SQL COMMIT WORK; 
-- simply ends the transaction since there are no changes 
-- to make permanent 
-- format and print report
</pre></div>
<!-- class="sect1" -->
<a id="CEGFFGGH"></a>
<div id="ZZPRE744" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overriding Default Locking</h2>
<p><a id="sthref954"></a>By default, Oracle <a id="sthref955"></a>implicitly (automatically) locks many data structures for you. However, you can request specific data locks on rows or tables when it is to your advantage to override default locking. Explicit locking lets you share or deny access to a table for the duration of a transaction or ensure multitable and multiquery read consistency.</p>
<p>With the <code>SELECT FOR UPDATE OF</code> statement, you can explicitly lock specific rows of a table to make sure they do not change before an update or delete is executed. However, Oracle automatically obtains row-level locks at update or delete time. So, use the <code>FOR UPDATE OF</code> clause only if you want to lock the rows <span class="italic">before</span> the update or delete.</p>
<p>You can explicitly lock entire tables using the <code>LOCK TABLE</code> statement.</p>
<a id="BABCGADJ"></a>
<div id="ZZPRE745" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the FOR UPDATE OF Clause</h3>
<p><a id="sthref956"></a>When you <code>DECLARE</code> a cursor that is referenced in the <code>CURRENT</code> <code>OF</code> clause of an <code>UPDATE</code> or <code>DELETE</code> statement, you use the FOR UPDATE OF clause to acquire <a id="sthref957"></a>exclusive row locks. <code>SELECT FOR UPDATE OF</code> identifies the rows that will be updated or deleted, then locks each row in the active set. (All rows are locked at the open, not as they are fetched.) This is useful, for example, when you want to base an update on the existing values in a row. You must make sure the row is not changed by another user before your update.</p>
<p>The <code>FOR UPDATE OF</code> clause is optional. For instance, instead of</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20 
 FOR UPDATE OF SAL;
</pre>
<p>you can drop the <code>FOR UPDATE OF</code> clause and simply code</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20;
</pre>
<p>The <code>CURRENT OF</code> clause signals the precompiler to add a FOR UPDATE clause if necessary. You use the <code>CURRENT OF</code> clause to refer to the latest row fetched from a cursor.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE746" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref958"></a>
<h3 class="sect2">Restrictions</h3>
<p>If you use the <code><a id="sthref959"></a>FOR UPDATE OF</code> clause, you cannot reference multiple tables. Also, an <a id="sthref960"></a><a id="sthref961"></a>explicit <code>FOR UPDATE OF</code> or an implicit <code>FOR UPDATE</code> acquires exclusive row locks. Row locks are released when you commit or rollback (except when you rollback to a savepoint). If you try to fetch from a <code>FOR UPDATE</code> cursor after a commit, Oracle generates the following error:</p>
<pre>ORA-01002: fetch out of sequence
</pre></div>
<!-- class="sect2" -->
<a id="BABGBEFC"></a>
<div id="ZZPRE747" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the <a id="sthref962"></a>LOCK TABLE Statement</h3>
<p><a id="sthref963"></a>You<a id="sthref964"></a><a id="sthref965"></a> use the <code>LOCK TABLE</code> statement to lock one or more tables in a specified lock mode. For example, the statement locks the EMP table in <span class="italic">row share</span> mode. Row share locks allow concurrent access to a table; they prevent other users from locking the entire table for exclusive use.</p>
<pre>EXEC SQL LOCK TABLE EMP IN ROW SHARE MODE NOWAIT;
</pre>
<p>The lock mode determines what other locks can be placed on the table. For <a id="sthref966"></a>example, <a id="sthref967"></a>many users can acquire row share locks on a table at the same time, but only one user at a time can acquire an <span class="italic">exclusive</span> lock. While one user has an exclusive lock on a table, no other users can insert, update, or delete rows in that table. For more information about lock modes, see the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>.</p>
<p><a id="sthref968"></a>The optional keyword <a id="sthref969"></a>NOWAIT<a id="sthref970"></a> tells Oracle not to wait for a table if it has been locked by another user. Control is immediately returned to your program, so it can do other work before trying again to acquire the lock. (You can check SQLCODE in the SQLCA to see if the table lock failed.) If you omit <code>NOWAIT</code>, Oracle waits until the table is available; the wait has no set limit.</p>
<p><a id="sthref971"></a>A table lock never keeps other users from querying a table, and a query never acquires a table lock. So, a query never blocks another query or an update, and an update never blocks a query. Only if two different transactions try to update the same row will one transaction wait for the other to complete. Table locks are released when your transaction issues a commit or rollback.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGHDABA"></a>
<div id="ZZPRE748" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Fetching Across Commits</h2>
<p><a id="sthref972"></a>If you want to intermix commits and fetches, do not use the <code>CURRENT OF</code> clause. Instead, select the rowid of each row, then use that value to identify the current row during the update or delete. Consider the following example:</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR
 SELECT ENAME, SAL, ROWID FROM EMP WHERE JOB = &#39;CLERK&#39;;
...
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND GOTO ...
LOOP
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary, :row_id;
 ... 
 EXEC SQL UPDATE EMP SET SAL = :new_salary
 WHERE ROWID = :row_id;
 EXEC SQL COMMIT;
ENDLOOP;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The fetched rows are <span class="italic">not</span> locked. So, you might get inconsistent results if another user modifies a row after you read it but before you update or delete it.</div>
</div>
<!-- class="sect1" -->
<a id="CEGIIABG"></a>
<div id="ZZPRE749" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Handling Distributed Transactions</h2>
<p>A <span class="italic">distributed database</span> is a single logical database comprising multiple physical databases at different nodes. A <span class="italic">distributed statement</span> is any SQL statement that accesses a remote node using a database link. A <span class="italic">distributed transaction</span> includes at least one distributed statement that updates data at multiple nodes of a distributed database. If the update affects only one node, the transaction is non-distributed.</p>
<p><a id="sthref973"></a>When you issue a commit, changes to each database affected by the distributed transaction are made permanent. If you issue a rollback instead, all the changes are undone. However, if a network or computer fails during the commit or rollback, the state of the distributed transaction might be unknown or <a id="sthref974"></a><span class="italic">in doubt</span>. In such cases, if you have F<code>ORCE TRANSACTION</code> system privileges, you can manually commit or roll back the transaction at your local database by using the <code>FORCE</code> clause. The transaction must be identified by a quoted literal containing the transaction ID, which can be found in the data dictionary view <code>DBA_2PC_PENDING</code>. Some examples follow:</p>
<pre>EXEC SQL COMMIT FORCE &#39;22.31.83&#39;;
...
EXEC SQL ROLLBACK FORCE &#39;25.33.86&#39;;
</pre>
<p><code>FORCE</code> commits or rolls back only the specified transaction and does not affect your current transaction. Note that you cannot manually roll back in-doubt transactions to a savepoint.</p>
<p>The <code>COMMENT</code> clause in the <code>COMMIT</code> statement lets you specify a comment to be associated with a distributed transaction. If ever the transaction is in doubt, Oracle stores the text specified by <code>COMMENT</code> in the data dictionary view <code>DBA_2PC_PENDING</code> along with the transaction ID. The text must be a quoted literal &lt;= 50 characters in length. An example follows:</p>
<pre>EXEC SQL COMMIT COMMENT &#39;In-doubt trans; notify Order Entry&#39;;
</pre>
<p>For more information about distributed transactions, see <a class="olink CNCPT" href="../CNCPT/toc.htm"><span class="italic">Oracle Database Concepts</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="CEGGCFHJ"></a>
<div id="ZZPRE750" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref975"></a>Guidelines</h2>
<p><a id="sthref976"></a>The following guidelines will help you avoid some common problems.</p>
<div id="ZZPRE751" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref977"></a>
<h3 class="sect2">Designing Applications</h3>
<p>When designing your application, group logically related actions together in one transaction. A well-designed transaction includes all the steps necessary to accomplish a given task -- no more and no less.</p>
<p>Data in the tables you reference must be left in a consistent state. So, the SQL statements in a transaction should change the data in a consistent way. For example, a transfer of funds between two bank accounts should include a debit to one account and a credit to another. Both updates should either succeed or fail together. An unrelated update, such as a new deposit to one account, should not be included in the transaction.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE752" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref978"></a>
<h3 class="sect2">Obtaining Locks</h3>
<p><a id="sthref979"></a>If your application programs include SQL locking statements, make sure the Oracle users requesting locks have the privileges needed to obtain the locks. Your DBA can lock any table. Other users can lock tables they own or tables for which they have a privilege, such as <code>ALTER</code>, <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE753" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref980"></a>
<h3 class="sect2"><a id="sthref981"></a>Using PL/SQL</h3>
<p><a id="sthref982"></a>If a PL/SQL block is part of a transaction, commits and rollbacks inside the block affect the whole transaction. In the following example, the rollback undoes changes made by the update <span class="italic">and</span> the insert:</p>
<pre>EXEC SQL INSERT INTO EMP ...
EXEC SQL EXECUTE
 BEGIN UPDATE emp 
...
 ...
 EXCEPTION
 WHEN DUP_VAL_ON_INDEX THEN
 ROLLBACK;
 END;
END-EXEC;
...
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3238">
<tr>
<td class="cellalignment3247">
<table class="cellalignment3243">
<tr>
<td class="cellalignment3242"><a href="ch_six.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3242"><a href="ch_eight.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3249">
<table class="cellalignment3241">
<tr>
<td class="cellalignment3242"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3242"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3242"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3242"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3242"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3242"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>