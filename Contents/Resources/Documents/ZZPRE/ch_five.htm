<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114752"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Using%20Embedded%20PL%2FSQL"></a><title>Using Embedded PL/SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T18:44:39Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Programmer&#39;s Guide to the Oracle Precompilers"/>
<meta name="dcterms.identifier" content="E53283-01"/>
<meta name="dcterms.isVersionOf" content="ZZPRE"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ch_four.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch_six.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53283-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/20</span> <!-- End Header -->
<div id="ZZPRE294" class="chapter"><a id="BIHJJIBA"></a>
<h1 class="chapter"><span class="secnum">5</span> Using Embedded PL/SQL</h1>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#BABCCIJG">Advantages of PL/SQL</a></p>
</li>
<li>
<p><a href="#BABHHFCF">Embedding PL/SQL Blocks</a></p>
</li>
<li>
<p><a href="#BABEHIBD">Using Host Variables</a></p>
</li>
<li>
<p><a href="#BABGECCH">Using Indicator Variables</a></p>
</li>
<li>
<p><a href="#BABDDBIG">Using Host Arrays</a></p>
</li>
<li>
<p><a href="#BABECAEF">Using Cursors</a></p>
</li>
<li>
<p><a href="#BABBDDAJ">Stored Subprograms</a></p>
</li>
<li>
<p><a href="#BABCJGAE">Using Dynamic PL/SQL</a></p>
</li>
</ul>
<p>This chapter shows you how to improve performance by embedding PL/SQL transaction processing blocks in your program.</p>
<a id="BABCCIJG"></a>
<div id="ZZPRE295" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref527"></a>Advantages of PL/SQL</h2>
<p>This section looks at some of the features and benefits offered by PL/SQL, such as</p>
<ul>
<li>
<p><a href="#BABFHFGB">Better Performance</a></p>
</li>
<li>
<p><a href="#BABIJAHF">Integration with Oracle</a></p>
</li>
<li>
<p><a href="#BABIJFCG">Cursor FOR Loops</a></p>
</li>
<li>
<p><a href="#BABEAIBA">Subprograms</a></p>
</li>
<li>
<p><a href="#BABFAIGD">Parameter Modes</a></p>
</li>
<li>
<p><a href="#BABFEBJB">Packages</a></p>
</li>
<li>
<p><a href="#BABEEDGH">PL/SQL Tables</a></p>
</li>
<li>
<p><a href="#BABHJGDH">User-defined Records</a></p>
</li>
</ul>
<a id="BABFHFGB"></a>
<div id="ZZPRE296" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Better Performance</h3>
<p>PL/SQL can help you reduce overhead, improve performance, and increase productivity. For example, without PL/SQL, Oracle must process SQL statements one at a time. Each SQL statement results in another call to the Server and consequently, a higher overhead. However, with PL/SQL, you can send an entire block of SQL statements to the Server. This minimizes communication between your application and Oracle.</p>
</div>
<!-- class="sect2" -->
<a id="BABIJAHF"></a>
<div id="ZZPRE297" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Integration<a id="sthref528"></a> with Oracle</h3>
<p>PL/SQL is tightly integrated with the Oracle Server. For example, most PL/SQL datatypes are native to the Oracle data dictionary. Furthermore, you can use the <a id="sthref529"></a><code>%TYPE</code> attribute to base variable declarations on column definitions stored in the data dictionary, as the following example shows:</p>
<pre>job_title emp.job%TYPE;
</pre>
<p>That way, you need not know the exact datatype of the column. Furthermore, if a column definition changes, the variable declaration changes accordingly and automatically. This provides data independence, reduces maintenance costs, and allows programs to adapt as the database changes.</p>
</div>
<!-- class="sect2" -->
<a id="BABIJFCG"></a>
<div id="ZZPRE298" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref530"></a>Cursor FOR Loops<a id="sthref531"></a></h3>
<p>With PL/SQL, you need not use the <code>DECLARE</code>, <code>OPEN</code>, <code>FETCH</code>, and <code>CLOSE</code> statements to define and manipulate a cursor. Instead, you can use a cursor <code>FOR</code> loop, which implicitly declares its loop index as a record, opens the cursor associated with a given query, repeatedly fetches data from the cursor into the record, then closes the cursor. An example follows:</p>
<pre>DECLARE
 ...
BEGIN
 FOR emprec IN (SELECT empno, sal, comm FROM emp) LOOP
 IF emprec.comm / emprec.sal &gt; 0.25 THEN ...
 ...
 END LOOP;
END;
</pre>
<p>Notice that you use dot notation to reference fields in the record.</p>
</div>
<!-- class="sect2" -->
<a id="BABEAIBA"></a>
<div id="ZZPRE299" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref532"></a><a id="sthref533"></a><a id="sthref534"></a>Subprograms</h3>
<p>PL/SQL has two types of subprograms called <span class="italic">procedures</span> and <span class="italic">functions</span>, which aid application development by letting you isolate operations. Generally, you use a procedure to perform an action and a function to compute a value.</p>
<p>Procedures and functions provide <span class="italic">extensibility</span>. That is, they let you tailor the PL/SQL language to suit your needs. For example, if you need a procedure that creates a new department, just write your own as follows:</p>
<pre>PROCEDURE create_dept
 (new_dname IN CHAR(14),
 new_loc IN CHAR(13),
 new_deptno OUT NUMBER(2)) IS
BEGIN
 SELECT deptno_seq.NEXTVAL INTO new_deptno FROM dual;
 INSERT INTO dept VALUES (new_deptno, new_dname, new_loc);
END create_dept;
</pre>
<p>When called, this procedure accepts a new department name and location, selects the next value in a department-number database sequence, inserts the new number, name, and location into the <span class="italic">dept</span> table, then returns the new number to the caller.</p>
<p>You can store subprograms in the database (using <code>CREATE</code> <code>FUNCTION</code> and <code>CREATE</code> <code>PROCEDURE</code>) that can be called from multiple applications without needing to be recompiled each time.</p>
</div>
<!-- class="sect2" -->
<a id="BABFAIGD"></a>
<div id="ZZPRE300" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Parameter Modes<a id="sthref535"></a></h3>
<p><a id="sthref536"></a>You use <span class="italic"><a id="sthref537"></a>parameter modes</span> to define the behavior of formal parameters. There are three parameter modes: <code>IN</code> (the default), <code><a id="sthref538"></a>OUT</code>, and <code>IN OUT</code>. An <code><a id="sthref539"></a>7IN</code> parameter lets you pass values to the subprogram being called. An <code>OUT</code> parameter lets you return values to the caller of a subprogram. An <code>IN OUT</code> parameter lets you pass initial values to the subprogram being called and return updated values to the caller.</p>
<p>The datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. <a href="ch_three.htm#BABDHHCD">Table 3-6</a> shows the legal conversions between datatypes.</p>
</div>
<!-- class="sect2" -->
<a id="BABFEBJB"></a>
<div id="ZZPRE301" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Packages<a id="sthref540"></a></h3>
<p><a id="sthref541"></a>PL/SQL lets you bundle logically related types, program objects, and subprograms into a <span class="italic">package</span>. Packages can be compiled and stored in an Oracle database, where their contents can be shared by multiple applications.</p>
<p>Packages usually have two parts: a specification and a body. The <span class="italic">specification</span> is the interface to your applications; it declares the types, constants, variables, exceptions, cursors, and subprograms available for use. The <span class="italic">body</span> defines cursors and subprograms and so implements the specification. In the following example, you &#34;package&#34; two employment procedures:</p>
<pre>PACKAGE emp_actions IS -- package specification
 PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...);
 PROCEDURE fire_employee (emp_id NUMBER);
END emp_actions;
PACKAGE BODY emp_actions IS -- package body
 PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...) IS
 BEGIN
 INSERT INTO emp VALUES (empno, ename, ...);
 END hire_employee;
 PROCEDURE fire_employee (emp_id NUMBER) IS
 BEGIN
 DELETE FROM emp WHERE empno = emp_id;
 END fire_employee;
END emp_actions;
</pre>
<p>Only the declarations in the package specification are visible and accessible to applications. Implementation details in the package body are hidden and inaccessible.</p>
</div>
<!-- class="sect2" -->
<a id="BABEEDGH"></a>
<div id="ZZPRE302" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref542"></a>PL/SQL Tables<a id="sthref543"></a></h3>
<p>PL/SQL provides a composite datatype named <code>TABLE</code>. Objects of type <code>TABLE</code> are called <span class="italic">PL/SQL tables</span>, which are modelled as (but not the same as) database tables. PL/SQL tables have only one column and use a primary key to give you array-like access to rows. The column can belong to any scalar type (such as <code>CHAR</code>, <code>DATE</code>, or <code>NUMBER</code>), but the primary key must belong to type <code>BINARY_INTEGER</code>.</p>
<p>You can declare PL/SQL table types in the declarative part of any block, procedure, function, or package. In the following example, you declare a <code>TABLE</code> type called <span class="italic">NumTabTyp</span>:</p>
<pre>DECLARE
 TYPE NumTabTyp IS TABLE OF NUMBER
 INDEX BY BINARY_INTEGER;
 ...
BEGIN
 ...
END;
</pre>
<p>After you define type <span class="italic">NumTabTyp</span>, you can declare PL/SQL tables of that type, as the next example shows:</p>
<pre>num_tab NumTabTyp;
</pre>
<p>The identifier <span class="italic">num_tab</span> represents an entire PL/SQL table.</p>
<p>You reference rows in a PL/SQL table using array-like syntax to specify the primary key value. For example, you reference the ninth row in the PL/SQL table named <span class="italic">num_tab</span> as follows:</p>
<pre>num_tab(9) ...
</pre></div>
<!-- class="sect2" -->
<a id="BABHJGDH"></a>
<div id="ZZPRE303" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref544"></a><a id="sthref545"></a><a id="sthref546"></a>User-defined Records</h3>
<p><a id="sthref547"></a>You can use the <code>%ROWTYPE</code> attribute to declare a record that represents a row in a database table or a row fetched by a cursor. However, you cannot specify the datatypes of fields in the record or define fields of your own. The composite datatype <code>RECORD</code> lifts those restrictions.</p>
<p>Objects of type <code>RECORD</code> are called <span class="italic">records</span>. Unlike PL/SQL tables, records have uniquely named fields, which can belong to different datatypes. For example, suppose you have different kinds of data about an employee such as name, salary, hire date, and so on. This data is dissimilar in type but logically related. A record that contains such fields as the name, salary, and hire date of an employee would let you treat the data as a logical unit.</p>
<p>You can declare record types and objects in the declarative part of any block, procedure, function, or package. In the following example, you declare a <code>RECORD</code> type called <span class="italic">DeptRecTyp</span>:</p>
<pre>DECLARE
 TYPE DeptRecTyp IS RECORD
 (deptno NUMBER(4) NOT NULL := 10, -- must initialize
 dname CHAR(9),
 loc CHAR(14));
</pre>
<p>Notice that the field declarations are like variable declarations. Each field has a unique <a id="sthref548"></a>name and specific datatype. You can add the <code>NOT</code> <code>NULL</code> option to any field declaration and so prevent the assigning of nulls to that field. However, you must initialize <code>NOT</code> <code>NULL</code> fields.</p>
<p>After you define type <span class="italic">DeptRecTyp</span>, you can declare records of that type, as the next example shows:</p>
<pre>dept_rec DeptRecTyp;
</pre>
<p>The identifier <span class="italic">dept_rec</span> represents an entire record.</p>
<p>You use dot notation to reference individual fields in a record. For example, you reference the <span class="italic">dname</span> field in the <span class="italic">dept_rec</span> record as follows:</p>
<pre>dept_rec.dname ...
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHHFCF"></a>
<div id="ZZPRE304" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Embedding PL/SQL Blocks</h2>
<p>The <a id="sthref549"></a>Oracle Precompilers treat a PL/SQL block like a single embedded SQL statement. So, you can place a PL/SQL block anywhere in a host program that you can place a SQL statement.</p>
<p><a id="sthref550"></a>To embed a PL/SQL block in your host program, simply bracket the PL/SQL block with the keywords <code>EXEC</code> <code>SQL</code> <code>EXECUTE</code> and <code>END-EXEC</code> as follows:</p>
<pre>EXEC SQL EXECUTE
 DECLARE
 ...
 BEGIN
 ...
 END;
END-EXEC;
</pre>
<p>The keyword <code>END-EXEC</code> must be followed by the statement terminator for your host language.</p>
<p>When your program embeds PL/SQL blocks, you must specify the precompiler option <code>SQLCHECK=SEMANTICS</code> because PL/SQL must be parsed by Oracle. To connect to <a id="sthref551"></a>Oracle, you must also specify the option <code><a id="sthref552"></a>USERID</code>. For more information, see <a href="ch_six.htm#CACJBGFE">&#34;Using the Precompiler Options&#34;</a>.</p>
</div>
<!-- class="sect1" -->
<a id="BABEHIBD"></a>
<div id="ZZPRE305" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Host Variables</h2>
<p>Host variables are the key to communication between a host language and a PL/SQL block. Host variables can be shared with PL/SQL, meaning that PL/SQL can set and reference host variables.</p>
<p>For example, you can prompt a user for information and use host variables to pass that information to a PL/SQL block. Then, PL/SQL can access the database and use host variables to pass the results back to your host program.</p>
<p><a id="sthref553"></a>Inside a PL/SQL block, host variables are treated as global to the entire block and can be used anywhere within the block wherever a PL/SQL variable is allowed. However, character host variables cannot exceed 255 characters in length. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects.</p>
<div id="ZZPRE306" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref554"></a>
<h3 class="sect2">An Example<a id="sthref555"></a></h3>
<p>The following example illustrates the use of host variables with PL/SQL. The program prompts the user for an employee number, then displays the job title, hire date, and salary of that employee.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 emp_number INTEGER;
 job_title CHARACTER(20);
 hire_date CHARACTER(9);
 salary REAL;
EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE SQLCA;
display &#39;Username? &#39;;
read username;
display &#39;Password? &#39;;
read password;
EXEC SQL WHENEVER SQLERROR DO sql_error;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display &#39;Connected to Oracle&#39;;
LOOP
 display &#39;Employee Number (0 to end)? &#39;;
 read emp_number;
 IF emp_number = 0 THEN
 EXEC SQL COMMIT WORK RELEASE;
 display &#39;Exiting program&#39;;
 exit program;
 ENDIF;
 ---------------- begin PL/SQL block -----------------
 EXEC SQL EXECUTE
 BEGIN
 SELECT job, hiredate, sal
 INTO :job_title, :hire_date, :salary
 FROM emp
 WHERE empno = :emp_number;
 END;
 END-EXEC;
 ---------------- end PL/SQL block -----------------
 display &#39;Number Job Title Hire Date Salary&#39;;
 display &#39;------------------------------------&#39;;
 display emp_number, job_title, hire_date, salary;
ENDLOOP;
...
ROUTINE sql_error
BEGIN
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display &#39;Processing error&#39;;
 exit program with an error;
END sql_error;
</pre>
<p>Notice that the host variable <span class="italic">emp_number</span> is set before the PL/SQL block is entered, and the host variables <span class="italic">job_title</span>, <span class="italic">hire_date</span>, and <span class="italic">salary</span> are set inside the block.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE307" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref556"></a>
<h3 class="sect2">A More Complex Example<a id="sthref557"></a></h3>
<p>In the example, you prompt the user for a bank account number, transaction type, and transaction amount, then debit or credit the account. If the account does not exist, you raise an exception. When the transaction is complete, you display its status.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 acct_num INTEGER;
 trans_type CHARACTER(1);
 trans_amt REAL;
 status CHARACTER(80);
EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE SQLCA;
display &#39;Username? &#39;;
read username;
display &#39;Password? &#39;;
read password;
EXEC SQL WHENEVER SQLERROR DO sql_error;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display &#39;Connected to Oracle&#39;;
LOOP
 display &#39;Account Number (0 to end)? &#39;;
 read acct_num;
 IF acct_num = 0 THEN
 EXEC SQL COMMIT WORK RELEASE;
 display &#39;Exiting program&#39;;
 exit program;
 ENDIF;
 display &#39;Transaction Type - D)ebit or C)redit? &#39;
 read trans_type;
 display &#39;Transaction Amount? &#39;
 read trans_amt;
 --------------------- begin PL/SQL block -------------------
 EXEC SQL EXECUTE
 DECLARE
 old_bal NUMBER(9,2);
 err_msg CHAR(70);
 nonexistent EXCEPTION;
 BEGIN
 :trans_type := UPPER(:trans_type);
 IF :trans_type = &#39;C&#39; THEN -- credit the account
 UPDATE accts SET bal = bal + :trans_amt
 WHERE acctid = :acct_num;
 IF SQL%ROWCOUNT = 0 THEN -- no rows affected
 RAISE nonexistent;
 ELSE
 :status := &#39;Credit applied&#39;;
 END IF;
 ELSIF :trans_type = &#39;D&#39; THEN -- debit the account
 SELECT bal INTO old_bal FROM accts
 WHERE acctid = :acct_num;
 IF old_bal &gt;= :trans_amt THEN -- enough funds
 UPDATE accts SET bal = bal - :trans_amt
 WHERE acctid = :acct_num;
 :status := &#39;Debit applied&#39;;
 ELSE
 :status := &#39;Insufficient funds&#39;;
 END IF;
 ELSE
 :status := &#39;Invalid type: &#39; || :trans_type;
 END IF;
 COMMIT;
 EXCEPTION
 WHEN NO_DATA_FOUND OR nonexistent THEN
 :status := &#39;Nonexistent account&#39;;
 WHEN OTHERS THEN
 err_msg := SUBSTR(SQLERRM, 1, 70);
 :status := &#39;Error: &#39; || err_msg;
 END;
 END-EXEC;
 ------------------- end PL/SQL block -----------------------
 display &#39;Status: &#39;, status;
ENDLOOP;
ROUTINE sql_error
BEGIN
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE; 
 display &#39;Processing error&#39;;
 exit program with an error;
END sql_error;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE308" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref558"></a>
<h3 class="sect2"><a id="sthref559"></a><a id="sthref560"></a>VARCHAR Pseudotype</h3>
<p>Recall from <a href="ch_three.htm#BABCBCDA">Chapter 3, &#34;Meeting Program Requirements&#34;</a> that you can use the <code>VARCHAR</code> pseudotype to declare variable-length character strings. If the <code>VARCHAR</code> is an input host variable, you must tell Oracle what length to expect. So, set the length field to the actual length of the value stored in the string field.</p>
<p>If the <code>VARCHAR</code> is an output host variable, Oracle automatically sets the length field. However, to use a <code>VARCHAR</code> output host variable in your PL/SQL block, you must initialize the length field <span class="italic">before</span> entering the block. So, set the length field to the declared (maximum) length of the <code>VARCHAR</code>, as shown in the following example:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 emp_number INTEGER;
 emp_name VARCHAR(10);
 salary REAL;
 ...
EXEC SQL END DECLARE SECTION;
...
set emp_name.len = 10; -- initialize length field
EXEC SQL EXECUTE
 BEGIN
 SELECT ename, sal INTO :emp_name, :salary
 FROM emp
 WHERE empno = :emp_number;
 ...
 END;
END-EXEC;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGECCH"></a>
<div id="ZZPRE309" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Indicator Variables</h2>
<p><a id="sthref561"></a>PL/SQL does not need indicator variables because it can manipulate nulls. For example, within PL/SQL, you can use the <code>IS NULL</code> operator to test for nulls, as follows:</p>
<pre>IF variable IS NULL THEN ...
</pre>
<p>You can use the assignment operator (<code>:=</code>) to assign nulls, as follows:</p>
<pre>variable := NULL;
</pre>
<p>However, host languages need indicator variables because they cannot manipulate nulls. Embedded PL/SQL meets this need by letting you use indicator variables to</p>
<ul>
<li>
<p>accept nulls input from a host program</p>
</li>
<li>
<p>output nulls or truncated values to a host program</p>
</li>
</ul>
<p>When used in a PL/SQL block, indicator variables are subject to the following rules:</p>
<ul>
<li>
<p>You cannot refer to an indicator variable by itself; it must be appended to its associated host variable.</p>
</li>
<li>
<p>If you refer to a host variable with its indicator variable, you must always refer to it that way in the same block.</p>
</li>
</ul>
<p>In the following example, the indicator variable <span class="italic">ind_comm</span> appears with its host variable <span class="italic">commission</span> in the <code>SELECT</code> statement, so it must appear that way in the <code>IF</code> statement:</p>
<pre>EXEC SQL EXECUTE
 BEGIN
 SELECT ename, comm
 INTO :emp_name, :commission:ind_comm FROM emp
 WHERE empno = :emp_number;
 IF :commission:ind_comm IS NULL THEN ...
 ...
 END;
END-EXEC;
</pre>
<p>Notice that PL/SQL treats <span class="italic">:commission:ind_comm</span> like any other simple variable. Though you cannot refer directly to an indicator variable inside a PL/SQL block, PL/SQL checks the value of the indicator variable when entering the block and sets the value correctly when exiting the block.</p>
<div id="ZZPRE310" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref562"></a>
<h3 class="sect2">Handling<a id="sthref563"></a> Nulls</h3>
<p>When entering a block, if an indicator variable has a value of <code>-1</code>, PL/SQL automatically assigns a null to the host variable. When exiting the block, if a host variable is null, PL/SQL automatically assigns a value of -1 to the indicator variable. In the next example, if <span class="italic">handsel</span> had a value of -1 before the PL/SQL block was entered, the <span class="italic">salary_missing</span> exception is raised. An <a id="sthref564"></a><span class="italic">exception</span> is a named error condition.</p>
<pre>EXEC SQL EXECUTE
 BEGIN
 IF :salary:ind_sal IS NULL THEN
 RAISE salary_missing;
 END IF;
 ...
 END;
END-EXEC;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE311" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref565"></a>
<h3 class="sect2">Handling <a id="sthref566"></a>Truncated Values</h3>
<p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string. In the following example, the host program will be able to tell, by checking the value of <span class="italic">ind_name</span>, if a truncated value was assigned to <span class="italic">emp_name</span>:</p>
<pre>EXEC SQL EXECUTE
 DECLARE
 ...
 new_name CHAR(10);
 BEGIN
 ...
 :emp_name:ind_name := new_name;
 ...
 END;
END-EXEC;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDDBIG"></a>
<div id="ZZPRE312" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Host Arrays</h2>
<p>You can pass input host arrays and indicator arrays to a PL/SQL block. They can be indexed by a PL/SQL variable of type <code>BINARY_INTEGER</code> or by a host variable compatible with that type. Normally, the entire host array is passed to PL/SQL, but you can use the <code>ARRAYLEN</code> statement (discussed later) to specify a smaller array dimension.</p>
<p>Furthermore, you can use a subprogram call to assign all the values in a host array to rows in a PL/SQL table. Given that the array subscript range is <span class="italic">m</span> .. <span class="italic">n</span>, the corresponding PL/SQL table index range is always 1 .. <span class="italic">(n</span> - <span class="italic">m</span> + 1). For example, if the array subscript range is 5 .. 10, the corresponding PL/SQL table index range is 1 .. (10 - 5 + 1) or 1 .. 6.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle Precompilers do not check your usage of host arrays. For instance, no index range checking is done.</div>
<p>In the example , you pass a host array named <span class="italic">salary</span> to a PL/SQL block, which uses the host array in a function call. The function is named <span class="italic">median</span> because it finds the middle value in a series of numbers. Its formal parameters include a PL/SQL table named <span class="italic">num_tab</span>. The function call assigns all the values in the actual parameter <span class="italic">salary</span> to rows in the formal parameter <span class="italic">num_tab</span>.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 ...
 salary (100) REAL;
 median_salary REAL;
EXEC SQL END DECLARE SECTION;
-- populate the host array
EXEC SQL EXECUTE
 DECLARE
 TYPE NumTabTyp IS TABLE OF REAL
 INDEX BY BINARY_INTEGER;
 n BINARY_INTEGER;
 ...
 FUNCTION median (num_tab NumTabTyp, n INTEGER)
 RETURN REAL IS
 BEGIN
 -- compute median
 END;
 BEGIN
 n := 100;
 :median_salary := median(:salary, n);
 ...
 END;
END-EXEC;
</pre>
<p>You can also use a subprogram call to assign all row values in a PL/SQL table to corresponding elements in a host array.</p>
<p><a href="#BABEGBGG">Table 5-1</a> shows the legal conversions between row values in a PL/SQL table and elements in a host array. For example, a host array of type <code>LONG</code> is compatible with a PL/SQL table of type <code>VARCHAR2</code>, <code>LONG</code>, <code>RAW</code>, or <code>LONG RAW</code>. Notably, it is not compatible with a PL/SQL table of type <code>CHAR</code>.</p>
<div id="ZZPRE313" class="tblformalmax">
<p class="titleintable"><a id="sthref567"></a><a id="BABEGBGG"></a>Table 5-1 Legal Conversions: PL/SQL Table Row and Host Array Elements</p>
<table class="cellalignment3245" title="Legal Conversions: PL/SQL Table Row and Host Array Elements" summary="pl sql" dir="ltr">
<thead>
<tr class="cellalignment3239">
<th class="cellalignment3246" id="r1c1-t3">PL/SQL Table</th>
<th class="cellalignment3246" id="r1c2-t3" colspan="8">Host Array</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r2c1-t3" headers="r1c1-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>LONG</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>LONG</code> <code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r2c1-t3 r1c2-t3">
<p><code>VARCHAR2</code></p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r3c1-t3" headers="r1c1-t3">
<p><code>CHARF</code></p>
</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r3c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r4c1-t3" headers="r1c1-t3">
<p><code>CHARZ</code></p>
</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r4c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r5c1-t3" headers="r1c1-t3">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r5c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r6c1-t3" headers="r1c1-t3">
<p><code>DECIMAL</code></p>
</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r6c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r7c1-t3" headers="r1c1-t3">
<p><code>DISPLAY</code></p>
</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r7c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r8c1-t3" headers="r1c1-t3">
<p><code>FLOAT</code></p>
</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r8c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r9c1-t3" headers="r1c1-t3">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r9c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r10c1-t3" headers="r1c1-t3">
<p><code>LONG</code></p>
</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r10c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r11c1-t3" headers="r1c1-t3">
<p><code>LONG</code> <code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r11c1-t3 r1c2-t3">
<p>_/</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r12c1-t3" headers="r1c1-t3">
<p><code>LONG</code> <code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r12c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r13c1-t3" headers="r1c1-t3">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r13c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r14c1-t3" headers="r1c1-t3">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r14c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r15c1-t3" headers="r1c1-t3">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r15c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r16c1-t3" headers="r1c1-t3">
<p><code>STRING</code></p>
</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r16c1-t3 r1c2-t3">
<p>_/</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r17c1-t3" headers="r1c1-t3">
<p><code>UNSIGNED</code></p>
</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r17c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r18c1-t3" headers="r1c1-t3">
<p><code>VARCHAR</code></p>
</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r18c1-t3 r1c2-t3">
<p>_/</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r19c1-t3" headers="r1c1-t3">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r19c1-t3 r1c2-t3">
<p>_/</p>
</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r20c1-t3" headers="r1c1-t3">
<p><code>VARNUM</code></p>
</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r20c1-t3 r1c2-t3">&nbsp;</td>
</tr>
<tr class="cellalignment3239">
<td class="cellalignment3247" id="r21c1-t3" headers="r1c1-t3">
<p><code>VARRAW</code></p>
</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">
<p>_/</p>
</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">&nbsp;</td>
<td class="cellalignment3247" headers="r21c1-t3 r1c2-t3">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalmax" -->
<div id="ZZPRE314" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref568"></a>
<h3 class="sect2">ARRAYLEN Statement</h3>
<p><a id="sthref569"></a>Suppose you must pass an input host array to a PL/SQL block for processing. By default, when binding such a host array, the Oracle Precompilers use its declared dimension. However, you might not want to process the entire array. In that case, you can use the <code>ARRAYLEN</code> statement to specify a smaller array dimension. <code>ARRAYLEN</code> associates the host array with a host variable, which stores the smaller dimension. The statement syntax is</p>
<pre>EXEC SQL ARRAYLEN host_array (dimension);
</pre>
<p>where <span class="italic">dimension</span> is a 4-byte, integer host variable, <span class="italic">not</span> a literal or an expression.</p>
<p>The <code>ARRAYLEN</code> statement must appear in the Declare Section along with, but somewhere after, the declarations of <span class="italic">host_array</span> and <span class="italic">dimension</span>. You cannot specify an offset into the host array. However, you might be able to use host-language features for that purpose.</p>
<p>In the following example, you use <code>ARRAYLEN</code> to override the default dimension of a host array named <span class="italic">bonus</span>:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 bonus (100) REAL;
 my_dim INTEGER;
 EXEC SQL ARRAYLEN bonus (my_dim);
EXEC SQL END DECLARE SECTION; 
-- populate the host array
...
set my_dim = 25; -- set smaller array dimension
EXEC SQL EXECUTE
 DECLARE
 TYPE NumTabTyp IS TABLE OF REAL
 INDEX BY BINARY_INTEGER;
 median_bonus REAL;
 FUNCTION median (num_tab NumTabTyp, n INTEGER)
 RETURN REAL IS
 BEGIN
 -- compute median
 END;
 BEGIN
 median_bonus := median(:bonus, :my_dim);
 ...
 END;
END-EXEC;
</pre>
<p>Only 25 array elements are passed to the PL/SQL block because <code>ARRAYLEN</code> downsizes the host array from 100 to 25 elements. As a result, when the PL/SQL block is sent to Oracle for execution, a much smaller host array is sent along. This saves time and, in a networked environment, reduces network traffic.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABECAEF"></a>
<div id="ZZPRE315" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Cursors</h2>
<p>Every embedded SQL statement is assigned a cursor, either explicitly by you in a <code>DECLARE</code> <code>CURSOR</code> statement or implicitly by the precompiler. Internally, the Oracle Precompilers maintain a cache, called the <span class="italic"><a id="sthref570"></a>cursor cache</span>, to control the execution of embedded SQL statements. When executed, every SQL statement is assigned an entry in the cursor cache. This entry is linked to a private SQL area in your <a id="sthref571"></a>Program Global Area (PGA) within Oracle.</p>
<p>Various precompiler options, including <code>MAXOPENCURSORS</code>, <code>HOLD_CURSOR</code>, and <code>RELEASE_CURSOR</code>, let you manage the cursor cache to improve performance. For example, <code>RELEASE_CURSOR</code> controls what happens to the link between the cursor cache and private SQL area. If you specify <code>RELEASE_CURSOR</code><code>=YES</code>, the link is removed after Oracle executes the SQL statement. This frees memory allocated to the private SQL area and releases parse locks.</p>
<p><a id="sthref572"></a>For purposes of cursor cache management, an embedded PL/SQL block is treated just like a SQL statement. At run time, a cursor, called a <span class="italic"><a id="sthref573"></a><a id="sthref574"></a>parent cursor</span>, is associated with the entire PL/SQL block. A corresponding entry is made to the cursor cache, and this entry is linked to a private SQL area in the PGA.</p>
<p><a id="sthref575"></a>Each SQL statement inside the PL/SQL block also requires a private SQL area in the PGA. So, PL/SQL manages a separate cache, called the <span class="italic">child cursor<a id="sthref576"></a> cache</span>, for these SQL statements. Their cursors are called <span class="italic">child cursors</span>. Because PL/SQL manages the child cursor cache, you do not have direct control over child cursors.</p>
<p>The maximum number of cursors your program can use simultaneously is set by the Oracle initialization parameter <code><a id="sthref577"></a>OPEN_CURSORS</code>.<a href="#BIHJFJEI">Figure 5-1</a> shows you how to calculate the maximum number of cursors in use.</p>
<div id="ZZPRE316" class="figure">
<p class="titleinfigure"><a id="BIHJFJEI"></a>Figure 5-1 Maximum Cursors in Use</p>
<img width="536" height="186" src="img/image009.gif" alt="Maximum cursors in use"/><br/>
<a id="sthref578" href="img_text/image009.htm">Description of &#34;Figure 5-1 Maximum Cursors in Use&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>If your program exceeds the limit imposed by <code>OPEN_CURSORS</code>, you get the following Oracle error:</p>
<pre>ORA-01000: maximum open cursors exceeded
</pre>
<p>You can avoid this error by specifying the <code>RELEASE_CURSOR</code><code>=YES</code> and <code>HOLD_CURSOR</code><code>=NO</code> options. If you do not want to precompile the entire program with <code>RELEASE_CURSOR</code> set to <code>YES</code>, simply reset it to <code>NO</code> after each PL/SQL block, as follows:</p>
<pre>EXEC ORACLE OPTION (RELEASE_CURSOR=YES);
-- first embedded PL/SQL block
 EXEC ORACLE OPTION (RELEASE_CURSOR=NO);
-- embedded SQL statements
 EXEC ORACLE OPTION (RELEASE_CURSOR=YES);
-- second embedded PL/SQL block
 EXEC ORACLE OPTION (RELEASE_CURSOR=NO);
-- embedded SQL statements
</pre>
<div id="ZZPRE317" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref579"></a>
<h3 class="sect2">An Alternative</h3>
<p>The <code>MAXOPENCURSORS</code> option specifies the initial size of the cursor cache. For example, when <code>MAXOPENCURSORS=1</code>0, the cursor cache can hold up to 10 entries. If a new cursor is needed, there are no free cache entries, and <code>HOLD_CURSOR=NO</code>, the precompiler tries to reuse an entry. If you specify a very low value for <code>MAXOPENCURSORS</code>, the precompiler is forced to reuse the parent cursor more often. All the child cursors are released as soon as the parent cursor is reused.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBDDAJ"></a>
<div id="ZZPRE318" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref580"></a>Stored Subprograms</h2>
<p><a id="sthref581"></a>Unlike anonymous blocks, PL/SQL subprograms (procedures and functions) can be compiled separately, stored in an Oracle database, and invoked. A subprogram explicitly created using an Oracle tool such as SQL*Plus is called a <span class="italic">stored</span> subprogram. Once compiled and stored in the data dictionary, it is a database object, which can be reexecuted without being recompiled.</p>
<p>When a subprogram within a PL/SQL block or stored subprogram is sent to Oracle by your application, it is called an <span class="italic">inline</span> subprogram. Oracle compiles the inline subprogram and caches it in the <a id="sthref582"></a>System Global Area (SGA), but does not store the source or object code in the data dictionary.</p>
<p><a id="sthref583"></a>Subprograms defined within a package are considered part of the package, and so are called <span class="italic">packaged</span> subprograms. Stored subprograms not defined within a package are called <span class="italic">standalone</span> subprograms.</p>
<div id="ZZPRE319" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref584"></a>
<h3 class="sect2">Creating <a id="sthref585"></a>Stored Subprograms</h3>
<p><a id="sthref586"></a>You can embed the SQL statements <code>CREATE</code> <code>FUNCTION</code>, <code>CREATE</code> <code>PROCEDURE</code>, and <code>CREATE</code> <code>PACKAGE</code> in a host program, as the following example shows:</p>
<pre>EXEC SQL CREATE
 FUNCTION sal_ok (salary REAL, title CHAR)
 RETURN BOOLEAN AS
 min_sal REAL;
 max_sal REAL;
 BEGIN
 SELECT losal, hisal INTO min_sal, max_sal
 FROM sals
 WHERE job = title;
 RETURN (salary &gt;= min_sal) AND
 (salary &lt;= max_sal);
 END sal_ok;
END-EXEC;
</pre>
<p>Notice that the embedded <code>CREATE</code> <code>{FUNCTION | PROCEDURE | PACKAGE}</code> statement is a hybrid. Like all other embedded <code>CREATE</code> statements, it begins with the keywords <code>EXEC SQL</code> (not <code>EXEC SQL EXECUTE</code>). But, unlike other embedded <code>CREATE</code> statements, it ends with the PL/SQL terminator <code>END-EXEC</code>.</p>
<p>In the example, you create a package that contains a procedure named <span class="italic">get_employees</span>, which fetches a batch of rows from the <span class="italic">emp</span> table. The batch size is determined by the caller of the procedure, which might be another stored subprogram or a client application program.</p>
<p>The procedure declares three PL/SQL tables as <code>OUT</code> formal parameters, then fetches a batch of employee data into the PL/SQL tables. The matching actual parameters are host arrays. When the procedure finishes, it automatically assigns all row values in the PL/SQL tables to corresponding elements in the host arrays.</p>
<pre>EXEC SQL CREATE OR REPLACE PACKAGE emp_actions AS
 TYPE CharArrayTyp IS TABLE OF VARCHAR2(10)
 INDEX BY BINARY_INTEGER;
 TYPE NumArrayTyp IS TABLE OF FLOAT
 INDEX BY BINARY_INTEGER;
 PROCEDURE get_employees(
 dept_number IN INTEGER,
 batch_size IN INTEGER,
 found IN OUT INTEGER,
 done_fetch OUT INTEGER,
 emp_name OUT CharArrayTyp,
 job-title OUT CharArrayTyp,
 salary OUT NumArrayTyp);
 END emp_actions;
END-EXEC;
EXEC SQL CREATE OR REPLACE PACKAGE BODY emp_actions AS
 CURSOR get_emp (dept_number IN INTEGER) IS
 SELECT ename, job, sal FROM emp
 WHERE deptno = dept_number;
 PROCEDURE get_employees(
 dept_number IN INTEGER,
 batch_size IN INTEGER,
 found IN OUT INTEGER,
 done_fetch OUT INTEGER,
 emp_name OUT CharArrayTyp,
 job_title OUT CharArrayTyp,
 salary OUT NumArrayTyp) IS
 BEGIN
 IF NOT get_emp%ISOPEN THEN
 OPEN get_emp(dept_number);
 END IF;
 done_fetch := 0;
 found := 0;
 FOR i IN 1..batch_size LOOP
 FETCH get_emp INTO emp_name(i),
 job_title(i), salary(i);
 IF get_emp%NOTFOUND THEN
 CLOSE get_emp;
 done_fetch := 1;
 EXIT;
 ELSE
 found := found + 1;
 END IF;
 END LOOP;
 END get_employees;
 END emp_actions;
END-EXEC;
</pre>
<p>You specify the <code>REPLACE</code> clause in the <code>CREATE</code> statement to redefine an existing package without having to drop the package, re-create it, and regrant privileges on it. For the full syntax of the <code>CREATE</code> statement see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>If an embedded <code>CREATE {FUNCTION|PROCEDURE|PACKAGE}</code> statement fails, Oracle generates a warning, not an error.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE320" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref587"></a>
<h3 class="sect2">Calling a <a id="sthref588"></a>Stored Subprogram</h3>
<p>To invoke (call) a stored subprogram from your host program, you must use an anonymous PL/SQL block. In the following example, you call a standalone procedure named <span class="italic">raise_salary</span>:</p>
<pre>EXEC SQL EXECUTE
 BEGIN
 raise_salary(:emp_id, :increase);
 END;
END-EXEC;
</pre>
<p>Notice that stored subprograms can take parameters. In this example, the actual parameters <span class="italic">emp_id</span> and <span class="italic">increase</span> are host variables.</p>
<p>In the next example, the procedure <span class="italic">raise_salary</span> is stored in a package named <span class="italic">emp_actions</span>, so you must use dot notation to fully qualify the procedure call:</p>
<pre>EXEC SQL EXECUTE
 BEGIN
 emp_actions.raise_salary(:emp_id, :increase);
 END;
END-EXEC;
</pre>
<p>An actual IN parameter can be a literal, host variable, host array, PL/SQL constant or variable, PL/SQL table, PL/SQL user-defined record, subprogram call, or expression. However, an actual OUT parameter cannot be a literal, subprogram call, or expression.</p>
<p>In the Pro*C example, three of the formal parameters are PL/SQL tables, and the corresponding actual parameters are host arrays. The program calls the stored procedure <span class="italic">get_employees</span> repeatedly, displaying each batch of employee data, until no more data is found.</p>
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
typedef char asciz;
EXEC SQL BEGIN DECLARE SECTION;
 /* Define type for null-terminated strings */
 EXEC SQL TYPE asciz IS STRING(20);
 asciz username[20];
 asciz password[20];
 int dept_no; /* which department to query */
 char emp_name[10][21];
 char job[10][21];
 float salary[10];
 int done_flag;
 int array_size;
 int num_ret; /* number of rows returned */
 int SQLCODE;
EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE sqlca;
int print_rows(); /* produces program output */
int sql_error(); /* handles NOLOGGING errors */
main()
{
 int i;
 /* Connect to Oracle. */
 strcpy(username, &#34;SCOTT&#34;);
 strcpy(password, &#34;TIGER&#34;);
 EXEC SQL WHENEVER SQLERROR DO sql_error();
 EXEC SQL CONNECT :username IDENTIFIED BY :password;
 printf(&#34;\nConnected to Oracle as user: %s\n&#34;, username);
 printf(&#34;enter department number: &#34;);
 scanf(&#34;%d&#34;, &amp;dept_no);
 fflush(stdin);
 /* Set the array size. */
 array_size = 10;
 done_flag = 0;
 num_ret = 0;
 /* Array fetch loop - ends when done_flag is true. */
 for (;;)
 {
 EXEC SQL EXECUTE
 BEGIN emp_actions.get_employees
 (:dept_no, :array_size, :num_ret,
 :done_flag, :emp_name, :job, :salary);
 END;
 END-EXEC;
 print_rows(num_ret);
 if (done_flag)
 break;
 }
 /* Disconnect from the database. */
 EXEC SQL COMMIT WORK RELEASE;
 exit(0);
}
print_rows(n)
int n;
{
 int i;
 if (n == 0)
 {
 printf(&#34;No rows retrieved.\n&#34;);
 return;
 }
 printf(&#34;\n\nGot %d row%c\n&#34;, n, n == 1 ? &#39;\0&#39; : &#39;s&#39;);
 printf(&#34;%-20.20s%-20.20s%s\n&#34;, &#34;Ename&#34;, &#34;Job&#34;, &#34;Salary&#34;);
 for (i = 0; i &lt; n; i++)
 printf(&#34;%20.20s%20.20s%6.2f\n&#34;,
 emp_name[i], job[i], salary[i]);
}
sql_error()
{
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 printf(&#34;\nOracle error detected:&#34;);
 printf(&#34;\n% .70s \n&#34;, sqlca.sqlerrm.sqlerrmc);
 EXEC SQL ROLLBACK WORK RELEASE;
 exit(1);
}
</pre>
<p>Remember, the datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. Also, before a stored subprogram exits, all OUT formal parameters must be assigned values. Otherwise, the values of corresponding actual parameters are indeterminate.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE321" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref589"></a>
<h3 class="sect2">Remote Access</h3>
<p>PL/SQL lets you access remote databases through <span class="italic">database links</span>. Typically, database links are established by your DBA and stored in the Oracle data dictionary. A database link tells Oracle where the remote database is located, the path to it, and what Oracle username and password to use. In the following example, you use the database link <span class="italic">dallas</span> to call the <span class="italic">raise_salary</span> procedure:</p>
<pre>EXEC SQL EXECUTE
 BEGIN
 raise_salary@dallas(:emp_id, :increase);
 END;
END-EXEC;
</pre>
<p>You can create synonyms to provide location transparency for remote subprograms, as the following example shows:</p>
<pre>CREATE PUBLIC SYNONYM raise_salary FOR raise_salary@dallas;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE322" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref590"></a>
<h3 class="sect2">Getting Information about Stored Subprograms</h3>
<p>In <a href="ch_three.htm#BABCBCDA">Chapter 3, &#34;Meeting Program Requirements&#34;</a>, you learned how to embed OCI calls in your host program. After calling the library routine <code>SQLLDA</code> to set up the LDA, you can use the OCI call <code>ODESSP</code> to get useful information about a stored subprogram. When you call <code>ODESSP</code>, you must pass it a valid LDA and the name of the subprogram. For packaged subprograms, you must also pass the name of the package. <code>ODESSP</code> returns information about each subprogram parameter such as its datatype, size, position, and so on.</p>
<p>You can also use the procedure <span class="italic">describe_procedure</span> in package DBMS_DESCRIBE, which is supplied with Oracle.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCJGAE"></a>
<div id="ZZPRE323" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Dynamic PL/SQL</h2>
<p>Recall that the Oracle Precompilers treat an entire PL/SQL block like a single SQL statement. Therefore, you can store a PL/SQL block in a string host variable. Then, if the block contains no host variables, you can use dynamic SQL Method 1 to execute the PL/SQL string. Or, if the block contains a known number of host variables, you can use dynamic SQL Method 2 to prepare and execute the PL/SQL string. If the block contains an unknown number of host variables, you must use dynamic SQL Method 4. For more information, refer to <a href="ch_ten.htm#CHDEFGBC">Chapter 10, &#34;Using Dynamic SQL&#34;</a>.</p>
<div id="ZZPRE324" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref591"></a>
<h3 class="sect2">Restriction</h3>
<p>In dynamic SQL Method 4, a host array cannot be bound to a PL/SQL procedure with a parameter of type <code>TABLE</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3238">
<tr>
<td class="cellalignment3247">
<table class="cellalignment3243">
<tr>
<td class="cellalignment3242"><a href="ch_four.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3242"><a href="ch_six.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3249">
<table class="cellalignment3241">
<tr>
<td class="cellalignment3242"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3242"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3242"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3242"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3242"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3242"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>