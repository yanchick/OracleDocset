<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114753"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Using%20Embedded%20SQL"></a><title>&nbsp;Using Embedded SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T18:44:39Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Programmer&#39;s Guide to the Oracle Precompilers"/>
<meta name="dcterms.identifier" content="E53283-01"/>
<meta name="dcterms.isVersionOf" content="ZZPRE"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ch_three.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch_five.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53283-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/20</span> <!-- End Header -->
<div id="ZZPRE260" class="chapter"><a id="BABEGAEG"></a>
<h1 class="chapter"><span class="secnum">4</span> &nbsp;Using Embedded SQL</h1>
<p>This chapter contains the following:</p>
<ul>
<li>
<p><a href="#BABIDCGI">Using Host Variables</a></p>
</li>
<li>
<p><a href="#BABCFFHH">Using Indicator Variables</a></p>
</li>
<li>
<p><a href="#BABEIBEC">The Basic SQL Statements</a></p>
</li>
<li>
<p><a href="#BABICBCB">Cursors</a></p>
</li>
<li>
<p><a href="#BABGGGHH">Cursor Variables</a></p>
</li>
</ul>
<p>This chapter helps you to understand and apply the basic techniques of embedded SQL programming. You learn how to use host variables, indicator variables, cursors, cursor variables, and the fundamental SQL commands that insert, update, select, and delete Oracle data.</p>
<a id="BABIDCGI"></a>
<div id="ZZPRE261" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Host Variables</h2>
<p><a id="sthref399"></a>Oracle uses host variables to pass data and status information to your program; your program uses host variables to pass data to Oracle.</p>
<div id="ZZPRE262" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref400"></a>
<h3 class="sect2"><a id="sthref401"></a>Output versus Input Host Variables</h3>
<p><a id="sthref402"></a>Depending on how they are used, host variables are called output or input host variables. Host variables in the <code>INTO</code> clause of a <code>SELECT</code> or <code>FETCH</code> statement are called <span class="italic">output</span> host variables because they hold column values output by Oracle. Oracle assigns the column values to corresponding output host variables in the <code><a id="sthref403"></a>INTO</code> clause.</p>
<p>All other host variables in a SQL statement are called <span class="italic">input</span> host variables because your program inputs their values to Oracle. For example, you use input host variables in the <code>VALUES</code> clause of an <code>INSERT</code> statement and in the <code>SET</code> clause of an <code>UPDATE</code> statement. <a id="sthref404"></a>They are also used in the <code>WHERE</code>, <code>HAVING</code>, and <code>FOR</code> clauses. In fact, input host variables can appear in a SQL statement wherever a value or expression is allowed.</p>
<p>In an <code>ORDER</code> <code>BY</code> clause, you <span class="italic">can</span> use a host variable, but it is treated as a constant or literal, and hence the contents of the host variable have no effect. For example, the SQL statement</p>
<pre>EXEC SQL SELECT ename, empno INTO :name, :number
 FROM emp
 ORDER BY :ord;
</pre>
<p>appears to contain an input host variable, <span class="italic">ord</span>. However, the host variable in this case is treated as a constant, and regardless of the value of <span class="italic">ord</span>, no ordering is done.</p>
<p><a id="sthref405"></a>You cannot use input host variables to supply SQL keywords or the names of database objects. Thus, you cannot use input host variables in data definition statements (sometimes called <span class="italic">DDL<a id="sthref406"></a></span>) such as <code>ALTER</code>, <code>CREATE</code>, and <code>DROP</code>. In the following example, the <code>DROP</code> <code>TABLE</code> statement is <span class="italic">invalid</span>:<a id="sthref407"></a></p>
<pre>EXEC SQL BEGIN DECLARE SECTION; 
 table_name CHARACTER(30); 
EXEC SQL END DECLARE SECTION; 
display &#39;Table name? &#39;; 
read table_name; 
EXEC SQL DROP TABLE :table_name; -- host variable not allowed
</pre>
<p>Before Oracle executes a SQL statement containing input host variables, your program must assign values to them. Consider the following example:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION; 
 emp_number INTEGER; 
 emp_name CHARACTER(20); 
EXEC SQL END DECLARE SECTION; 
-- get values for input host variables 
display &#39;Employee number? &#39;; 
read emp_number; 
display &#39;Employee name? &#39;; 
read emp_name; 
EXEC SQL INSERT INTO EMP (EMPNO, ENAME) 
 VALUES (:emp_number, :emp_name);
</pre>
<p>Notice that the input host variables in the <code>VALUES</code> clause of the <code>INSERT</code> statement are prefixed with colons.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCFFHH"></a>
<div id="ZZPRE263" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Indicator Variables</h2>
<p><a id="sthref408"></a>You can associate any host variable with an optional indicator variable. Each time the host variable is used in a SQL statement, a result code is stored in its associated indicator variable. Thus, indicator variables let you monitor host variables.</p>
<p>You use indicator variables in the <code>VALUES</code> or <code>SET</code> clause to assign nulls to input host variables and in the <code>INTO</code> clause to detect nulls or truncated values in output host variables.</p>
<div id="ZZPRE264" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref409"></a>
<h3 class="sect2">Input Variables</h3>
<p>For input host variables, the values your program can assign to an indicator variable have the following meanings:</p>
<ul>
<li>
<p>-1: Oracle will assign a null to the column, ignoring the value of the host variable.</p>
</li>
<li>
<p>&gt;= 0: <a id="sthref410"></a>Oracle will assigns the value of the host variable to the column.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ZZPRE265" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref411"></a>
<h3 class="sect2">Output Variables</h3>
<p><a id="sthref412"></a>For output<a id="sthref413"></a> host variables, the values Oracle can assign to an indicator variable have the following meanings:</p>
<ul>
<li>
<p>-2: Oracle assigned a <a id="sthref414"></a>truncated column value to the host variable, but could not assign the original length of the column value to the indicator variable because the number was too large.</p>
</li>
<li>
<p>-1: The column value is null, so the value of the host variable is indeterminate.</p>
</li>
<li>
<p>0: Oracle assigned an intact column value to the host variable.</p>
</li>
<li>
<p>&gt; 0: Oracle assigned a truncated column value to the host variable, assigned the original column length (expressed in characters, instead of bytes, for multibyte Globalization Support host variables) to the indicator variable, and set SQLCODE in the SQLCA to zero.</p>
</li>
</ul>
<p>Remember, an indicator variable must be defined in the Declare Section as a 2-byte integer and, in SQL statements, must be prefixed with a colon and appended to its host variable (unless you use the keyword INDICATOR).</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE266" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref415"></a>
<h3 class="sect2">Inserting Nulls</h3>
<p><a id="sthref416"></a>You can use indicator variables to insert nulls. Before the insert, for each column you want to be null, set the appropriate indicator variable to -1, as shown in the following example:</p>
<pre>set ind_comm = -1; 
EXEC SQL INSERT INTO EMP (EMPNO, COMM) 
 VALUES (:emp_number, :commission:ind_comm);
</pre>
<p>The indicator variable <span class="italic">ind_comm</span> specifies that a null is to be stored in the <code>COMM</code> column.</p>
<p>You can <a id="sthref417"></a>hardcode the null instead, as follows:</p>
<pre>EXEC SQL INSERT INTO EMP (EMPNO, COMM) 
 VALUES (:emp_number, NULL);
</pre>
<p>While this is less flexible, it might be more readable.</p>
<p>Typically, you insert nulls conditionally, as the next example shows:</p>
<pre>display &#39;Enter employee number or 0 if not available: &#39;; 
read emp_number; 
IF emp_number = 0 THEN 
 set ind_empnum = -1; ELSE 
 set ind_empnum = 0; 
ENDIF; 
EXEC SQL INSERT INTO EMP (EMPNO, SAL) 
 VALUES (:emp_number:ind_empnum, :salary);
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE267" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref418"></a>
<h3 class="sect2">Handling Returned Nulls</h3>
<p><a id="sthref419"></a>You can also use indicator variables to manipulate returned nulls, as the following example shows:</p>
<pre>EXEC SQL SELECT ENAME, SAL, COMM 
 INTO :emp_name, :salary, :commission:ind_comm 
 FROM EMP 
 WHERE EMPNO = :emp_number; 
IF ind_comm = -1 THEN 
 set pay = salary; -- commission is null; ignore it 
ELSE 
 set pay = salary + commission; 
ENDIF;
<a id="sthref420"></a>
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE268" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref421"></a>
<h3 class="sect2">Fetching Nulls</h3>
<p>When DBMS=NATIVE, V7, or V8, if you select or fetch nulls into a host variable that lacks an indicator variable, Oracle issues the following error message:<a id="sthref422"></a></p>
<pre>ORA-01405: fetched column value is NULL
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE269" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref423"></a>
<h3 class="sect2">Testing for Nulls</h3>
<p><a id="sthref424"></a>You <a id="sthref425"></a>can use indicator variables in the <code>WHERE</code> clause to test for nulls, as the following example shows:</p>
<pre>EXEC SQL SELECT ENAME, SAL 
 INTO :emp_name, :salary 
 FROM EMP 
 WHERE :commission:ind_comm IS NULL ...
</pre>
<p><a id="sthref426"></a>However, you cannot use a relational operator to compare nulls with each other or with other values. For example, the following <code>SELECT</code> statement fails if the <code>COMM</code> column contains one or more nulls:</p>
<pre>EXEC SQL SELECT ENAME, SAL 
 INTO :emp_name, :salary 
 FROM EMP 
 WHERE COMM = :commission:ind_comm;
</pre>
<p>The next example shows how to compare values for equality when some of them might be nulls:</p>
<pre>EXEC SQL SELECT ENAME, SAL 
 INTO :emp_name, :salary 
 FROM EMP 
 WHERE (COMM = :commission) OR ((COMM IS NULL) AND 
 (:commission:ind_comm IS NULL));
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE270" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref427"></a>
<h3 class="sect2">Fetching Truncated Values</h3>
<p><a id="sthref428"></a>If you select or fetch a truncated column value into a host variable that lacks an indicator variable, no error is generated.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABEIBEC"></a>
<div id="ZZPRE271" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The Basic SQL Statements</h2>
<p>Executable SQL statements let you query, manipulate, and control Oracle data and <a id="sthref429"></a>create, define, and maintain Oracle objects such as tables, views, and indexes. This chapter focuses on <a id="sthref430"></a>data manipulation statements (sometimes called <span class="italic">DML</span>) and cursor control statements. The following SQL statements let you query and <a id="sthref431"></a>manipulate Oracle data:</p>
<ul>
<li>
<p><code>SELECT</code>: Returns rows from one or more tables.</p>
</li>
<li>
<p><code>INSERT</code>: Adds new rows to a table.</p>
</li>
<li>
<p><code>UPDATE</code>: Modifies rows in a table.</p>
</li>
<li>
<p><code>DELETE</code>: Removes rows from a table.</p>
</li>
</ul>
<p>When executing a data manipulation statement such as <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, your only concern, besides setting the values of any input host variables, is whether the statement succeeds or fails. To find out, you simply check the SQLCA. (Executing any SQL statement sets the SQLCA variables.) You can check in the following two ways:</p>
<ul>
<li>
<p>Implicit checking with the <code>WHENEVER</code> statement</p>
</li>
<li>
<p>Explicit checking of SQLCA variables</p>
</li>
</ul>
<p>Alternatively, when <code>MODE={ANSI|ANSI14}</code>, you can check the status variable <code>SQLSTATE</code> or <code>SQLCODE</code>. For more information, see <a href="ch_eight.htm#CEGJDGDH">&#34;Using Status Variables when MODE={ANSI|ANSI14}&#34;</a>.</p>
<p>When executing a <code>SELECT</code> statement (<a id="sthref432"></a>query), however, you must also deal with the rows of data it returns. Queries can be classified as follows:</p>
<ul>
<li>
<p>queries that return no rows (that is, merely check for existence)</p>
</li>
<li>
<p>queries that return only one row</p>
</li>
<li>
<p>queries that return more than one row</p>
</li>
</ul>
<p><a id="sthref433"></a>Queries that return more than one row require an explicitly declared cursor or cursor variable (or the use of host arrays, which are discussed in <a href="ch_nine.htm#BABHFECC">Chapter 9, &#34;Using Host Arrays&#34;</a>). The following embedded SQL statements let you define and control an explicit cursor:</p>
<ul>
<li>
<p><code>DECLARE</code>: Names the cursor and associates it with a query.</p>
</li>
<li>
<p><code>OPEN</code>: Executes the query and identifies the active set.</p>
</li>
<li>
<p><code>FETCH</code>: Advances the cursor and retrieves each row in the active set, one by one.</p>
</li>
<li>
<p><code>CLOSE</code>: Disables the cursor (the active set becomes undefined).</p>
</li>
</ul>
<p>In the coming sections, first you learn how to code <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and single-row <code>SELECT</code> statements. Then, you progress to multi-row <code>SELECT</code> statements.</p>
<div id="ZZPRE272" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref434"></a>
<h3 class="sect2">Selecting Rows</h3>
<p><a id="sthref435"></a>Querying the database is a common SQL operation. To issue a query you use the <a id="sthref436"></a><code>SELECT</code> statement. In the following <a id="sthref437"></a>example, you query the <code>EMP</code> table:</p>
<pre>EXEC SQL SELECT ENAME, JOB, SAL + 2000 
 INTO :emp_name, :job_title, :salary 
 FROM EMP 
 WHERE EMPNO = :emp_number;
</pre>
<p><a id="sthref438"></a>The column names and expressions following the keyword <code>SELECT</code> make up the <span class="italic"><a id="sthref439"></a>select list</span>. The select list in our example contains three items. Under the conditions specified in the <code>WHERE</code> clause (and following clauses, if present), Oracle returns column values to the host variables in the <code><a id="sthref440"></a>INTO</code> clause. The number of items in the select list should equal the number of host variables in the <code>INTO</code> clause, so there is a place to store every returned value.</p>
<p><a id="sthref441"></a>In the simplest case, when a query returns one row, its form is that shown in the last example (in which <code>EMPNO</code> is a unique key). However, if a query can return more than one row, you must fetch the rows using a cursor or select them into a host array.</p>
<p>If you write a query to return only one row but it might actually return several rows, the result depends on how you specify the option <code><a id="sthref442"></a>SELECT_ERROR</code>. When <code>SELECT_ERROR</code><code>=</code><code>YES</code> (the default), Oracle issues the following error message if more than one row is returned:</p>
<pre>ORA-01422: exact fetch returns more than requested number of rows
</pre>
<p>When <code>SELECT_ERROR=NO</code>, a row is returned and Oracle generates no error.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE273" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref443"></a>
<h3 class="sect2"><a id="sthref444"></a>Available Clauses</h3>
<p>You can use all of the following standard SQL clauses in your <code>SELECT</code> statements: <code>INTO</code>, <code>FROM</code>, <code>WHERE</code>, <code>CONNECT</code> <code>BY</code>, <code>START</code> <code>WITH</code>, <code>GROUP</code> <code>BY</code>, <code>HAVING</code>, <code>ORDER</code> <code>BY</code>, and <code>FOR</code> <code>UPDATE</code> <code>OF</code>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE274" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref445"></a>
<h3 class="sect2">Inserting Rows</h3>
<p><a id="sthref446"></a>You use the <code><a id="sthref447"></a>INSERT</code> statement to add rows to a table or view. In the following example, you add a row to the <code>EMP</code> table:</p>
<pre>EXEC SQL INSERT INTO EMP (EMPNO, ENAME, SAL, DEPTNO) 
 VALUES (:emp_number, :emp_name, :salary, :dept_number);
</pre>
<p><a id="sthref448"></a>Each column you specify in the column list must belong to the table named in the <a id="sthref449"></a><code>INTO</code> <a id="sthref450"></a>clause. The <code>VALUES</code> clause specifies the row of values to be inserted. The values can be those of constants, host variables, SQL expressions, or pseudocolumns, such as <code>USER</code> and <code>SYSDATE</code>.</p>
<p>The number of values in the <code>VALUES</code> clause must equal the number of names in the column list. However, you can omit the column list if the <code>VALUES</code> clause contains a value for each column in the table in the same order they were defined by <code>CREATE</code> <code>TABLE</code>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE275" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref451"></a>
<h3 class="sect2">Using Subqueries</h3>
<p>A <a id="sthref452"></a><span class="italic">subquery</span> is a nested <code>SELECT</code> statement. Subqueries let you conduct multipart searches. They can be used to</p>
<ul>
<li>
<p>supply values for comparison in the <code>WHERE</code>, <code>HAVING</code>, and <code>START</code> <code>WITH</code> clauses of <code>SELECT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements</p>
</li>
<li>
<p>define the set of rows to be inserted by a <code>CREATE</code> <code>TABLE</code> or <code>INSERT</code> statement</p>
</li>
<li>
<p>define values for the <code>SET</code> clause of an <code>UPDATE</code> statement</p>
</li>
</ul>
<p><a id="sthref453"></a><a id="sthref454"></a><a id="sthref455"></a>For <a id="sthref456"></a>example, to copy rows from one table to another, replace the <code>VALUES</code> clause in an <code>INSERT</code> statement with a subquery, as follows:</p>
<pre>EXEC SQL INSERT INTO EMP2 (EMPNO, ENAME, SAL, DEPTNO) 
 SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP 
 WHERE JOB = :job_title;
</pre>
<p>Notice how the <code>INSERT</code> statement uses the subquery to obtain intermediate results.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE276" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref457"></a>
<h3 class="sect2">Updating Rows</h3>
<p><a id="sthref458"></a>You use the <a id="sthref459"></a><a id="sthref460"></a><code>UPDATE</code> statement to change the values of specified columns in a table or view. In the following example, you update the <code>SAL</code> and <code>COMM</code> columns in the <code>EMP</code> table:</p>
<pre>EXEC SQL UPDATE EMP 
 SET SAL = :salary, COMM = :commission 
 WHERE EMPNO = :emp_number;
</pre>
<p>You can use the optional <code>WHERE</code> clause to specify the conditions under which rows are updated. See <a href="#BABDGBHG">&#34;Using the WHERE Clause&#34;</a>.</p>
<p><a id="sthref461"></a><a id="sthref462"></a><a id="sthref463"></a>The <a id="sthref464"></a><a id="sthref465"></a><code>SET</code> clause lists the names of one or more columns for which you must provide values. You can use a subquery to provide the values, as the following example shows:</p>
<pre>EXEC SQL UPDATE EMP 
 SET SAL = (SELECT AVG(SAL)*1.1 FROM EMP WHERE DEPTNO = 20) 
 WHERE EMPNO = :emp_number;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE277" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref466"></a>
<h3 class="sect2">Deleting Rows</h3>
<p><a id="sthref467"></a>You use the <code>DELETE</code> statement to remove rows from a table or view. In the following example, you delete all employees in a given department from the <code>EMP</code> table:</p>
<pre>EXEC SQL DELETE FROM EMP 
 WHERE DEPTNO = :dept_number;
</pre>
<p><a id="sthref468"></a>You can use the optional <code>WHERE</code> clause to specify the condition under which rows are deleted.</p>
</div>
<!-- class="sect2" -->
<a id="BABDGBHG"></a>
<div id="ZZPRE278" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the <a id="sthref469"></a>WHERE Clause</h3>
<p><a id="sthref470"></a>You use the <code>WHERE</code> clause to select, update, or delete only those rows in a table or view that meet your search condition. The <code>WHERE</code>-clause <span class="italic"><a id="sthref471"></a><a id="sthref472"></a>search condition</span> is a Boolean expression, which can include scalar host variables, host arrays (not in <code>SELECT</code> statements), and subqueries.</p>
<p>If you omit the <code>WHERE</code> clause, all rows in the table or view are processed. If you omit the <code>WHERE</code> clause in an <code>UPDATE</code> or <code>DELETE</code> statement, Oracle sets SQLWARN(5) in the SQLCA to &#39;W&#39; to warn that all rows were processed.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABICBCB"></a>
<div id="ZZPRE279" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Cursors</h2>
<p><a id="sthref473"></a>When a query returns multiple<a id="sthref474"></a> rows, you can explicitly define a cursor to:</p>
<ul>
<li>
<p>Process beyond the first row returned by the query</p>
</li>
<li>
<p>Keep track of which row is currently being processed</p>
</li>
</ul>
<p><a id="sthref475"></a>A cursor identifies the current row in the set of rows returned by the query. This allows your program to process the rows one at a time. The following statements let you define and manipulate a cursor:</p>
<ul>
<li>
<p><code>DECLARE</code></p>
</li>
<li>
<p><code>OPEN</code></p>
</li>
<li>
<p><code>FETCH</code></p>
</li>
<li>
<p><code>CLOSE</code></p>
</li>
</ul>
<p><a id="sthref476"></a>First <a id="sthref477"></a>you use the <code>DECLARE</code> statement to name the cursor and associate it with a query.</p>
<p>The <code>OPEN</code> statement executes the query and identifies all the rows that meet the query search condition. These rows form a set called the active set of the cursor. <a id="sthref478"></a>After opening the cursor, you can use it to retrieve the rows returned by its associated query.</p>
<p>Rows of the active set are retrieved one by one (unless you use host arrays). You use a <code>FETCH</code> statement to retrieve the current row in the active set. You can execute <code>FETCH</code> repeatedly until all rows have been retrieved.</p>
<p>When you complete fetching rows from the active set, you disable the cursor with a <code>CLOSE</code> statement, and the active set becomes undefined.</p>
<div id="ZZPRE280" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref479"></a>
<h3 class="sect2">Declaring a Cursor</h3>
<p><a id="sthref480"></a><a id="sthref481"></a>You use the <code>DECLARE</code> statement to define a cursor by giving it a name and associating it with a query, as the following example shows:</p>
<pre><a id="sthref482"></a>EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, EMPNO, SAL 
 FROM EMP 
 WHERE DEPTNO = :dept_number;
</pre>
<p><a id="sthref483"></a>The <a id="sthref484"></a>cursor name is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be defined in the Declare Section. Therefore, cursor names cannot be passed from one precompilation unit to another. Also, cursor names cannot be hyphenated. They can be any length, but only the first 31 characters are significant. For ANSI compatibility, use cursor names no longer than 18 characters.</p>
<p>The <code>SELECT</code> statement associated with the cursor cannot include an <code>INTO</code> clause. Rather, the <code>INTO</code> clause and list of output host variables are part of the <code>FETCH</code> statement.</p>
<p><a id="sthref485"></a>Because it is declarative, the <code>DECLARE</code> statement must physically (not just logically) precede all other SQL statements referencing the cursor. That is, <a id="sthref486"></a>forward references to the cursor are not allowed. In the following example, the <code>OPEN</code> statement is misplaced:</p>
<pre>EXEC SQL OPEN emp_cursor; -- misplaced OPEN statement
EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, EMPNO, SAL 
 FROM EMP 
 WHERE ENAME = :emp_name;
</pre>
<p>The cursor control statements must all occur within the same precompiled unit. For example, you cannot declare a cursor in file A, then open it in file B.</p>
<p>Your host program can declare as many cursors as it needs. However, in a given file, every <code>DECLARE</code> statement must be unique. That is, you cannot declare two cursors with the same name in one precompilation unit, even across blocks or procedures, because the scope<a id="sthref487"></a> of a cursor is global within a file.<a id="sthref488"></a> If you will be using many cursors, you might want to specify the <code>MAXOPENCURSORS</code> option. For more information, see <a href="ch_six.htm#BABFHDDH">&#34;MAXOPENCURSORS&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE281" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref489"></a>
<h3 class="sect2">Opening a Cursor</h3>
<p>Use the <a id="sthref490"></a><code>OPEN</code> statement to execute the query and identify the active set. In the following <a id="sthref491"></a>example, a cursor named <span class="italic">emp_cursor</span> is opened.</p>
<pre>EXEC SQL OPEN emp_cursor;
</pre>
<p><code>OPEN</code> positions the cursor just before the first row of the active set. It also zeroes the rows-processed count kept by SQLERRD(3) in the SQLCA. However, none of the rows is actually retrieved at this point. That will be done by the <code>FETCH</code> statement.</p>
<p>After you open a cursor, the query&#39;s input host variables are not reexamined until you reopen the cursor. Thus, the active set does not change. <a id="sthref492"></a>To change the active set, you must reopen the cursor.</p>
<p><a id="sthref493"></a>Generally, you should close a cursor before reopening it. However, if you specify <code><a id="sthref494"></a>MODE=ORACLE</code> (the default), you need not close a cursor before reopening it. This can boost performance; for details, see <a href="appc.htm#BABCHGDI">Appendix C, &#34;Performance Tuning&#34;</a></p>
<p>The amount of work done by OPEN depends on the values of three precompiler options: <code>HOLD_CURSOR, RELEASE_CURSOR</code>, and <code>MAXOPENCURSORS</code>. For more information, see <a href="ch_six.htm#CACJBGFE">&#34;Using the Precompiler Options&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE282" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref495"></a>
<h3 class="sect2">Fetching from a Cursor</h3>
<p>You use the <code>FETCH</code> statement to retrieve rows from the active set and specify the output host variables that will contain the results. Recall that the <code>SELECT</code> statement associated with the cursor cannot include an <code><a id="sthref496"></a>INTO</code> clause. Rather, the <code>INTO</code> clause and list of output host variables are part of the <code>FETCH</code> statement. In the following example, you fetch into three host variables:</p>
<pre>EXEC SQL FETCH emp_cursor 
 INTO :emp_name, :emp_number, :salary;
</pre>
<p>The cursor must have been previously declared and opened. The first time you execute <code>FETCH</code>, the cursor moves from before the first row in the active set to the first row. This row becomes the current row. Each subsequent execution of <code>FETCH</code> advances the cursor to the next row in the active set, changing the current row. The cursor can only move forward in the active set. To return to a row that has already been fetched, you must reopen the cursor, then begin again at the first row of the active set.</p>
<p><a id="sthref497"></a>If you want to change the active set, you must assign new values to the input host variables in the query associated with the cursor, then reopen the cursor. When <code>MODE={ANSI | ANSI14 | ANSI13}</code>, you must close the cursor before reopening it.</p>
<p>As the next example shows, you can fetch from the same cursor using different sets of output host variables. However, corresponding host variables in the <code>INTO</code> clause of each <code>FETCH</code> statement must have the same datatype.</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, SAL FROM EMP WHERE DEPTNO = 20; 
... 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND DO ... 
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name1, :salary1; 
 EXEC SQL FETCH emp_cursor INTO :emp_name2, :salary2; 
 EXEC SQL FETCH emp_cursor INTO :emp_name3, :salary3; 
 ... 
ENDLOOP;
</pre>
<p><a id="sthref498"></a>If <a id="sthref499"></a>the active set is empty or contains no more rows, <code>FETCH</code> returns the &#34;no data found&#34; Oracle warning code to <code>SQLCODE</code> in the SQLCA (or when MODE=ANSI, to the status variable <code>SQLSTATE</code>). The status of the output host variables is indeterminate. (In a typical program, the <code>WHENEVER NOT FOUND</code> statement detects this error.) To reuse the cursor, you must reopen it.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE283" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref500"></a>
<h3 class="sect2">Closing a Cursor</h3>
<p><a id="sthref501"></a>When finished fetching rows from the active set, you close the cursor to free the resources, such as storage, acquired by opening the cursor. When a cursor is closed, parse locks are released. What resources are freed depends on how you specify the options <code>HOLD_CURSOR</code> and <code>RELEASE_CURSOR</code>. In the following example, you close the cursor named <code>emp_cursor</code>:<a id="sthref502"></a></p>
<pre>EXEC SQL CLOSE emp_cursor;
</pre>
<p>You cannot fetch from a closed cursor because its active set becomes undefined. If necessary, you can reopen a cursor (with new values for the input host variables, for example).</p>
<p>When <code>MODE={ANSI13|ORACLE}</code>, issuing a commit or rollback closes cursors referenced in a <code>CURRENT OF</code> clause. Other cursors are unaffected by a commit or rollback and if open, remain open. However, when <code>MODE={ANSI|ANSI14}</code>, issuing a commit or rollback closes <span class="italic">all</span> explicit cursors.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE284" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref503"></a>
<h3 class="sect2">Using the CURRENT OF Clause</h3>
<p><a id="sthref504"></a>You use the <code>CURRENT OF</code> <span class="italic">cursor_name</span> clause in a <code>DELETE</code> or <code>UPDATE</code> statement to refer to the latest row fetched from the named cursor. The cursor must be open and positioned on a row. If no fetch has been done or if the cursor is not open, the <code>CURRENT OF</code> clause results in an error and processes no rows.</p>
<p>The <code>FOR UPDATE OF</code> clause is optional when you declare a cursor that is referenced in the <code>CURRENT OF</code> clause of an <code>UPDATE</code> or <code>DELETE</code> statement. The <code>CURRENT OF</code> clause signals the precompiler to add a <code>FOR UPDATE</code> clause if necessary. For more information, see <a href="ch_seven.htm#BABCGADJ">&#34;Using the FOR UPDATE OF Clause&#34;</a>.</p>
<p><a id="sthref505"></a>In the following example, you use the <code>CURRENT OF</code> clause to refer to the latest row fetched from a cursor named <span class="italic">emp_cursor</span>:</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, SAL FROM EMP WHERE JOB = &#39;CLERK&#39; 
 FOR UPDATE OF SAL; 
... 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND DO ... 
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary; 
 ... 
 EXEC SQL UPDATE EMP SET SAL = :new_salary 
 WHERE CURRENT OF emp_cursor; 
ENDLOOP;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE285" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref506"></a>
<h3 class="sect2">Restrictions</h3>
<p><a id="sthref507"></a>An explicit <code>FOR UPDATE OF</code> or an implicit <code>FOR UPDATE</code> acquires exclusive row locks. All rows are locked at the open, not as they are fetched, and are released when you commit or rollback. If you try to fetch from a <code>FOR UPDATE</code> cursor after a commit, Oracle generates the following error:</p>
<pre>ORA-01002: fetch out of sequence
</pre>
<p>You cannot use host arrays with the <code>CURRENT OF</code> clause. For an alternative, see <a href="ch_nine.htm#BGBCADBJ">&#34;Mimicking the CURRENT OF Clause&#34;</a>. Also, you cannot reference multiple tables in an associated <code>FOR UPDATE OF</code> clause, which means that you cannot do joins with the <code>CURRENT OF</code> clause. Finally, you cannot use the <code>CURRENT OF</code> clause in dynamic SQL.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE286" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref508"></a>
<h3 class="sect2">A Typical Sequence of Statements</h3>
<p>The following example shows the typical sequence of cursor control statements in an application program:</p>
<pre>-- Define a cursor.
EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, JOB FROM EMP 
 WHERE EMPNO = :emp_number 
 FOR UPDATE OF JOB; 

-- Open the cursor and identify the active set.
EXEC SQL OPEN emp_cursor; 
-- Exit if the last row was already fetched.
EXEC SQL WHENEVER NOT FOUND DO no_more; 

-- Fetch and process data in a loop.
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name, :job_title; 
 -- host-language statements that operate on the fetched data 
 EXEC SQL UPDATE EMP 
 SET JOB = :new_job_title 
 WHERE CURRENT OF emp_cursor; 
ENDLOOP; 
... 
ROUTINE no_more
BEGIN
-- Disable the cursor.
 EXEC SQL CLOSE emp_cursor; 
 EXEC SQL COMMIT WORK RELEASE; 
 exit program; 
END no_more;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE287" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref509"></a>
<h3 class="sect2">A Complete Example</h3>
<p>The following program illustrates the use of a cursor and the <code>FETCH</code> statement. The program prompts for a department number, then displays the names of all employees in that department.</p>
<p>All fetches except the final one return a row and, if no errors were detected during the fetch, a success status code. The final fetch fails and returns the &#34;no data found&#34; Oracle warning code to <code>SQLCODE</code> in the SQLCA. The cumulative number of rows actually fetched is found in <code>SQLERRD(3)</code> in the SQLCA.</p>
<pre>-- declare host variables 
EXEC SQL BEGIN DECLARE SECTION; 
 username CHARACTER(20); 
 password CHARACTER(20); 
 emp_name CHARACTER(10); 
 dept_number INTEGER; 
EXEC SQL END DECLARE SECTION; 
-- copy in the SQL Communications Area 
EXEC SQL INCLUDE SQLCA; 

display &#39;Username? &#39;; 
read username; 
display &#39;Password? &#39;; 
read password; 

-- handle processing errors 
EXEC SQL WHENEVER SQLERROR DO sql_error; 

-- log on to Oracle 
EXEC SQL CONNECT :username IDENTIFIED BY :password; 
display &#39;Connected to Oracle&#39;; 

-- declare a cursor 
EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME FROM EMP WHERE DEPTNO = :dept_number; 

display &#39;Department number? &#39;; 
read dept_number; 

-- open the cursor and identify the active set 
EXEC SQL OPEN emp_cursor; 

-- exit if the last row was already fetched 
EXEC SQL WHENEVER NOT FOUND DO no_more; 

display &#39;Employee Name&#39;; 
display &#39;-------------&#39;; 

-- fetch and process data in a loop 
LOOP 
 EXEC SQL FETCH emp_cursor INTO :emp_name; display emp_name; 
ENDLOOP;
ROUTINE no_more
BEGIN
 EXEC SQL CLOSE emp_cursor; 
 EXEC SQL COMMIT WORK RELEASE; 
 display &#39;End of program&#39;; 
 exit program; 
END no_more;

ROUTINE sql_error
BEGIN
 EXEC SQL WHENEVER SQLERROR CONTINUE; 
 EXEC SQL ROLLBACK WORK RELEASE; 
 display &#39;Processing error&#39;; 
 exit program with an error; 
END sql_error;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGGGHH"></a>
<div id="ZZPRE288" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Cursor Variables</h2>
<p>This section gives a brief overview of cursor variables. For more information, see your host language supplement and the <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>When using static embedded SQL with the Pro*COBOL and Pro*FORTRAN Precompilers, you can declare cursor variables. Like a cursor, a cursor variable points to the current row in the active set of a multi-row query. Cursors differ from cursor variables the way constants differ from variables. While a cursor is static, a cursor variable is dynamic, because it is not tied to a specific query. You can open a cursor variable for any type-compatible query.</p>
<p>Also, you can assign new values to a cursor variable and pass it as a parameter to subprograms, including subprograms stored in an Oracle database. This gives you a convenient way to centralize data retrieval.</p>
<p>First, you declare the cursor variable. After declaring the variable, you use four statements to control a cursor variable:</p>
<ul>
<li>
<p><code>ALLOCATE</code></p>
</li>
<li>
<p><code>OPEN ... FOR</code></p>
</li>
<li>
<p><code>FETCH</code></p>
</li>
<li>
<p><code>CLOSE</code></p>
</li>
</ul>
<p>After you declare the cursor variable and allocate memory for it, you must pass it as an input host variable (bind variable) to PL/SQL, OPEN it FOR a multi-row query on the server side, <code>FETCH</code> from it on the client side, then <code>CLOSE</code> it on either side.</p>
<div id="ZZPRE289" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref510"></a>
<h3 class="sect2">Declaring a Cursor Variable</h3>
<p>How you declare a cursor variable is dependent on your host language. For instructions about declaring a cursor variable, see your host-language supplement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZPRE290" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref511"></a>
<h3 class="sect2">Allocating a Cursor Variable</h3>
<p>You use the <code>ALLOCATE</code> statement to allocate memory for the cursor variable. The syntax follows:</p>
<pre>EXEC SQL ALLOCATE &lt;cursor_variable&gt;;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE291" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref512"></a>
<h3 class="sect2">Opening a Cursor Variable</h3>
<p><a id="sthref513"></a>You use the <a id="sthref514"></a><code>OPEN ... FOR</code> statement to associate a cursor variable with a multi-row query, execute the query, and identify the active set. The syntax follows:</p>
<pre>EXEC SQL OPEN &lt;cursor_variable&gt; FOR &lt;select_statement&gt;;
</pre>
<p>The <code>SELECT</code> statement can reference input host variables and PL/SQL variables, parameters, and functions but cannot be <code><a id="sthref515"></a>FOR UPDATE</code>. In the following example, you open a cursor variable named <span class="italic">emp_cv</span>:</p>
<pre>EXEC SQL OPEN emp_cv FOR SELECT * FROM EMP;
</pre>
<p><a id="sthref516"></a>You must open a cursor variable on the server side. You do that by passing it as an input host variable to an anonymous PL/SQL block. At run time, the block is sent to the Oracle Server for execution. In the following example, you declare and initialize a cursor variable, then pass it to a PL/SQL block, which opens the cursor variable:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
 ...
-- declare cursor variable
 emp_cur SQL_CURSOR;
EXEC SQL END DECLARE SECTION;
 
-- initialize cursor variable
EXEC SQL ALLOCATE :emp_cur;
 
EXEC SQL EXECUTE
 -- pass cursor variable to PL/SQL block
 BEGIN
 -- open cursor variable
 OPEN :emp_cur FOR SELECT * FROM EMP;
 END;
END-EXEC;
</pre>
<p>Generally, you pass a cursor variable to PL/SQL by calling a stored procedure that declares a cursor variable as one of its formal parameters. For example, the following packaged procedure opens a cursor variable named <span class="italic">emp_cv</span>:</p>
<pre>CREATE PACKAGE emp_data AS
 -- define REF CURSOR type
 TYPE EmpCurTyp IS REF CURSOR RETURN emp%ROWTYPE;
 -- declare formal paramter of that type
 PROCEDURE open_emp_cv (emp_cv IN OUT EmpCurTyp);
END emp_data;
 
CREATE PACKAGE BODY emp_data AS
 PROCEDURE open_emp_cv (emp_cv IN OUT EmpCurTyp) IS
 BEGIN
 -- open cursor variable
 OPEN emp_cv FOR SELECT * FROM emp;
 END open_emp_cv;
END emp_data;
</pre>
<p>You can call the procedure from any application, as follows:</p>
<pre>EXEC SQL EXECUTE
 BEGIN 
 emp_data.open_emp_cv(:emp_cur); 
 END; 
END-EXEC;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE292" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref517"></a>
<h3 class="sect2">Fetching from a Cursor Variable</h3>
<p><a id="sthref518"></a>After opening a cursor variable for a multi-row query, you use the <code>FETCH</code> statement to retrieve rows from the active set one at a time. The syntax follows:</p>
<pre>EXEC SQL FETCH cursor_variable_name 
 INTO {record_name | variable_name[, variable_name, ...]};
</pre>
<p>Each column value returned by the cursor variable is assigned to a corresponding field or variable in the <code><a id="sthref519"></a><a id="sthref520"></a>INTO</code> clause, providing their datatypes are compatible.</p>
<p><a id="sthref521"></a>The <code><a id="sthref522"></a>FETCH</code> statement must be executed on the client side. In the following <a id="sthref523"></a>example, you fetch rows into a host record named <span class="italic">emp_rec</span>:</p>
<pre>-- exit loop when done fetching
EXEC SQL WHENEVER NOT FOUND DO no_more;
LOOP
 -- fetch row into record
 EXEC SQL FETCH :emp_cur INTO :emp_rec; 
 -- process the data
ENDLOOP;
</pre></div>
<!-- class="sect2" -->
<div id="ZZPRE293" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref524"></a>
<h3 class="sect2">Closing a Cursor Variable</h3>
<p><a id="sthref525"></a>You use the <code><a id="sthref526"></a>CLOSE</code> statement to close a cursor variable, at which point its active set becomes undefined. The syntax follows:</p>
<pre>EXEC SQL CLOSE cursor_variable_name;
</pre>
<p>The <code>CLOSE</code> statement can be executed on the client side or the server side. In the following example, when the last row is processed, you close the cursor variable <span class="italic">emp_cur</span>:</p>
<pre>-- close cursor variable
EXEC SQL CLOSE :emp_cur;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3238">
<tr>
<td class="cellalignment3247">
<table class="cellalignment3243">
<tr>
<td class="cellalignment3242"><a href="ch_three.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3242"><a href="ch_five.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3249">
<table class="cellalignment3241">
<tr>
<td class="cellalignment3242"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3242"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3242"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3242"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3242"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3242"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>