<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-73898"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Object%20Programming"></a><title>Object Programming</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1082"/>
<meta name="dcterms.created" content="2016-06-01T12:8:10Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="C++ Call Interface Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E48221-07"/>
<meta name="dcterms.isVersionOf" content="LNCPP"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="relational.htm" title="Previous" type="text/html"/>
<link rel="Next" href="types.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E48221-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/54</span> <!-- End Header -->
<div id="LNCPP004" class="chapter"><a id="CIHDHCCH"></a> <a id="i1001003"></a>
<h1 class="chapter"><span class="secnum">4</span> Obje<a id="sthref204"></a>ct Programming</h1>
<p>This chapter provides information on how to implement object-relational programming using the Oracle C++ Call Interface (OCCI).</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1001705">Overview of Object Programming</a></p>
</li>
<li>
<p><a href="#i1003618">Working with Objects in C++ with OCCI</a></p>
</li>
<li>
<p><a href="#i1007093">Representing Objects in C++ Applications</a></p>
</li>
<li>
<p><a href="#CIHBEAFE">Developing a C++ Application using OCCI</a></p>
</li>
<li>
<p><a href="#BAJIEEHG">Migrating C++ Applications to Oracle Using OCCI</a></p>
</li>
<li>
<p><a href="#i1003644">Overview of Associative Access</a></p>
</li>
<li>
<p><a href="#i1007163">Overview of Navigational Access</a></p>
</li>
<li>
<p><a href="#i1009758">Overview of Complex Object Retrieval</a></p>
</li>
<li>
<p><a href="#i1003654">Working with Collections</a></p>
</li>
<li>
<p><a href="#i1007323">Using Object References</a></p>
</li>
<li>
<p><a href="#i1007327">Deleting Objects from the Database</a></p>
</li>
<li>
<p><a href="#CIHHEFEH">Type Inheritance</a></p>
</li>
<li>
<p><a href="#i1005035">A Sample OCCI Application</a></p>
</li>
</ul>
<a id="i1001705"></a>
<div id="LNCPP20143" class="sect1">
<h2 class="sect1">Overview of Object P<a id="sthref205"></a>rogramming</h2>
<p>OCCI supports both the associative and navigational style of data access. Traditionally, third-generation language (3GL) programs manipulate data stored in a database by using the <span class="bold">associative access</span> based on the associations organized by relational database tables. In associative access, data is manipulated by executing SQL statements and PL/SQL procedures. OCCI supports associative access to objects by enabling your applications to execute SQL statements and PL/SQL procedures on the database server without incurring the cost of transporting data to the client.</p>
<p>Object-oriented programs that use OCCI can also make use of <span class="bold">navigational access</span> that is a key aspect of this programming paradigm. Object relationships between objects are implemented as references (<code dir="ltr">REF</code>s). Typically, an object application that uses navigational access first retrieves one or more objects from the database server by issuing a SQL statement that returns <code dir="ltr">REF</code>s to those objects. The application then uses those <code dir="ltr">REF</code>s to traverse related objects, and perform computations on these other objects as required. Navigational access does not involve executing SQL statements, except to fetch the references of an initial set of objects. By using the OCCI APIs for navigational access, your application can perform the following functions on Oracle objects:</p>
<ul>
<li>
<p>Creating, accessing, locking, deleting, copying and flushing objects</p>
</li>
<li>
<p>Getting references to objects and navigating through the references</p>
</li>
</ul>
<p>This chapter gives examples that show you how to create a persistent object, access an object, modify an object, and flush the changes to the database server. It discusses how to access the object using both navigational and associative approaches.</p>
</div>
<!-- class="sect1" -->
<a id="i1003618"></a>
<div id="LNCPP20144" class="sect1">
<h2 class="sect1">Working with <a id="sthref206"></a>Objects in C++ with OCCI</h2>
<p>Many of the programming principles that govern a relational OCCI applications are identical for object-relational applications. An object-relational application uses the standard OCCI calls to establish database connections and process SQL statements. The difference is that the SQL statements that are issued retrieve object references, which can then be manipulated with OCCI object functions. An object can also be directly manipulated as a value (without using its object reference).</p>
<p>Instances of an Oracle type are categorized into <span class="bold">per<a id="sthref207"></a>sistent objects</span> and <span class="bold">trans<a id="sthref208"></a>ient objects</span> based on their lifetime. Instances of persistent objects can be further divided into <span class="bold">standalone objects</span> and <span class="bold">embedded objects</span> depending on whether they are referenced by way of an object identifier.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1001967">Persistent Objects</a></p>
</li>
<li>
<p><a href="#CIHBBCFJ">Transient Objects</a></p>
</li>
<li>
<p><a href="#BEIHJBBJ">Values</a></p>
</li>
</ul>
<a id="i1001967"></a>
<div id="LNCPP20145" class="sect2">
<h3 class="sect2">Persistent<a id="sthref209"></a> Objects</h3>
<p>A <span class="bold">persistent object</span> is an object which is stored in an Oracle database. It may be fetched into the object cache and modified by an OCCI application. The lifetime of a persistent object can exceed that of the application which is accessing it. There are two types of persistent objects:</p>
<ul>
<li>
<p>A <span class="bold">standa<a id="sthref210"></a>lone <a id="sthref211"></a>instance</span> is stored in a database table row, and has a unique object identifier. An OCCI application can retrieve a reference to a standalone object, pin the object, and navigate from the pinned object to other related objects. Standalone objects may also be referred to as <span class="bold">ref<a id="sthref212"></a>erenc<a id="sthref213"></a>eable objects</span>.</p>
<p>It is also possible to select a persistent object, in which case you fetch the object <span class="italic">by value</span> instead of fetching it by reference.</p>
</li>
<li>
<p>An <span class="bold">embed<a id="sthref214"></a>ded<a id="sthref215"></a> instance</span> is not stored in a database table row, but rather is embedded within another object. Examples of embedded objects are objects which are attributes of another object, or objects that exist in an object column of a database table. Embedded objects do not have object identifiers, and OCCI applications cannot get <code dir="ltr">REF</code>s to embedded instances.</p>
<p>Embedded objects may also be referred to as <span class="bold">no<a id="sthref216"></a>nreferencea<a id="sthref217"></a>ble objects</span> or <span class="bold">value instances</span>. You may sometimes see them referred to as <span class="bold">values</span>, which is not to be confused with scalar data values. The context should make the meaning clear.</p>
</li>
</ul>
<p>Users do not have to explicitly delete persistent objects that have been materialized through references.</p>
<p>Users should delete persistent objects created by application when the transactions are rolled back</p>
<p>The SQL examples, <a href="#BEICJAAH">Example 4-1</a> and <a href="#BEIIABGC">Example 4-2</a>, demonstrate the difference between these two types of persistent objects.</p>
<div id="LNCPP20146" class="example">
<p class="titleinexample"><a id="BEICJAAH"></a>Example 4-1 <a id="sthref218"></a><a id="sthref219"></a>Creating Standalone Objects</p>
<p>Objects that are stored in the object table <code dir="ltr">person_tab</code> are standalone objects. They have object identifiers and can be referenced. They can be pinned in an OCCI application.</p>
<pre dir="ltr">CREATE TYPE person_t AS OBJECT
   (name      varchar2(30),
    age       number(3));
CREATE TABLE person_tab OF person_t;
</pre></div>
<!-- class="example" -->
<div id="LNCPP20147" class="example">
<p class="titleinexample"><a id="BEIIABGC"></a>Example 4-2 Creating Em<a id="sthref220"></a>bedded Objects</p>
<p>Objects which are stored in the <code dir="ltr">manager</code> column of the <code dir="ltr">department</code> table are embedded objects. They do not have object identifiers, and they cannot be referenced. Therefore, they cannot be pinned in an OCCI application, and they also never have to be unpinned. They are always retrieved into the object cache <span class="italic">by value</span>.</p>
<pre dir="ltr">CREATE TABLE department
   (deptno     number,
    deptname   varchar2(30),
    manager    person_t);
</pre>
<p>The Array Pin feature allows a vector of references to be dereferenced in one round-trip to return a vector of the corresponding objects. A new global method, <code dir="ltr">pinVectorOfRefs()</code>, takes a vector of <code dir="ltr">Ref</code>s and populates a vector of <code dir="ltr">PObject</code>s in a single round-trip, saving the cost of pinning <code dir="ltr">n-1</code> references in <code dir="ltr">n-1</code> round-trips.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHBBCFJ"></a>
<div id="LNCPP20148" class="sect2">
<h3 class="sect2">Transient Obje<a id="sthref221"></a>cts</h3>
<p>A transient object is an instance of an object type. Its lifetime cannot exceed that of the application. The application can also delete a transient object at any time.</p>
<p>The Object Type Translator (OTT) utility generates two <code dir="ltr">operator new</code> methods for each C++ class, as demonstrated in <a href="#BEIDGFBH">Two Methods for Operator new() in the Object Type Translator Utility</a><a href="#BEIDGFBH">Example 4-3</a>:</p>
<div id="LNCPP20149" class="example">
<p class="titleinexample"><a id="BEIDGFBH"></a>Example 4-3 Two Methods for Operator new() in the Object Type Translator Utility</p>
<pre dir="ltr">class Person : public PObject {
   ...
public:
   dvoid *operator new(size_t size);    // creates transient instance
   dvoid *operator new(size_t size, Connection &amp;conn, string table);
                                        // creates persistent instance
}
</pre></div>
<!-- class="example" -->
<p><a href="#BEICGCBD">Example 4-4</a> demonstrates how to dynamically create a transient object. Transient objects cannot be converted to persistent objects. Their role is fixed at the time they are instantiated, and it is your responsibility to free memory by deleting transient objects.</p>
<div id="LNCPP20150" class="example">
<p class="titleinexample"><a id="BEICGCBD"></a>Example 4-4 How to Dynamically Create a Transient Object</p>
<pre dir="ltr">Person *p = new P<a id="sthref222"></a>erson();
</pre></div>
<!-- class="example" -->
<p>A transient object can also be created on the stack as a local variable, as demonstrated in <a href="#BEIGDIHD">Example 4-5</a>. The latter approach guarantees that the transient object is destroyed when the scope of the variable ends.</p>
<div id="LNCPP20151" class="example">
<p class="titleinexample"><a id="BEIGDIHD"></a>Example 4-5 How to Create a Transient Object as a Local Variable</p>
<pre dir="ltr">Person p;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink CNCPT88817" href="../CNCPT/tablecls.htm#CNCPT88817"><span class="italic">Oracle Database Concepts</span></a> for more information about objects</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BEIHJBBJ"></a>
<div id="LNCPP20152" class="sect2">
<h3 class="sect2">Val<a id="sthref223"></a>ues<a id="sthref224"></a></h3>
<p>In this manual, a <span class="bold">value</span> refers to either:</p>
<ul>
<li>
<p>A scalar value which is stored in a non-object column of a database table. An OCCI application can fetch values from a database by issuing SQL statements.</p>
</li>
<li>
<p>An embedded (nonreferenceable) object.</p>
</li>
</ul>
<p>The context should make it clear which meaning is intended.</p>
<p>It is possible to <code dir="ltr">SELECT</code> a referenceable object into the object cache, rather than pinning it, in which case you fetch the object <span class="italic">by value</span> instead of fetching it by reference.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007093"></a>
<div id="LNCPP20153" class="sect1">
<h2 class="sect1">Representing Objects in C++ Applications</h2>
<p>Before an OCCI application can work with object types, those types must exist in the database. Typically, you create types with SQL DDL statements, such as <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code>.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#BEIDADDJ">Creating Persistent and Transient Objects</a></p>
</li>
<li>
<p><a href="#BEICIDEE">Creating Object Representations using the OTT Utility</a></p>
</li>
</ul>
<a id="BEIDADDJ"></a>
<div id="LNCPP20154" class="sect2">
<h3 class="sect2">Creating Persistent and Transient Objects</h3>
<p>This section discusses how persistent and transient objects are created.</p>
<p>Before you create a persistent object, you must have created the environment and opened a connection.</p>
<p>A persistent object is created in the database only when one of the following occurs:</p>
<ul>
<li>
<p>The transaction is committed (<code dir="ltr">Connection::commit()</code>)</p>
</li>
<li>
<p>The object cache is flushed (<code dir="ltr">Connection::flushCache()</code>)</p>
</li>
<li>
<p>The object itself is flushed (<code dir="ltr">PObject::flush()</code>)</p>
</li>
</ul>
<p><a href="#BEIJIHDH">Example 4-6</a> shows how to create a persistent object, <code dir="ltr">addr</code>, in the database table, <code dir="ltr">addr_tab</code>.</p>
<div id="LNCPP20155" class="example">
<p class="titleinexample"><a id="BEIJIHDH"></a>Example 4-6 How to Create a <a id="sthref225"></a>Persistent Object</p>
<pre dir="ltr">CREATE TYPE ADDRESS AS OBJECT (
   state CHAR(2), 
   zip_code CHAR(5));
CREATE TABLE ADDR_TAB of ADDRESS;
ADDRESS *addr = new(conn, &#34;ADDR_TAB&#34;) ADDRESS(&#34;CA&#34;, &#34;94065&#34;);
</pre></div>
<!-- class="example" -->
<p><a href="#BEIFGGJJ">Example 4-7</a> shows hot to create an instance of the transient object <code dir="ltr">ADDRESS</code>.</p>
<div id="LNCPP20156" class="example">
<p class="titleinexample"><a id="BEIFGGJJ"></a>Example 4-7 How to Create a <a id="sthref226"></a>Transient Object</p>
<pre dir="ltr">ADDRESS *addr_trans = new ADDRESS(&#34;MD&#34;, &#34;94111&#34;);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BEICIDEE"></a>
<div id="LNCPP20157" class="sect2">
<h3 class="sect2">Creating Object Representations using the OTT Utility</h3>
<p>When your C++ application retrieves instances of object types from the database, it must have a client-side representation of the objects. The Object Type Translator (OTT) utility generates C++ class representations of database object types for you. <a href="#BEIGDFED">Example 4-8</a> shows the declaration of a custom type in the database, and the corresponding C++ class that the OTT utility generates.</p>
<div id="LNCPP21904" class="example">
<p class="titleinexample"><a id="BEIGDFED"></a>Example 4-8 How to Declare a Custom Type in the Database</p>
<pre dir="ltr">CREATE TYPE address AS OBJECT (state CHAR(2), zip_code CHAR(5));
</pre>
<p>The OTT utility produces the following C++ class:</p>
<pre dir="ltr">class ADDRESS : public PObject {

   protected:
      string state;
      string zip;

   public:
      void *operator new(size_t size); 
      void *operator new(size_t size, 
         const Connection* conn, 
         const string&amp; table);
      string  getSQLTypeName() const;
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      ADDRESS(void *ctx) : PObject(ctx) { };
      static void *readSQL(void *ctx);
      virtual void readSQL(AnyData&amp; stream);
      static void writeSQL(void *obj, void *ctx);
      virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
<!-- class="example" -->
<p>These class declarations in <a href="#BEIGDFED">Example 4-8</a> are automatically written by OTT to a header file that you name. This header file is included in the source files for an application to provide access to objects. Instances of a <code dir="ltr">PObject</code> (and also instances of classes derived from <code dir="ltr">PObject</code>s) can be either transient or persistent. The methods <code dir="ltr">writeSQL()</code> and <code dir="ltr">readSQL()</code> are used internally by the OCCI object cache to linearize and delinearize the objects and are not to be used or modified by OCCI clients.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ottutility.htm#CHDBCDBH">Chapter 8, &#34;Object Type Translator Utility&#34;</a> for more information about the OTT utility</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHBEAFE"></a>
<div id="LNCPP20158" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Developing <a id="sthref227"></a>a C++ Application using OCCI</h2>
<p>This section discusses the steps involved in developing a basic OCCI object application.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1007455">Basic Object Program Structure</a></p>
</li>
<li>
<p><a href="#BEICAJHJ">Basic Object Operational Flow</a></p>
</li>
</ul>
<a id="i1007455"></a>
<div id="LNCPP20159" class="sect2">
<h3 class="sect2">Basic Obj<a id="sthref228"></a>ect Program Structure</h3>
<p>The basic structure of an OCCI application that uses objects is similar to a relational OCCI application, the difference being object functionality. The steps involved in an OCCI object program include:</p>
<ol>
<li>
<p>Initialize the <code dir="ltr">Environment</code>. Initialize the OCCI programming environment in object mode. Your application must include C++ class representations of database objects in a header file. You can create these classes by using the Object Type Translator (OTT) utility, as described in <a href="ottutility.htm#CHDBCDBH">Chapter 8, &#34;Object Type Translator Utility&#34;</a>.</p>
</li>
<li>
<p>Establish a Connection. Use the environment handle to establish a connection to the database server.</p>
</li>
<li>
<p>Prepare a SQL statement. This is a local (client-side) step, which may include binding placeholders. In an object-relational application, this SQL statement should return a reference (<code dir="ltr">REF</code>) to an object.</p>
</li>
<li>
<p>Access the object.</p>
<ol>
<li>
<p>Associate the prepared statement with a database server, and execute the statement.</p>
</li>
<li>
<p>By using navigational access, retrieve an object reference (<code dir="ltr">REF</code>) from the database server and pin the object. You can then perform some or all of the following:</p>
<ul>
<li>
<p>Manipulate the attributes of an object and mark it as <span class="bold">dirty</span> (modified)</p>
</li>
<li>
<p>Follow a reference to another object or series of objects</p>
</li>
<li>
<p>Access type and attribute information</p>
</li>
<li>
<p>Navigate a complex object retrieval graph</p>
</li>
<li>
<p>Flush modified objects to the database server</p>
</li>
</ul>
</li>
<li>
<p>By using associative access, you can fetch an entire object <span class="italic">by value</span> by using SQL. Alternately, you can select an embedded (nonreferenceable) object. You can then perform some or all of the following:</p>
<ul>
<li>
<p>Insert values into a table</p>
</li>
<li>
<p>Modify existing values</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Commit the transaction. This step implicitly writes all modified objects to the database server and commits the changes.</p>
</li>
<li>
<p>Free statements and handles; the prepared statements should not be used or executed again.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="relational.htm#CHDJCICB">Chapter 3, &#34; Accessing Oracle Database Using C++&#34;</a> for information about using OCCI to connect to a database server, process SQL statements, and allocate handles</p>
</li>
<li>
<p><a href="ottutility.htm#CHDBCDBH">Chapter 8, &#34;Object Type Translator Utility&#34;</a> for information about the OTT utility</p>
</li>
<li>
<p><a href="reference.htm#CIAJIDCF">Chapter 13, &#34;OCCI Application Programming Interface&#34;</a> for descriptions of OCCI relational functions and the <code dir="ltr">Connect</code> class and the <code dir="ltr">getMetaData()</code> method</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BEICAJHJ"></a>
<div id="LNCPP20160" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Basic Ob<a id="sthref229"></a>ject Operational Flow</h3>
<p>Figure&nbsp;3-1 shows a simple program logic flow for how an application might work with objects. For simplicity, some required steps are omitted.</p>
<div id="LNCPP20161" class="figure">
<p class="titleinfigure"><a id="sthref230"></a>Figure 4-1 Basic Object Operational Flow</p>
<img width="235" height="303" src="img/object_operational_flow.gif" alt="Description of Figure 4-1 follows"/><br/>
<a id="sthref231" href="img_text/object_operational_flow.htm">Description of &#39;&#39;Figure 4-1 Basic Object Operational Flow&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The steps shown in Figure&nbsp;3-1 are discussed in the following sections:</p>
<a id="i1003634"></a>
<div id="LNCPP20162" class="sect3">
<h4 class="sect3">Initialize OCCI i<a id="sthref232"></a><a id="sthref233"></a>n Object Mode</h4>
<p>If your OCCI application accesses and manipulates objects, then it is essential that you specify a value of <code dir="ltr">OBJECT</code> for the <code dir="ltr">mode</code> parameter of the <code dir="ltr">createEnvironment()</code> method, the first call in any OCCI application. Specifying this value for <code dir="ltr">mode</code> indicates to OCCI that your application works with objects. This notification has the following important effects:</p>
<ul>
<li>
<p>The object run-time environment is established.</p>
</li>
<li>
<p>The object cache is set up.</p>
</li>
</ul>
<p>Note that ithe <code dir="ltr">mode</code> parameter is not set to <code dir="ltr">OBJECT</code>, any attempt to use an object-related function results in an error.</p>
<p>The following code example demonstrates how to specify the <code dir="ltr">OBJECT</code> <code dir="ltr">mode</code> when creating an OCCI environment:</p>
<pre dir="ltr">Environment *env;
Connection *con;
Statement *stmt;

env = Environment::createEnvironment(Environment::OBJECT);
con = Connection(userName, password, connectString);
</pre>
<p>Your application does not have to allocate memory when database objects are loaded into the object cache. The object cache provides transparent and efficient memory management for database objects. When database objects are loaded into the object cache, they are transparently mapped into the host language (C++) representation.</p>
<p>The object cache<a id="sthref234"></a> maintains the association between the object copy in the object cache and the corresponding database object. Upon <code dir="ltr">commit</code>, changes made to the object copy in the object cache are automatically propagated back to the database.</p>
<p>The object cache maintains a look-up table for mapping references to objects. When an application dereferences a reference to an object and the corresponding object is not yet cached in the object cache, the object cache automatically sends a request to the database server to fetch the object from the database and load it into the object cache. Subsequent dereferences of the same reference are faster since they are to the object cache itself and do not incur a round-trip to the database server.</p>
<p>Subsequent dereferences of the same reference fetch from the cache instead of requiring a round-trip. The exception to this is in a dereferencing operation that occurs just after a commit. In this case, the latest object copy from the server is returned. This ensures that the latest object from the database is cached after each transaction.</p>
<p>The object cache maintains a pin count for each persistent object in the object cache. When an application dereferences a reference to an object, the pin count of the object is incremented. The subsequent dereferencing of the same reference to the object does not change the pin count. Until the reference to the object goes out of scope, the object continues to be pinned in the object cache and be accessible by the OCCI client.</p>
<p>The pin count functions as a reference count for the object. The pin count of the object becomes zero (<code dir="ltr">0</code>) only when there are no more references referring to this object, during which time the object becomes eligible for garbage collection. The object cache uses a least recently used algorithm to manage the size of the object cache. This algorithm frees objects with a pin count of 0 when the object cache reaches the maximum size.</p>
</div>
<!-- class="sect3" -->
<a id="i1010314"></a>
<div id="LNCPP20163" class="sect3">
<h4 class="sect3">Pin <a id="sthref235"></a><a id="sthref236"></a>Object</h4>
<p>In most situations, OCCI users do not have to explicitly pin or unpin the objects because the object cache automatically keeps track of the pin counts of all the objects in the cache. As explained earlier, the object cache increments the pin count when a reference points to the object and decrements it when the reference goes out of scope or no longer points to the object.</p>
<p>But there is one exception. If an OCCI application uses <code dir="ltr">Ref&lt;T&gt;::ptr()</code> method to get a pointer to the object, then the <code dir="ltr">pin</code> and <code dir="ltr">unpin</code> methods of the <code dir="ltr">PObject</code> class can be used by the application to control pinning and unpinning of the objects in the object cache.</p>
</div>
<!-- class="sect3" -->
<div id="LNCPP20164" class="sect3"><a id="sthref237"></a>
<h4 class="sect3">Operate on Objec<a id="sthref238"></a>t in Cache</h4>
<p>Note that the object cache does not manage the contents of object copies; it does not automatically refresh object copies. Your application must ensure the validity and consistency of object copies.</p>
</div>
<!-- class="sect3" -->
<div id="LNCPP20165" class="sect3"><a id="sthref239"></a>
<h4 class="sect3">Flush Chang<a id="sthref240"></a>es to Object</h4>
<p>Whenever changes are made to object copies in the object cache, your application is responsible for flushing the changed object to the database.</p>
<p>Memory for the object cache is allocated on demand when objects are loaded into the object cache.</p>
<p>The client-side object cache is allocated in the program&#39;s process space. This object cache is the memory for objects that have been retrieved from the database server and are available to your application.</p>
<p>If you initialize the OCCI environment in object mode, your application allocates memory for the object cache, whether the application actually uses object calls.</p>
<p>There is only one object cache allocated for each OCCI environment. All objects retrieved or created through different connections within the environment use the same physical object cache. Each connection has its own logical object cache.</p>
</div>
<!-- class="sect3" -->
<a id="i1010645"></a>
<div id="LNCPP20166" class="sect3">
<h4 class="sect3">Deletion of an Object</h4>
<p>For objects retrieved into the cache by dereferencing a reference, you should not perform an explicit delete. For such objects, the pin count is incremented when a reference is dereferenced for the first time and decremented when the reference goes out of scope. When the pin count of the object becomes <code dir="ltr">0</code>, indicating that all references to that object are out of scope, the object is automatically eligible for garbage collection and subsequently deleted from the cache.</p>
<p>For persistent objects that have been created by calling the <code dir="ltr">new</code> operator, you must call a <code dir="ltr">delete</code> if you do not commit the transaction. Otherwise, the object is garbage collected after the commit. This is because when such an object is created using <code dir="ltr">new</code>, its pin count is initially <code dir="ltr">0</code>. However, because the object is dirty it remains in the cache. After a commit, it is no longer dirty and thus garbage collected. Therefore, a delete is not required.</p>
<p>If a commit is not performed, then you must explicitly call <code dir="ltr">delete</code> to destroy that object. You can do this if there are no references to that object. For transient objects, you must delete explicitly to destroy the object.</p>
<p>You should not call a delete operator on a persistent object. A persistent object that is not marked/dirty is freed by the garbage collector when its pin count is 0. However, for transient objects you must delete explicitly to destroy the object.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BAJIEEHG"></a>
<div id="LNCPP20167" class="sect1">
<h2 class="sect1">Migrating C++ Applications to Oracle Using OCCI</h2>
<p>This section describes how to migrate existing C++ applications using OCCI.</p>
<p>The steps of migration are:</p>
<ol>
<li>
<p>Determine object model and class hierarchy</p>
</li>
<li>
<p>Use JDeveloper9<span class="italic">i</span> to map to Oracle object schema</p>
</li>
<li>
<p>Generate C++ header files using Oracle Type Translator</p>
</li>
<li>
<p>Modify old C++ access classes as required to work with new object type definitions</p>
</li>
<li>
<p>Add functionality for transient and persistent object management, as required.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1003644"></a>
<div id="LNCPP20169" class="sect1">
<h2 class="sect1">Overview of <a id="sthref241"></a>Associative Access</h2>
<p>You can employ SQL within OCCI to retrieve objects, and to perform DML operations.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1003409">Using SQL to Access Objects</a></p>
</li>
<li>
<p><a href="#i1003414">Inserting and Modifying Values</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</div>
</li>
</ul>
<a id="i1003409"></a>
<div id="LNCPP20170" class="sect2">
<h3 class="sect2">Using SQL to Ac<a id="sthref242"></a>cess Objects</h3>
<p>In the previous sections we discussed navigational access, where SQL is used only to fetch the references of an initial set of objects and then navigate from them to the other objects. Here we discuss how to fetch the objects using SQL.</p>
<p>The following example shows how to use the <code dir="ltr">ResultSet::getObject()</code> method to fetch objects through associative access where it gets each object from the table, <code dir="ltr">addr_tab</code>, using SQL:</p>
<pre dir="ltr">string sel_addr_val = &#34;SELECT VALUE(address) FROM ADDR_TAB address&#34;;

ResultSet *rs = stmt-&gt;executeQuery(sel_addr_val);

while (rs-&gt;next())
{
   ADDRESS *addr_val = rs-&gt;getObject(1); 
   cout &lt;&lt; &#34;state: &#34; &lt;&lt; addr_val-&gt;getState();
}
</pre>
<p>The objects fetched through associative access are termed value instances and they behave just like transient objects. Methods such as <code dir="ltr">markModified()</code>, <code dir="ltr">flush()</code>, and <code dir="ltr">markDeleted()</code> are applicable only for persistent objects.</p>
<p>Any changes made to these objects are not reflected in the database.</p>
<p>Since the object returned is a value instance, it is the user&#39;s responsibility to free memory by deleting the object pointer.</p>
</div>
<!-- class="sect2" -->
<a id="i1003414"></a>
<div id="LNCPP20171" class="sect2">
<h3 class="sect2">Inserting and<a id="sthref243"></a> Modifying Values</h3>
<p>We have just seen how to use SQL to access objects. OCCI also provides the ability to use SQL to insert new objects or modify existing objects in the database server through the <code dir="ltr">Statement::setObject</code> method interface.</p>
<p><a id="sthref244"></a>The following example creates a transient object <code dir="ltr">Address</code> and inserts it into the database table <code dir="ltr">addr_tab</code>:</p>
<pre dir="ltr">ADDRESS *addr_val = new address(&#34;NV&#34;, &#34;12563&#34;);  // new a transient instance
stmt-&gt;setSQL(&#34;INSERT INTO ADDR_TAB values(:1)&#34;);
stmt-&gt;setObject(1, addr_val);
stmt-&gt;execute();
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007163"></a>
<div id="LNCPP20172" class="sect1">
<h2 class="sect1">Overvi<a id="sthref245"></a>ew of Navigational Access</h2>
<p>By using navigational access, you engage in a series of operations.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1007201">Retrieving an Object Reference (REF) from the Database Server</a></p>
</li>
<li>
<p><a href="#i1007233">Pinning an Object</a></p>
</li>
<li>
<p><a href="#i1007266">Manipulating Object Attributes</a></p>
</li>
<li>
<p><a href="#i1007278">Marking Objects and Flushing Changes</a></p>
</li>
<li>
<p><a href="#BEIJBGGE">Marking an Object as Modified (Dirty)</a></p>
</li>
<li>
<p><a href="#BEIDBGDH">Recording Changes in the Database</a></p>
</li>
<li>
<p><a href="#i1010647">Collecting Garbage in the Object Cache</a></p>
</li>
<li>
<p><a href="#i1010648">Ensuring Transactional Consistency of References</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</div>
</li>
</ul>
<a id="i1007201"></a>
<div id="LNCPP20173" class="sect2">
<h3 class="sect2">Retrieving an Object Reference (REF) from the Database Server</h3>
<p>To work with objects, your application must first retrieve one or more objects from the database server. You accomplish this by issuing a SQL statement that returns references (<code dir="ltr">REF</code>s) to one or more objects.</p>
<p>It is also possible for a SQL statement to fetch value instances, rather than <code dir="ltr">REF</code>s, from a database.</p>
<p>The following SQL statement retrieves a <code dir="ltr">REF</code> to a single object <code dir="ltr">address</code> from the database table <code dir="ltr">addr_tab</code>:</p>
<pre dir="ltr">string sel_addr = &#34;SELECT REF(address) 
   FROM addr_tab address 
   WHERE zip_code = &#39;94065&#39;&#34;;
</pre>
<p>The following code example illustrates how to execute the query and fetch the <code dir="ltr">REF</code> from the result set.</p>
<pre dir="ltr">ResultSet *rs = stmt-&gt;executeQuery(sel_addr);
rs-&gt;next();
Ref&lt;address&gt; addr_ref = rs-&gt;getRef(1);
</pre>
<p>At this point, you could use the object reference to access and manipulate the object or objects from the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="relational.htm#CHDHCIGI">&#34;Executing SQL DDL and DML Statements&#34;</a> for general information about preparing and executing SQL statements</div>
</div>
<!-- class="sect2" -->
<a id="i1007233"></a>
<div id="LNCPP20174" class="sect2">
<h3 class="sect2">Pinning an <a id="sthref246"></a><a id="sthref247"></a>Object<a id="sthref248"></a></h3>
<p>This section deals with a simple pin operation involving a single object at a time. For information about retrieving multiple objects through complex object retrieval, see the section <a href="#i1009758">Overview of Complex Object Retrieval</a>.</p>
<p>Upon completion of the fetch step, your application has a <code dir="ltr">REF</code> to an object. The actual object is not currently available to work with. Before you can manipulate an object, it must be <span class="bold">pinn<a id="sthref249"></a>ed</span>. Pinning an object loads the object into the object cache, and enables you to access and modify the object&#39;s attributes and follow references from that object to other objects. Your application also controls when modified objects are written back to the database server.</p>
<p>OCCI requires only that you dereference the <code dir="ltr">REF</code> in the same way you would dereference any C++ pointer. Dereferencing the <code dir="ltr">REF</code> transparently materializes the object as a C++ class instance.</p>
<p>Continuing the <code dir="ltr">Address</code> class example from the previous section, assume that the user has added the following method:</p>
<pre dir="ltr">string  Address::getState()
{
   return state;
}
</pre>
<p>To dereference this <code dir="ltr">REF</code> and access the object&#39;s attributes and methods:</p>
<pre dir="ltr">string state = addr_ref-&gt;getState();     // -&gt; pins the object
</pre>
<p>The first time <code dir="ltr">Ref&lt;T&gt;</code> <code dir="ltr">(addr_ref)</code> is dereferenced, the object is pinned, which is to say that it is loaded into the object cache from the database server. From then on, the behavior of operator <code dir="ltr">-&gt;</code> on <code dir="ltr">Ref&lt;T&gt;</code> is just like that of any C++ pointer <code dir="ltr">(T *)</code>. The object remains in the object cache until the <code dir="ltr">REF</code> <code dir="ltr">(addr_ref)</code> goes out of scope. It then becomes eligible for garbage collection.</p>
<p>Now that the object has been pinned, your application can modify that object.</p>
</div>
<!-- class="sect2" -->
<a id="i1007266"></a>
<div id="LNCPP20175" class="sect2">
<h3 class="sect2">Manipula<a id="sthref250"></a><a id="sthref251"></a>ting Object Attributes</h3>
<p>Manipulating object attributes is no different from that of accessing them as shown in the previous section. Let us assume the <code dir="ltr">Address</code> class has the following user defined method that sets the <code dir="ltr">state</code> attribute to the input value:</p>
<pre dir="ltr">void Address::setState(string new_state)
{
   state = new_state;
}
</pre>
<p>The following example shows how to modify the state attribute of the object, <code dir="ltr">addr</code>:</p>
<pre dir="ltr">addr_ref-&gt;setState(&#34;PA&#34;);
</pre>
<p>As explained earlier, the first invocation of the operator <code dir="ltr">-&gt;</code> on <code dir="ltr">Ref&lt;T&gt;</code> loads the object, if it is not in the object cache.</p>
</div>
<!-- class="sect2" -->
<a id="i1007278"></a>
<div id="LNCPP20176" class="sect2">
<h3 class="sect2">Marking O<a id="sthref252"></a>b<a id="sthref253"></a>jects and Flushing Changes</h3>
<p>In the example in the previous section, an attribute of an object was changed. This change exists only in the client-side cache; you must implement specific programmatic steps to write the changes to the database.</p>
</div>
<!-- class="sect2" -->
<a id="BEIJBGGE"></a>
<div id="LNCPP20177" class="sect2">
<h3 class="sect2">Marking an<a id="sthref254"></a> Object as Modified (Dirty)</h3>
<p>The first step is to indicate that the object has been modified. This is done by calling the <code dir="ltr">markModified()</code> method on the object (derived method of <code dir="ltr">PObject</code>). This method marks the object as <span class="bold">dirty</span> (modified).</p>
<p>Continuing the previous example, after object attributes are manipulated, the object referred to by <code dir="ltr">addr_ref</code> can be marked dirty as follows:</p>
<pre dir="ltr">addr_ref-&gt;markModified();
</pre></div>
<!-- class="sect2" -->
<a id="BEIDBGDH"></a>
<div id="LNCPP20178" class="sect2">
<h3 class="sect2">Recording Changes in<a id="sthref255"></a> the Database</h3>
<p>Objects that have had their dirty flag set must be flushed to the database server for the changes to be recorded in the database. This can be done in three ways:</p>
<ul>
<li>
<p>Flush a single object marked dirty by calling the method <code dir="ltr">flush</code>, a derived method of <code dir="ltr">PObject</code>.</p>
</li>
<li>
<p>Flush the entire object cache using the <code dir="ltr">Connection::flushCache()</code> method. In this case, OCCI traverses the dirty list maintained by the object cache and flushes all the dirty objects.</p>
</li>
<li>
<p>Commit a transaction by calling the <code dir="ltr">Connection::commit()</code> method. Doing so also traverses the dirty list and flushes the objects to the database server. The dirty list includes newly created persistent objects.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1010647"></a>
<div id="LNCPP20179" class="sect2">
<h3 class="sect2">Collecting Garbage in the Object Cache</h3>
<p>The object cache has two important associated parameters:</p>
<ul>
<li>
<p>The maximum cache size percentage</p>
</li>
<li>
<p>The optimal cache size</p>
</li>
</ul>
<p>These parameters refer to levels of cache memory usage, and they help determine when the cache automatically &#39;ages out&#39; eligible objects to free up memory.</p>
<p>If the memory occupied by the objects currently in the cache reaches or exceeds the maximum cache size, the cache automatically begins to free (or age out) unmarked objects which have a pin count of zero. The cache continues freeing such objects until memory usage in the cache reaches the optimal size, or until it runs out of objects eligible for freeing. Note that the cache can grow beyond the specified maximum cache size.</p>
<p>The maximum object cache size (in bytes) is computed by incrementing the optimal cache size (<code dir="ltr">optimal_size</code>) by the maximum cache size percentage (<code dir="ltr">max_size_percentage</code>), as follows:</p>
<pre dir="ltr">Maximum cache size = optimal_size + optimal_size * max_size_percentage / 100;
</pre>
<p>The default value for the maximum cache size percentage is 10%. The default value for the optimal cache size is 8MB. When a persistent object is created through the overloaded <code dir="ltr">PObject::new()</code> operator, the newly created object is marked dirty and its pin count is set to <code dir="ltr">0</code>.</p>
<p>These parameters can be set or retrieved using the following member functions of the Environment class:</p>
<ul>
<li>
<p><code dir="ltr">void setCacheMaxSize(unsigned int maxSize);</code></p>
</li>
<li>
<p><code dir="ltr">unsigned int getCacheMaxSize() const;</code></p>
</li>
<li>
<p><code dir="ltr">void setCacheOptSize(unsigned int OptSize);</code></p>
</li>
<li>
<p><code dir="ltr">unsigned int getCacheOptSize() const;</code></p>
</li>
</ul>
<p><a href="#i1010314">&#34;Pin Object&#34;</a> describes how pin count of an object functions as a reference count and how an unmarked object with a <code dir="ltr">0</code> pin count can become eligible for garbage collection. For a newly created persistent object, the object is unmarked after the transaction is committed or aborted, and if the object has a <code dir="ltr">0</code> pin count. Because nothing is referencing this object, it becomes a candidate for ageing out.</p>
<p>If you are working with several object that have a large number of string or collection attributes, most of the memory is allocated from the C++ heap; this is because OCCI uses STLs. You should therefore set the cache size to a low value to avoid high memory use before garbage collection activates.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="reference.htm#CIAJIDCF">Chapter 13, &#34;OCCI Application Programming Interface&#34;</a> for details.</div>
</div>
<!-- class="sect2" -->
<a id="i1010648"></a>
<div id="LNCPP20180" class="sect2">
<h3 class="sect2">Ensuring Transactional Consistency of References</h3>
<p>As described in the previous section, dereferencing a <code dir="ltr">Ref&lt;T&gt;</code> for the first time results in the object being loaded into the object cache from the database server. From then on, the behavior of operator <code dir="ltr">-&gt;</code> on <code dir="ltr">Ref&lt;T&gt;</code> equals any C++ pointer, and it provides access to the object copy in the cache. But when the transaction commits or aborts, the object copy in the cache can no longer be valid because it could be modified by any other client. Therefore, after the transaction ends, when the <code dir="ltr">Ref&lt;T&gt;</code> is again dereferenced, the object cache recognizes the fact that the object is no longer valid and fetches the most recent copy from the database server.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009758"></a>
<div id="LNCPP20181" class="sect1">
<h2 class="sect1">Overview o<a id="sthref256"></a>f Complex Object Retrieval</h2>
<p>In the examples discussed earlier, only a single object was fetched or pinned at a time. In these cases, each pin operation involved a separate database server round-trip to retrieve the object.</p>
<p>Object-oriented applications often model their problems as a set of interrelated objects that form graphs of objects. These applications process objects by starting with some initial set of objects and then using the references in these objects to traverse the remaining objects. In a client/server setting, each of these traversals could result in costly network round-trips to fetch objects.</p>
<p>The performance of such applications can be increased with <span class="bold">complex object retrieval</span> (COR). This is a prefetching mechanism in which an application specifies some criteria (content and boundary) for retrieving a set of linked objects in a single network round-trip. Using COR does not mean that these prefetched objects are pinned. They are fetched into the object cache, so that subsequent pin calls are local operations.</p>
<p>A <span class="bold">comple<a id="sthref257"></a>x ob<a id="sthref258"></a>ject</span> is a set of logically related objects consisting of a root object, and a set of objects each of which is prefetched based on a given depth level. The <span class="bold">ro<a id="sthref259"></a><a id="sthref260"></a>ot</span> object is explicitly fetched or pinned. The <span class="bold">d<a id="sthref261"></a>epth</span> <span class="bold">le<a id="sthref262"></a>vel</span> is the shortest number of references that have to be traversed from the root object to a given prefetched object in a complex object.</p>
<p>An application specifies a complex object by describing its content and boundary. The fetching of complex objects is constrained by an environment&#39;s <span class="bold">prefetc<a id="sthref263"></a><a id="sthref264"></a>h limit</span>, the amount of memory in the object cache that is available for prefetching objects.</p>
<p>The use of complex object retrieval does not add functionality; it only improves performance, and so its use is optional.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#BEICCIEA">Retrieving Complex Objects</a></p>
</li>
<li>
<p><a href="#BEIBDGIC">Prefetching Complex Objects</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</div>
</li>
</ul>
<a id="BEICCIEA"></a>
<div id="LNCPP20182" class="sect2">
<h3 class="sect2"><a id="sthref265"></a>Retrieving Co<a id="sthref266"></a>mplex Objects</h3>
<p>An OCCI application can achieve COR by setting the appropriate attributes of a <code dir="ltr">Ref&lt;T&gt;</code> before dereferencing it using the following methods:</p>
<pre dir="ltr">// prefetch attributes of the specified type name up to the specified depth
Ref&lt;T&gt;::setPrefetch(const string &amp;typeName, unsigned int depth);
// prefetch all the attribute types up to the specified depth.
Ref&lt;T&gt;::setPrefetch(unsigned int depth);
</pre>
<p>The application can also choose to fetch all objects reachable from the root object by way of REFs (transitive closure) to a certain depth. To do so, set the level parameter to the depth desired. For the preceding two examples, the application could also specify <code dir="ltr">(PO object REF, OCCI_MAX_PREFETCH_DEPTH)</code> and <code dir="ltr">(PO object REF, 1)</code> respectively to prefetch required objects. Doing so results in many extraneous fetches but is quite simple to specify, and requires only one database server round-trip.</p>
<p>As an example for this discussion, consider the following type declaration:</p>
<pre dir="ltr">CREATE TYPE customer(...);
CREATE TYPE line_item(...);
CREATE TYPE line_item_varray as VARRAY(100) of REF line_item;
CREATE TYPE purchase_order AS OBJECT
   ( po_number         NUMBER, 
    cust              REF customer,
    related_orders    REF purchase_order,
    line_items        line_item_varray);
</pre>
<p>The <code dir="ltr">purchase_order</code> type contains a scalar value for <code dir="ltr">po_number</code>, a <code dir="ltr">VARRAY</code> of <code dir="ltr">line_items</code>, and two references. The first is to a <code dir="ltr">customer</code> type and the second is to a <code dir="ltr">purchase_order</code> type, indicating that this type can be implemented as a linked list.</p>
<p>When fetching a complex object, an application must specify the following:</p>
<ul>
<li>
<p>A reference to the desired root object</p>
</li>
<li>
<p>One or more pairs of type and depth information to specify the boundaries of the complex object. The type information indicates which <code dir="ltr">REF</code> attributes should be followed for COR, and the depth level indicates how many levels deep those links should be followed.</p>
</li>
</ul>
<p>In the case of the <code dir="ltr">purchase_order</code> object in the preceding example, the application must specify the following:</p>
<ul>
<li>
<p>The reference to the root <code dir="ltr">purchase_order</code> object</p>
</li>
<li>
<p>One or more pairs of type and depth information for <code dir="ltr">customer</code>, <code dir="ltr">purchase_order</code>, or <code dir="ltr">line_item</code></p>
</li>
</ul>
<p>An application prefetching a purchase order needs access to the customer information for that purchase order. Using simple navigation, this would require two database server accesses to retrieve the two objects.</p>
<p>Through complex object retrieval, <code dir="ltr">customer</code> can be prefetched when the application pins the <code dir="ltr">purchase_order</code> object. In this case, the complex object would consist of the <code dir="ltr">purchase_order</code> object and the <code dir="ltr">customer</code> object it references.</p>
<p>In the previous example, if the application wanted to prefetch a purchase order and the related customer information, the application would specify the <code dir="ltr">purchase_order</code> object and indicate that <code dir="ltr">customer</code> should be followed to a depth level of one as follows:</p>
<pre dir="ltr">Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch(&#34;CUSTOMER&#34;,1);
</pre>
<p>If the application wanted to prefetch a <code dir="ltr">purchase order</code> and all objects in the object graph it contains, the application would specify the <code dir="ltr">purchase_order</code> object and indicate that both <code dir="ltr">customer</code> and <code dir="ltr">purchase_order</code> should be followed to the maximum depth level possible as follows:</p>
<pre dir="ltr">Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch(&#34;CUSTOMER&#34;, OCCI_MAX_PREFETCH_DEPTH);
poref.setPrefetch(&#34;PURCHASE_ORDER&#34;, OCCI_MAX_PREFETCH_DEPTH);
</pre>
<p>where <code dir="ltr">OCCI_MAX_PREFETCH_DEPTH</code> specifies that all objects of the specified type reachable through references from the root object should be prefetched.</p>
<p>If an application wanted to prefetch a purchase order and all the line items associated with it, the application would specify the <code dir="ltr">purchase_order</code> object and indicate that <code dir="ltr">line_items</code> should be followed to the maximum depth level possible as follows:</p>
<pre dir="ltr">Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch(&#34;LINE_ITEM&#34;, 1);
</pre></div>
<!-- class="sect2" -->
<a id="BEIBDGIC"></a>
<div id="LNCPP20183" class="sect2">
<h3 class="sect2">Prefetching Com<a id="sthref267"></a>plex Objects</h3>
<p>After specifying and fetching a complex object, subsequent fetches of objects contained in the complex object do not incur the cost of a network round-trip, because these objects have been prefetched and are in the object cache. Keep in mind that excessive prefetching of objects can lead to a flooding of the object cache. This flooding, in turn, may force out other objects that the application had pinned, leading to a performance degradation instead of performance improvement.</p>
<p>Note that if there is insufficient memory in the object cache to hold all prefetched objects, some objects may not be prefetched. The application then incurs a network round-trip when those objects are accessed later.</p>
<p>You must have the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> privilege for all prefetched objects. Objects in the complex object for which the application does not have <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> privilege cannot prefetched.</p>
<p>An entire vector of <code dir="ltr">Ref</code>s can be prefetched into object cache in a single round-trip by using the global <a href="reference010.htm#CACCCEJG">pinVectorOfRefs()</a> method of the <a href="reference010.htm#i1118650">Connection Class</a>. This method reduces the number of round-trips for an <code dir="ltr">n</code>-sized vector of <code dir="ltr">Ref</code>s from <code dir="ltr">n</code> to <code dir="ltr">1</code>, and tracks the newly pinned objects through an <code dir="ltr">OUT</code> parameter vector.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1003654"></a>
<div id="LNCPP20184" class="sect1">
<h2 class="sect1">Working with <a id="sthref268"></a>Collections</h2>
<p>Oracle supports two kinds of collections - variable length arrays (ordered collections) and nested tables (unordered collections). OCCI maps both of them to a Standard Template Library (STL) vector container, giving you the full power, flexibility, and speed of an STL vector to access and manipulate the collection elements. <a href="#BEIJBAIA">Example 4-9</a> shows the SQL DDL to create a <code dir="ltr">VARRAY</code> and an object that contains an attribute of type <code dir="ltr">VARRAY</code>, and the resulting C++ declaration that OTT generates.</p>
<div id="LNCPP21905" class="example">
<p class="titleinexample"><a id="BEIJBAIA"></a>Example 4-9 How to Create a VARRAY Collection</p>
<pre dir="ltr">CREATE TYPE ADDR_LIST AS VARRAY(3) OF REF ADDRESS;
CREATE TYPE PERSON AS OBJECT (name VARCHAR2(20), addr_l ADDR_LIST);
</pre>
<p>Here is the C++ class declaration generated by OTT:</p>
<pre dir="ltr">class PERSON : public PObject
{
   protected:
      string name;
      vector&lt; Ref&lt; ADDRESS &gt; &gt; addr_1;

   public:
      void *operator new(size_t size); 
      void *operator new(size_t size,
      const Connection* conn,
      const string&amp; table); 
      string  getSQLTypeName() const;
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      PERSON (void *ctx) : PObject(ctx) { };
      static void *readSQL(void *ctx);
      virtual void readSQL(AnyData&amp; stream);
      static void writeSQL(void *obj, void *ctx);
      virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</div>
<div id="LNCPP20185" class="sect2"><a id="sthref269"></a>
<h3 class="sect2">Fetching Emb<a id="sthref270"></a>edded Objects<a id="sthref271"></a></h3>
<p>If your application must fetch an embedded object, which is an object stored in a column of a regular table rather than an object table, you cannot use the <code dir="ltr">REF</code> retrieval mechanism. Embedded instances do not have object identifiers, so it is not possible to get a reference to them. Therefore, they cannot serve as the basis for object navigation. There are still many situations, however, in which an application fetches embedded instances.</p>
<p>For example, assume that an <code dir="ltr">address</code> type has been created.</p>
<pre dir="ltr">CREATE TYPE address AS OBJECT
(  street1             varchar2(50),
   street2             varchar2(50),
   city                varchar2(30),
   state               char(2),
   zip                 number(5));
</pre>
<p>You could then use that type as the data type of a column in another table:</p>
<pre dir="ltr">CREATE TABLE clients
( name          varchar2(40),
   addr          address);
</pre>
<p>Your OCCI application could then issue the following SQL statement:</p>
<pre dir="ltr">SELECT addr FROM clients
WHERE name=&#39;BEAR BYTE DATA MANAGEMENT&#39;;
</pre>
<p>This statement would return an embedded <code dir="ltr">address</code> object from the <code dir="ltr">clients</code> table. The application could then use the values in the attributes of this object for other processing. The application should execute the statement and fetch the object in the same way as described in the section <a href="#i1003644">&#34;Overview of Associative Access&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNCPP20186" class="sect2"><a id="sthref272"></a>
<h3 class="sect2">Nu<a id="sthref273"></a>llness</h3>
<p>If a column in a row of a database table has no value, then that column is said to be <code dir="ltr">NULL</code>, or to contain a <code dir="ltr">NULL</code>. Two different types of <code dir="ltr">NULL</code>s can apply to objects:</p>
<ul>
<li>
<p>Any attribute of an object can have a <code dir="ltr">NULL</code> value. This indicates that the value of that attribute of the object is not known.</p>
</li>
<li>
<p>An object may be <span class="bold">atomic<a id="sthref274"></a>ally NULL</span>. Therefore, the value of the entire object is unknown.</p>
</li>
</ul>
<p>Atomic <code dir="ltr">NULL</code>ness is different from nonexistence. An atomically <code dir="ltr">NULL</code> object still exists, its value is just not known. It may be thought of as an existing object with no data.</p>
<p>For every type of object attribute, OCCI provides a corresponding class. For instance, <code dir="ltr">NUMBER</code> attribute type maps to the <code dir="ltr">Number</code> class, <code dir="ltr">REF</code> maps to <code dir="ltr">RefAny</code>, and so on. Each and every OCCI class that represents a data type provides two methods:</p>
<ul>
<li>
<p><code dir="ltr">isNull()</code> &mdash; returns whether the object is <code dir="ltr">NULL</code></p>
</li>
<li>
<p><code dir="ltr">setNull()</code> &mdash; sets the object to <code dir="ltr">NULL</code></p>
</li>
</ul>
<p>Similarly, these methods are inherited from the <code dir="ltr">PObject</code> class by all the objects and can be used to access and set atomically <code dir="ltr">NULL</code> information about them.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007323"></a>
<div id="LNCPP20187" class="sect1">
<h2 class="sect1">Using Obj<a id="sthref275"></a><a id="sthref276"></a>ect References</h2>
<p>OCCI provides the application with the flexibility to access the contents of the objects using their pointers or their references. OCCI provides the <code dir="ltr">PObject::getRef()</code> method to return a reference to a persistent object. This call is valid for persistent objects only.</p>
</div>
<!-- class="sect1" -->
<a id="i1007327"></a>
<div id="LNCPP20188" class="sect1">
<h2 class="sect1">Deleting Objects from the Database</h2>
<p>OCCI users can use the overloaded <code dir="ltr">PObject::operator</code> <code dir="ltr">new()</code> to create the persistent objects. However, to delete the object from the database server, it is best to call <code dir="ltr">ref</code>.<a href="reference023.htm#i1072305">markDelete()</a> directly on the <code dir="ltr">Ref</code>; this prevents the object from getting into the client cache. If the object is in the client cache, it can be removed by an <code dir="ltr">obj</code>.<a href="reference023.htm#i1072305">markDelete()</a> call on the object. The object marked for deletion is permanently removed when the transaction commits.</p>
</div>
<!-- class="sect1" -->
<a id="CIHHEFEH"></a>
<div id="LNCPP20189" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref277"></a>Type Inheritance</h2>
<p>Type inheritance of objects has many similarities to inheritance in C++ and Java. You can create an object type as a subtype of an existing object type. The subtype is said to inherit all the attributes and methods (member functions and procedures) of the supertype, which is the original type. Only single inheritance is supported; an object cannot have multiple supertypes. The subtype can add new attributes and methods to the ones it inherits. It can also override (redefine the implementation) of any of its inherited methods. A subtype is said to extend (that is, inherit from) its supertype.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ7054" href="../ADOBJ/adobjint.htm#ADOBJ7054"><span class="italic">Oracle Database Object-Relational Developer&#39;s Guide</span></a> for a more complete discussion of this topic</div>
<p>As an example, a type <code dir="ltr">Person_t</code> can have a subtype <code dir="ltr">Student_t</code> and a subtype <code dir="ltr">Employee_t</code>. In turn, <code dir="ltr">Student_t</code> can have its own subtype, <code dir="ltr">PartTimeStudent_t</code>. A type declaration must have the flag <code dir="ltr">NOT FINAL</code> so that it can have subtypes. The default is <code dir="ltr">FINAL</code>, which means that the type can have no subtypes.</p>
<p>All types discussed so far in this chapter are <code dir="ltr">FINAL</code>. All types in applications developed before Oracle Database release 8.1.7 are <code dir="ltr">FINAL</code>. A type that is <code dir="ltr">FINAL</code> can be altered to be <code dir="ltr">NOT FINAL</code>. A <code dir="ltr">NOT FINAL</code> type with no subtypes can be altered to be <code dir="ltr">FINAL</code>. <code dir="ltr">Person_ t</code> is declared as <code dir="ltr">NOT FINAL</code> for our example:</p>
<pre dir="ltr">CREATE TYPE Person_t AS OBJECT
(  ssn NUMBER,
   name VARCAHR2(30),
   address VARCHAR2(100)) NOT FINAL; 
</pre>
<p>A subtype inherits all the attributes and methods declared in its supertype. It can also declare new attributes and methods, which must have different names than those of the supertype. The keyword <code dir="ltr">UNDER</code> identifies the supertype, like this:</p>
<pre dir="ltr">CREATE TYPE Student_t UNDER Person_t
(  deptid NUMBER,
   major  VARCHAR2(30)) NOT FINAL;
</pre>
<p>The newly declared attributes <code dir="ltr">deptid</code> and <code dir="ltr">major</code> belong to the subtype <code dir="ltr">Student_t</code>. The subtype <code dir="ltr">Employee_t</code> is declared as, for example:</p>
<pre dir="ltr">CREATE TYPE Employee_t UNDER Person_t
(  empid NUMBER,
   mgr   VARCHAR2(30));
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1005167">&#34;OTT Support for Type Inheritance&#34;</a> for the classes generated by OTT for this example.</p>
</li>
</ul>
</div>
<p>Subtype <code dir="ltr">Student_t</code> can have its own subtype, such as <code dir="ltr">PartTimeStudent_t</code>:</p>
<pre dir="ltr">CREATE TYPE PartTimeStuden_t UNDER Student_t ( numhours NUMBER) ;
</pre>
<div id="LNCPP20190" class="sect2"><a id="sthref278"></a>
<h3 class="sect2">Substitutabi<a id="sthref279"></a>lity</h3>
<p>The benefits of polymorphism derive partially from the property substitutability. Substitutability allows a value of some subtype to be used by code originally written for the supertype, without any specific knowledge of the subtype being needed in advance. The subtype value behaves to the surrounding code just like a value of the supertype would, even if it perhaps uses different mechanisms within its specializations of methods.</p>
<p>Instance substitutability refers to the ability to use an object value of a subtype in a context declared in terms of a supertype. <code dir="ltr">REF</code> substitutability refers to the ability to use a <code dir="ltr">REF</code> to a subtype in a context declared in terms of a <code dir="ltr">REF</code> to a supertype.</p>
<p><code dir="ltr">REF</code> type attributes are substitutable, that is, an attribute defined as <code dir="ltr">REF T</code> can hold a <code dir="ltr">REF</code> to an instance of <code dir="ltr">T</code> or any of its subtypes.</p>
<p>Object type attributes are substitutable, that is, an attribute defined to be of (an object) type <code dir="ltr">T</code> can hold an instance of <code dir="ltr">T</code> or any of its subtypes.</p>
<p>Collection element types are substitutable, that is, if we define a collection of elements of type <code dir="ltr">T</code>, then it can hold instances of type <code dir="ltr">T</code> and any of its subtypes. Here is an example of object attribute substitutability:</p>
<pre dir="ltr">CREATE TYPE Book_t AS OBJECT 
(  title VARCHAR2(30),
   author Person_t     /* substitutable */);
</pre>
<p>Thus, a <code dir="ltr">Book_t</code> instance can be created by specifying a title string and a <code dir="ltr">Person_t</code> (or any subtype of <code dir="ltr">Person_t</code>) object:</p>
<pre dir="ltr">Book_t(&#39;My Oracle Experience&#39;,
   Employee_t(12345, &#39;Joe&#39;, &#39;SF&#39;, 1111, NULL))
</pre></div>
<!-- class="sect2" -->
<div id="LNCPP20191" class="sect2"><a id="sthref280"></a>
<h3 class="sect2">NOT INSTANTIABLE Types and Methods</h3>
<p>A type can be declared <code dir="ltr">NOT INSTANTIABLE</code>, which means that there is no constructor (default or user defined) for the type. Thus, it is not be possible to construct instances of this type. The typical usage would be to define instantiable subtypes for such a type. Here is how this property is used:</p>
<pre dir="ltr">CREATE TYPE Address_t AS OBJECT(...) NOT INSTANTIABLE NOT FINAL;
CREATE TYPE USAddress_t UNDER Address_t(...);
CREATE TYPE IntlAddress_t UNDER Address_t(...);
</pre>
<p>A method of a type can be declared to be <code dir="ltr">NOT INSTANTIABLE</code>. Declaring a method as <code dir="ltr">NOT INSTANTIABLE</code> means that the type is not providing an implementation for that method. Further, a type that contains any <code dir="ltr">NOT INSTANTIABLE</code> methods must necessarily be declared as <code dir="ltr">NOT INSTANTIABLE</code>. For example:</p>
<pre dir="ltr">CREATE TYPE T AS OBJECT
(  x NUMBER,
   NOT INSTANTIABLE MEMBER FUNCTION func1() RETURN NUMBER 
) NOT INSTANTIABLE;
</pre>
<p>A subtype of <code dir="ltr">NOT INSTANTIABLE</code> can override any of the <code dir="ltr">NOT INSTANTIABLE</code> methods of the supertype and provide concrete implementations. If there are any <code dir="ltr">NOT INSTANTIABLE</code> methods remaining, the subtype must also necessarily be declared as <code dir="ltr">NOT INSTANTIABLE</code>.</p>
<p>A <code dir="ltr">NOT INSTANTIABLE</code> subtype can be defined under an instantiable supertype. Declaring a <code dir="ltr">NOT INSTANTIABLE</code> type to be <code dir="ltr">FINAL</code> is not useful and is not allowed.</p>
</div>
<!-- class="sect2" -->
<div id="LNCPP20192" class="sect2"><a id="sthref281"></a>
<h3 class="sect2">OCCI Support for Type Inh<a id="sthref282"></a>eritance</h3>
<p>The following calls support type inheritance.</p>
<div id="LNCPP20193" class="sect3"><a id="sthref283"></a>
<h4 class="sect3">Connection::getMetaData()</h4>
<p>This method provides information specific to inherited types. Additional attributes have been added for the properties of inherited types. For example, you can get the supertype of a type.</p>
</div>
<!-- class="sect3" -->
<div id="LNCPP20194" class="sect3"><a id="sthref284"></a>
<h4 class="sect3">Bind and Define Functions</h4>
<p>The <code dir="ltr">setRef()</code>, <code dir="ltr">setObject()</code> and <code dir="ltr">setVector()</code> methods of the <code dir="ltr">Statement</code> class are used to bind <code dir="ltr">REF</code>, object, and collections respectively. All these functions support <code dir="ltr">REF</code>, instance, and collection element substitutability. Similarly, the corresponding <code dir="ltr">get</code><code dir="ltr"><span class="codeinlineitalic">xxx</span></code><code dir="ltr">()</code> methods to fetch the data also support substitutability.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1005167"></a>
<div id="LNCPP20195" class="sect2">
<h3 class="sect2">OTT Support for Ty<a id="sthref285"></a>pe Inheritance</h3>
<p>Class declarations for objects with inheritance are similar to the simple object declarations except that the class is derived from the parent type class and only the fields corresponding to attributes not in the parent class are included. The structure for these declarations is listed in <a href="#CIHFBACF">Example 4-10</a>:</p>
<div id="LNCPP20196" class="example">
<p class="titleinexample"><a id="CIHFBACF"></a>Example 4-10 OTT Support Inheritance</p>
<pre dir="ltr">class &lt;typename&gt; : public &lt;parentTypename&gt; 
{
   protected:
      &lt;OCCItype1&gt; &lt;attributename1&gt;;
      ...
      &lt;OCCItypen&gt; &lt;attributenamen&gt;;

   public:
      void *operator new(size_t size); 
      void *operator new(size_t size, const Connection* conn, 
                          const string&amp; table); 
      string  getSQLTypeName() const;
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      &lt;typename&gt; (void *ctx) : &lt;parentTypename&gt;(ctx) { };
      static void *readSQL(void *ctx);
      virtual void readSQL(AnyData&amp; stream);
      static void writeSQL(void *obj, void *ctx);
      virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
<!-- class="example" -->
<p>In this structure, all variables are the same as in the simple object case. <code dir="ltr">parentTypename</code> refers to the name of the parent type, that is, the class name of the type from which typename inherits.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005035"></a>
<div id="LNCPP20197" class="sect1">
<h2 class="sect1">A Sam<a id="sthref286"></a>ple OCCI Application</h2>
<p>This section describes a sample OCCI application that uses some features discussed in this chapter.</p>
<div id="LNCPP20198" class="example">
<p class="titleinexample"><a id="sthref287"></a>Example 4-11 Listing of demo2.sql for a Sample OCCI Application</p>
<pre dir="ltr">drop table ADDR_TAB
/
drop table PERSON_TAB
/
drop type STUDENT
/
drop type PERSON
/
drop type ADDRESS_TAB
/
drop type ADDRESS
/
drop type FULLNAME
/
CREATE TYPE FULLNAME AS OBJECT (first_name CHAR(20), last_name CHAR(20))
/
CREATE TYPE ADDRESS AS OBJECT (state CHAR(20), zip CHAR(20)) 
/
CREATE TYPE ADDRESS_TAB  AS VARRAY(3) OF REF ADDRESS
/
CREATE TYPE PERSON AS OBJECT (id NUMBER, name FULLNAME,curr_addr REF ADDRESS, 
prev_addr_l ADDRESS_TAB) NOT FINAL
/
CREATE TYPE STUDENT UNDER  PERSON (school_name CHAR(20))
/
CREATE TABLE ADDR_TAB OF ADDRESS
/
CREATE TABLE PERSON_TAB OF PERSON
/
</pre></div>
<!-- class="example" -->
<div id="LNCPP20199" class="example">
<p class="titleinexample"><a id="CIHEEFFI"></a>Example 4-12 Listing of demo2.typ for a Sample OCCI Application</p>
<pre dir="ltr">TYPE FULLNAME GENERATE CFullName as MyFullName
TYPE ADDRESS GENERATE CAddress as MyAddress
TYPE PERSON GENERATE CPerson as MyPerson
TYPE STUDENT GENERATE CStudent as MyStudent
</pre></div>
<!-- class="example" -->
<div id="LNCPP20200" class="example">
<p class="titleinexample"><a id="sthref288"></a>Example 4-13 Listing of OTT Command that Generates Files for a Sample OCCI Application</p>
<p>OTT attempts to connect with user name <code dir="ltr">demousr</code>; the system prompts for the password.</p>
<pre dir="ltr">ott userid=demousr intype=demo2.typ code=cpp hfile=demo2.h
   cppfile=demo2.cpp mapfile=mappings.cpp attraccess=private
</pre></div>
<!-- class="example" -->
<div id="LNCPP20201" class="example">
<p class="titleinexample"><a id="sthref289"></a>Example 4-14 Listing of mappings.h for a Sample OCCI Application</p>
<pre dir="ltr">#ifndef MAPPINGS_ORACLE
# define MAPPINGS_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

#ifndef DEMO2_ORACLE
# include &#34;demo2.h&#34;
#endif

void mappings(oracle::occi::Environment* envOCCI_);

#endif
</pre></div>
<!-- class="example" -->
<div id="LNCPP20202" class="example">
<p class="titleinexample"><a id="sthref290"></a>Example 4-15 Listing of mappings.cpp for a Sample OCCI Application</p>
<pre dir="ltr">#ifndef MAPPINGS_ORACLE
# include &#34;mappings.h&#34;
#endif

void mappings(oracle::occi::Environment* envOCCI_)
{
  oracle::occi::Map *mapOCCI_ = envOCCI_-&gt;getMap();
  mapOCCI_-&gt;put(&#34;HR.FULLNAME&#34;, &amp;CFullName::readSQL, &amp;CFullName::writeSQL);
  mapOCCI_-&gt;put(&#34;HR.ADDRESS&#34;, &amp;CAddress::readSQL, &amp;CAddress::writeSQL);
  mapOCCI_-&gt;put(&#34;HR.PERSON&#34;, &amp;CPerson::readSQL, &amp;CPerson::writeSQL);
  mapOCCI_-&gt;put(&#34;HR.STUDENT&#34;, &amp;CStudent::readSQL, &amp;CStudent::writeSQL);
}
</pre></div>
<!-- class="example" -->
<div id="LNCPP20203" class="example">
<p class="titleinexample"><a id="sthref291"></a>Example 4-16 Listing of demo2.h for a Sample OCCI Application</p>
<pre dir="ltr">#ifndef DEMO2_ORACLE
# define DEMO2_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

using namespace std;
using namespace oracle::occi;

class MyFullName;
class MyAddress;
class MyPerson;
/*   Changes ended here */

/*  GENERATED DECLARATIONS FOR THE FULLNAME OBJECT TYPE. */
class CFullName : public oracle::occi::PObject {

private:
   OCCI_STD_NAMESPACE::string FIRST_NAME;
   OCCI_STD_NAMESPACE::string LAST_NAME;

public:   OCCI_STD_NAMESPACE::string getFirst_name() const;
   void setFirst_name(const OCCI_STD_NAMESPACE::string &amp;value);
   OCCI_STD_NAMESPACE::string getLast_name() const;
   void setLast_name(const OCCI_STD_NAMESPACE::string &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CFullName();
   CFullName(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CFullName();
};

/* GENERATED DECLARATIONS FOR THE ADDRESS OBJECT TYPE. */ 
class CAddress : public oracle::occi::PObject {

private:
   OCCI_STD_NAMESPACE::string STATE;
   OCCI_STD_NAMESPACE::string ZIP;

public:
   OCCI_STD_NAMESPACE::string getState() const;
   void setState(const OCCI_STD_NAMESPACE::string &amp;value);
   OCCI_STD_NAMESPACE::string getZip() const;
   void setZip(const OCCI_STD_NAMESPACE::string &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CAddress();
   CAddress(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CAddress();
};

/* GENERATED DECLARATIONS FOR THE PERSON OBJECT TYPE. */
class CPerson : public oracle::occi::PObject {

private:
   oracle::occi::Number ID;
   MyFullName * NAME;
   oracle::occi::Ref&lt; MyAddress &gt; CURR_ADDR;
   OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt; PREV_ADDR_L;

public:   oracle::occi::Number getId() const;
   void setId(const oracle::occi::Number &amp;value);
   MyFullName * getName() const;
   void setName(MyFullName * value);
   oracle::occi::Ref&lt; MyAddress &gt; getCurr_addr() const;
   void setCurr_addr(const oracle::occi::Ref&lt; MyAddress &gt; &amp;value);
   OCCI_STD_NAMESPACE::vector&lt;oracle::occi::Ref&lt; MyAddress&gt;&gt;&amp; 
      getPrev_addr_l();
   const OCCI_STD_NAMESPACE::vector&lt;oracle::occi::Ref&lt;MyAddress&gt;&gt;&amp; 
      getPrev_addr_l() const;
   void setPrev_addr_l(const OCCI_STD_NAMESPACE::vector 
      &lt;oracle::occi::Ref&lt; MyAddress &gt; &gt; &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CPerson();
   CPerson(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CPerson();
};

/* GENERATED DECLARATIONS FOR THE STUDENT OBJECT TYPE. */
/*  changes to the generated file - declarations for the MyPerson class. */
class MyPerson : public CPerson {

public:
      MyPerson(Number id_i, MyFullName *name_i, const Ref&lt;MyAddress&gt;&amp; addr_i) ;
      MyPerson(void *ctxOCCI_);
      void move(const Ref&lt;MyAddress&gt;&amp; new_addr);
      void displayInfo();
      MyPerson();
};
/* changes  end here */

class CStudent : public MyPerson {
private:
   OCCI_STD_NAMESPACE::string SCHOOL_NAME;

public:
   OCCI_STD_NAMESPACE::string getSchool_name() const;
   void setSchool_name(const OCCI_STD_NAMESPACE::string &amp;value);\
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,\
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CStudent();
   CStudent(void *ctxOCCI_) : MyPerson (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CStudent();
};

/*changes  made to the generated file */
/* declarations for the MyFullName class. */
class MyFullName : public  CFullName
{  public:
      MyFullName(string first_name, string last_name);
      void displayInfo();
      MyFullName(void *ctxOCCI_);
};

// declarations for the MyAddress class.
class MyAddress : public CAddress
{  public:
      MyAddress(string state_i, string zip_i);
      void displayInfo();
      MyAddress(void *ctxOCCI_);
};

class MyStudent : public CStudent
{
  public :
     MyStudent(void *ctxOCCI_) ;
};
/* changes end here */ 
#endif
</pre></div>
<!-- class="example" -->
<div id="LNCPP20204" class="example">
<p class="titleinexample"><a id="sthref292"></a>Example 4-17 Listing of demo2.cpp for a Sample OCCI Application</p>
<pre dir="ltr">#ifndef DEMO2_ORACLE
# include &#34;demo2.h&#34;
#endif

/* GENERATED METHOD IMPLEMENTATIONS FOR THE FULLNAME OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CFullName::getFirst_name() const
{
  return FIRST_NAME;
}

void CFullName::setFirst_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  FIRST_NAME = value;
}

OCCI_STD_NAMESPACE::string CFullName::getLast_name() const
{
  return LAST_NAME;
}

void CFullName::setLast_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  LAST_NAME = value;
}

void *CFullName::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CFullName::operator new(size_t size, const oracle::occi::Connection *
  sess,  const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) &#34;HR.FULLNAME&#34;);
}

void *CFullName::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CFullName::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CFullName::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string(&#34;HR.FULLNAME&#34;);
}

void CFullName::getSQLTypeName(oracle::occi::Environment *env,
     void  **schemaName, unsigned int &amp;schemaNameLen, void **typeName,
     unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CFullName::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CFullName::CFullName()
{
}

void *CFullName::readSQL(void *ctxOCCI_)
{
  MyFullName *objOCCI_ = new(ctxOCCI_) MyFullName(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CFullName::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   FIRST_NAME = streamOCCI_.getString();
   LAST_NAME = streamOCCI_.getString();
}

void CFullName::writeSQL(void *objectOCCI_, void *ctxOCCI_){
  CFullName *objOCCI_ = (CFullName *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CFullName::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setString(FIRST_NAME);
   streamOCCI_.setString(LAST_NAME);
}

CFullName::~CFullName()
{
  int i;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE ADDRESS OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CAddress::getState() const
{
  return STATE;
}

void CAddress::setState(const OCCI_STD_NAMESPACE::string &amp;value)
{
  STATE = value;
}

OCCI_STD_NAMESPACE::string CAddress::getZip() const
{
  return ZIP;
}

void CAddress::setZip(const OCCI_STD_NAMESPACE::string &amp;value)
{
  ZIP = value;
}

void *CAddress::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CAddress::operator new(size_t size, 
                             const oracle::occi::Connection * sess,
                             const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) &#34;HR.ADDRESS&#34;);
}

void *CAddress::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CAddress::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CAddress::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string(&#34;HR.ADDRESS&#34;);
}

void CAddress::getSQLTypeName(oracle::occi::Environment *env, 
                              void **schemaName,
                              unsigned int &amp;schemaNameLen, 
                              void **typeName, 
                              unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CAddress::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CAddress::CAddress()
{
}

void *CAddress::readSQL(void *ctxOCCI_)
{
  MyAddress *objOCCI_ = new(ctxOCCI_) MyAddress(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CAddress::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   STATE = streamOCCI_.getString();
   ZIP = streamOCCI_.getString();
}

void CAddress::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CAddress *objOCCI_ = (CAddress *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CAddress::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setString(STATE);
   streamOCCI_.setString(ZIP);
}

CAddress::~CAddress()
{
  int i;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE PERSON OBJECT TYPE. */
oracle::occi::Number CPerson::getId() const
{
  return ID;
}

void CPerson::setId(const oracle::occi::Number &amp;value)
{
  ID = value;
}

MyFullName * CPerson::getName() const
{
  return NAME;
}

void CPerson::setName(MyFullName * value)
{
  NAME = value;
}

oracle::occi::Ref&lt; MyAddress &gt; CPerson::getCurr_addr() const
{
  return CURR_ADDR;
}

void CPerson::setCurr_addr(const oracle::occi::Ref&lt; MyAddress &gt; &amp;value)
{
  CURR_ADDR = value;
}

OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt;&amp;
   CPerson::getPrev_addr_l() 
{
  return PREV_ADDR_L;
}

const OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt;&amp;
  CPerson::getPrev_addr_l() const
{
  return PREV_ADDR_L;
}

void CPerson::setPrev_addr_l(const OCCI_STD_NAMESPACE::vector&lt;
 oracle::occi::Ref&lt; MyAddress &gt; &gt; &amp;value)
{
  PREV_ADDR_L = value;
}
void *CPerson::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CPerson::operator new(size_t size, 
                            const oracle::occi::Connection * sess,
                            const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) &#34;HR.PERSON&#34;);
}

void *CPerson::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CPerson::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CPerson::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string(&#34;HR.PERSON&#34;);
}

void CPerson::getSQLTypeName(oracle::occi::Environment *env, 
                             void **schemaName,
                             unsigned int &amp;schemaNameLen, 
                             void **typeName, 
                             unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CPerson::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CPerson::CPerson()
{
   NAME = (MyFullName *) 0;
}

void *CPerson::readSQL(void *ctxOCCI_)
{
  MyPerson *objOCCI_ = new(ctxOCCI_) MyPerson(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CPerson::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   ID = streamOCCI_.getNumber();
   NAME = (MyFullName *) streamOCCI_.getObject(&amp;MyFullName::readSQL);
   CURR_ADDR = streamOCCI_.getRef();
   oracle::occi::getVectorOfRefs(streamOCCI_, PREV_ADDR_L);
}

void CPerson::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CPerson *objOCCI_ = (CPerson *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CPerson::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setNumber(ID);
   streamOCCI_.setObject(NAME);
   streamOCCI_.setRef(CURR_ADDR);
   oracle::occi::setVectorOfRefs(streamOCCI_, PREV_ADDR_L);
}

CPerson::~CPerson()
{
  int i;
  delete NAME;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE STUDENT OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CStudent::getSchool_name() const
{
  return SCHOOL_NAME;
}

void CStudent::setSchool_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  SCHOOL_NAME = value;
}

void *CStudent::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CStudent::operator new(size_t size, 
                             const oracle::occi::Connection * sess,
                             const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) &#34;HR.STUDENT&#34;);
}

void *CStudent::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CStudent::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CStudent::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string(&#34;HR.STUDENT&#34;);
}

void CStudent::getSQLTypeName(oracle::occi::Environment *env, 
                              void **schemaName,
                              unsigned int &amp;schemaNameLen,
                              void **typeName,
                              unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CStudent::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CStudent::CStudent()
{
}
void *CStudent::readSQL(void *ctxOCCI_)
{
  MyStudent *objOCCI_ = new(ctxOCCI_) MyStudent(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CStudent::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   CPerson::readSQL(streamOCCI_);
   SCHOOL_NAME = streamOCCI_.getString();
}

void CStudent::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CStudent *objOCCI_ = (CStudent *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CStudent::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   CPerson::writeSQL(streamOCCI_);
   streamOCCI_.setString(SCHOOL_NAME);
}

CStudent::~CStudent()
{
  int i;
}
</pre></div>
<!-- class="example" -->
<p>Let us assume OTT generates <code dir="ltr">FULL_NAME</code>, <code dir="ltr">ADDRSESS</code>, <code dir="ltr">PERSON</code>, and <code dir="ltr">PFGRFDENT</code> class declarations in <code dir="ltr">demo2.h</code>. The following sample OCCI application extends the classes generated by OTT, as specified in <code dir="ltr">demo2.typ</code> file in <a href="#CIHEEFFI">Example 4-12</a>, and adds some user-defined methods. Note that these class declarations have been incorporated into <code dir="ltr">demo2.h</code> to ensure correct compilation.</p>
<div id="LNCPP20205" class="example">
<p class="titleinexample"><a id="i1012401"></a>Example 4-18 Listing of myDemo.h for a Sample OCCI Application</p>
<pre dir="ltr">#ifndef MYDEMO_ORACLE
#define MYDEMO_ORACLE

#include &lt;string&gt;

#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

using namespace std;
using namespace oracle::occi;

// declarations for the MyFullName class.
class MyFullName : public  CFullName
{  public:
      MyFullName(string first_name, string last_name);
      void displayInfo();
};

// declarations for the MyAddress class.
class MyAddress : public CAddress 
{  public:
      MyAddress(string state_i, string zip_i);
      void displayInfo();
};

// declarations for the MyPerson class.
class MyPerson : public CPerson
{  public:
      MyPerson(Number id_i, MyFullname *name_i, 
               const Ref&lt;MyAddress&gt;&amp; addr_i);
      void move(const Ref&lt;MyAddress&gt;&amp; new_addr);
      void displayInfo();
};

#endif
</pre></div>
<!-- class="example" -->
<div id="LNCPP20206" class="example">
<p class="titleinexample"><a id="sthref293"></a>Example 4-19 Listing for myDemo.cpp for a Sample OCCI Application</p>
<pre dir="ltr">#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

using namespace std;

/* initialize MyFullName */
MyFullName::MyFullName(string first_name,string last_name)
{
 setFirst_name(first_name);
 setLast_name(last_name);
}

/* display all the information in MyFullName */
void MyFullName::displayInfo()
{
   cout &lt;&lt; &#34;FIRST NAME is&#34; &lt;&lt; getFirst_name() &lt;&lt; endl;
   cout &lt;&lt; &#34;LAST NAME is&#34; &lt;&lt; getLast_name() &lt;&lt; endl;
}

MyFullName::MyFullName(void *ctxOCCI_):CFullName(ctxOCCI_)
{
}

/* METHOD IMPLEMENTATIONS FOR MyAddress CLASS. */

/* initialize MyAddress */
MyAddress::MyAddress(string state_i, string zip_i)
{
  setState(state_i); 
  setZip(zip_i);
}

/* display all the information in MyAddress */
void MyAddress::displayInfo()
{
   cout &lt;&lt; &#34;STATE is&#34; &lt;&lt; getState() &lt;&lt; endl;
   cout &lt;&lt; &#34;ZIP is&#34; &lt;&lt; getZip() &lt;&lt; endl;
}

MyAddress::MyAddress(void *ctxOCCI_) :CAddress(ctxOCCI_)
{
}

/* METHOD IMPLEMENTATIONS FOR MyPerson CLASS. */

/* initialize MyPerson */
MyPerson::MyPerson(Number id_i, MyFullName* name_i, 
           const Ref&lt;MyAddress&gt;&amp; addr_i)
{
  setId(id_i);
  setName(name_i);
  setCurr_addr(addr_i);
}

MyPerson::MyPerson(void *ctxOCCI_) :CPerson(ctxOCCI_)
{
}

/* move Person from curr_addr to new_addr */ 
void MyPerson::move(const Ref&lt;MyAddress&gt;&amp; new_addr)
{
   // append curr_addr to the vector //
   getPrev_addr_l().push_back(getCurr_addr());  
   setCurr_addr(new_addr);

   // mark the object as dirty
   this-&gt;markModified();
}

/*  display all the information of MyPerson */
void MyPerson::displayInfo()
{
   cout &lt;&lt; &#34;ID is&#34; &lt;&lt; (int)getId() &lt;&lt; endl;
   getName()-&gt;displayInfo();

   // de-referencing the Ref attribute using -&gt; operator
   getCurr_addr()-&gt;displayInfo();
   cout &lt;&lt; &#34;Prev Addr List: &#34; &lt;&lt; endl;
   for (int i = 0; i &lt; getPrev_addr_l().size(); i++)
   {  
      // access the collection elements using [] operator
      (getPrev_addr_l())[i]-&gt;displayInfo();
   }
}

MyPerson::MyPerson()
{
}

MyStudent::MyStudent(void *ctxOCCI_) : CStudent(ctxOCCI_)
{
}
</pre></div>
<!-- class="example" -->
<div id="LNCPP20207" class="example">
<p class="titleinexample"><a id="sthref294"></a>Example 4-20 Listing of main.cpp for a Sample OCCI Application</p>
<pre dir="ltr">#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

#ifndef MAPPINGS_ORACLE
#include &lt;mappings.h&gt;
#endif

#include &lt;iostream&gt;
using namespace std;
using namespace::oracle;

int main()
{
   Environment *env = Environment::createEnvironment(Environment::OBJECT);
   mappings(env);

   try {
     Connection *conn = Connection(&#34;HR&#34;, <span class="italic">&#34;password</span>&#34;);

    /* Call the OTT generated function to register the mappings */
    /* create a persistent object of type ADDRESS in the database table, 
       ADDR_TAB */
    MyAddress *addr1 = new(conn, &#34;ADDR_TAB&#34;) MyAddress(&#34;CA&#34;, &#34;94065&#34;);
    conn-&gt;commit();

    Statement *st = conn-&gt;createStatement(&#34;select ref(a) from addr_tab a&#34;);
   ResultSet *rs = st-&gt;executeQuery();
   Ref&lt;MyAddress&gt; r1;
   if ( rs-&gt;next())
      r1 = rs-&gt;getRef(1);
   st-&gt;closeResultSet(rs);
   conn-&gt;terminateStatement(st);

   MyFullName * name1 = new MyFullName(&#34;Joe&#34;, &#34;Black&#34;);

   /* create a persistent object of type Person in the database table 
      PERSON_TAB */
   MyPerson *person1 = new(conn, &#34;PERSON_TAB&#34;) MyPerson(1,name1,r1);
   conn-&gt;commit();

   /* selecting the inserted information */
   Statement *stmt = conn-&gt;createStatement();
   ResultSet *resultSet = 
        stmt-&gt;executeQuery(&#34;SELECT REF(a) from person_tab a where id = 1&#34;);

   if (resultSet-&gt;next())
   {
      Ref&lt;MyPerson&gt; joe_ref = (Ref&lt;MyPerson&gt;) resultSet-&gt;getRef(1);
      joe_ref-&gt;displayInfo();

      /* create a persistent object of type ADDRESS in the database table
         ADDR_TAB */
      MyAddress *new_addr1 = new(conn, &#34;ADDR_TAB&#34;) MyAddress(&#34;PA&#34;, &#34;92140&#34;);
      joe_ref-&gt;move(new_addr1-&gt;getRef());
      joe_ref-&gt;displayInfo();
   }

   /* commit the transaction which results in the newly created object
       new_addr and the dirty object joe to be flushed to the server.
       Note that joe was marked dirty in move(). */
   conn-&gt;commit();

   conn-&gt;terminateStatement(stmt);
   env-&gt;terminateConnection(conn);
 }

 catch ( exception &amp;x)

 {
  cout &lt;&lt; x.what () &lt;&lt; endl;
 }
   Environment::terminateEnvironment(env);
   return 0;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2196">
<tr>
<td class="cellalignment2205">
<table class="cellalignment2201">
<tr>
<td class="cellalignment2200"><a href="relational.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2200"><a href="types.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2208">
<table class="cellalignment2199">
<tr>
<td class="cellalignment2200"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2200"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2200"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2200"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2200"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2200"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>