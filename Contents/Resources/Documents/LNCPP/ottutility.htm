<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-73899"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Object%20Type%20Translator%20Utility"></a><title>Object Type Translator Utility</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1082"/>
<meta name="dcterms.created" content="2016-06-01T12:8:10Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="C++ Call Interface Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E48221-07"/>
<meta name="dcterms.isVersionOf" content="LNCPP"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="lobs.htm" title="Previous" type="text/html"/>
<link rel="Next" href="globalization.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E48221-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/54</span> <!-- End Header -->
<div id="LNCPP008" class="chapter"><a id="CHDBCDBH"></a> <a id="i441621"></a>
<h1 class="chapter"><span class="secnum">8</span> Object Type Translator Utility</h1>
<p>This chapter discusses the Object Type Translator (OTT) utility, which is used to map database object types, LOB types, and named collection types to C++ class declarations for use in OCCI applications.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i420185">Overview of the Object Type Translator Utility</a></p>
</li>
<li>
<p><a href="#i439131">Using the OTT Utility</a></p>
</li>
<li>
<p><a href="#i426997">Creating Types in the Database</a></p>
</li>
<li>
<p><a href="#i434134">Invoking the OTT Utility</a></p>
</li>
<li>
<p><a href="#i432196">Using the INTYPE File</a></p>
</li>
<li>
<p><a href="#i426569">OTT Utility Data Type Mappings</a></p>
</li>
<li>
<p><a href="#i440359">Overview of the OUTTYPE File</a></p>
</li>
<li>
<p><a href="#CHDDJHFG">The OTT Utility and OCCI Applications</a></p>
</li>
<li>
<p><a href="#i469445">Carrying Forward User Added Code</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<code dir="ltr">$</code><code dir="ltr"><span class="codeinlineitalic">ORACLE_HOME</span></code><code dir="ltr">/rdbms/demo</code> for a complete code listing of the demonstration program used in this chapter, and the class and method implementation generated by the OTT utility.</div>
<a id="i420185"></a>
<div id="LNCPP20348" class="sect1">
<h2 class="sect1">Overview of the Object Type Translator Utility</h2>
<p>The Object Type Translator (OTT) utility assists in the development of applications that make use of user-defined types in an Oracle database server.</p>
<p>You can create object types using the SQL <code dir="ltr">CREATE TYPE</code> statement. The definitions of these types are stored in the database, and can be subsequently used to create database tables. Once these tables are populated, an OCCI programmer can access objects stored in the tables.</p>
<p>An application that accesses object data must be able to represent the data in a host language format. This is accomplished by representing object types classes in C++.</p>
<p>You could code structures or classes manually to represent database object types, but this is time-consuming and error-prone. The OTT utility simplifies this step by automatically generating the appropriate classes for C++.</p>
<p>For OCCI, the application must include and link the following files:</p>
<ul>
<li>
<p>Include the header file containing the generated class declarations</p>
</li>
<li>
<p>Include the header file containing the prototype for the function to register the mappings</p>
</li>
<li>
<p>Link with the C++ source file containing the static methods to be called by OCCI while instantiating the objects</p>
</li>
<li>
<p>Link with the file containing the function to register the mappings with the environment and call this function</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i439131"></a>
<div id="LNCPP20349" class="sect1">
<h2 class="sect1">Using the OTT Utility<a id="sthref532"></a></h2>
<p>To translate database types to C++ representation, you must explicitly invoke the OTT utility. OCCI programmers must register the mappings with the environment. This function is generated by the OTT utility.</p>
<p>On most operating systems, the OTT utility is invoked on the command line. It takes as input an <code dir="ltr">INTYPE</code> file, and generates an <code dir="ltr">OUTTYPE</code> file, one or more C++ header files that contain the prototype information, and additional C++ method files that register generated mappings.</p>
<div id="LNCPP20350" class="example">
<p class="titleinexample"><a id="sthref533"></a>Example 8-1 How to Use the OTT Utility</p>
<p>The following command invokes the OTT utility and generates C++ classes. OTT attempts to connect with user name <code dir="ltr">demousr</code>; the system prompts for the password.</p>
<pre dir="ltr">ott userid=demousr intype=demoin.typ outtype=demoout.typ code=cpp
   hfile=demo.h cppfile=demo.cpp mapfile=RegisterMappings.cpp
</pre>
<p>OTT utility uses the <code dir="ltr">demoin.typ</code> file as the <code dir="ltr">INTYPE</code> file, and the <code dir="ltr">demoout.typ</code> file as the <code dir="ltr">OUTTYPE</code> file. The resulting declarations are output to the file <code dir="ltr">demo.h</code> in C++, specified by the <code dir="ltr">CODE=cpp</code> parameter, the method implementations written to the file <code dir="ltr">demo.cpp</code>, and the functions to register mappings is written to <code dir="ltr">RegisterMappings.cpp</code> with its prototype written to <code dir="ltr">RegisterMappings.h</code>.</p>
</div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i458231">Extending C++ Classes</a> for a complete C++ example</div>
</div>
<!-- class="sect1" -->
<a id="i426997"></a>
<div id="LNCPP20351" class="sect1">
<h2 class="sect1">Creating Types in the Database<a id="sthref534"></a></h2>
<p>The first step in using the OTT utility is to create object types or named collection types and store them in the database. This is accomplished by the SQL <code dir="ltr">CREATE TYPE</code> statement.</p>
<div id="LNCPP20352" class="example">
<p class="titleinexample"><a id="sthref535"></a>Example 8-2 Object Creation Statements of the OTT Utility</p>
<pre dir="ltr">CREATE TYPE FULL_NAME AS OBJECT (first_name CHAR(20), last_name CHAR(20));
CREATE TYPE ADDRESS AS OBJECT (state CHAR(20), zip CHAR(20));
CREATE TYPE ADDRESS_TAB AS VARRAY(3) OF REF ADDRESS;
CREATE TYPE PERSON AS OBJECT (id NUMBER, name FULL_NAME, curr_addr REF ADDRESS,
   prev_addr_1 ADDRESS_TAB) NOT FINAL;
CREATE TYPE STUDENT UNDER PERSON (school_name CHAR(20));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i434134"></a>
<div id="LNCPP20353" class="sect1">
<h2 class="sect1">Invoking the OTT Utility<a id="sthref536"></a></h2>
<p>After creating types in the database, the next step is to invoke the OTT utility.</p>
<div id="LNCPP20354" class="sect2"><a id="sthref537"></a>
<h3 class="sect2">Specifying OTT Parameters</h3>
<p>You can specify OTT parameters either on the command line or in a configuration file. Certain parameters can also be specified in the <code dir="ltr">INTYPE</code> file.</p>
<p>If you specify a parameter in multiple locations, then its value on the command line takes precedence over its value in the <code dir="ltr">INTYPE</code> file. The value in the <code dir="ltr">INTYPE</code> file takes precedence over its value in a user-defined configuration file, which takes precedence over its value in the default configuration file.</p>
<p>Parameter precedence then is as follows:</p>
<ol>
<li>
<p>OTT command line</p>
</li>
<li>
<p>Value in <code dir="ltr">INTYPE</code> file</p>
</li>
<li>
<p>User-defined configuration file</p>
</li>
<li>
<p>Default configuration file</p>
</li>
</ol>
<p>For global options (that is, options on the command line or options at the beginning of the <code dir="ltr">INTYPE</code> file before any <code dir="ltr">TYPE</code> statements), the value on the command line overrides the value in the <code dir="ltr">INTYPE</code> file. (The options that can be specified globally in the <code dir="ltr">INTYPE</code> file are <code dir="ltr">CASE</code>, <code dir="ltr">INITFILE</code>, <code dir="ltr">INITFUNC</code>, <code dir="ltr">MAPFILE</code> and <code dir="ltr">MAPFUNC</code>, but not <code dir="ltr">HFILE</code> or <code dir="ltr">CPPFILE</code>.) Anything in the <code dir="ltr">INTYPE</code> file in a <code dir="ltr">TYPE</code> specification applies to a particular type only and overrides anything on the command line that would otherwise apply to the type. So if you enter <code dir="ltr">TYPE person HFILE=p.h</code>, then it applies to <code dir="ltr">person</code> only and overrides the <code dir="ltr">HFILE</code> on the command line. The statement is not considered a command line parameter.</p>
<div id="LNCPP20355" class="sect3"><a id="sthref538"></a>
<h4 class="sect3">Setting Parameters on the Command Line</h4>
<p>Parameters (also called options) set on the command line override any parameters or option set elsewhere.</p>
</div>
<!-- class="sect3" -->
<div id="LNCPP20356" class="sect3"><a id="sthref539"></a>
<h4 class="sect3">Setting Parameters in the INTYPE File</h4>
<p>The <code dir="ltr">INTYPE</code> file gives a list of types for the OTT utility to translate.</p>
<p>The parameters <code dir="ltr">CASE</code>, <code dir="ltr">CPPFILE</code>, <code dir="ltr">HFILE</code>, <code dir="ltr">INITFILE</code>, <code dir="ltr">INITFUNC</code>, <code dir="ltr">MAPFILE</code>, and <code dir="ltr">MAPFUNC</code> can appear in the <code dir="ltr">INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<div id="LNCPP20357" class="sect3"><a id="sthref540"></a>
<h4 class="sect3">Setting Parameters in the Configuration File</h4>
<p>A configuration file is a text file that contains OTT parameters. Each nonblank line in the file contains one parameter, with its associated value or values. If multiple parameters are on the same line, then only the first one is used. No blank space is allowed on any nonblank line of a configuration file.</p>
<p>A configuration file can be named on the command line. In addition, a default configuration file is always read. This default configuration file must always exist, but can be empty. The name of the default configuration file is <code dir="ltr">ottcfg.cfg</code>, and the location of the file is operating system-specific.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Your operating system-specific documentation for more information about the location of the default configuration file.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNCPP20358" class="sect2"><a id="sthref541"></a>
<h3 class="sect2">Invoking the OTT Utility on the Command Line</h3>
<p>On most platforms, the OTT utility is invoked on the command line. You can specify the input and output files and the database connection information at the command line, among other things.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Your operating system-specific documentation to see how to invoke the OTT utility on your operating system</div>
<div id="LNCPP20359" class="example">
<p class="titleinexample"><a id="sthref542"></a>Example 8-3 How to Invoke the OTT Utility to Generate C++ Classes</p>
<p>OTT attempts to connect with user name <code dir="ltr">demousr</code>; the system prompts for the password.</p>
<pre dir="ltr">ott userid=demousr intype=demoin.typ outtype=demoout.typ code=cpp
   hfile=demo.h cppfile=demo.cpp mapfile=RegisterMappings.cpp
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Caution:</p>
No spaces are permitted around the equals sign (<code dir="ltr">=</code>) on the OTT command line.</div>
<p>An OTT command line statement consists of the command OTT, followed by a list of OTT utility parameters.</p>
<p>The <code dir="ltr">HFILE</code> parameter is almost always used. If omitted, then <code dir="ltr">HFILE</code> must be specified individually for each type in the <code dir="ltr">INTYPE</code> file. If the OTT utility determines that a type not listed in the <code dir="ltr">INTYPE</code> file must be translated, then an error is reported. Therefore, it is safe to omit the <code dir="ltr">HFILE</code> parameter only if the <code dir="ltr">INTYPE</code> file was previously generated as an OTT <code dir="ltr">OUTTYPE</code> file.</p>
<p>If the <code dir="ltr">INTYPE</code> file is omitted, then the entire schema is translated. See the parameter descriptions in the following section for more information.</p>
<div id="LNCPP20360" class="sect3"><a id="sthref543"></a>
<h4 class="sect3">Elements Used on the OTT Command Line</h4>
<p>Elements used on the OTT command line are:</p>
<ul>
<li>
<p>OTT command that invokes the OTT utility. It must be the first item on the command line.</p>
</li>
<li>
<p><a href="#i461368">USERID</a> parameter</p>
</li>
<li>
<p><a href="#i461337">INTYPE</a> parameter</p>
</li>
<li>
<p><a href="#i461357">OUTTYPE</a> parameter.</p>
</li>
<li>
<p><a href="#i461309">CODE</a> parameter.</p>
</li>
<li>
<p><a href="#i461325">HFILE</a> parameter.</p>
</li>
<li>
<p><a href="#i461317">CPPFILE</a> parameter.</p>
</li>
<li>
<p><a href="#i461349">MAPFILE</a> parameter.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i428064"></a>
<div id="LNCPP20361" class="sect2">
<h3 class="sect2">OTT Utility Parameters<a id="sthref544"></a></h3>
<p>To generate C++ using the OTT utility, the <code dir="ltr">CODE</code> parameter must be set to <code dir="ltr">CODE=CPP</code>. Once <code dir="ltr">CODE=CPP</code> is specified, you are required to specify the <code dir="ltr">CPPFILE</code> and <code dir="ltr">MAPFILE</code> parameters to define the filenames for the method implementation file and the mappings registration function file. The name of the mapping function is derived by the OTT utility from the <code dir="ltr">MAPFILE</code> or you may specify the name with the <code dir="ltr">MAPFUNC</code> parameter. <code dir="ltr">ATTRACCESS</code> is also an optional parameter that can be specified to change the generated code. These parameters control the generation of C++ classes.</p>
<ul>
<li>
<p>Enter parameters on the OTT command line where <code dir="ltr">parameter</code> is the literal parameter string and <code dir="ltr">value</code> is a valid parameter setting. The literal parameter string is not case sensitive:</p>
<pre dir="ltr">parameter=value
</pre></li>
<li>
<p>Separate command line parameters by using either spaces or tabs.</p>
</li>
<li>
<p>Parameters can also appear within a configuration file, but, in that case, no whitespace is permitted within a line, and each parameter must appear on a separate line. Additionally, the parameters <code dir="ltr">CASE</code>, <code dir="ltr">CPPFILE</code>, <code dir="ltr">HFILE</code>, <code dir="ltr">INITFILE</code>, <code dir="ltr">INTFUNC</code>, <code dir="ltr">MAPFILE</code>, and <code dir="ltr">MAPFUNC</code> can appear in the <code dir="ltr">INTYPE</code> file.</p>
</li>
</ul>
<p><a href="#BABBEIHG">Table 8-1</a> lists all OTT Utility parameters:</p>
<div id="LNCPP20362" class="tblformal">
<p class="titleintable"><a id="sthref545"></a><a id="BABBEIHG"></a>Table 8-1 Summary of OTT Utility Parameters</p>
<table class="cellalignment2203" title="Summary of OTT Utility Parameters" summary="Parameter and description" dir="ltr">
<thead>
<tr class="cellalignment2197">
<th class="cellalignment2204" id="r1c1-t7">Parameter</th>
<th class="cellalignment2204" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r2c1-t7" headers="r1c1-t7">
<p><a href="#i461293">ATTRACCESS</a></p>
</td>
<td class="cellalignment2205" headers="r2c1-t7 r1c2-t7">
<p>Specifies whether the access to type attributes is <code dir="ltr">PROTECTED</code> or <code dir="ltr">PRIVATE</code>.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r3c1-t7" headers="r1c1-t7">
<p><a href="#i443287">CASE</a></p>
</td>
<td class="cellalignment2205" headers="r3c1-t7 r1c2-t7">
<p>Affects the letter case of generated C++ identifiers</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r4c1-t7" headers="r1c1-t7">
<p><a href="#i461309">CODE</a></p>
</td>
<td class="cellalignment2205" headers="r4c1-t7 r1c2-t7">
<p>Specifies the target language for the translation. Use <code dir="ltr">CPP</code>.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r5c1-t7" headers="r1c1-t7">
<p><a href="#i461313">CONFIG</a></p>
</td>
<td class="cellalignment2205" headers="r5c1-t7 r1c2-t7">
<p>Specifies the name of the OTT configuration file that lists commonly used parameter specifications.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r6c1-t7" headers="r1c1-t7">
<p><a href="#i461317">CPPFILE</a></p>
</td>
<td class="cellalignment2205" headers="r6c1-t7 r1c2-t7">
<p>Specifies the name of the C++ source file into which the method implementations are written.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r7c1-t7" headers="r1c1-t7">
<p><a href="#i461321">ERRTYPE</a></p>
</td>
<td class="cellalignment2205" headers="r7c1-t7 r1c2-t7">
<p>Specifies the name of the error message output file.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r8c1-t7" headers="r1c1-t7">
<p><a href="#i461325">HFILE</a></p>
</td>
<td class="cellalignment2205" headers="r8c1-t7 r1c2-t7">
<p>Specifies the name of the C++ header file to which the generated C++ classes are written.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r9c1-t7" headers="r1c1-t7">
<p><a href="#i461337">INTYPE</a></p>
</td>
<td class="cellalignment2205" headers="r9c1-t7 r1c2-t7">
<p>Specifies the name of the <code dir="ltr">INTYPE</code> file.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r10c1-t7" headers="r1c1-t7">
<p><a href="#i461349">MAPFILE</a></p>
</td>
<td class="cellalignment2205" headers="r10c1-t7 r1c2-t7">
<p>Specifies the name of the mapping file and the corresponding header file generated by the OTT utility.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r11c1-t7" headers="r1c1-t7">
<p><a href="#i461353">MAPFUNC</a></p>
</td>
<td class="cellalignment2205" headers="r11c1-t7 r1c2-t7">
<p>Specifies the name of the function used to register generated mappings.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r12c1-t7" headers="r1c1-t7">
<p><a href="#i461357">OUTTYPE</a></p>
</td>
<td class="cellalignment2205" headers="r12c1-t7 r1c2-t7">
<p>Specifies the name of the <code dir="ltr">OUTTYPE</code> file.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r13c1-t7" headers="r1c1-t7">
<p><a href="#i461361">SCHEMA_NAMES</a></p>
</td>
<td class="cellalignment2205" headers="r13c1-t7 r1c2-t7">
<p>Controls the qualifying the database name of a type from the default schema</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r14c1-t7" headers="r1c1-t7">
<p><a href="#i461506">TRANSITIVE</a></p>
</td>
<td class="cellalignment2205" headers="r14c1-t7 r1c2-t7">
<p>Indicates whether to translate type dependency that are not explicitly listed in the <a href="#i461337">INTYPE</a>.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r15c1-t7" headers="r1c1-t7">
<p><a href="#BABHGEHE">UNICODE</a></p>
</td>
<td class="cellalignment2205" headers="r15c1-t7 r1c2-t7">
<p>Indicates whether the application should provide UTF16 support generate <code dir="ltr">UString</code> types.</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r16c1-t7" headers="r1c1-t7">
<p><a href="#i469376">USE_MARKER</a></p>
</td>
<td class="cellalignment2205" headers="r16c1-t7 r1c2-t7">
<p>Indicates whether OTT markers should be supported to carry forward user added cod</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r17c1-t7" headers="r1c1-t7">
<p><a href="#i461368">USERID</a></p>
</td>
<td class="cellalignment2205" headers="r17c1-t7 r1c2-t7">
<p>Specifies the database connection information that the OTT utility uses.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<a id="i461293"></a>
<div id="LNCPP20363" class="sect3">
<h4 class="sect3">ATTRACCESS</h4>
<p>This parameter specifies access to type attributes:</p>
<ul>
<li>
<p><code dir="ltr">PROTECTED</code> is the default.</p>
</li>
<li>
<p><code dir="ltr">PRIVATE</code> indicates that the OTT utility generates accessory and mutator methods for each type attribute, <code dir="ltr">get</code><code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">()</code> and <code dir="ltr">set</code><code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">()</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i443287"></a>
<div id="LNCPP20364" class="sect3">
<h4 class="sect3">CASE<a id="sthref546"></a><a id="sthref547"></a></h4>
<p>This parameter affects the letter case of generated C++ identifiers. The valid values of <code dir="ltr">CASE</code> are:</p>
<ul>
<li>
<p><code dir="ltr">SAME</code> is the case of letters remains unchanged when converting database type and attribute names to C++ identifiers.</p>
</li>
<li>
<p><code dir="ltr">LOWER</code> indicates that all uppercase letters are converted to lowercase.</p>
</li>
<li>
<p><code dir="ltr">UPPER</code> indicates that all lowercase letters are converted to uppercase.</p>
</li>
<li>
<p><code dir="ltr">OPPOSITE</code> indicates that all uppercase letters are converted to lowercase, and all lowercase letters are converted to uppercase.</p>
</li>
</ul>
<p>This parameter affects only those identifiers (attributes or types not explicitly listed) not mentioned in the <code dir="ltr">INTYPE</code> file. Case conversion takes place after a legal identifier has been generated.</p>
<p>Case insensitive SQL identifiers not mentioned in the <code dir="ltr">INTYPE</code> file appear in uppercase if <code dir="ltr">CASE=SAME</code>, and in lowercase if <code dir="ltr">CASE=OPPOSITE</code>. A SQL identifier is case insensitive if it was not quoted when it was declared.</p>
</div>
<!-- class="sect3" -->
<a id="i461309"></a>
<div id="LNCPP20365" class="sect3">
<h4 class="sect3">CODE<a id="sthref548"></a><a id="sthref549"></a></h4>
<p>This parameter specifies the host language to be output by the OTT utility. <code dir="ltr">CODE=CPP</code> must be specified for the OTT utility to generate C++ code for OCCI applications.</p>
</div>
<!-- class="sect3" -->
<a id="i461313"></a>
<div id="LNCPP20366" class="sect3">
<h4 class="sect3">CONFIG<a id="sthref550"></a><a id="sthref551"></a></h4>
<p>This parameter specifies the name of the OTT configuration file that lists commonly used parameter specifications. Parameter specifications are also read from a system configuration file found in an operating system-dependent location. All remaining parameter specifications must appear either on the command line or in the <code dir="ltr">INTYPE</code> file.</p>
<p>The <code dir="ltr">CONFIG</code> parameter can only be specified on the OTT command line. It is not allowed in the <code dir="ltr">CONFIG</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461317"></a>
<div id="LNCPP20367" class="sect3">
<h4 class="sect3">CPPFILE</h4>
<p>This parameter specifies the name of the C++ source file that contains the method implementations generated by the OTT utility. The methods generated in this file are called by OCCI while instantiating the objects and are not to be called directly in the an application.</p>
<p>This parameter is required under the following conditions:</p>
<ul>
<li>
<p>A type not mentioned in the <code dir="ltr">INTYPE</code> file must be generated and two or more <code dir="ltr">CPPFILE</code>s are being generated. In this case, the unmentioned type goes in the <code dir="ltr">CPPFILE</code> specified on the command line.</p>
</li>
<li>
<p>The <code dir="ltr">INTYPE</code> parameter is not specified, and you want the OTT utility to translate all the types in the schema.</p>
</li>
</ul>
<p>This parameter is optional when the <code dir="ltr">CPPFILE</code> is specified for individual types in the <code dir="ltr">INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461321"></a>
<div id="LNCPP20368" class="sect3">
<h4 class="sect3">ERRTYPE<a id="sthref552"></a><a id="sthref553"></a></h4>
<p>This parameter specifies the name of the error message output file. Information and error messages are sent to the standard output regardless of whether the <code dir="ltr">ERRTYPE</code> parameter is specified. Essentially, the <code dir="ltr">ERRTYPE</code> file is a copy of the <code dir="ltr">INTYPE</code> file with error messages added. In most cases, an error message includes a pointer to the text that caused the error.</p>
<p>If the filename specified for the <code dir="ltr">ERRTYPE</code> parameter on the command line does not include an extension, a platform-specific extension, like .<code dir="ltr">TLS</code> or .<code dir="ltr">tls</code>, is added automatically.</p>
</div>
<!-- class="sect3" -->
<a id="i461325"></a>
<div id="LNCPP20369" class="sect3">
<h4 class="sect3">HFILE<a id="sthref554"></a><a id="sthref555"></a></h4>
<p>This parameter specifies the name of the header (<code dir="ltr">.h</code>) file to be generated by the OTT utility. The <code dir="ltr">HFILE</code> specified on the command line contains the declarations of types that are mentioned in the <code dir="ltr">INTYPE</code> file but whose header files are not specified there.</p>
<p>This parameter is required unless the header file for each type is specified individually in the <code dir="ltr">INTYPE</code> file. This parameter is also required if a type not mentioned in the <code dir="ltr">INTYPE</code> file must be generated because other types require it, and these other types are declared in two or more different files.</p>
<p>If the filename specified for the <code dir="ltr">HFILE</code> parameter on the command line or in the <code dir="ltr">INTYPE</code> file does not include an extension, a platform-specific extension, like <code dir="ltr">.H</code> or <code dir="ltr">.h</code>, is added automatically.</p>
</div>
<!-- class="sect3" -->
<a id="i461337"></a>
<div id="LNCPP20370" class="sect3">
<h4 class="sect3">INTYPE<a id="sthref556"></a><a id="sthref557"></a></h4>
<p>This parameter specifies the name of the file from which to read the list of object type specifications. The OTT utility translates each type in the list. If the <code dir="ltr">INTYPE</code> parameter is not specified, all types in the user&#39;s schema is translated.</p>
<p>If the filename specified for the <code dir="ltr">INTYPE</code> parameter on the command line does not include an extension, a platform-specific extension, like <code dir="ltr">.TYP</code> or <code dir="ltr">.typ</code>, is automatically added.</p>
<p><code dir="ltr">INTYPE=</code> may be omitted if <code dir="ltr">USERID</code> and <code dir="ltr">INTYPE</code> are the first two parameters, in that order, and <code dir="ltr">USERID=</code> is omitted.</p>
<p>The <code dir="ltr">INTYPE</code> file can be thought of as a makefile for type declarations. It lists the types for which C++ classes are needed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i420386">&#34;Structure of the INTYPE File&#34;</a> for more information about the format of the <code dir="ltr">INTYPE</code> file</div>
</div>
<!-- class="sect3" -->
<a id="i461349"></a>
<div id="LNCPP20371" class="sect3">
<h4 class="sect3">MAPFILE</h4>
<p>This parameter specifies the name of the mapping file (<code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">.cpp</code>) and corresponding header file (<code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">.h</code>) that are generated by the OTT utility. The <code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">.cpp</code> file contains the implementation of the functions to register the mappings, while the <code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">.h</code> file contains the prototype for the function.</p>
<p>This parameter may be specified either on the command line or in the <code dir="ltr">INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461353"></a>
<div id="LNCPP20372" class="sect3">
<h4 class="sect3">MAPFUNC</h4>
<p>This parameter specifies the name of the function to be used to register the mappings generated by the OTT utility.</p>
<p>If this parameter is omitted, then the name of the function to register the mappings is derived from the filename specified in the <code dir="ltr">MAPFILE</code> parameter.</p>
<p>This parameter may be specified either on the command line or in the <code dir="ltr">INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461357"></a>
<div id="LNCPP20373" class="sect3">
<h4 class="sect3">OUTTYPE<a id="sthref558"></a><a id="sthref559"></a></h4>
<p>This parameter specifies the name of the file into which the OTT utility writes type information for all the object data types it processes. This file includes all types explicitly named in the <code dir="ltr">INTYPE</code> file, and may include additional types that are translated because they are used in the declarations of other types that must be translated. This file may be used as an <code dir="ltr">INTYPE</code> file in a future invocation of the OTT utility.</p>
<p>If the <code dir="ltr">INTYPE</code> and <code dir="ltr">OUTTYPE</code> parameters refer to the same file, then the new <code dir="ltr">INTYPE</code> information replaces the old information in the <code dir="ltr">INTYPE</code> file. This provides a convenient way for the same <code dir="ltr">INTYPE</code> file to be used repeatedly in the cycle of altering types, generating type declarations, editing source code, precompiling, compiling, and debugging.</p>
<p>If the filename specified for the <code dir="ltr">OUTTYPE</code> parameter on the command line or in the <code dir="ltr">INTYPE</code> file does not include an extension, a platform-specific extension, like<code dir="ltr">.TYP</code> or <code dir="ltr">.typ</code>, is automatically added.</p>
</div>
<!-- class="sect3" -->
<a id="i461361"></a>
<div id="LNCPP20374" class="sect3">
<h4 class="sect3">SCHEMA_NAMES<a id="sthref560"></a><a id="sthref561"></a></h4>
<p>This parameter offers control in qualifying the database name of a type from the default schema that is named in the <a href="#i461357">OUTTYPE</a> file. The <a href="#i461357">OUTTYPE</a> file generated by the OTT utility contains information about the types processed by the OTT utility, including the type names. Valid values include:</p>
<ul>
<li>
<p><code dir="ltr">ALWAYS</code> (default) indicates that all type names in the <a href="#i461357">OUTTYPE</a> file are qualified with a schema name.</p>
</li>
<li>
<p><code dir="ltr">IF_NEEDED</code> indicates that the type names in the <a href="#i461357">OUTTYPE</a> file that belong to the default schema are not qualified with a schema name. Type names belonging to other schemas are qualified with the schema name.</p>
</li>
<li>
<p><code dir="ltr">FROM_INTYPE</code> indicates that a type mentioned in the <a href="#i461337">INTYPE</a> file is qualified with a schema name in the <a href="#i461357">OUTTYPE</a> file only if it was qualified with a schema name in the <a href="#i461337">INTYPE</a> file. A type in the default schema that is not mentioned in the <a href="#i461337">INTYPE</a> file but generated because of type dependency is written with a schema name only if the first type encountered by the OTT utility that depends on it is also written with a schema name. However, a type that is not in the default schema to which the OTT utility is connected is always written with an explicit schema name.</p>
</li>
</ul>
<p>The name of a type from a schema other that the default schema is always qualified with a schema name in the <a href="#i461357">OUTTYPE</a> file.</p>
<p>The schema name, or its absence, determines in which schema the type is found during program execution.</p>
<div id="LNCPP20375" class="example">
<p class="titleinexample"><a id="sthref562"></a>Example 8-4 How to use the SCHEMA_NAMES Parameter in OTT Utility</p>
<p>Consider an example where the <code dir="ltr">SCHEMA_NAMES</code> parameter is set to <code dir="ltr">FROM_INTYPE</code>, and the <code dir="ltr">INTYPE</code> file contains the following:</p>
<pre dir="ltr">TYPE Person
TYPE joe.Dept
TYPE sam.Company
</pre>
<p>If the OTT utility and the application both connect to schema joe, then the application uses the same type (<code dir="ltr">joe.Person</code>) that the OTT utility uses. If the OTT utility connects to schema <code dir="ltr">joe</code> but the application connects to schema <code dir="ltr">mary</code>, then the application uses the type <code dir="ltr">mary.Person</code>. This behavior is appropriate only if the same <code dir="ltr">CREATE TYPE Person</code> statement has been executed in schema <code dir="ltr">joe</code> and schema <code dir="ltr">mary</code>.</p>
<p>On the other hand, the application uses type <code dir="ltr">joe.Dept</code> regardless of which schema the application is connected to. If this is the behavior you want, then be sure to include schema names with your type names in the <code dir="ltr">INTYPE</code> file.</p>
<p>In some cases, the OTT utility translates a type that the user did not explicitly name. For example, consider the following SQL declarations:</p>
<pre dir="ltr">CREATE TYPE Address AS OBJECT
(
   street    VARCHAR2(40),
   city      VARCHAR(30),
   state     CHAR(2),
   zip_code  CHAR(10)
);

CREATE TYPE Person AS OBJECT
(
   name      CHAR(20),
   age       NUMBER,
   addr      ADDRESS
);
</pre>
<p>Suppose that the OTT utility connects to schema <code dir="ltr">joe</code>, <code dir="ltr">SCHEMA_NAMES=FROM_INTYPE</code> is specified, and the user&#39;s <code dir="ltr">INTYPE</code> files include either <code dir="ltr">TYPE Person</code> or <code dir="ltr">TYPE joe.Person</code>. The <code dir="ltr">INTYPE</code> file does not mention the type <code dir="ltr">joe.Address</code>, which is used as a nested object type in type <code dir="ltr">joe.Person</code>.</p>
<ul>
<li>
<p>If <code dir="ltr">Type Person</code> appears in the <code dir="ltr">INTYPE</code> file, then <code dir="ltr">TYPE Person</code> and <code dir="ltr">TYPE Address</code> appears in the <code dir="ltr">OUTTYPE</code> file.</p>
</li>
<li>
<p>If <code dir="ltr">TYPE joe.Person</code> appears in the <code dir="ltr">INTYPE</code> file, then <code dir="ltr">TYPE joe.Person</code> and <code dir="ltr">TYPE joe.Address</code> appear in the <code dir="ltr">OUTTYPE</code> file.</p>
</li>
<li>
<p>If the <code dir="ltr">joe.Address</code> type is embedded in several types translated by the OTT utility, but it is not explicitly mentioned in the <code dir="ltr">INTYPE</code> file, then the decision of whether to use a schema name is made the first time the OTT utility encounters the embedded <code dir="ltr">joe.Address</code> type. If, for some reason, the user wants type <code dir="ltr">joe.Address</code> to have a schema name but does not want type <code dir="ltr">Person</code> to have one, then you must explicitly request this in the <code dir="ltr">INTYPE</code> file: <code dir="ltr">TYPE joe.Address</code>.</p>
</li>
</ul>
<p>In the usual case in which each type is declared in a single schema, it is safest for you to qualify all type names with schema names in the <code dir="ltr">INTYPE</code> file.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i461506"></a>
<div id="LNCPP20376" class="sect3">
<h4 class="sect3">TRANSITIVE<a id="sthref563"></a><a id="sthref564"></a></h4>
<p>This parameter indicates whether type dependencies not explicitly listed in the <code dir="ltr">INTYPE</code> file are to be translated. Valid values are:</p>
<ul>
<li>
<p><code dir="ltr">TRUE</code> (default): types needed by other types and not mentioned in the <code dir="ltr">INTYPE</code> file are generated</p>
</li>
<li>
<p><code dir="ltr">FALSE</code>: types not mentioned in the <code dir="ltr">INTYPE</code> file are not generated, even if they are used as attribute types of other generated types.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABHGEHE"></a>
<div id="LNCPP20377" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">UNICODE</h4>
<p>This parameter specifies whether the application provides unicode (<code dir="ltr">UTF16</code>) support.</p>
<ul>
<li>
<p><code dir="ltr">NONE</code> (default)</p>
</li>
<li>
<p><code dir="ltr">ALL</code>: All <code dir="ltr">CHAR</code> (<code dir="ltr">CHAR</code>/<code dir="ltr">VARCHAR</code>) and <code dir="ltr">NCHAR</code> (<code dir="ltr">NCHAR</code>/<code dir="ltr">NVARCHAR2</code>) type attributes are declared as <code dir="ltr">UString</code> type in the OTT generated C++ class files. The corresponding <code dir="ltr">get</code><code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">()</code>/<code dir="ltr">set</code><code dir="ltr"><span class="codeinlineitalic">XXX</span></code><code dir="ltr">()</code> return values or parameters are <code dir="ltr">UString</code> types. The generated persistent operator new would also take only <code dir="ltr">UString</code> arguments.</p>
<p>This setting is necessary when both the client characterset and the national characterset is <code dir="ltr">UTF16</code>.</p>
</li>
<li>
<p><code dir="ltr">ONLYNCHAR</code>: Similar to the <code dir="ltr">ALL</code> option, but only <code dir="ltr">NCHAR</code> type attributes are declared as <code dir="ltr">UString</code>.</p>
<p>This setting is necessary when the application sets only the Environment&#39;s national characterset to <code dir="ltr">UTF16</code>.</p>
</li>
</ul>
<div id="LNCPP20378" class="example">
<p class="titleinexample"><a id="sthref565"></a>Example 8-5 How to Define a Schema for Unicode Support in OTT</p>
<pre dir="ltr">create type CitiesList as varray(100) of varchar2(100);
 
create type Country as object
(  CNo Number(10),
   CName Varchar2(100),
   CNationalName NVarchar2(100),
   MainCities CitiesList);
</pre></div>
<!-- class="example" -->
<div id="LNCPP20379" class="example">
<p class="titleinexample"><a id="sthref566"></a>Example 8-6 How to Use UNICODE=ALL Parameter in OTT</p>
<pre dir="ltr">class Country : public oracle::occi::PObject
{
   private:
      oracle::occi::Number CNO;
      oracle::occi::UString CNAME;
      oracle::occi::UString CNATIONALNAME;
      OCCI_STD_NAMESPACE:::vector&lt; oracle::occi::UString &gt; MAINCITIES;

   public:

      oracle::occi::Number getCno() const;
      void setCno(const oracle::occi::Number &amp;value);

      oracle::occi::UString getCname() const;
      void setCname(const oracle::occi::UString &amp;value);
 
      oracle::occi::UString getCnationalname() const;
      void setCnationalname(const oracle::occi::UString &amp;value);
 
      OCCI_STD_NAMESPACE::vector&lt; oracle::occi::UString &gt;&amp; getMaincities();
      const OCCI_STD_NAMESPACE::vector&lt; oracle::occi::UString &gt;&amp; 
          getMaincities() const;
     void setMaincities(const OCCI_STD_NAMESPACE::vector&lt; oracle::occi::UString
          &gt; &amp;value);
...
}
</pre></div>
<!-- class="example" -->
<div id="LNCPP20380" class="example">
<p class="titleinexample"><a id="sthref567"></a>Example 8-7 How to Use UNICODE=ONLYCHAR Parameter in OTT</p>
<pre dir="ltr">class Country : public oracle::occi::PObject
{
   private:
      oracle::occi::Number CNO;
      oracle::occi::string CNAME;
      oracle::occi::UString CNATIONALNAME;
      OCCI_STD_NAMESPACE::vector&lt; std::string &gt; MAINCITIES;

   public:

      oracle::occi::Number getCno() const;
      void setCno(const oracle::occi::Number &amp;value);

      oracle::occi::string getCname() const;
      void setCname(const OCCI_STD_NAMESPACE::string &amp;value);
 
      oracle::occi::UString getCnationalname() const;
      void setCnationalname(const oracle::occi::UString &amp;value);
 
      OCCI_STD_NAMESPACE::vector&lt; OCCI_STD_NAMESPACE::string&gt;&amp; 
         getMaincities();
      const OCCI_STD_NAMESPACE::vector&lt; OCCI_STD_NAMESPACE::string &gt;&amp;
         getMaincities() const;
     void setMaincities(const OCCI_STD_NAMESPACE::vector
         &lt; OCCI_STD_NAMESPACE::string &gt; &amp;value);
...
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i469376"></a>
<div id="LNCPP20381" class="sect3">
<h4 class="sect3"><a id="sthref568"></a><a id="sthref569"></a>USE_MARKER</h4>
<p>This parameter indicates whether to support OTT markers for carrying forward user added code. Valid values are:</p>
<ul>
<li>
<p><code dir="ltr">FALSE</code> (default): User-supplied code is not carried forward, even if the code is added between <code dir="ltr">OTT_USERCODE_START</code> and <code dir="ltr">OTT_USERCODE_END</code> markers.</p>
</li>
<li>
<p><code dir="ltr">TRUE</code>: User-supplied code, between the markers <code dir="ltr">OTT_USER_CODESTART</code> and <code dir="ltr">OTT_USERCODE_END</code>, is carried forward when the same file is generated again.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i461368"></a>
<div id="LNCPP20382" class="sect3">
<h4 class="sect3"><a id="sthref570"></a><a id="sthref571"></a>USERID</h4>
<p>This parameter specifies the Oracle username and optional database name (Oracle Net database specification string). If the database name is omitted, the default database is assumed.</p>
<pre dir="ltr">USERID=<span class="italic">username</span>[@db_name]
</pre>
<p>If this is the first parameter, then <code dir="ltr">USERID=</code> may be omitted as shown:</p>
<pre dir="ltr">OTT <span class="italic">username</span> ...
</pre>
<p>Note that the system prompts you for the password that corresponds to the user id.</p>
<p>This parameter is optional. If omitted, the OTT utility automatically attempts to connect to the default database as user <code dir="ltr"><span class="codeinlineitalic">OPS$username</span></code>, where <code dir="ltr"><span class="codeinlineitalic">username</span></code> is the user&#39;s operating system username.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i450542"></a>
<div id="LNCPP20383" class="sect2">
<h3 class="sect2">Where OTT Parameters Can Appear<a id="sthref572"></a></h3>
<p>Supply OTT parameters on the command line, in a <code dir="ltr">CONFIG</code> file named on the command line, or both. Some parameters are also allowed in the <code dir="ltr">INTYPE</code> file.</p>
<p>The OTT utility is invoked as follows:</p>
<pre dir="ltr">OTT parameters
</pre>
<p>You can name a configuration file on the command line with the <code dir="ltr">CONFIG</code> parameter as follows:</p>
<pre dir="ltr">CONFIG=<span class="italic">filename</span>
</pre>
<p>If you name this parameter on the command line, then additional parameters are read from the configuration file named <code dir="ltr"><span class="codeinlineitalic">filename</span></code>.</p>
<p>In addition, parameters are also read from a default configuration file that resides in an operating system-dependent location. This file must exist, but can be empty. If you choose to enter data in the configuration file, note that no white space is allowed on a line and parameters must be entered one to a line.</p>
<p>If the OTT utility is executed without any arguments, then an online parameter reference is displayed.</p>
<p>The types for the OTT utility to translate are named in the file specified by the <code dir="ltr">INTYPE</code> parameter. The parameters <code dir="ltr">CASE</code>, <code dir="ltr">CPPFILE</code>, <code dir="ltr">HFILE</code>, <code dir="ltr">INITFILE</code>, <code dir="ltr">INITFUNC</code>, <code dir="ltr">MAPFILE</code>, and <code dir="ltr">MAPFNC</code> may also appear in the <code dir="ltr">INTYPE</code> file. <code dir="ltr">OUTTYPE</code> files generated by the OTT utility include the <code dir="ltr">CASE</code> parameter, and include the <code dir="ltr">INITFILE</code>, and <code dir="ltr">INITFUNC</code> parameters if an initialization file was generated or the <code dir="ltr">MAPFILE</code> and <code dir="ltr">MAPFUNC</code> parameters if C++ codes was generated. The <code dir="ltr">OUTTYPE</code> file and the <code dir="ltr">CPPFILE</code> for C++ specify the <code dir="ltr">HFILE</code> individually for each type.</p>
<p>The case of the OTT command is operating system-dependent.</p>
</div>
<!-- class="sect2" -->
<a id="i432220"></a>
<div id="LNCPP20384" class="sect2">
<h3 class="sect2">File Name Comparison Restriction</h3>
<p>Currently, the OTT utility determines if two files are the same by comparing the filenames provided by the user either on the command line or in the <code dir="ltr">INTYPE</code> file. But one potential problem can occur when the OTT utility must know if two filenames refer to the same file. For example, if the OTT-generated file foo.h requires a type declaration written to <code dir="ltr">foo1.h</code>, and another type declaration written to <code dir="ltr">/private/smith/foo1.h</code>, then the OTT utility should generate one <code dir="ltr">#include</code> if the two files are the same, and two <code dir="ltr">#include</code>s if the files are different. In practice, though, it concludes that the two files are different, and generates two <code dir="ltr">#include</code>s as follows:</p>
<pre dir="ltr">#ifndef FOO1_ORACLE
#include &#34;foo1.h&#34;
#endif
#ifndef FOO1_ORACLE
#include &#34;/private/smith/foo1.h&#34;
#endif
</pre>
<p>If <code dir="ltr">foo1.h</code> and <code dir="ltr">/private/smith/foo1.h</code> are different files, then only the first one is included. If <code dir="ltr">foo1.h</code> and <code dir="ltr">/private/smith/foo1.h</code> are the same file, then a redundant <code dir="ltr">#include</code> is written.</p>
<p>Therefore, if a file is mentioned several times on the command line or in the <code dir="ltr">INTYPE</code> file, then each mention of the file should use the same filename.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref573"></a>
<h3 class="sect2">OTT Command on Microsoft Windows</h3>
<p>OTT executable on Microsoft Windows in the current release is <code dir="ltr">ott.bat</code>, instead of <code dir="ltr">ott.exe</code> as in the earlier releases. This may break Windows batch scripts, as the scripts exit immediately after executing ott. To fix this problem, OTT should be invoked as follows, in Windows batch scripts:</p>
<pre dir="ltr">call ott [arguments]
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">ORACLE_HOME\precomp\admin\ott.exe</code> can be used until the scripts are fixed, as an intermediate solution. However, this intermediate solution will not be provided in future releases.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i432196"></a>
<div id="LNCPP20385" class="sect1">
<h2 class="sect1">Using the INTYPE File</h2>
<p>When you run the OTT utility, the <code dir="ltr">INTYPE</code> file tells the OTT utility which database types should be translated. The <code dir="ltr">INTYPE</code> file also controls the naming of the generated structures or classes. You can either create an <code dir="ltr">INTYPE</code> file or use the <code dir="ltr">OUTTYPE</code> file of a previous invocation of the OTT utility. If you do not use an <code dir="ltr">INTYPE</code> file, then all types in the schema to which the OTT utility connects are translated.</p>
<div id="LNCPP20386" class="sect2"><a id="sthref574"></a>
<h3 class="sect2">Overview of the INTYPE File</h3>
<div id="LNCPP20387" class="example">
<p class="titleinexample"><a id="sthref575"></a>Example 8-8 How to Create a User Defined INTYPE File Using the OTT Utility</p>
<pre dir="ltr">CASE=LOWER
TYPE employee
   TRANSLATE SALARY$ AS salary
             DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE &#34;Person&#34;
TYPE PURCHASE_ORDER AS p_o
</pre>
<ul>
<li>
<p>In the first line, the <code dir="ltr">CASE</code> parameter indicates that generated C identifiers should be in lowercase. However, this <code dir="ltr">CASE</code> parameter is only applied to those identifiers that are not explicitly mentioned in the <code dir="ltr">INTYPE</code> file. Thus, <code dir="ltr">employee</code> and <code dir="ltr">ADDRESS</code> would always result in C structures <code dir="ltr">employee</code> and <code dir="ltr">ADDRESS</code>, respectively. The members of these structures are named in lowercase.</p>
</li>
<li>
<p>The lines that begin with the <code dir="ltr">TYPE</code> keyword specify which types in the database should be translated. In this case, the <code dir="ltr">EMPLOYEE</code>, <code dir="ltr">ADDRESS</code>, <code dir="ltr">ITEM</code>, <code dir="ltr">PERSON</code>, and <code dir="ltr">PURCHASE_ORDER</code> types are set to be translated.</p>
</li>
<li>
<p>The <code dir="ltr">TRANSLATE...AS</code> keywords specify that the name of an object attribute should be changed when the type is translated into a C structure. In this case, the <code dir="ltr">SALARY$</code> attribute of the <code dir="ltr">employee</code> type is translated to <code dir="ltr">salary</code>.</p>
</li>
<li>
<p>The <code dir="ltr">AS</code> keyword in the final line specifies that the name of an object type should be changed when it is translated into a structure. In this case, the <code dir="ltr">purchase_order</code> database type is translated into a structure called <code dir="ltr">p_o</code>.</p>
</li>
</ul>
</div>
<!-- class="example" -->
<p>The OTT utility may have to translate additional types that are not listed in the <code dir="ltr">INTYPE</code> file. This is because the OTT utility analyzes the types in the <code dir="ltr">INTYPE</code> file for type dependencies before performing the translation, and it translates other types as necessary. For example, if the <code dir="ltr">ADDRESS</code> type were not listed in the <code dir="ltr">INTYPE</code> file, but the <code dir="ltr">Person</code> type had an attribute of type <code dir="ltr">ADDRESS</code>, then the OTT utility would still translate <code dir="ltr">ADDRESS</code> because it is required to define the <code dir="ltr">Person</code> type.</p>
<p>You may indicate whether the OTT utility should generate required object types that are not specified in the <code dir="ltr">INTYPE</code> file. Set <code dir="ltr">TRANSITIVE=FALSE</code> so the OTT utility does not to generate required object types. The default is <code dir="ltr">TRANSITIVE=TRUE</code>.</p>
<p>A normal case insensitive SQL identifier can be spelled in any combination of uppercase and lowercase in the <code dir="ltr">INTYPE</code> file, and is not quoted.</p>
<p>Use quotation marks, such as <code dir="ltr">TYPE &#34;Person&#34;</code> to reference SQL identifiers that have been created in a case sensitive manner, for example, <code dir="ltr">CREATE TYPE &#34;Person&#34;</code>. A SQL identifier is case sensitive if it was quoted when it was declared. Quotation marks can also be used to refer to a SQL identifier that is an OTT-reserved word, for example, <code dir="ltr">TYPE &#34;CASE&#34;</code>. In this case, the quoted name must be in uppercase if the SQL identifier was created in a case insensitive manner, for example, <code dir="ltr">CREATE TYPE Case</code>. If an OTT-reserved word is used to refer to the name of a SQL identifier but is not quoted, then the OTT utility reports a syntax error in the <code dir="ltr">INTYPE</code> file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i420386">&#34;Structure of the INTYPE File&#34;</a> for a more detailed specification of the structure of the <code dir="ltr">INTYPE</code> file and the available options.</p>
</li>
<li>
<p><a href="#i443287">&#34;CASE&#34;</a> for further information regarding the <code dir="ltr">CASE</code> parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i420386"></a>
<div id="LNCPP20388" class="sect2">
<h3 class="sect2">Structure of the INTYPE File</h3>
<p>The <code dir="ltr">INTYPE</code> and <code dir="ltr">OUTTYPE</code> files<a id="sthref576"></a> list the types translated by the OTT utility and provide all the information needed to determine how a type or attribute name is translated to a legal C or C++ identifier. These files contain one or more type specifications, and may also contain specifications of <code dir="ltr">CASE</code>, <code dir="ltr">CPPFILE</code>, <code dir="ltr">HFILE</code>, <code dir="ltr">INITFILE</code>, <code dir="ltr">INITFUNC</code>, <code dir="ltr">MAPFILE</code>, or <code dir="ltr">MAPFUNC</code>.</p>
<p>If the <code dir="ltr">CASE</code>, <code dir="ltr">INITFILE</code>, <code dir="ltr">INITFUNC</code>, <code dir="ltr">MAPFILE</code>, or <code dir="ltr">MAPFUNC</code> options are present, then they must precede any type specifications. If these options appear both on the command line and in the <code dir="ltr">INTYPE</code> file, then the value on the command line is used.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i440359">&#34;Overview of the OUTTYPE File&#34;</a> for an example of a simple user-defined <code dir="ltr">INTYPE</code> file and of the full <code dir="ltr">OUTTYPE</code> file that the OTT utility generates from it</div>
<div id="LNCPP20389" class="sect3"><a id="sthref577"></a>
<h4 class="sect3">INTYPE File Type Specifications</h4>
<p>A type specification in the <code dir="ltr">INTYPE</code> file names an object data type that is to be translated. The following is an example of a user-created <code dir="ltr">INTYPE</code> file:</p>
<pre dir="ltr">TYPE employee
   TRANSLATE SALARY$ AS salary
      DEPTNO AS department
TYPE ADDRESS
TYPE PURCHASE_ORDER AS p_o
</pre>
<p>The structure of a type specification is as follows:</p>
<pre dir="ltr">TYPE type_name
[GENERATE type_identifier]
[AS type_identifier]
[VERSION [=] version_string]
[HFILE [=] hfile_name]
[CPPFILE [=] cppfile_name]
[TRANSLATE{member_name [AS identifier]}...]
</pre>
<p>The <code dir="ltr">type_name</code> syntax follows this form:</p>
<pre dir="ltr">[schema_name.]type_name
</pre>
<p>In this syntax, <code dir="ltr"><span class="codeinlineitalic">schema_name</span></code> is the name of the schema that owns the given object data type, and <code dir="ltr"><span class="codeinlineitalic">type_name</span></code> is the name of the type. The default schema, if one is not specified, is that of the userID invoking the OTT utility. To use a specific schema, you must use schema_name.</p>
<p>The components of the type specification are:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">type_name</span></code>: Name of the object data type.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">type_identifier</span></code>: C / C++ identifier used to represent the class. The <code dir="ltr">GENERATE</code> clause is used to specify the name of the class that the OTT utility generates. The AS clause specifies the name of the class that you write. The <code dir="ltr">GENERATE</code> clause is typically used to extend a class. The <code dir="ltr">AS</code> clause, when optionally used without the <code dir="ltr">GENERATE</code> clause, specifies the name of the C structure or the C++ class that represents the user-defined type.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">version_string</span></code>: Version string of the type that was used when the code was generated by the previous invocation of the OTT utility. The version string is generated by the OTT utility and written to the <code dir="ltr">OUTTYPE</code> file, which can later be used as the <code dir="ltr">INTYPE</code> file in later invocations of the OTT utility. The version string does not affect how the OTT utility operates, but can be used to select which version of the object data type is used in the running program.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">hfile_name</span></code>: Name of the header file into which the declarations of the corresponding class are written. If you omit the <code dir="ltr">HFILE</code> clause, then the file specified by the command line <code dir="ltr">HFILE</code> parameter is used.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">cppfile_name</span></code>: Name of the C++ source file into which the method implementations of the corresponding class is written. If you omit the <code dir="ltr">CPPFILE</code> clause, the file specified by the command line <code dir="ltr">CPPFILE</code> parameter is used.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">member_name</span></code>: Name of an attribute (data member) that is to be translated to the identifier.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">identifier</span></code>: C / C++ identifier used to represent the attribute in the program. You can specify identifiers in this way for any number of attributes. The default name mapping algorithm is used for the attributes not mentioned.</p>
</li>
</ul>
<p>An object data type may be translated for one of two reasons:</p>
<ul>
<li>
<p>It appears in the <code dir="ltr">INTYPE</code> file.</p>
</li>
<li>
<p>It is required to declare another type that must be translated, and the <code dir="ltr">TRANSITIVE</code> parameter is set to <code dir="ltr">TRUE</code>.</p>
</li>
</ul>
<p>If a type that is not mentioned explicitly is necessary to types declared in exactly one file, then the translation of the required type is written to the same files as the explicitly declared types that require it.</p>
<p>If a type that is not mentioned explicitly is necessary to types declared in multiple files, then the translation of the required type is written to the global <code dir="ltr">HFILE</code> file.</p>
<p>You may indicate whether the OTT utility should generate required object types that are not specified in the <code dir="ltr">INTYPE</code> file. Set <code dir="ltr">TRANSITIVE=FALSE</code> so the OTT utility does not to generate required object types. The default is <code dir="ltr">TRANSITIVE=TRUE</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i432204"></a>
<div id="LNCPP20390" class="sect2">
<h3 class="sect2">Nested #include File Generation</h3>
<p><code dir="ltr">HFILE</code> files generated by the OTT utility <code dir="ltr">#include</code> other necessary files, and <code dir="ltr">#define</code> a symbol constructed from the name of the file. This symbol <code dir="ltr">#define</code> can then be used to determine if the related <code dir="ltr">HFILE</code> file has been included. Consider, for example, a database with the following types:</p>
<pre dir="ltr">create type px1 AS OBJECT (col1 number, col2 integer);
create type px2 AS OBJECT (col1 px1);
create type px3 AS OBJECT (col1 px1);
</pre>
<p>The <code dir="ltr">INTYPE</code> file contains the following information:</p>
<pre dir="ltr">CASE=lower
type pxl
   hfile tott95a.h
type px3
   hfile tott95b.h
</pre>
<p>You invoke the OTT utility as follows:</p>
<pre dir="ltr">&gt;ott hr intype=tott95i.typ outtype=tott95o.typ code=cpp
...
Enter password: <span class="italic">password</span>
</pre>
<p>The OTT utility then generates the following two header files, named <code dir="ltr">tott95a.h</code> and <code dir="ltr">tott95b.h</code>. They are listed in</p>
<div id="LNCPP20391" class="example">
<p class="titleinexample"><a id="sthref578"></a>Example 8-9 Listing of ott95a.h</p>
<pre dir="ltr">#ifndef TOTT95A_ORACLE
# define TOTT95A_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

/************************************************************/
//  generated declarations for the PX1 object type.
/************************************************************/

class px1 : public oracle::occi::PObject {

protected:
   oracle::occi::Number col1;
   oracle::occi::Number col2;

public:
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   px1();
   px1(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~px1();
};

#endif
</pre></div>
<!-- class="example" -->
<div id="LNCPP20392" class="example">
<p class="titleinexample"><a id="sthref579"></a>Example 8-10 Listing of ott95b.h</p>
<pre dir="ltr">#ifndef TOTT95B_ORACLE
# define TOTT95B_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

#ifndef TOTT95A_ORACLE
# include &#34;tott95a.h&#34;
#endif

/************************************************************/
//  generated declarations for the PX3 object type.
/************************************************************/

class px3 : public oracle::occi::PObject {

protected:
   px1 * col1;

public:
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   px3();
   px3(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~px3();
};
#endif
</pre></div>
<!-- class="example" -->
<p>In the <code dir="ltr">tott95b.h</code> file, the symbol <code dir="ltr">TOTT95B_ORACLE</code> is <code dir="ltr">#define</code> d at the beginning of the file. This enables you to conditionally <code dir="ltr">#include</code> this header file in another file, using the following construct:</p>
<pre dir="ltr">#ifndef TOTT95B_ORACLE
#include &#34;tott95b.h&#34;
#endif
</pre>
<p>By using this technique, you can <code dir="ltr">#include</code> <code dir="ltr">tott95b.h</code> in, say <code dir="ltr">foo.h</code>, without having to know whether some other file <code dir="ltr">#includ</code>ed in <code dir="ltr">foo.h</code> also <code dir="ltr">#include</code>s <code dir="ltr">tott95b.h</code>.</p>
<p>Next, the file <code dir="ltr">tott95a.h</code> is included because it contains the declaration of <code dir="ltr">struct px1</code>, that <code dir="ltr">tott95b.h</code> requires. When the <code dir="ltr">INTYPE</code> file requests that type declarations be written to multiple files, the OTT utility determines which other files each <code dir="ltr">HFILE</code> must <code dir="ltr">#include</code>, and generates each necessary <code dir="ltr">#include</code>.</p>
<p>Note that the OTT utility uses quotes in this <code dir="ltr">#include</code>. When a program including <code dir="ltr">tott95b.h</code> is compiled, the search for <code dir="ltr">tott95a.h</code> begins where the source program was found, and thereafter follows an implementation-defined search rule. If <code dir="ltr">tott95a.h</code> cannot be found in this way, then a complete filename (for example, a UNIX absolute path name beginning with a slash character (<code dir="ltr">/</code>)) is necessary in the <code dir="ltr">INTYPE</code> file to specify the location of <code dir="ltr">tott95a.h</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i426569"></a>
<div id="LNCPP20393" class="sect1">
<h2 class="sect1">OTT Utility Data Type Mappings<a id="sthref580"></a></h2>
<p>When the OTT utility generates a C++ class from a database type, the structure or class contains one element corresponding to each attribute of the object type. The data types of the attributes are mapped to types that are used in Oracle object data types. The data types found in Oracle include a set of predefined, primitive types and provide for the creation of user-defined types, like object types and collections.</p>
<p>The set of predefined types includes standard types that are familiar to most programmers, including number and character types. It also includes large object data types (for example, <code dir="ltr">BLOB</code> or <code dir="ltr">CLOB</code>).</p>
<div id="LNCPP20394" class="example">
<p class="titleinexample"><a id="sthref581"></a>Example 8-11 How to Represent Object Attributes Using the OTT Utility</p>
<p>Oracle also includes a set of predefined types that are used to represent object type attributes in C++ classes. Consider the following object type definition, and its corresponding OTT-generated structure declarations:</p>
<pre dir="ltr">CREATE TYPE employee AS OBJECT
(  name       VARCHAR2(30),
   empno      NUMBER,
   deptno     NUMBER,
   hiredate   DATE,
   salary     NUMBER
);
</pre>
<p>The OTT utility, assuming that the <code dir="ltr">CASE</code> parameter is set to <code dir="ltr">LOWER</code> and there are no explicit mappings of type or attribute names, produces the following output:</p>
<pre dir="ltr">#ifndef DATATYPES_ORACLE
# define DATATYPES_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

/************************************************************/
//  generated declarations for the EMPLOYEE object type.
/************************************************************/

class employee : public oracle::occi::PObject {

protected:
   OCCI_STD_NAMESPACE::string NAME;
   oracle::occi::Number EMPNO;
   oracle::occi::Number DEPTNO;   oracle::occi::Date HIREDATE;
   oracle::occi::Number SALARY;

public:
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   employee();
   employee(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~employee();

};

#endif
</pre>
<p><a href="#g498965">Table 8-2</a> lists the mappings from types that can be used as attributes to object data types that are generated by the OTT utility.</p>
</div>
<!-- class="example" -->
<div id="LNCPP20395" class="tblformal">
<p class="titleintable"><a id="sthref582"></a><a id="g498965"></a>Table 8-2 C++ Object Data Type Mappings for Object Type Attributes</p>
<table class="cellalignment2203" title="C++ Object Data Type Mappings for Object Type Attributes" summary="First column lists object attribute types; second column provides C++ mappings." dir="ltr">
<thead>
<tr class="cellalignment2197">
<th class="cellalignment2204" id="r1c1-t12">Object Attribute Types</th>
<th class="cellalignment2204" id="r1c2-t12">C++ Mapping</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r2c1-t12" headers="r1c1-t12">
<p><code dir="ltr">BFILE</code></p>
</td>
<td class="cellalignment2205" headers="r2c1-t12 r1c2-t12">
<p><code dir="ltr">Bfile</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r3c1-t12" headers="r1c1-t12">
<p><code dir="ltr">BLOB</code></p>
</td>
<td class="cellalignment2205" headers="r3c1-t12 r1c2-t12">
<p><code dir="ltr">Blob</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r4c1-t12" headers="r1c1-t12">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment2205" headers="r4c1-t12 r1c2-t12">
<p><code dir="ltr">BDouble</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r5c1-t12" headers="r1c1-t12">
<p><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment2205" headers="r5c1-t12 r1c2-t12">
<p><code dir="ltr">BFloat</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r6c1-t12" headers="r1c1-t12">
<p><code dir="ltr">CHAR(n), CHARACTER(n)</code></p>
</td>
<td class="cellalignment2205" headers="r6c1-t12 r1c2-t12">
<p><code dir="ltr">string</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r7c1-t12" headers="r1c1-t12">
<p><code dir="ltr">CLOB</code></p>
</td>
<td class="cellalignment2205" headers="r7c1-t12 r1c2-t12">
<p><code dir="ltr">Clob</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r8c1-t12" headers="r1c1-t12">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment2205" headers="r8c1-t12 r1c2-t12">
<p><code dir="ltr">Date</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r9c1-t12" headers="r1c1-t12">
<p><code dir="ltr">DEC, DEC(n), DEC(n,n)</code></p>
</td>
<td class="cellalignment2205" headers="r9c1-t12 r1c2-t12">
<p><code dir="ltr">Number</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r10c1-t12" headers="r1c1-t12">
<p><code dir="ltr">DECIMAL, DECIMAL(n), DECIMAL(n,n)</code></p>
</td>
<td class="cellalignment2205" headers="r10c1-t12 r1c2-t12">
<p><code dir="ltr">Number</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r11c1-t12" headers="r1c1-t12">
<p><code dir="ltr">FLOAT, FLOAT(n), DOUBLE PRECISION</code></p>
</td>
<td class="cellalignment2205" headers="r11c1-t12 r1c2-t12">
<p><code dir="ltr">Number</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r12c1-t12" headers="r1c1-t12">
<p><code dir="ltr">INT, INTEGER, SMALLINT</code></p>
</td>
<td class="cellalignment2205" headers="r12c1-t12 r1c2-t12">
<p><code dir="ltr">Number</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r13c1-t12" headers="r1c1-t12">
<p><code dir="ltr">INTERVAL DAY TO SECOND</code></p>
</td>
<td class="cellalignment2205" headers="r13c1-t12 r1c2-t12">
<p><code dir="ltr">IntervalDS</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r14c1-t12" headers="r1c1-t12">
<p><code dir="ltr">INTERVAL YEAR TO MONTH</code></p>
</td>
<td class="cellalignment2205" headers="r14c1-t12 r1c2-t12">
<p><code dir="ltr">IntervalYM</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r15c1-t12" headers="r1c1-t12">
<p><code dir="ltr">Nested Object Type</code></p>
</td>
<td class="cellalignment2205" headers="r15c1-t12 r1c2-t12">
<p>C++ name of the nested object type</p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r16c1-t12" headers="r1c1-t12">
<p><code dir="ltr">NESTED TABLE</code></p>
</td>
<td class="cellalignment2205" headers="r16c1-t12 r1c2-t12">
<p><code dir="ltr">vector&lt;attribute_type&gt;</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r17c1-t12" headers="r1c1-t12">
<p><code dir="ltr">NUMBER, NUMBER(n), NUMBER(n,n)</code></p>
</td>
<td class="cellalignment2205" headers="r17c1-t12 r1c2-t12">
<p><code dir="ltr">Number</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r18c1-t12" headers="r1c1-t12">
<p><code dir="ltr">NUMERIC, NUMERIC(n), NUMERIC(n,n)</code></p>
</td>
<td class="cellalignment2205" headers="r18c1-t12 r1c2-t12">
<p><code dir="ltr">Number</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r19c1-t12" headers="r1c1-t12">
<p><code dir="ltr">RAW</code></p>
</td>
<td class="cellalignment2205" headers="r19c1-t12 r1c2-t12">
<p><code dir="ltr">Bytes</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r20c1-t12" headers="r1c1-t12">
<p><code dir="ltr">REAL</code></p>
</td>
<td class="cellalignment2205" headers="r20c1-t12 r1c2-t12">
<p><code dir="ltr">Number</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r21c1-t12" headers="r1c1-t12">
<p><code dir="ltr">REF</code></p>
</td>
<td class="cellalignment2205" headers="r21c1-t12 r1c2-t12">
<p><code dir="ltr">Ref&lt;attribute_type&gt;</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r22c1-t12" headers="r1c1-t12">
<p><code dir="ltr">TIMESTAMP,TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE</code></p>
</td>
<td class="cellalignment2205" headers="r22c1-t12 r1c2-t12">
<p><code dir="ltr">Timestamp</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r23c1-t12" headers="r1c1-t12">
<p><code dir="ltr">VARCHAR(n)</code></p>
</td>
<td class="cellalignment2205" headers="r23c1-t12 r1c2-t12">
<p><code dir="ltr">string</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r24c1-t12" headers="r1c1-t12">
<p><code dir="ltr">VARCHAR2(n)</code></p>
</td>
<td class="cellalignment2205" headers="r24c1-t12 r1c2-t12">
<p><code dir="ltr">string</code></p>
</td>
</tr>
<tr class="cellalignment2197">
<td class="cellalignment2205" id="r25c1-t12" headers="r1c1-t12">
<p><code dir="ltr">VARRAY</code></p>
</td>
<td class="cellalignment2205" headers="r25c1-t12 r1c2-t12">
<p><code dir="ltr">vector&lt;attribute_type&gt;</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="LNCPP20396" class="example">
<p class="titleinexample"><a id="sthref583"></a>Example 8-12 How to Map Object Data Types Using the OTT Utility</p>
<p>The example assumes that the following database types are created:</p>
<pre dir="ltr">CREATE TYPE my_varray AS VARRAY(5) of integer;

CREATE TYPE object_type AS OBJECT
   (object_name VARCHAR2(20));

CREATE TYPE other_type AS OBJECT
   (object_number NUMBER);

CREATE TYPE my_table AS TABLE OF object_type;

CREATE TYPE many_types AS OBJECT
(
    the_varchar    VARCHAR2(30),
   the_char       CHAR(3),
   the_blob       BLOB,
   the_clob       CLOB,
   the_object     object_type,
   another_ref    REF other_type,
   the_ref        REF many_types,
   the_varray     my_varray,
   the_table      my_table,
   the_date       DATE,
   the_num        NUMBER,
   the_raw        RAW(255)
);
</pre>
<p>An <code dir="ltr">INTYPE</code> file exists, and includes the following:</p>
<pre dir="ltr">CASE = LOWER
TYPE many_types
</pre>
<p>The following is an example of the OTT type mappings for C++, given the types created in the example in the previous section, and an <code dir="ltr">INTYPE</code> file that includes the following:</p>
<pre dir="ltr">CASE = LOWER
TYPE many_types
</pre>
<pre dir="ltr">#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCCI_ORACLE
#include &lt;occi.h&gt;
#endif

/************************************************************/
//  generated declarations for the OBJECT_TYPE object type.
/************************************************************/

class object_type : public oracle::occi::PObject 
{
   protected:
      OCCI_STD_NAMESPACE::string object_name;

   public:
      void *operator new(size_t size);
      void *operator new(size_t size, const oracle::occi::Connection * sess,
         const OCCI_STD_NAMESPACE::string&amp; table);
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      object_type();
      object_type(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
      static void *readSQL(void *ctxOCCI_);
      virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
      static void writeSQL(void *objOCCI_, void *ctxOCCI_);
      virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
};

/************************************************************/
//  generated declarations for the OTHER_TYPE object type.
/************************************************************/

class other_type : public oracle::occi::PObject
{
   protected:
      oracle::occi::Number object_number;

   public:
      void *operator new(size_t size);
      void *operator new(size_t size, const oracle::occi::Connection * sess,
         const OCCI_STD_NAMESPACE::string&amp; table);
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      other_type();
      other_type(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
      static void *readSQL(void *ctxOCCI_);
      virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
      static void writeSQL(void *objOCCI_, void *ctxOCCI_);
      virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
};

/************************************************************/
//  generated declarations for the MANY_TYPES object type.
/************************************************************/

class many_types : public oracle::occi::PObject 
{
   protected:
      OCCI_STD_NAMESPACE::string the_varchar;
      OCCI_STD_NAMESPACE::string the_char;
      oracle::occi::Blob the_blob;
      oracle::occi::Clob the_clob;
      object_type * the_object;
      oracle::occi::Ref&lt; other_type &gt; another_ref;
      oracle::occi::Ref&lt; many_types &gt; the_ref;
      OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Number &gt; the_varray;
      OCCI_STD_NAMESPACE::vector&lt; object_type * &gt; the_table;
      oracle::occi::Date the_date;
      oracle::occi::Number the_num;
      oracle::occi::Bytes the_raw;

   public:
      void *operator new(size_t size);
      void *operator new(size_t size, const oracle::occi::Connection * sess,
         const OCCI_STD_NAMESPACE::string&amp; table);
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      many_types();
      many_types(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
      static void *readSQL(void *ctxOCCI_);
      virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
      static void writeSQL(void *objOCCI_, void *ctxOCCI_);
      virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
};

#endif
</pre>
<p>The OTT utility generates the following C++ class declarations (comments are not part of the OTT output, and are added only to clarify the example):</p>
<p>For C++, when <code dir="ltr">TRANSITIVE=TRUE</code>, the OTT utility automatically translates any types that are used as attributes of a type being translated, including types that are only being accessed by a pointer or <code dir="ltr">REF</code> in an object type attribute. Even though only the <code dir="ltr">many_types</code> object was specified in the <code dir="ltr">INTYPE</code> file for the C++ example, a class declaration was generated for all the object types, including the <code dir="ltr">other_type</code> object, which was only accessed by a <code dir="ltr">REF</code> in the <code dir="ltr">many_types</code> object.</p>
</div>
<!-- class="example" -->
<a id="i433388"></a>
<div id="LNCPP20397" class="sect2">
<h3 class="sect2">Default Name Mapping<a id="sthref584"></a></h3>
<p>When the OTT utility creates a C or C++ identifier name for an object type or attribute, it translates the name from the database character set to a legal C or C++ identifier. First, the name is translated from the database character set to the character set used by the OTT utility. Next, if a translation of the resulting name is supplied in the <code dir="ltr">INTYPE</code> file, that translation is used. Otherwise, the OTT utility translates the name character-by-character to the compiler character set, applying the character case specified in the CASE parameter. The following text describes this in more detail.</p>
<p>When the OTT utility reads the name of a database entity, the name is automatically translated from the database character set to the character set used by the OTT utility. In order for the OTT utility to read the name of the database entity successfully, all the characters of the name must be found in the OTT character set, although a character may have different encodings in the two character sets.</p>
<p>The easiest way to guarantee that the character set used by the OTT utility contains all the necessary characters is to make it the same as the database character set. Note, however, that the OTT character set must be a superset of the compiler character set. That is, if the compiler character set is 7-bit ASCII, then the OTT character set must include 7-bit ASCII as a subset, and if the compiler character set is 7-bit EBCDIC, then the OTT character set must include 7-bit EBCDIC as a subset. The user specifies the character set that the OTT utility uses by setting the <code dir="ltr">NLS_LANG</code> environment variable, or by some other operating system-specific mechanism.</p>
<p>Once the OTT utility has read the name of a database entity, it translates the name from the character set used by the OTT utility to the compiler&#39;s character set. If a translation of the name appears in the <code dir="ltr">INTYPE</code> file, then the OTT utility uses that translation.</p>
<p>Otherwise, the OTT utility attempts to translate the name as follows:</p>
<ol>
<li>
<p>If the OTT character set is a multibyte character set, all multibyte characters in the name that have single-byte equivalents are converted to those single-byte equivalents.</p>
</li>
<li>
<p>The name is converted from the OTT character set to the compiler character set. The compiler character set is a single-byte character set such as <code dir="ltr">US7ASCII</code>.</p>
</li>
<li>
<p>The case of letters is set according to how the <code dir="ltr">CASE</code> parameter is defined, and any character that is not legal in a C or C++ identifier, or that has no translation in the compiler character set, is replaced by an underscore character (<code dir="ltr">_</code>). If at least one character is replaced by an underscore, then the OTT utility gives a warning message. If all the characters in a name are replaced by underscores, the OTT utility gives an error message.</p>
</li>
</ol>
<p>Character-by-character name translation does not alter underscores, digits, or single-byte letters that appear in the compiler character set, so legal C or C++ identifiers are not altered.</p>
<p>Name translation may, for example, translate accented single-byte characters such as <span class="italic">o</span> with an umlaut or an <span class="italic">a</span> with an accent grave to <span class="italic">o</span> or <span class="italic">a</span>, with no accent, and may translate a multibyte letter to its single-byte equivalent. Name translation typically fails if the name contains multibyte characters that lack single-byte equivalents. In this case, the user must specify name translations in the <code dir="ltr">INTYPE</code> file.</p>
<p>The OTT utility does not detect a naming clash caused by two or more database identifiers being mapped to the same C name, nor does it detect a naming problem where a database identifier is mapped to a C keyword.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i440359"></a>
<div id="LNCPP20398" class="sect1">
<h2 class="sect1">Overview of the OUTTYPE File</h2>
<p>The <code dir="ltr">OUTTYPE</code> file is named on the OTT command line. When the OTT utility generates a C++ header file, it also writes the results of the translation into the <code dir="ltr">OUTTYPE</code> file. This file contains an entry for each of the translated types, including its version string and the header file to which its C++ representation was written.</p>
<p>The <code dir="ltr">OUTTYPE</code> file from one OTT utility run can be used as the <code dir="ltr">INTYPE</code> file for a subsequent invocation of the OTT utility.</p>
<div id="LNCPP20399" class="example">
<p class="titleinexample"><a id="sthref585"></a>Example 8-13 OUTTYPE File Generated by the OTT Utility</p>
<p>In this <code dir="ltr">INTYPE</code> file, the programmer specifies the case for OTT-generated C++ identifiers, and provides a list of types that should be translated. In two of these types, naming conventions are specified. This is what the <code dir="ltr">OUTTYPE</code> file looks like after running the OTT utility:</p>
<p>The following example shows what t:</p>
<pre dir="ltr">CASE = LOWER
TYPE EMPLOYEE AS employee
   VERSION = &#34;$8.0&#34;
   HFILE = demo.h
   TRANSLATE SALARY$ AS salary
             DEPTNO AS department
TYPE ADDRESS AS ADDRESS
   VERSION = &#34;$8.0&#34;
   HFILE = demo.h
TYPE ITEM AS item
   VERSION = &#34;$8.0&#34;
   HFILE = demo.h
TYPE &#34;Person&#34; AS Person
   VERSION = &#34;$8.0&#34;
   HFILE = demo.h
TYPE PURCHASE_ORDER AS p_o
   VERSION = &#34;$8.0&#34;
   HFILE = demo.h
</pre>
<p>When examining the contents of the <code dir="ltr">OUTTYPE</code> file, you might discover types listed that were not included in the <code dir="ltr">INTYPE</code> file specification. For example, consider the case where the <code dir="ltr">INTYPE</code> file only specified that the <code dir="ltr">person</code> type was to be translated:</p>
<pre dir="ltr">CASE = LOWER
TYPE PERSON
</pre>
<p>If the definition of the <code dir="ltr">person</code> type includes an attribute of type <code dir="ltr">address</code>, then the <code dir="ltr">OUTTYPE</code> file includes entries for both <code dir="ltr">PERSON</code> and <code dir="ltr">ADDRESS</code>. The <code dir="ltr">person</code> type cannot be translated completely without first translating <code dir="ltr">address</code>.</p>
</div>
<!-- class="example" -->
<p>The OTT utility analyzes the types in the <code dir="ltr">INTYPE</code> file for type dependencies before performing the translation, and translates other types as necessary.</p>
<p>You may indicate whether the OTT utility should generate required object types that are not specified in the <code dir="ltr">INTYPE</code> file. Set <code dir="ltr">TRANSITIVE=FALSE</code> so the OTT utility does not generate required object types. The default is <code dir="ltr">TRANSITIVE=TRUE</code>.</p>
</div>
<!-- class="sect1" -->
<a id="CHDDJHFG"></a>
<div id="LNCPP20400" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The OTT Utility and OCCI Applications</h2>
<p>The OTT utility generates objects and maps SQL data types to C++ classes. The OTT utility also implements a few methods called by OCCI when instantiating objects and a function that is called in the OCCI application to register the mappings with the environment. These declarations are stored in a header file that you include (<code dir="ltr">#include</code>) in your OCCI application. The prototype for the function that registers the mappings is written to a separate header file, which you also include in your OCCI application. The method implementations are stored in a C++ source code file (with extension <code dir="ltr">.cpp</code>) that is linked with the OCCI application. The function that registers the mappings is stored in a separate C++ (<code dir="ltr"><span class="codeinlineitalic">xxx</span></code><code dir="ltr">.cpp</code>) file that is also linked with the application.</p>
<p><a href="#CHDCICIE">Figure 8-1</a> shows the steps involved in using the OTT utility with OCCI. These steps are described following the figure.</p>
<div id="LNCPP20401" class="figure">
<p class="titleinfigure"><a id="CHDCICIE"></a>Figure 8-1 The OTT Utility with OCCI</p>
<img width="569" height="430" src="img/ott_utility_with_occi.gif" alt="Description of Figure 8-1 follows"/><br/>
<a id="sthref586" href="img_text/ott_utility_with_occi.htm">Description of &#39;&#39;Figure 8-1 The OTT Utility with OCCI&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" -->
<ol>
<li>
<p>Create the type definitions in the database by using the SQL DLL.</p>
</li>
<li>
<p>Create the <code dir="ltr">INTYPE</code> file that contains the database types to be translated by the OTT utility.</p>
</li>
<li>
<p>Specify that C++ should be generated and invoke the OTT utility.</p>
<p>The OTT utility then generates the following files:</p>
<ul>
<li>
<p>A header file (with the extension <code dir="ltr">.h</code>) that contains C++ class representations of object types; the filename is specified on the OTT command line by the <code dir="ltr">HFILE</code> parameter.</p>
</li>
<li>
<p>A header file that contains the prototype of the function (<code dir="ltr">MAPFUNC</code>) that registers the mappings.</p>
</li>
<li>
<p>A C++ source file (with the extension <code dir="ltr">.cpp</code>) that contains the static methods called by OCCI while instantiating the objects; the filename is specified on the OTT command line by the <code dir="ltr">CPPFILE</code> parameter. Do not call these methods directly from your OCCI application.</p>
</li>
<li>
<p>A file that contains the function used to register the mappings with the environment (with the extension <code dir="ltr">.cpp</code>); the filename is specified on the OTT command line by the <code dir="ltr">MAPFILE</code> parameter.</p>
</li>
<li>
<p>A file (<code dir="ltr">OUTTYPE</code> file) that contains an entry for each of the translated types, including the version string and the file into which it is written; the filename is specified on the OTT command line by the <code dir="ltr">OUTTYPE</code> parameter.</p>
</li>
</ul>
</li>
<li>
<p>Write the OCCI application and include the header files created by the OTT utility in the OCCI source code file.</p>
<p>The application declares an environment and calls the function <code dir="ltr">MAPFUNC</code> to register the mappings.</p>
</li>
<li>
<p>Compile the OCCI application to create the OCCI object code, and link the object code with the OCCI libraries to create the program executable.</p>
</li>
</ol>
<a id="g528741"></a>
<div id="LNCPP20402" class="sect2">
<h3 class="sect2">C++ Classes Generated by the OTT Utility</h3>
<p>When the OTT utility generates a C++ class from a database object type, the class declaration contains one element corresponding to each attribute of the object type. The data types of the attribute are mapped to types that are used in Oracle object data types, as defined in <a href="#g498965">Table 8-2</a>.</p>
<p>For each class, two new operators, <code dir="ltr">readSQL()</code> and <code dir="ltr">writeSQL()</code> methods are generated. They are used by OCCI to marshall and unmarshall objects.</p>
<p>By default, the C++ classes generated by the OTT utility for an object type are derived from the <code dir="ltr">PObject</code> class, so the generated constructor in the class also derives from the <code dir="ltr">PObject</code> class. For inherited database types, the class is derived from the parent type class as is the generated constructor and only the elements corresponding to attributes not in the parent class are included.</p>
<p>Class declarations that include the elements corresponding to the database type attributes and the method declarations are included in the header file generated by the OTT utility. The method implementations are included in the <code dir="ltr">CPPFILE</code> file generated by the OTT utility.</p>
<div id="LNCPP20403" class="example">
<p class="titleinexample"><a id="sthref587"></a>Example 8-14 How to Generate C++ Classes Using the OTT Utility</p>
<p>This example demonstrates how to generate C++ classes using the OTT utility:</p>
<ol>
<li>
<p>Define the types:</p>
<pre dir="ltr">CREATE TYPE FULL_NAME AS OBJECT (first_name CHAR(20), 
   last_name CHAR(20));
CREATE TYPE ADDRESS AS OBJECT (state CHAR(20), zip CHAR(20));
CREATE TYPE ADDRESS_TAB AS VARRAY(3) of REF ADDRESS;
CREATE TYPE PERSON AS OBJECT (id NUMBER, name FULL_NAME, 
   curr_addr REF ADDRESS, prev_addr_l ADDRESS_TAB) NOT FINAL;
CREATE TYPE STUDENT UNDER PERSON (school_name CHAR(20));
</pre></li>
<li>
<p>Provide an <code dir="ltr">INTYPE</code> file:</p>
<pre dir="ltr">CASE = SAME
MAPFILE = RegisterMappings_3.cpp
TYPE FULL_NAME AS FullName
   TRANSLATE first_name as FirstName
             last_name as LastName
TYPE ADDRESS
TYPE PERSON
TYPE STUDENT
</pre></li>
<li>
<p>Invoke the OTT utility:</p>
<pre dir="ltr">ott userid=demousr intype=demoin_3.typ outype=demoout_3.typ 
   code=cpp hfile=demo_3.h cppfile=demo_3.cpp
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="LNCPP20404" class="sect2"><a id="sthref588"></a>
<h3 class="sect2">Map Registry Function</h3>
<p>One function to register the mappings with the environment is generated by the OTT utility. The function contains the mappings for all the types translated by the invocation of the OTT utility. The function name is either specified in the <code dir="ltr">MAPFUNC</code> parameter or, if that parameter is not specified, derived from <code dir="ltr">MAPFILE</code> parameter. The only argument to the function is the pointer to <code dir="ltr">Environment</code>.</p>
<p>The function uses the provided <code dir="ltr">Environment</code> to get <code dir="ltr">Map</code> and then registers the mapping of each translated type.</p>
</div>
<!-- class="sect2" -->
<a id="i458231"></a>
<div id="LNCPP20405" class="sect2">
<h3 class="sect2">Extending C++ Classes</h3>
<p>To enhance the functionality of a class generated by the OTT utility, you can derive new classes. You can also add methods to a class, but Oracle does not recommend doing so due to an inherent risk.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i469445">&#34;Carrying Forward User Added Code&#34;</a> for details on how to use OTT markers to retain code you want to add in OTT generated files</div>
<p>To generate both <code dir="ltr">CAddress</code> and <code dir="ltr">MyAddress</code> classes from the SQL object type <code dir="ltr">ADDRESS</code>, <code dir="ltr">MyAddress</code> class can be derived from <code dir="ltr">CAddress</code> class. The OTT utility must then alter the code it generates in the following ways:</p>
<ul>
<li>
<p>By using the <code dir="ltr">MyAddress</code> class instead of the <code dir="ltr">CAddress</code> class to represent attributes whose database type is <code dir="ltr">ADDRESS</code></p>
</li>
<li>
<p>By using the <code dir="ltr">MyAddress</code> class instead of the <code dir="ltr">CAddress</code> class to represent vector and <code dir="ltr">REF</code> elements whose database type is <code dir="ltr">ADDRESS</code></p>
</li>
<li>
<p>By using the <code dir="ltr">MyAddress</code> class instead of the <code dir="ltr">CAddress</code> class as the base class for database object types that are inherited from <code dir="ltr">ADDRESS</code>. Even though a derived class is a subtype of <code dir="ltr">MyAddress</code>, the <code dir="ltr">readSQL</code>() and <code dir="ltr">writeSQL()</code> methods called are those of the <code dir="ltr">CAddress</code> class.</p>
</li>
</ul>
<div class="infoboxnotewarn">
<p class="notep1">Caution:</p>
When a class is both extended and used as a base class for another generated class, the <span class="italic">inheriting</span> type class and the <span class="italic">inherited</span> type class must be generated in separate files.</div>
<div id="LNCPP20406" class="example">
<p class="titleinexample"><a id="sthref589"></a>Example 8-15 How to Extend C++ Classes Using the OTT Utility</p>
<p>To use the OTT utility to generate the <code dir="ltr">CAddress</code> class, which is derived from <code dir="ltr">MyAddress</code> class), the following clause must be specified in the <code dir="ltr">TYPE</code> statement:</p>
<pre dir="ltr">TYPE ADDRESS GENERATE CAdress AS MyAddress
</pre>
<p>Given the database types <code dir="ltr">FULL_NAME</code>, <code dir="ltr">ADDRESS</code>, <code dir="ltr">PERSON</code>, and <code dir="ltr">PFGRFDENT</code> as they were created before and changing the <code dir="ltr">INTYPE</code> file to include the <code dir="ltr">GENERATE...</code><code dir="ltr">AS</code> clause:</p>
<pre dir="ltr">CASE = SAME
MAPFILE = RegisterMappings_5.cpp

TYPE FULL_NAME GENERATE CFullName AS MyFullName
   TRANSLATE first_name as FirstName
             last_name as LastName

TYPE ADDRESS GENERATE CAddress AS MyAddress
TYPE PERSON GENERATE CPerson AS MyPerson
TYPE STUDENT GENERATE CStudent AS MyStudent
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i469445"></a>
<div id="LNCPP20407" class="sect1">
<h2 class="sect1">Carrying Forward User Added Code</h2>
<p>To extend the functionality of OTT generated code, at times programmers may want to add code in the OTT generated file. The way OTT can distinguish between OTT generated code and code added by the user is by looking for some predefined markers (tags). OTT recognizes <code dir="ltr">OTT_USERCODE_START</code> as the start of user code marker, and <code dir="ltr">OTT_USERCODE_END</code> as the end of user code marker.</p>
<p>For OTT marker support, a user block is defined as</p>
<pre dir="ltr">OTT_USERCODE_START + user added code + OTT_USERCODE_END
</pre>
<p>OTT marker support enables carrying forward the user added blocks in *.h and *.cpp files.</p>
<a id="i474922"></a>
<div id="LNCPP20408" class="sect2">
<h3 class="sect2">Properties of OTT Markers</h3>
<p>These items describe the properties of OTT Markers Support:</p>
<ol>
<li>
<p>User must use the command line option <code dir="ltr">USE_MARKER=TRUE</code> from the very first time OTT is invoked to generate a file.</p>
</li>
<li>
<p>User should treat markers like other C++ statements; a marker defined by OTT in the generated file as follows when the command line option <code dir="ltr">USE_MARKER=TRUE</code> is used:</p>
<pre dir="ltr">         #ifndef OTT_USERCODE_START 
         #define OTT_USERCODE_START 
         #endif
         #ifndef OTT_USERCODE_END
         #define OTT_USERCODE_END
         #endif
</pre></li>
<li>
<p>The markers, <code dir="ltr">OTT_USERCODE_START</code> and <code dir="ltr">OTT_USERCODE_END</code>, must be preceded and followed by white space.</p>
</li>
<li>
<p>OTT copies the text or code given within markers verbatim, along with the markers, while generating the code next time.</p>
<p>User modified code:</p>
<pre dir="ltr">         1  // --- modified generated code 
         2  OTT_USERCODE_START 
         3  // --- including &#34;myfullname.h&#34; 
         4  #ifndef MYFULLNAME_ORACLE 
         5  #include &#34;myfullname.h&#34; 
         6  #endif 
         7  OTT_USERCODE_END 
         8  // --- end of code addition 
</pre>
<p>Carried forward code:</p>
<pre dir="ltr">         1  OTT_USERCODE_START 
         2  // --- including &#34;myfullname.h&#34; 
         3  #ifndef MYFULLNAME_ORACLE 
         4  #include &#34;myfullname.h&#34; 
         5  #endif 
         6  OTT_USERCODE_END 
</pre></li>
<li>
<p>OTT does not carry forward user-added code properly if the database <code dir="ltr">TYPE</code> or <code dir="ltr">INTYPE</code> file undergoes changes as shown in the following cases:</p>
<ul>
<li>
<p>If user modifies the case of the type name, OTT fails to determine the class name with which the code was associated earlier, as the case of the class name is modified by the user in the <code dir="ltr">INTYPE</code> file.</p>
<pre dir="ltr"><span class="bold">CASE=UPPER                               CASE=LOWER </span>
TYPE employee                            TYPE employee 
TRANSLATE SALARY$ AS salary              TRANSLATE SALARY$ AS salary 
   DEPTNO AS department                     DEPTNO AS department 
TYPE ADDRESS                             TYPE ADDRESS 
TYPE item                                TYPE item 
TYPE &#34;Person&#34;                            TYPE &#34;Person&#34; 
TYPE PURCHASE_ORDER AS p_o               TYPE PURCHASE_ORDER AS p_o
</pre></li>
<li>
<p>If user asks to generate the class with a different name (<code dir="ltr">GENERATE AS</code> clause of <code dir="ltr">INTYPE</code> file), OTT fails to determine the class name with which the code was associated earlier as the class name was modified by the user in the <code dir="ltr">INTYPE</code> file.</p>
<pre dir="ltr">CASE=LOWER                           CASE=LOWER 
TYPE employee                        TYPE employee 
TRANSLATE SALARY$ AS salary          TRANSLATE SALARY$ AS salary 
   DEPTNO AS department                 DEPTNO AS department 
TYPE ADDRESS                         TYPE ADDRESS 
TYPE item                            TYPE item 
TYPE &#34;Person&#34;                        TYPE &#34;Person&#34; 
<span class="bold">TYPE PURCHASE_ORDER AS p_o           TYPE PURCHASE_ORDER AS</span>
<span class="bold">                                        purchase_order</span>
</pre></li>
</ul>
</li>
<li>
<p>If OTT encounters an error while parsing an <code dir="ltr">.h</code> or <code dir="ltr">.cpp</code> file, it reports the error and leaves the file having error as it is so that the user can go back and correct the error reported, and rerun OTT.</p>
</li>
<li>
<p>OTT flags an error if:</p>
<ul>
<li>
<p>it does not find a matching <code dir="ltr">OTT_USERCODE_END</code> for <code dir="ltr">OTT_USERCODE_START</code> encountered</p>
</li>
<li>
<p>markers are nested (OTT finds next <code dir="ltr">OTT_USERCODE_START</code> before <code dir="ltr">OTT_USERCODE_END</code> is found for the previous <code dir="ltr">OTT_USERCODE_START</code>)</p>
</li>
<li>
<p><code dir="ltr">OTT_USERCODE_END</code> is encountered before <code dir="ltr">OTT_USERCODE_START</code></p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i474923"></a>
<div id="LNCPP20409" class="sect2">
<h3 class="sect2">Using OTT Markers</h3>
<p>The user must use command line option <code dir="ltr">USE_MARKER=TRUE</code> to turn on marker support. There are two general ways in which OTT markers can carry forward user added code:</p>
<ol>
<li>
<p><span class="bold">User code added in .h file.</span></p>
<ul>
<li>
<p><span class="bold">User code added in global scope.</span> This is typically the case when user must include different header files, forward declaration, and so on. Refer to the code example provided later.</p>
</li>
<li>
<p><span class="bold">User code added in class declaration.</span> At any point of time OTT generated class declaration has private scope for data members and public scope for methods, or protected scope for data members and public scope for methods. User blocks can be added after all OTT generated declarations in either access specifiers.</p>
</li>
</ul>
<div id="LNCPP20410" class="example">
<p class="titleinexample"><a id="sthref590"></a>Example 8-16 How to Add User Code to a Header File Using OTT Utility</p>
<pre dir="ltr">...                                                 
#ifndef OTT_USERCODE_START                                  
#define OTT_USERCODE_START 
#endif
#ifndef OTT_USERCODE_END
#define OTT_USERCODE_END
#endif           

#ifndef OCCI_ORACLE
#include &lt;occi.h&gt;
#endif

OTT_USERCODE_START     // user added code 
...
OTT_USERCODE_END

#ifndef ...            // OTT generated include
#include &#34; ... &#34;
#endif

OTT_USERCODE_START     // user added code 
...
OTT_USERCODE_END

class &lt;class_name_1&gt; : public oracle::occi::PObject
{  protected:
      ...             // OTT generated data members 
      OTT_USERCODE_START    // user added code  for data member / method
      ...                   //    declaration / inline method
      OTT_USERCODE_END
     
   public:
      void *operator new(size_t size);
      ...
      OTT_USERCODE_START   // user added code  for data member / method
      ...                  // declaration / inline method definition
      OTT_USERCODE_END
};
  
OTT_USERCODE_START     // user added code 
...
OTT_USERCODE_END

class &lt;class_name_2&gt; : public oracle::occi::PObject
{
   ...
};

OTT_USERCODE_START     // user added code 
...                                                          
OTT_USERCODE_END                                             
...                                                                  
#endif                 // end of .h file                     
</pre></div>
<!-- class="example" --></li>
<li>
<p><span class="bold">User code added in .cpp file.</span> OTT supports adding a new user defined method within OTT markers. The user block must be added at the beginning of the file, just after the includes and before the definition of OTT-generated methods. If there are multiple OTT-generated <code dir="ltr">include</code>s, user code can also be added between OTT generated includes. User code added in any other part of a <code dir="ltr"><span class="codeinlineitalic">xxx</span></code><code dir="ltr">.cpp</code> file is not carried forward.</p>
<div id="LNCPP20411" class="example">
<p class="titleinexample"><a id="sthref591"></a>Example 8-17 How to Add User Code to the Source File Using the OTT Utility</p>
<pre dir="ltr">#ifndef OTT_USERCODE_START                                   
#define OTT_USERCODE_START                                  
#endif                                                       
                                                                   
#ifndef OTT_USERCODE_END
#define OTT_USERCODE_END
#endif
...
   OTT_USERCODE_START    // user added code 
      ...
   OTT_USERCODE_END
...
   OTT_USERCODE_START    // user added code 
      ...
   OTT_USERCODE_END

/*************************************************************
/ generated method implementations for the ... object type.
/*************************************************************/

void *&lt;class_name_1&gt;::operator new(size_t size)
{
   return oracle::occi::PObject::operator new(size);
}
...                                                          
// end of .cpp file                                          
</pre></div>
<!-- class="example" --></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2196">
<tr>
<td class="cellalignment2205">
<table class="cellalignment2201">
<tr>
<td class="cellalignment2200"><a href="lobs.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2200"><a href="globalization.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2208">
<table class="cellalignment2199">
<tr>
<td class="cellalignment2200"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2200"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2200"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2200"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2200"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2200"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>