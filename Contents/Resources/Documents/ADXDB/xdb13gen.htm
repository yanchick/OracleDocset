<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-1612"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Generation%20of%20XML%20Data%20from%20Relational%20Data"></a><title>Generation of XML Data from Relational Data</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content."/>
<meta name="keywords" content="generating XML, SQL/XML standard, generating XML data, functions, SQL, XMLElement, XMLElement SQL function, XMLAttributes, XMLAttributes SQL function, nested XML, generating with XMLElement, UDT, generating an element from, XMLForest, XMLForest SQL function, XMLConcat, XMLConcat SQL function, XMLAgg, XMLAgg SQL function, XMLPI, XMLPI SQL function, XMLPI SQL function, XMLComment, XMLComment SQL function, XMLSerialize, XMLSerialize SQL function, pretty-printing, XMLParse, XMLParse SQL function, XMLRoot, XMLRoot SQL function, XMLColAttVal, XMLColAttVal SQL function, XMLColAttVal SQL function, XMLCDATA, XMLCDATA SQL function, DBMS_XMLGEN PL/SQL package, PL/SQL packages, DBMS_XMLGEN, DBMS_XMLGEN PL/SQL package, generating using DBMS_XMLGEN, sys_XMLAgg, sys_XMLAgg SQL function, sys_XMLAgg SQL function"/>
<meta name="dcterms.created" content="2016-12-08T13:53:25Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="XML DB Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E41152-15"/>
<meta name="dcterms.isVersionOf" content="ADXDB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="partpg4.htm" title="Previous" type="text/html"/>
<link rel="Next" href="xdb_rel_views.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41152-15.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686"></a> <span id="PAGE" style="display:none;">18/61</span> <!-- End Header -->
<script>
//<![CDATA[
window.name='xdb13gen'
//]]>
</script> <script>
    function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote&amp;nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
</script><noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="ADXDB1600"></a>
<h1 id="ADXDB-GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" class="sect1"><span class="enumeration_chapter">8</span> Generation of XML Data from Relational Data</h1>
<div>
<p>Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb13gen.htm#GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F" title="You can generate XML data using Oracle XML&nbsp;DB using standard SQL/XML functions, Oracle-specific SQL functions, PL/SQL subprograms from package DBMS_XMLGEN, or DBURIType.">Overview of Generating XML Data</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL/SQL package DBMS_XMLGEN creates XML documents from SQL query results. It retrieves an XML document as a CLOB or XMLType value.">Generation of XML Data Using DBMS_XMLGEN</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" title="Oracle SQL function sys_XMLAgg aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named ROWSET (by default).">SYS_XMLAGG Oracle SQL Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130" title="To use the XMLAgg ORDER BY clause before aggregation, specify the ORDER BY clause following the first XMLAGG argument.">Ordering Query Results Before Aggregating_ Using XMLAGG ORDER BY Clause</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384" title="You can use standard SQL/XML function XMLTable to return a rowset with relevant portions of a document extracted as multiple rows.">Returning a Rowset Using XMLTABLE</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686__GUID-52EE5CDD-75CF-48B8-88F5-055B8A1B4116">
<p class="notep1">See Also:</p>
<p><a href="xdb_xquery.htm#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a> for information about constructing XML data using SQL/XML functions <code>XMLQuery</code> and <code>XMLTable</code></p>
</div>
</div>
<a id="ADXDB4987"></a>
<div class="props_rev_3"><a id="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F"></a>
<h2 id="ADXDB-GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F" class="sect2"><span class="enumeration_section">8.1</span> Overview of Generating XML Data</h2>
<div>
<p>You can generate XML data using Oracle XML&nbsp;DB using standard SQL/XML functions, Oracle-specific SQL functions, PL/SQL subprograms from package <code>DBMS_XMLGEN</code>, or <code>DBURIType</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p>Use standard SQL/XML functions. See <span class="q">&#34;<a href="xdb13gen.htm#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a>&#34;</span>.</p>
</li>
<li>
<p>Use <a id="d57804e178" class="indexterm-anchor"></a>Oracle SQL functions&thinsp;. See the following sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb13gen.htm#GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD" title="You can use Oracle SQL function XMLRoot to add a VERSION property, and optionally a STANDALONE property, to the root information item of an XML value. Typically, this is done to ensure data-model compliance.">XMLROOT Oracle SQL Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" title="Oracle SQL function XMLColAttVal generates a forest of XML column elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions.">XMLCOLATTVAL Oracle SQL Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" title="You use Oracle SQL function XMLCDATA to generate an XML CDATA section.">XMLCDATA Oracle SQL Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" title="Oracle SQL function sys_XMLAgg aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named ROWSET (by default).">SYS_XMLAGG Oracle SQL Function</a>. This operates on groups of rows, aggregating several XML documents into one.</p>
</li>
</ul>
</li>
<li>
<p>Use PL/SQL package <code>DBMS_XMLGEN</code>. See <span class="q">&#34;<a href="xdb13gen.htm#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL/SQL package DBMS_XMLGEN creates XML documents from SQL query results. It retrieves an XML document as a CLOB or XMLType value.">Generation of XML Data Using DBMS_XMLGEN</a>&#34;</span>.</p>
</li>
<li>
<p>Use a <code>DBURIType</code> instance to construct XML documents from database data. See <a href="xdb15dbu.htm#GUID-0F5F6D4C-0C27-4EC0-926C-CDCC0C1F9798" title="You can generate and store URIs in the database and use them to retrieve the database data they target. There are three kinds of URIs you can use this way: DBUris, XDBUris, and HTTPUris.">Data Access Using URIs</a>.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F__GUID-5682D9D5-603D-4EC6-9030-AB6EC2E99703">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb03usg.htm#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="xdb08tra.htm#GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" title="There are several Oracle SQL functions and XMLType APIs for transforming XMLType data using XSLT stylesheets and for validating XMLType instances against an XML schema.">Transformation and Validation of XMLType Data</a></p>
</li>
<li>
<p><a href="xdb10pls.htm#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="There are several PL/SQL packages that provide APIs for XMLType.">PL/SQL APIs for XMLType</a></p>
</li>
<li>
<p><a href="xdb11jav.htm#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="The Java DOM API for XMLType lets you operate on XMLType instances using a DOM. You can use it to manipulate XML data in Java, including fetching it through Java Database Connectivity (JDBC).">Java DOM API for XMLType</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB1620"></a>
<div class="props_rev_3"><a id="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967"></a>
<h2 id="ADXDB-GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" class="sect2"><span class="enumeration_section">8.2</span> Generation of XML Data Using SQL Functions</h2>
<div>
<p>Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb13gen.htm#GUID-868E591C-19A1-4E4A-BC2A-013181071B77" title="SQL/XML standard function XMLElement constructs XML elements from relational data. SQL/XML standard function XMLAttributes can be used together with XMLElement, to specify attributes for the generated elements.">XMLELEMENT and XMLATTRIBUTES SQL/XML Functions</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB" title="You use SQL/XML standard function XMLForest to construct a forest of XML elements.">XMLFOREST SQL/XML Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17" title="You use SQL/XML standard function XMLConcat to construct an XML fragment by concatenating multiple XMLType instances.">XMLCONCAT SQL/XML Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB" title="You use SQL/XML standard function XMLAgg to construct a forest of XML elements from a collection of XML elements&thinsp;&mdash;&thinsp;it is an aggregate function.">XMLAGG SQL/XML Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C" title="You use SQL/XML standard function XMLPI to construct an XML processing instruction (PI).">XMLPI SQL/XML Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915" title="You use SQL/XML standard function XMLComment to construct an XML comment.">XMLCOMMENT SQL/XML Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8" title="You use SQL/XML standard function XMLSerialize to obtain a string or LOB representation of XML data.">XMLSERIALIZE SQL/XML Function</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C" title="You use SQL/XML standard function XMLParse to parse a string containing XML data and construct a corresponding XMLType instance.">XMLPARSE SQL/XML Function</a></p>
</li>
</ul>
<p>The standard XML-generation functions are also known as <a id="d57804e467" class="indexterm-anchor"></a><a id="d57804e471" class="indexterm-anchor"></a>SQL/XML <strong class="term">publishing</strong> or <strong class="term">generation</strong> functions.</p>
<p>The use of SQL/XML function <code>XMLQuery</code> is not limited to generating (publishing) XML data. Function <code>XMLQuery</code> is very general and is referred to in this book as a SQL/XML <span class="italic">query and update</span> function.</p>
<p>The following XML-generating SQL functions are Oracle-specific (not part of the SQL/XML standard):</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb13gen.htm#GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD" title="You can use Oracle SQL function XMLRoot to add a VERSION property, and optionally a STANDALONE property, to the root information item of an XML value. Typically, this is done to ensure data-model compliance.">XMLROOT Oracle SQL Function</a>.</p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" title="Oracle SQL function XMLColAttVal generates a forest of XML column elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions.">XMLCOLATTVAL Oracle SQL Function</a>.</p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" title="You use Oracle SQL function XMLCDATA to generate an XML CDATA section.">XMLCDATA Oracle SQL Function</a>.</p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" title="Oracle SQL function sys_XMLAgg aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named ROWSET (by default).">SYS_XMLAGG Oracle SQL Function</a>. This operates on groups of relational rows, aggregating several XML documents into one.</p>
</li>
</ul>
<p>All of the XML-generation SQL functions convert scalars and user-defined data-type instances to their canonical XML format. In this canonical mapping, user-defined data-type attributes are mapped to XML elements.</p>
<div class="infoboxnotealso" id="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967__GUID-6F3CA72A-669C-4BEE-9B68-FC2E2EEC3032">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_xquery.htm#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a> for information about constructing XML data using SQL/XML function <code>XMLQuery</code></p>
</li>
<li>
<p><a class="olink SQLRF55529" target="_blank" href="../SQLRF/ap_standard_sql010.htm#SQLRF55529"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about Oracle support for the SQL/XML standard</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB4995"></a><a id="ADXDB4996"></a><a id="ADXDB4994"></a>
<div class="props_rev_3"><a id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77"></a>
<h3 id="ADXDB-GUID-868E591C-19A1-4E4A-BC2A-013181071B77" class="sect3"><span class="enumeration_section">8.2.1</span> XMLELEMENT and XMLATTRIBUTES SQL/XML Functions</h3>
<div>
<p>SQL/XML standard function <code>XMLElement</code> constructs XML elements from relational data. SQL/XML standard function <code>XMLAttributes</code> can be used together with <code>XMLElement</code>, to specify attributes for the generated elements.</p>
<div class="section">
<p>SQL/XML standard function <code>XMLElement</code> takes as arguments an XML element name, an optional collection of attributes for the element, and zero or more additional arguments that make up the element content. It returns an <code>XMLType</code> instance.</p>
<div class="figure" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__i1030781">
<p class="titleinfigure">Figure 8-1 XMLELEMENT Syntax</p>
<img width="652" height="218" src="img/GUID-D9167902-BF93-4578-8375-A29719317127-default.gif" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows"/><br/>
<a href="img_text/GUID-D9167902-BF93-4578-8375-A29719317127-print.htm">Description of &#34;Figure 8-1 XMLELEMENT Syntax&#34;</a></div>
<!-- class="figure" -->
<p>For an explanation of keywords <code>ENTITYESCAPING</code> and <code>NOENTITYESCAPING</code>, see <span class="q">&#34;<a href="xdb13gen.htm#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &ndash; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>&#34;</span>. These keywords are Oracle extensions to standard SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>.</p>
<p>The first argument to function <code>XMLElement</code> defines an identifier that names the <span class="italic">root</span> XML element to be created. The root-element identifier argument can be defined using a literal identifier (<span class="italic"><code>identifier</code></span>, in <a href="xdb13gen.htm#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__i1030781">Figure 8-1</a>) or by <code>EVALNAME</code> followed by an expression (<span class="italic"><code>value_expr</code></span>) that evaluates to an identifier. However it is defined, the identifier must not be <code>NULL</code> or else an error is raised. The possibility of using <code>EVALNAME</code> is an Oracle extension to standard SQL/XML function <code>XMLElement</code>.</p>
<p>The optional <span class="italic"><code>XML-attributes-clause</code></span> argument of function <code>XMLElement</code> specifies the attributes of the root element to be generated. <a href="xdb13gen.htm#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">Figure 8-2</a> shows the syntax of this argument.</p>
<p>In addition to the optional <span class="italic"><code>XML-attributes-clause</code></span> argument, function <code>XMLElement</code> accepts zero or more <span class="italic"><code>value_expr</code></span> arguments that make up the <span class="italic">content</span> of the root element (child elements and text content). If an <span class="italic"><code>XML-attributes-clause</code></span> argument is also present then these content arguments must follow the <span class="italic"><code>XML-attributes-clause</code></span> argument. Each of the content-argument expressions is evaluated, and the result is converted to XML format. If a value argument evaluates to <code>NULL</code>, then no content is created for that argument.</p>
<div class="infobox-note" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-228026D6-5437-408D-98D4-2B68F90098BE">
<p class="notep1">Note:</p>
<p>The <code>AS</code> preceding an alias (<span class="italic"><code>c_alias</code></span>) is required by the SQL/XML standard, but is optional for Oracle.</p>
</div>
<p>The optional <span class="italic"><code>XML-attributes-clause</code></span> argument uses SQL/XML standard function <code>XMLAttributes</code> to specify the <span class="italic">attributes</span> of the root element. Function <code>XMLAttributes</code> can be used <span class="italic">only</span> in a call to function <code>XMLElement</code>. It cannot be used on its own.</p>
<div class="figure" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">
<p class="titleinfigure">Figure 8-2 XMLAttributes Clause Syntax (XMLATTRIBUTES)</p>
<img width="478" height="294" src="img/GUID-4452C3BD-75CE-4125-A1FD-E64929A15D70-default.gif" alt="Description of Figure 8-2 follows" title="Description of Figure 8-2 follows"/><br/>
<a href="img_text/GUID-4452C3BD-75CE-4125-A1FD-E64929A15D70-print.htm">Description of &#34;Figure 8-2 XMLAttributes Clause Syntax (XMLATTRIBUTES)&#34;</a></div>
<!-- class="figure" -->
<p>For an explanation of keywords <code>ENTITYESCAPING</code> and <code>NOENTITYESCAPING</code>, see <span class="q">&#34;<a href="xdb13gen.htm#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &ndash; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>&#34;</span>. These keywords are Oracle extensions to standard SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>.</p>
<p>Keywords <code>SCHEMACHECK</code> and <code>NOSCHEMACHECK</code> determine whether or not a run-time check is made of the generated attributes, to see if any of them specify a schema location that corresponds to an XML schema that is registered with Oracle XML&nbsp;DB, and, if so, to try to generate XML schema-based XML data accordingly. The default behavior is that provided by <code>NOSCHEMACHECK</code>: no check is made. In releases prior to 12<span class="italic">c</span> Release 1 (12.1), the default behavior is to perform the check. Keyword <code>SCHEMACHECK</code> can be used to obtain backward compatibility.</p>
<p>Note that a similar check is <span class="italic">always</span> made at <span class="italic">compile</span> time, regardless of the presence or absence of <code>NOSCHEMACHECK</code>. This means, in particular, that if you use a string literal to specify an XML schema location attribute value, then a (compile-time) check is made, and, if appropriate, XML schema-based data is generated accordingly.</p>
<p>Keywords <code>SCHEMACHECK</code> and <code>NOSCHEMACHECK</code> are Oracle extensions to standard SQL/XML function <code>XMLAttributes</code>.</p>
<div class="infobox-note" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-416A016B-0D0B-4BC7-8C0A-73286E22EC20">
<p class="notep1">Note:</p>
<p>If a view is created to generate XML data, function <code>XMLAttributes</code> is used to add XML-schema location references, and the target XML schema has not yet been registered with Oracle XML&nbsp;DB, then the XML data that is generated is not XML schema-based. If the XML schema is subsequently registered, then XML data that is generated thereafter is also <span class="italic">not</span> XML-schema-based. To create XML schema-based data, you must recompile the view.</p>
</div>
<p>Argument <span class="italic"><code>XML-attributes-clause</code></span> itself contains one or more <span class="italic"><code>value_expr</code></span> expressions as arguments to function <code>XMLAttributes</code>. These are evaluated to obtain the values for the attributes of the root element. (Do not confuse these <span class="italic"><code>value_expr</code></span> arguments to function <code>XMLAttributes</code> with the <span class="italic"><code>value_expr</code></span> arguments to function <code>XMLElement</code>, which specify the content of the root element.) The optional <code>AS</code> <span class="italic"><code>c_alias</code></span> clause for each <span class="italic"><code>value_expr</code></span> specifies that the attribute name is <span class="italic"><code>c_alias</code></span>, which can be either a string literal or <code>EVALNAME</code> followed by an expression that evaluates to a string literal.</p>
<div class="infobox-note" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-87072A08-898A-4FD1-A257-7C67307B7786">
<p class="notep1">Note:</p>
<p>The following are Oracle extensions to the standard SQL/XML syntax:</p>
<ul style="list-style-type: disc;">
<li>
<p>The possibility of using <code>EVALNAME</code>.</p>
</li>
<li>
<p>The fact that <code>AS</code> preceding an alias (<span class="italic"><code>c_alias</code></span>) is optional.</p>
</li>
</ul>
</div>
<p>If an attribute value expression evaluates to <code>NULL</code>, then no corresponding attribute is created. The data type of an attribute value expression cannot be an object type or a collection.</p>
</div>
<!-- class="section" --></div>
<a id="ADXDB4997"></a>
<div class="props_rev_3"><a id="GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2"></a>
<h4 id="ADXDB-GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" class="sect4"><span class="enumeration_section">8.2.1.1</span> Escape of Characters in Generated XML Data</h4>
<div>
<p>As specified by the SQL/XML standard, characters in explicit <span class="italic">identifiers</span> are <span class="italic">not</span> escaped in any way &ndash; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.</p>
<p>In particular, it applies to the root-element identifier of <code>XMLElement</code> (<span class="italic"><code>identifier</code></span>, in <a href="xdb13gen.htm#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__i1030781">Figure 8-1</a>) and to attribute identifier aliases named with <code>AS</code> clauses of <code>XMLAttributes</code> (see <a href="xdb13gen.htm#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">Figure 8-2</a>).</p>
<p>However, other XML data that is generated is <span class="italic">escaped</span>, by default, to ensure that only valid XML <code>NameChar</code> characters are generated. As part of generating a valid XML element or attribute name from a SQL identifier, each character that is disallowed in an XML name is replaced with an underscore character (<code>_</code>), followed by the hexadecimal Unicode representation of the original character, followed by a second underscore character. For example, the colon character (<code>:</code>) is escaped by replacing it with <code>_003A_</code>, where 003A is the hexadecimal Unicode representation.</p>
<p>Escaping applies to characters in the evaluated <span class="italic"><code>value_expr</code></span> arguments to <span class="italic">all</span> SQL/XML functions, including <code>XMLElement</code> and <code>XMLAttributes</code>. It applies also to the characters of an attribute identifier that is defined implicitly from an <code>XMLAttributes</code> attribute value expression that is <span class="italic">not</span> followed by an <code>AS</code> clause: the escaped form of the SQL column name is used as the name of the attribute.</p>
<p>In some cases, you might not need or want character escaping. If you know, for example, that the XML data being generated is well-formed, then you can save some processing time by inhibiting escaping. You can do that by specifying the keyword <code>NOENTITYESCAPING</code> for SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>. Keyword <code>ENTITYESCAPING</code> imposes escaping, which is the default behavior. Keywords <code>NOENTITYESCAPING</code> and <code>ENTITYESCAPING</code> are Oracle extensions to standard SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>.</p>
</div>
</div>
<a id="ADXDB4998"></a>
<div class="props_rev_3"><a id="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527"></a>
<h4 id="ADXDB-GUID-18DC2329-2C1D-4A23-9321-82519AAC4527" class="sect4"><span class="enumeration_section">8.2.1.2</span> Formatting of XML Dates and Timestamps</h4>
<div>
<p>The XML Schema standard specifies that dates and timestamps in XML data be in standard formats. XML generation functions in Oracle XML&nbsp;DB produce XML dates and timestamps according to this standard.</p>
<p>In releases prior to Oracle Database&nbsp;10g Release 2, the database settings for date and timestamp formats, not the XML Schema standard formats, were used for XML. You can reproduce this <span class="italic">previous</span> behavior by setting the database event 19119, level 0x8, as follows:</p>
<pre>ALTER SESSION SET EVENTS &#39;19119 TRACE NAME CONTEXT FOREVER, LEVEL 0x8&#39;;
</pre>
<p>If you must otherwise produce a non-standard XML date or timestamp, use SQL function <code>to_char</code> &ndash; see <a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">Example 8-1</a>.</p>
<div class="infoboxnotealso" id="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527__GUID-ADBDB093-4AF5-4520-BCCA-40E86EFABD61">
<p class="notep1">See Also:</p>
<p><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#isoformats" target="_blank"><code>http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#isoformats</code></a> for the XML Schema specification of XML date and timestamp formats</p>
</div>
</div>
</div>
<a id="ADXDB5000"></a><a id="ADXDB5001"></a><a id="ADXDB5002"></a><a id="ADXDB5003"></a><a id="ADXDB5895"></a><a id="ADXDB5004"></a><a id="ADXDB5005"></a><a id="ADXDB4999"></a>
<div class="props_rev_3"><a id="GUID-49E8774C-E240-47BA-966B-60B28DD50774"></a>
<h4 id="ADXDB-GUID-49E8774C-E240-47BA-966B-60B28DD50774" class="sect4"><span class="enumeration_section">8.2.1.3</span> XMLElement Examples</h4>
<div>
<p>Examples here illustrate the use SQL/XML function <code>XMLElement</code>.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">Example 8-1</a> uses <code>XMLElement</code> to generate an XML date with a format that is different from the XML Schema standard date format.</p>
<p><a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGBHCC">Example 8-2</a> uses <code>XMLElement</code> to generate an <code>Emp</code> element for each employee, with the employee name as the content.</p>
<p><a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGGIGG">Example 8-3</a> uses <code>XMLElement</code> to generate an <code>Emp</code> element for each employee, with child elements that provide the employee name and hire date.</p>
<p><a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEDFACF">Example 8-4</a> uses <code>XMLElement</code> to generate an <code>Emp</code> element for each employee, with attributes <code>id</code> and <code>name</code>.</p>
<p>As mentioned in <span class="q">&#34;<a href="xdb13gen.htm#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &ndash; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>&#34;</span>, characters in the root-element name and the names of any attributes defined by <code>AS</code> clauses are <span class="italic">not</span> escaped. Characters in an identifier name are escaped only if the name is created from an evaluated expression (such as a column reference).</p>
<p><a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEIEAJH">Example 8-5</a> shows that, with XML data constructed using <code>XMLElement</code>, the root-element name and the attribute name are <span class="italic">not</span> escaped. Invalid XML is produced because greater-than sign (<code>&gt;</code>) and a comma (<code>,</code>) are not allowed in XML element and attribute names.</p>
<p>A full description of character escaping is included in the SQL/XML standard.</p>
<p><a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">Example 8-6</a> illustrates the use of namespaces to create an XML schema-based document. Assuming that an XML schema &#34;<code>http://www.oracle.com/Employee.xsd</code>&#34; exists and has no target namespace, the query in <a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">Example 8-6</a> creates an <code>XMLType</code> instance conforming to that schema:</p>
<p><a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">Example 8-7</a> uses <code>XMLElement</code> to generate an XML document with employee and department information, using data from sample database schema table <code>hr.departments</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">
<p class="titleinexample">Example 8-1 XMLELEMENT: Formatting a Date</p>
<pre dir="ltr">-- With standard XML date format:
SELECT XMLElement(&#34;Date&#34;, hire_date)
  FROM hr.employees
  WHERE employee_id = 203;
 
XMLELEMENT(&#34;DATE&#34;,HIRE_DATE)
----------------------------
&lt;Date&gt;2002-06-07&lt;/Date&gt;
 
1 row selected.
 
-- With an alternative date format:
SELECT XMLElement(&#34;Date&#34;, <span class="bold">to_char</span>(hire_date))
  FROM hr.employees
  WHERE employee_id = 203;
 
XMLELEMENT(&#34;DATE&#34;,TO_CHAR(HIRE_DATE))
-------------------------------------
&lt;Date&gt;<span class="bold">07-JUN-02</span>&lt;/Date&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGBHCC">
<p class="titleinexample">Example 8-2 XMLELEMENT: Generating an Element for Each Employee</p>
<pre dir="ltr">SELECT e.employee_id, 
       XMLELEMENT (&#34;Emp&#34;, e.first_name ||&#39; &#39;|| e.last_name) AS &#34;RESULT&#34;
   FROM hr.employees e
   WHERE employee_id &gt; 200;
</pre>
<p>This query produces the following typical result:</p>
<pre dir="ltr">EMPLOYEE_ID RESULT
----------- -----------------------------------
        201 &lt;Emp&gt;Michael Hartstein&lt;/Emp&gt;
        202 &lt;Emp&gt;Pat Fay&lt;/Emp&gt;
        203 &lt;Emp&gt;Susan Mavris&lt;/Emp&gt;
        204 &lt;Emp&gt;Hermann Baer&lt;/Emp&gt;
        205 &lt;Emp&gt;Shelley Higgins&lt;/Emp&gt;
        206 &lt;Emp&gt;William Gietz&lt;/Emp&gt;
 
6 rows selected.
</pre>
<p>SQL/XML function <code>XMLElement</code> can also be nested, to produce XML data with a nested structure.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGGIGG">
<p class="titleinexample">Example 8-3 XMLELEMENT: Generating Nested XML</p>
<pre dir="ltr">SELECT XMLElement(&#34;Emp&#34;, 
                   XMLElement(&#34;name&#34;, e.first_name ||&#39; &#39;|| e.last_name),
                   XMLElement(&#34;hiredate&#34;, e.hire_date)) AS &#34;RESULT&#34; 
FROM hr.employees e 
WHERE employee_id &gt; 200;
</pre>
<p>This query produces the following typical XML result:</p>
<pre dir="ltr">RESULT
-----------------------------------------------------------------------
&lt;Emp&gt;&lt;name&gt;Michael Hartstein&lt;/name&gt;&lt;hiredate&gt;2004-02-17&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Pat Fay&lt;/name&gt;&lt;hiredate&gt;2005-08-17&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Susan Mavris&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Hermann Baer&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Shelley Higgins&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;William Gietz&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEDFACF">
<p class="titleinexample">Example 8-4 XMLELEMENT: Generating Employee Elements with Attributes ID and Name</p>
<pre dir="ltr">SELECT XMLElement(&#34;Emp&#34;, XMLAttributes(
                           e.employee_id as &#34;ID&#34;,
                           e.first_name ||&#39; &#39; || e.last_name AS &#34;name&#34;))
  AS &#34;RESULT&#34;
  FROM hr.employees e
  WHERE employee_id &gt; 200;
</pre>
<p>This query produces the following typical XML result fragment:</p>
<pre dir="ltr">RESULT
-----------------------------------------------
&lt;Emp ID=&#34;201&#34; name=&#34;Michael Hartstein&#34;&gt;&lt;/Emp&gt;
&lt;Emp ID=&#34;202&#34; name=&#34;Pat Fay&#34;&gt;&lt;/Emp&gt;
&lt;Emp ID=&#34;203&#34; name=&#34;Susan Mavris&#34;&gt;&lt;/Emp&gt;
&lt;Emp ID=&#34;204&#34; name=&#34;Hermann Baer&#34;&gt;&lt;/Emp&gt;
&lt;Emp ID=&#34;205&#34; name=&#34;Shelley Higgins&#34;&gt;&lt;/Emp&gt;
&lt;Emp ID=&#34;206&#34; name=&#34;William Gietz&#34;&gt;&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEIEAJH">
<p class="titleinexample">Example 8-5 XMLELEMENT: Characters in Generated XML Data Are Not Escaped</p>
<pre dir="ltr">SELECT XMLElement(&#34;Emp-<span class="bold">&gt;</span>Special&#34;, 
                  XMLAttributes(e.last_name || &#39;, &#39; || e.first_name
                                AS &#34;Last<span class="bold">,</span>First&#34;))
   AS &#34;RESULT&#34;
   FROM hr.employees e
   WHERE employee_id = 201;
</pre>
<p>This query produces the following result, which is <span class="italic">not</span> well-formed XML:</p>
<pre dir="ltr">RESULT
--------------------------------------------------------------------
&lt;Emp-<span class="bold">&gt;</span>Special Last<span class="bold">,</span>First=&#34;Hartstein, Michael&#34;&gt;&lt;/Emp-<span class="bold">&gt;</span>Special&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">
<p class="titleinexample">Example 8-6 Creating a Schema-Based XML Document Using XMLELEMENT with Namespaces</p>
<pre dir="ltr">SELECT XMLElement(&#34;Employee&#34;, 
                  XMLAttributes(&#39;http://www.w3.org/2001/XMLSchema&#39; AS
                                  &#34;xmlns:xsi&#34;,
                                &#39;http://www.oracle.com/Employee.xsd&#39; AS
                                  &#34;xsi:nonamespaceSchemaLocation&#34;),
                  XMLForest(employee_id, last_name, salary)) AS &#34;RESULT&#34;
   FROM hr.employees
   WHERE department_id = 10;
</pre>
<p>This creates the following XML document that conforms to XML schema <code>Employee.xsd</code>. (The result is shown here pretty-printed, for clarity.)</p>
<pre dir="ltr">RESULT
-----------------------------------------------------------------------------
&lt;Employee xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema&#34;
          xsi:nonamespaceSchemaLocation=&#34;http://www.oracle.com/Employee.xsd&#34;&gt;
   &lt;EMPLOYEE_ID&gt;200&lt;/EMPLOYEE_ID&gt;
   &lt;LAST_NAME&gt;Whalen&lt;/LAST_NAME&gt;
   &lt;SALARY&gt;4400&lt;/SALARY&gt;
&lt;/Employee&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">
<p class="titleinexample">Example 8-7 XMLELEMENT: Generating an Element from a User-Defined Data-Type Instance</p>
<pre dir="ltr">CREATE OR REPLACE TYPE emp_t AS OBJECT (&#34;@EMPNO&#34; NUMBER(4),
                                         ENAME VARCHAR2(10));

CREATE OR REPLACE TYPE emplist_t AS TABLE OF emp_t;

CREATE OR REPLACE TYPE dept_t AS OBJECT (&#34;@DEPTNO&#34; NUMBER(2),
                                         DNAME VARCHAR2(14),
                                         EMP_LIST emplist_t);

SELECT XMLElement(&#34;Department&#34;,
                  dept_t(department_id,
                         department_name,
                         cast(MULTISET
                              (SELECT employee_id, last_name
                                 FROM hr.employees e
                                 WHERE e.department_id = d.department_id)
                              AS emplist_t)))
  AS deptxml
  FROM hr.departments d
  WHERE d.department_id = 10;
</pre>
<p>This produces an XML document which contains the <code>Department</code> element and the canonical mapping of type <code>dept_t</code>.</p>
<pre dir="ltr">DEPTXML
-------------
&lt;Department&gt;
  &lt;DEPT_T DEPTNO=&#34;10&#34;&gt;
    &lt;DNAME&gt;ACCOUNTING&lt;/DNAME&gt;
    &lt;EMPLIST&gt;
      &lt;EMP_T EMPNO=&#34;7782&#34;&gt;
        &lt;ENAME&gt;CLARK&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
      &lt;EMP_T EMPNO=&#34;7839&#34;&gt;
        &lt;ENAME&gt;KING&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
      &lt;EMP_T EMPNO=&#34;7934&#34;&gt;
        &lt;ENAME&gt;MILLER&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
    &lt;/EMPLIST&gt;
  &lt;/DEPT_T&gt;
&lt;/Department&gt;

1 row selected.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB5007"></a><a id="ADXDB5008"></a><a id="ADXDB5009"></a><a id="ADXDB5006"></a>
<div class="props_rev_3"><a id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB"></a>
<h3 id="ADXDB-GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB" class="sect3"><span class="enumeration_section">8.2.2</span> XMLFOREST SQL/XML Function</h3>
<div>
<p>You use SQL/XML standard function <code>XMLForest</code> to construct a forest of XML elements.</p>
<div class="section">
<p>Its arguments are expressions to be evaluated, with optional aliases. <a href="xdb13gen.htm#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__i1030830">Figure 8-3</a> describes the <code>XMLForest</code> syntax.</p>
<div class="figure" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__i1030830">
<p class="titleinfigure">Figure 8-3 XMLFOREST Syntax</p>
<img width="576" height="112" src="img/GUID-7020860D-D76B-4A9E-95EB-C0A2138793C6-default.gif" alt="Description of Figure 8-3 follows" title="Description of Figure 8-3 follows"/><br/>
<a href="img_text/GUID-7020860D-D76B-4A9E-95EB-C0A2138793C6-print.htm">Description of &#34;Figure 8-3 XMLFOREST Syntax&#34;</a></div>
<!-- class="figure" -->
<p>Each of the value expressions (<span class="italic"><code>value_expr</code></span> in <a href="xdb13gen.htm#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__i1030830">Figure 8-3</a>) is converted to XML format, and, optionally, identifier <span class="italic"><code>c_alias</code></span> is used as the attribute identifier (<span class="italic"><code>c_alias</code></span> can be a string literal or <code>EVALNAME</code> followed by an expression that evaluates to a string literal). The possibility of using <code>EVALNAME</code> is an Oracle extension to standard SQL/XML function <code>XMLForest</code>.</p>
<p>For an object type or collection, the <code>AS</code> clause is required. For other types, the <code>AS</code> clause is optional. For a given expression, if the <code>AS</code> clause is omitted, then characters in the evaluated value expression are <span class="italic">escaped</span> to form the name of the enclosing tag of the element. The escaping is as defined in <span class="q">&#34;<a href="xdb13gen.htm#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way &ndash; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">Escape of Characters in Generated XML Data</a>&#34;</span>. If the value expression evaluates to <code>NULL</code>, then no element is created for that expression.</p>
<p><a href="xdb13gen.htm#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">Example 8-8</a> uses <code>XMLElement</code> and <code>XMLForest</code> to generate an <code>Emp</code> element for each employee, with a <code>name</code> attribute and with child elements containing the employee hire date and department as the content.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">
<p class="titleinexample">Example 8-8 XMLFOREST: Generating Elements with Attribute and Child Elements</p>
<pre dir="ltr">SELECT XMLElement(&#34;Emp&#34;, 
                  XMLAttributes(e.first_name ||&#39; &#39;|| e.last_name AS &#34;name&#34;),
                  XMLForest(e.hire_date, e.department AS &#34;department&#34;))
AS &#34;RESULT&#34;
FROM employees e WHERE e.department_id = 20;
</pre>
<p>(The <code>WHERE</code> clause is used here to keep the example brief.) This query produces the following XML result:</p>
<pre dir="ltr">RESULT
-------------------------------------
&lt;Emp name=&#34;Michael Hartstein&#34;&gt;
  &lt;HIRE_DATE&gt;2004-02-17&lt;/HIRE_DATE&gt;
  &lt;department&gt;20&lt;/department&gt;
&lt;/Emp&gt;
&lt;Emp name=&#34;Pat Fay&#34;&gt;
  &lt;HIRE_DATE&gt;2005-08-17&lt;/HIRE_DATE&gt;
  &lt;department&gt;20&lt;/department&gt;
&lt;/Emp&gt;

2 rows selected.
</pre></div>
<!-- class="example" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__GUID-6B7023B4-A0A7-4D43-AA24-92C36CEC1EB1">
<p class="notep1">See Also:</p>
<p><a href="xdb13gen.htm#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">Example 8-20</a></p>
</div>
<p><a href="xdb13gen.htm#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHEFIJFD">Example 8-9</a> uses <code>XMLForest</code> to generate hierarchical XML data from user-defined data-type instances.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHEFIJFD">
<p class="titleinexample">Example 8-9 XMLFOREST: Generating an Element from a User-Defined Data-Type Instance</p>
<pre dir="ltr">SELECT XMLForest(
  dept_t(department_id,
         department_name,
         cast(MULTISET
              (SELECT employee_id, last_name
                 FROM hr.employees e WHERE e.department_id = d.department_id)
              AS emplist_t))
         AS &#34;Department&#34;)
  AS deptxml
  FROM hr.departments d
  WHERE department_id=10;
</pre></div>
<!-- class="example" -->
<div class="section">
<p>This produces an XML document with element <code>Department</code> containing attribute <code>DEPTNO</code> and child element <code>DNAME</code>.</p>
<pre dir="ltr">DEPTXML
---------------------------------
&lt;Department DEPTNO=&#34;10&#34;&gt;
  &lt;DNAME&gt;Administration&lt;/DNAME&gt;
    &lt;EMP_LIST&gt;
      &lt;EMP_T EMPNO=&#34;200&#34;&gt;
        &lt;ENAME&gt;Whalen&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
    &lt;/EMP_LIST&gt;
&lt;/Department&gt;

1 row selected.
</pre>
<p>You might want to compare this example with <a href="xdb13gen.htm#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">Example 8-7</a> and <a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025801">Example 8-25</a>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5017"></a><a id="ADXDB5018"></a><a id="ADXDB5019"></a><a id="ADXDB5016"></a>
<div class="props_rev_3"><a id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17"></a>
<h3 id="ADXDB-GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17" class="sect3"><span class="enumeration_section">8.2.3</span> XMLCONCAT SQL/XML Function</h3>
<div>
<p>You use SQL/XML standard function <code>XMLConcat</code> to construct an XML fragment by concatenating multiple <code>XMLType</code> instances.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__i1032783">Figure 8-4</a> shows the <code>XMLConcat</code> syntax. Function <code>XMLConcat</code> has two forms:</p>
<ul style="list-style-type: disc;">
<li>
<p>The first form takes as argument an <code>XMLSequenceType</code> value, which is a varray of <code>XMLType</code> instances, and returns a single <code>XMLType</code> instance that is the concatenation of all of the elements of the varray. This form is useful to collapse lists of <code>XMLType</code> instances into a single instance.</p>
</li>
<li>
<p>The second form takes an arbitrary number of <code>XMLType</code> instances and concatenates them together. If one of the values is <code>NULL</code>, then it is ignored in the result. If all the values are <code>NULL</code>, then the result is <code>NULL</code>. This form is used to concatenate arbitrary number of <code>XMLType</code> instances in the same row. Function <code>XMLAgg</code> can be used to concatenate <code>XMLType</code> instances across rows.</p>
</li>
</ul>
<div class="figure" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__i1032783">
<p class="titleinfigure">Figure 8-4 XMLCONCAT Syntax</p>
<img width="331" height="58" src="img/GUID-24364CAB-F9F5-4F98-9FB3-FC30B7AE995D-default.gif" alt="Description of Figure 8-4 follows" title="Description of Figure 8-4 follows"/><br/>
<a href="img_text/GUID-24364CAB-F9F5-4F98-9FB3-FC30B7AE995D-print.htm">Description of &#34;Figure 8-4 XMLCONCAT Syntax&#34;</a></div>
<!-- class="figure" -->
<p><a href="xdb13gen.htm#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFIGF">Example 8-10</a> uses SQL/XML function <code>XMLConcat</code> to return a concatenation of <code>XMLType</code> instances from an <code>XMLSequenceType</code> value (a varray of <code>XMLType</code> instances).</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFIGF">
<p class="titleinexample">Example 8-10 XMLCONCAT: Concatenating XMLType Instances from a Sequence</p>
<pre dir="ltr">SELECT XMLSerialize(
         CONTENT
         XMLConcat(XMLSequenceType(
                   XMLType(&#39;&lt;PartNo&gt;1236&lt;/PartNo&gt;&#39;),
                   XMLType(&#39;&lt;PartName&gt;Widget&lt;/PartName&gt;&#39;),
                   XMLType(&#39;&lt;PartPrice&gt;29.99&lt;/PartPrice&gt;&#39;)))
         AS CLOB)
  AS &#34;RESULT&#34;
  FROM DUAL;
</pre>
<p>This query returns a single XML fragment. (The result is shown here pretty-printed, for clarity.)</p>
<pre dir="ltr">RESULT
---------------
&lt;PartNo&gt;1236&lt;/PartNo&gt;
&lt;PartName&gt;Widget&lt;/PartName&gt;
&lt;PartPrice&gt;29.99&lt;/PartPrice&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<div class="section">
<p><a href="xdb13gen.htm#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFCJG">Example 8-11</a> uses <code>XMLConcat</code> to create and concatenate XML elements for employee first and the last names.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFCJG">
<p class="titleinexample">Example 8-11 XMLCONCAT: Concatenating XML Elements</p>
<pre dir="ltr">SELECT XMLConcat(XMLElement(&#34;first&#34;, e.first_name), 
                 XMLElement(&#34;last&#34;, e.last_name))
  AS &#34;RESULT&#34;
  FROM employees e;
</pre>
<p>This query produces the following XML fragment:</p>
<pre dir="ltr">RESULT
--------------------------------------------
&lt;first&gt;Den&lt;/first&gt;&lt;last&gt;Raphaely&lt;/last&gt;
&lt;first&gt;Alexander&lt;/first&gt;&lt;last&gt;Khoo&lt;/last&gt;
&lt;first&gt;Shelli&lt;/first&gt;&lt;last&gt;Baida&lt;/last&gt;
&lt;first&gt;Sigal&lt;/first&gt;&lt;last&gt;Tobias&lt;/last&gt;
&lt;first&gt;Guy&lt;/first&gt;&lt;last&gt;Himuro&lt;/last&gt;
&lt;first&gt;Karen&lt;/first&gt;&lt;last&gt;Colmenares&lt;/last&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5021"></a><a id="ADXDB5022"></a><a id="ADXDB5896"></a><a id="ADXDB5023"></a><a id="ADXDB5020"></a>
<div class="props_rev_3"><a id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB"></a>
<h3 id="ADXDB-GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB" class="sect3"><span class="enumeration_section">8.2.4</span> XMLAGG SQL/XML Function</h3>
<div>
<p>You use SQL/XML standard function <code>XMLAgg</code> to construct a forest of XML elements from a collection of XML elements&thinsp;&mdash;&thinsp;it is an aggregate function.</p>
<div class="section">
<div class="figure" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__i1032735">
<p class="titleinfigure">Figure 8-5 XMLAGG Syntax</p>
<img width="433" height="46" src="img/GUID-7CAA7834-FA5A-4B73-AA2B-C6E8ED668505-default.gif" alt="Description of Figure 8-5 follows" title="Description of Figure 8-5 follows"/><br/>
<a href="img_text/GUID-7CAA7834-FA5A-4B73-AA2B-C6E8ED668505-print.htm">Description of &#34;Figure 8-5 XMLAGG Syntax&#34;</a></div>
<!-- class="figure" -->
<p><a href="xdb13gen.htm#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__i1032735">Figure 8-5</a> describes the <code>XMLAgg</code> syntax, where the <code>order_by_clause</code> is the following:</p>
<pre dir="ltr">ORDER BY [list of: expr [ASC|DESC] [NULLS {FIRST|LAST}]]
</pre>
<p>Numeric literals are <span class="italic">not</span> interpreted as column positions. For example, <code>ORDER BY 1</code> does not mean order by the first column. Instead, numeric literals are interpreted as any other literals.</p>
<p>As with SQL/XML function <code>XMLConcat</code>, any arguments whose value is <code>NULL</code> are dropped from the result. SQL/XML function <code>XMLAgg</code> is similar to Oracle SQL function <code>sys_XMLAgg</code>, but <code>XMLAgg</code> returns a forest of nodes and it does not accept an <code>XMLFormat</code> parameter.</p>
<p>SQL/XML function <code>XMLAgg</code> can be used to concatenate <code>XMLType</code> instances across <span class="italic">multiple rows</span>. It also accepts an optional <code>ORDER BY</code> clause, to order the XML values being aggregated. Function <code>XMLAgg</code> produces one aggregated XML result for each group. If there is no group by specified in the query, then it returns a single aggregated XML result for all the rows of the query.</p>
<p><a href="xdb13gen.htm#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEJIFCD">Example 8-12</a> uses SQL/XML functions <code>XMLAgg</code> and <code>XMLElement</code> to construct a <code>Department</code> element that contains <code>Employee</code> elements that have employee job ID and last name as their contents. It also orders the <code>Employee</code> elements in the department by employee last name. (The result is shown pretty-printed, for clarity.)</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEJIFCD">
<p class="titleinexample">Example 8-12 XMLAGG: Generating a Department Element with Child Employee Elements</p>
<pre dir="ltr">SELECT XMLElement(&#34;Department&#34;, XMLAgg(XMLElement(&#34;Employee&#34;,
                                                  e.job_id||&#39; &#39;||e.last_name)
                                       ORDER BY e.last_name))
  AS &#34;Dept_list&#34;     
  FROM hr.employees e
  WHERE e.department_id = 30 OR e.department_id = 40;

Dept_list
------------------
&lt;Department&gt;
  &lt;Employee&gt;PU_CLERK Baida&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Colmenares&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Himuro&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Khoo&lt;/Employee&gt;
  &lt;Employee&gt;HR_REP Mavris&lt;/Employee&gt;
  &lt;Employee&gt;PU_MAN Raphaely&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Tobias&lt;/Employee&gt;
&lt;/Department&gt;

<span class="bold">1</span> row selected.
</pre></div>
<!-- class="example" -->
<div class="section">
<p>The result is a <span class="italic">single</span> row, because <code>XMLAgg</code> aggregates the employee rows.</p>
<p><a href="xdb13gen.htm#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEEEACD">Example 8-13</a> shows how to use the <code>GROUP</code> <code>BY</code> clause to group the returned set of rows into multiple groups, forming multiple <code>Department</code> elements. (The result is shown here pretty-printed, for clarity.)</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEEEACD">
<p class="titleinexample">Example 8-13 XMLAGG: Using GROUP BY to Generate Multiple Department Elements</p>
<pre dir="ltr">SELECT XMLElement(&#34;Department&#34;, XMLAttributes(department_id AS &#34;deptno&#34;), 
                  XMLAgg(XMLElement(&#34;Employee&#34;, e.job_id||&#39; &#39;||e.last_name)))
   AS &#34;Dept_list&#34;
   FROM hr.employees e
   <span class="bold">GROUP BY e.department_id;</span>

Dept_list
------------------
&lt;Department deptno=&#34;<span class="bold">30</span>&#34;&gt;
  &lt;Employee&gt;PU_MAN Raphaely&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Colmenares&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Himuro&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Tobias&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Baida&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Khoo&lt;/Employee&gt;&lt;/Department&gt;

&lt;Department deptno=&#34;<span class="bold">40</span>&#34;&gt;
  &lt;Employee&gt;HR_REP Mavris&lt;/Employee&gt;
&lt;/Department&gt;

<span class="bold">2</span> rows selected.
</pre></div>
<!-- class="example" -->
<div class="section">
<p>You can order the employees within each department by using the <code>ORDER BY</code> clause inside the <code>XMLAgg</code> expression.</p>
<div class="infobox-note" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__GUID-1591AAE9-4479-4F45-906D-B1E9A732D6CF">
<p class="notep1">Note:</p>
<p>Within the <code>ORDER BY</code> clause, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause.</p>
</div>
<p>Function <code>XMLAgg</code> can be used to reflect the hierarchical nature of some relationships that exist in tables. <a href="xdb13gen.htm#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEHHCJI">Example 8-14</a> generates a department element for department 30. Within this element is a child element <code>emp</code> for each employee of the department. Within each employee element is a <code>dependent</code> element for each dependent of that employee.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEHHCJI">
<p class="titleinexample">Example 8-14 XMLAGG: Generating Nested Elements</p>
<pre dir="ltr">SELECT last_name, employee_id FROM employees WHERE department_id = 30;
 
LAST_NAME                 EMPLOYEE_ID
------------------------- -----------
Raphaely                          114
Khoo                              115
Baida                             116
Tobias                            117
Himuro                            118
Colmenares                        119
 
6 rows selected.
 
</pre>
<p>A <code>dependents</code> table holds the dependents of each employee.</p>
<pre dir="ltr">CREATE TABLE hr.dependents (id NUMBER(4) PRIMARY KEY,
                            employee_id NUMBER(4),
                            name VARCHAR2(10));
Table created.
INSERT INTO dependents VALUES (1, 114, &#39;MARK&#39;);
1 row created.
INSERT INTO dependents VALUES (2, 114, &#39;JACK&#39;);
1 row created.
INSERT INTO dependents VALUES (3, 115, &#39;JANE&#39;);
1 row created.
INSERT INTO dependents VALUES (4, 116, &#39;HELEN&#39;);
1 row created.
INSERT INTO dependents VALUES (5, 116, &#39;FRANK&#39;);
1 row created.
COMMIT;
Commit complete.
 
</pre>
<p>The following query generates the XML data for a department that contains the information about dependents. (The result is shown here pretty-printed, for clarity.)</p>
<pre dir="ltr">SELECT
  XMLElement(
    &#34;Department&#34;,
    XMLAttributes(d.department_name AS &#34;name&#34;),
    (SELECT
       XMLAgg(XMLElement(&#34;emp&#34;,
                         XMLAttributes(e.last_name AS name),
                         (SELECT XMLAgg(XMLElement(&#34;dependent&#34;,
                                        XMLAttributes(de.name AS &#34;name&#34;)))
                            FROM dependents de
                            WHERE de.employee_id = e.employee_id)))
       FROM employees e
       WHERE e.department_id = d.department_id)) AS &#34;dept_list&#34;
  FROM departments d
  WHERE department_id = 30;
 
dept_list
--------------------------------------------------------------------------------
&lt;Department name=&#34;Purchasing&#34;&gt;
  &lt;emp NAME=&#34;Raphaely&#34;&gt;
    &lt;dependent name=&#34;MARK&#34;&gt;&lt;/dependent&gt;
    &lt;dependent name=&#34;JACK&#34;&gt;&lt;/dependent&gt;
  &lt;/emp&gt;&lt;emp NAME=&#34;Khoo&#34;&gt;
    &lt;dependent name=&#34;JANE&#34;&gt;&lt;/dependent&gt;
  &lt;/emp&gt;
  &lt;emp NAME=&#34;Baida&#34;&gt;
    &lt;dependent name=&#34;HELEN&#34;&gt;&lt;/dependent&gt;
    &lt;dependent name=&#34;FRANK&#34;&gt;&lt;/dependent&gt;
  &lt;/emp&gt;&lt;emp NAME=&#34;Tobias&#34;&gt;&lt;/emp&gt;
  &lt;emp NAME=&#34;Himuro&#34;&gt;&lt;/emp&gt;
  &lt;emp NAME=&#34;Colmenares&#34;&gt;&lt;/emp&gt;
&lt;/Department&gt;
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5025"></a><a id="ADXDB5026"></a><a id="ADXDB5024"></a>
<div class="props_rev_3"><a id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C"></a>
<h3 id="ADXDB-GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C" class="sect3"><span class="enumeration_section">8.2.5</span> XMLPI SQL/XML Function</h3>
<div>
<p>You use SQL/XML standard function <code>XMLPI</code> to construct an XML processing instruction (PI).</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHDIAAEJ">Figure 8-6</a> shows the syntax:</p>
<div class="figure" id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHDIAAEJ">
<p class="titleinfigure">Figure 8-6 XMLPI Syntax</p>
<img width="503" height="79" src="img/GUID-B7379659-AAA9-4E85-AF8A-4C6E17A4B2A4-default.gif" alt="Description of Figure 8-6 follows" title="Description of Figure 8-6 follows"/><br/>
<a href="img_text/GUID-B7379659-AAA9-4E85-AF8A-4C6E17A4B2A4-print.htm">Description of &#34;Figure 8-6 XMLPI Syntax&#34;</a></div>
<!-- class="figure" -->
<p>Argument <span class="italic"><code>value_expr</code></span> is evaluated, and the string result is appended to the optional identifier (<span class="italic"><code>identifier</code></span>), separated by a space. This concatenation is then enclosed between <code>&#34;&lt;?&#34;</code> and <code>&#34;?&gt;</code>&#34; to create the processing instruction. That is, if <span class="italic"><code>string-result</code></span> is the result of evaluating <span class="italic"><code>value_expr</code></span>, then the generated processing instruction is <code>&lt;?</code><span class="italic"><code>identifier</code></span> <span class="italic"><code>string-result?&gt;</code></span>. If <span class="italic"><code>string-result</code></span> is the empty string, <code>&#39;&#39;</code>, then the function returns <code>&lt;?</code><span class="italic"><code>identifier</code></span><span class="italic"><code>?&gt;</code></span>.</p>
<p>As an alternative to using keyword <code>NAME</code> followed by a <span class="italic">literal</span> string <span class="italic"><code>identifier</code></span>, you can use keyword <code>EVALNAME</code> followed by an expression that evaluates to a string to be used as the identifier. The possibility of using <code>EVALNAME</code> is an Oracle extension to standard SQL/XML function <code>XMLPI</code>.</p>
<p>An error is raised if the constructed XML is not a legal XML processing instruction. In particular:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic"><code>identifier</code></span> must <span class="italic">not</span> be the word &#34;<code>xml</code>&#34; (uppercase, lowercase, or mixed case).</p>
</li>
<li>
<p><span class="italic"><code>string-result</code></span> must <span class="italic">not</span> contain the character sequence &#34;<code>?&gt;</code>&#34;.</p>
</li>
</ul>
<p>Function <code>XMLPI</code> returns an instance of <code>XMLType</code>. If <span class="italic"><code>string-result</code></span> is <code>NULL</code>, then it returns <code>NULL</code>.</p>
<p><a href="xdb13gen.htm#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHEFBGFC">Example 8-15</a> uses <code>XMLPI</code> to generate a simple processing instruction.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHEFBGFC">
<p class="titleinexample">Example 8-15 Using SQL/XML Function XMLPI</p>
<pre dir="ltr">SELECT XMLPI(NAME &#34;OrderAnalysisComp&#34;, &#39;imported, reconfigured, disassembled&#39;)
  AS pi FROM DUAL; 
</pre>
<p>This results in the following output:</p>
<pre dir="ltr">PI
----------------------------------------------------------
&lt;?OrderAnalysisComp imported, reconfigured, disassembled?&gt;

1 row selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5028"></a><a id="ADXDB5029"></a><a id="ADXDB5027"></a>
<div class="props_rev_3"><a id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915"></a>
<h3 id="ADXDB-GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915" class="sect3"><span class="enumeration_section">8.2.6</span> XMLCOMMENT SQL/XML Function</h3>
<div>
<p>You use SQL/XML standard function <code>XMLComment</code> to construct an XML comment.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHDFIFFI">Figure 8-7</a> shows the syntax:</p>
<div class="figure" id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHDFIFFI">
<p class="titleinfigure">Figure 8-7 XMLComment Syntax</p>
<img width="268" height="27" src="img/GUID-C9E4211D-17C7-4154-A3D3-80BAAD644947-default.gif" alt="Description of Figure 8-7 follows" title="Description of Figure 8-7 follows"/><br/>
<a href="img_text/GUID-C9E4211D-17C7-4154-A3D3-80BAAD644947-print.htm">Description of &#34;Figure 8-7 XMLComment Syntax&#34;</a></div>
<!-- class="figure" -->
<p>Argument <span class="italic"><code>value_expr</code></span> is evaluated to a string, and the result is used as the body of the generated XML comment. The result is thus <code>&lt;!--</code><span class="italic"><code>string-result</code></span><code>--&gt;</code>, where <span class="italic"><code>string-result</code></span> is the string result of evaluating <span class="italic"><code>value_expr</code></span>. If <span class="italic"><code>string-result</code></span> is the empty string, then the comment is empty: <code>&lt;!----&gt;</code>.</p>
<p>An error is raised if the constructed XML is not a legal XML comment. In particular, <span class="italic"><code>string-result</code></span> must <span class="italic">not</span> contain two consecutive hyphens (<code>-</code>): &#34;<code>--</code>&#34;.</p>
<p>Function <code>XMLComment</code> returns an instance of <code>XMLType</code>. If <span class="italic"><code>string-result</code></span> is <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="xdb13gen.htm#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHECEGCI">Example 8-16</a> uses <code>XMLComment</code> to generate a simple XML comment.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHECEGCI">
<p class="titleinexample">Example 8-16 Using SQL/XML Function XMLCOMMENT</p>
<pre dir="ltr">SELECT XMLComment(&#39;This is a comment&#39;) AS cmnt FROM DUAL; 
</pre>
<p>This query results in the following output:</p>
<pre dir="ltr">CMNT
--------------------------
&lt;!--This is a comment--&gt;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5034"></a><a id="ADXDB5035"></a><a id="ADXDB5033"></a>
<div class="props_rev_3"><a id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8"></a>
<h3 id="ADXDB-GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8" class="sect3"><span class="enumeration_section">8.2.7</span> XMLSERIALIZE SQL/XML Function</h3>
<div>
<p>You use SQL/XML standard function <code>XMLSerialize</code> to obtain a string or LOB representation of XML data.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHDBGEEH">Figure 8-8</a> shows the syntax of <code>XMLSerialize</code>:</p>
<div class="figure" id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHDBGEEH">
<p class="titleinfigure">Figure 8-8 XMLSerialize Syntax</p>
<img width="616" height="256" src="img/GUID-8AC61D8C-3CDB-4E39-B417-49E5020E9430-default.gif" alt="Description of Figure 8-8 follows" title="Description of Figure 8-8 follows"/><br/>
<a href="img_text/GUID-8AC61D8C-3CDB-4E39-B417-49E5020E9430-print.htm">Description of &#34;Figure 8-8 XMLSerialize Syntax&#34;</a></div>
<!-- class="figure" -->
<p>Argument <span class="italic"><code>value_expr</code></span> is evaluated, and the resulting <code>XMLType</code> instance is serialized to produce the content of the created string or LOB. If present<a id="fn_1" href="#fn_1" onclick="footdisplay(1,&#34;The SQL/XML standard requires argument data-type to be present, but it is optional in the Oracle XML&nbsp;DB implementation of the standard, for ease of use. &#34;)"><sup>Foot&nbsp;1</sup></a>, the specified <span class="italic"><code>datatype</code></span> must be one of the following (the default data type is <code>CLOB</code>):</p>
<ul style="list-style-type: disc;">
<li>
<p><code>VARCHAR2(</code><span class="italic"><code>N</code></span><code>)</code>, where <span class="italic"><code>N</code></span> is the size in bytes<a id="fn_2" href="#fn_2" onclick="footdisplay(2,&#34;The limit is 32767 or 4000 bytes, depending on the value of initialization parameter MAX_STRING_SIZE.&thinsp; See Oracle Database SQL Language Reference. &#34;)"><sup>Foot&nbsp;2</sup></a></p>
</li>
<li>
<p><code>CLOB</code></p>
</li>
<li>
<p><code>BLOB</code></p>
</li>
</ul>
<p>If you specify <code>DOCUMENT</code>, then the result of evaluating <span class="italic"><code>value_expr</code></span> must be a well-formed document. In particular, it must have a single root. If the result is not a well-formed document, then an error is raised. If you specify <code>CONTENT</code>, however, then the result of <span class="italic"><code>value_expr</code></span> is <span class="italic">not</span> checked for being well-formed.</p>
<p>If <span class="italic"><code>value_expr</code></span> evaluates to <code>NULL</code> or to the empty string (<code>&#39;&#39;</code>), then function <code>XMLSerialize</code> returns <code>NULL</code>.</p>
<p>The <code>ENCODING</code> clause specifies the character encoding for XML data that is serialized as a <code>BLOB</code> instance. <span class="italic"><code>xml_encoding_spec</code></span> is an XML encoding declaration (<code>encoding=&#34;...&#34;</code>). If <span class="italic"><code>datatype</code></span> is <code>BLOB</code> and you specify an <code>ENCODING</code> clause, then the output is encoded as specified, and <span class="italic"><code>xml_encoding_spec</code></span> is added to the prolog to indicate the <code>BLOB</code> encoding. If you specify an <code>ENCODING</code> clause with a <span class="italic"><code>datatype</code></span> other than <code>BLOB</code>, then an error is raised. For UTF-16 characters, <span class="italic"><code>xml_encoding_spec</code></span> must be one of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>encoding=UTF-16BE</code> &ndash; Big-endian UTF-16 encoding</p>
</li>
<li>
<p><code>encoding=UTF-16LE</code> &ndash; Little-endian UTF-16 encoding</p>
</li>
</ul>
<p>If you specify <code>VERSION</code> then the specified version is used in the XML declaration (<code>&lt;?xml version=&#34;...&#34; ...?&gt;</code>).</p>
<p>If you specify <code>NO INDENT</code>, then all insignificant whitespace is stripped, so that it does not appear in the output. If you specify <code>INDENT SIZE =</code> <span class="italic"><code>N</code></span>, where <span class="italic"><code>N</code></span> is a whole number, then the output is <span class="italic">pretty-printed</span> using a relative indentation of <span class="italic"><code>N</code></span> spaces. If <span class="italic"><code>N</code></span> is <code>0</code>, then pretty-printing inserts a newline character after each element, placing each element on a line by itself, but there is no other insignificant whitespace in the output. If you specify <code>INDENT</code> without a <code>SIZE</code> specification, then 2-space indenting is used. If you specify neither <code>NO INDENT</code> nor <code>INDENT</code>, then the behavior (pretty-printing or not) is indeterminate.</p>
<p><code>HIDE DEFAULTS</code> and <code>SHOW DEFAULTS</code> apply only to XML schema-based data. If you specify <code>SHOW DEFAULTS</code> and the input data is missing any optional elements or attributes for which the XML schema defines default values, then those elements or attributes are included in the output with their default values. If you specify <code>HIDE DEFAULTS</code>, then no such elements or attributes are included in the output. <code>HIDE DEFAULTS</code> is the default behavior.</p>
<p><a href="xdb13gen.htm#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHEHCEAA">Example 8-17</a> uses <code>XMLSerialize</code> to produce a <code>CLOB</code> instance containing serialized XML data.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHEHCEAA">
<p class="titleinexample">Example 8-17 Using SQL/XML Function XMLSERIALIZE</p>
<pre dir="ltr">SELECT XMLSerialize(DOCUMENT XMLType(&#39;&lt;poid&gt;143598&lt;/poid&gt;&#39;) AS CLOB)
  AS xmlserialize_doc FROM DUAL; 
</pre>
<p>This results in the following output:</p>
<pre dir="ltr">XMLSERIALIZE_DOC
-------------------
&lt;poid&gt;143598&lt;/poid&gt;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5037"></a><a id="ADXDB5038"></a><a id="ADXDB5036"></a>
<div class="props_rev_3"><a id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C"></a>
<h3 id="ADXDB-GUID-8BABF906-A641-49D9-9CED-8B039A6D272C" class="sect3"><span class="enumeration_section">8.2.8</span> XMLPARSE SQL/XML Function</h3>
<div>
<p>You use SQL/XML standard function <code>XMLParse</code> to parse a string containing XML data and construct a corresponding <code>XMLType</code> instance.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHDBGIJH">Figure 8-9</a> shows the syntax:</p>
<div class="figure" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHDBGIJH">
<p class="titleinfigure">Figure 8-9 XMLParse Syntax</p>
<img width="524" height="64" src="img/GUID-2277E8E6-585B-46C5-8140-A96D6E47BE61-default.gif" alt="Description of Figure 8-9 follows" title="Description of Figure 8-9 follows"/><br/>
<a href="img_text/GUID-2277E8E6-585B-46C5-8140-A96D6E47BE61-print.htm">Description of &#34;Figure 8-9 XMLParse Syntax&#34;</a></div>
<!-- class="figure" -->
<p>Argument <span class="italic"><code>value_expr</code></span> is evaluated to produce the string that is parsed. If you specify <code>DOCUMENT</code>, then <span class="italic"><code>value_expr</code></span> must correspond to a <span class="italic">singly rooted</span>, well-formed XML document. If you specify <code>CONTENT</code>, then <span class="italic"><code>value_expr</code></span> need only correspond to a well-formed XML fragment (it need not be singly rooted).</p>
<p>Keyword <code>WELLFORMED</code> is an Oracle XML&nbsp;DB extension to the SQL/XML standard. When you specify <code>WELLFORMED</code>, you are informing the parser that argument <span class="italic"><code>value_expr</code></span> is well-formed, so Oracle XML&nbsp;DB does <span class="italic">not</span> check to ensure that it is well-formed.</p>
<p>Function <code>XMLParse</code> returns an instance of <code>XMLType</code>. If <span class="italic"><code>value_expr</code></span> evaluates to <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="xdb13gen.htm#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHECCHJG">Example 8-18</a> uses <code>XMLParse</code> to parse a string of XML code and produce an <code>XMLType</code> instance.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHECCHJG">
<p class="titleinexample">Example 8-18 Using SQL/XML Function XMLPARSE</p>
<pre dir="ltr">SELECT XMLParse(CONTENT 
                &#39;124 &lt;purchaseOrder poNo=&#34;12435&#34;&gt;
                       &lt;customerName&gt; Acme Enterprises&lt;/customerName&gt;
                       &lt;itemNo&gt;32987457&lt;/itemNo&gt;
                     &lt;/purchaseOrder&gt;&#39;
                WELLFORMED)
  AS po FROM DUAL d;
</pre>
<p>This results in the following output:</p>
<pre dir="ltr">PO
-----------------------------------------------
124 &lt;purchaseOrder poNo=&#34;12435&#34;&gt;
&lt;customerName&gt;Acme Enterprises&lt;/customerName&gt;
&lt;itemNo&gt;32987457&lt;/itemNo&gt;
&lt;/purchaseOrder&gt;
</pre></div>
<!-- class="example" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__GUID-04E98AA6-68F4-4304-8052-74E8B3659078">
<p class="notep1">See Also:</p>
<p><a href="http://www.w3.org/TR/REC-xml/" target="_blank"><code>http://www.w3.org/TR/REC-xml/</code></a>, <span class="italic">Extensible Markup Language (XML) 1.0</span>, for the definition of well-formed XML documents and fragments</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5031"></a><a id="ADXDB5032"></a><a id="ADXDB5030"></a>
<div class="props_rev_3"><a id="GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD"></a>
<h3 id="ADXDB-GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD" class="sect3"><span class="enumeration_section">8.2.9</span> XMLROOT Oracle SQL Function</h3>
<div>
<p>You can use Oracle SQL function <code>XMLRoot</code> to add a <code>VERSION</code> property, and optionally a <code>STANDALONE</code> property, to the root information item of an XML value. Typically, this is done to ensure data-model compliance.</p>
<div class="section">
<p>Oracle SQL function <code>XMLRoot</code> was at one time part of the SQL/XML standard, but it is <span class="italic">deprecated</span> as a standard function as of SQL/XML 2005. It remains available in Oracle XML&nbsp;DB, as an Oracle SQL function.</p>
<p><a href="xdb13gen.htm#GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD__CHDFCACA">Figure 8-10</a> shows the syntax of <code>XMLRoot</code>:</p>
<div class="figure" id="GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD__CHDFCACA">
<p class="titleinfigure">Figure 8-10 XMLRoot Syntax</p>
<img width="803" height="128" src="img/GUID-85D701EB-EDFE-4CB1-AF62-65099E4900A7-default.gif" alt="Description of Figure 8-10 follows" title="Description of Figure 8-10 follows"/><br/>
<a href="img_text/GUID-85D701EB-EDFE-4CB1-AF62-65099E4900A7-print.htm">Description of &#34;Figure 8-10 XMLRoot Syntax&#34;</a></div>
<!-- class="figure" -->
<p>The first argument, <span class="italic"><code>xml-expression</code></span>, is evaluated, and the indicated properties (<code>VERSION</code>, <code>STANDALONE</code>) and their values are added to a new prolog for the resulting <code>XMLType</code> instance. If the evaluated <span class="italic"><code>xml-expression</code></span> already contains a prolog, then an error is raised.</p>
<p>Second argument <span class="italic"><code>string-valued-expression</code></span> (which follows keyword <code>VERSION</code>) is evaluated, and the resulting string is used as the value of the prolog <code>version</code> property. The value of the prolog <code>standalone</code> property (lowercase) is taken from the optional third argument <code>STANDALONE</code> <code>YES</code> or <code>NO</code> value. If <code>NOVALUE</code> is used for <code>VERSION</code>, then <code>&#34;version=1.0&#34;</code> is used in the resulting prolog. If <code>NOVALUE</code> is used for <code>STANDALONE</code>, then the <code>standalone</code> property is omitted from the resulting prolog.</p>
<p>Function <code>XMLRoot</code> returns an instance of <code>XMLType</code>. If first argument <span class="italic"><code>xml-expression</code></span> evaluates to <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="xdb13gen.htm#GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD__CHECHGFD">Example 8-19</a> uses <code>XMLRoot</code> to add an XML declaration with <code>version</code> and <code>standalone</code> attributes.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-09539105-E0D7-418E-BCE9-35F857D0FFBD__CHECHGFD">
<p class="titleinexample">Example 8-19 Using Oracle SQL Function XMLRoot</p>
<pre dir="ltr">SELECT XMLRoot(XMLType(&#39;&lt;poid&gt;143598&lt;/poid&gt;&#39;), VERSION &#39;1.0&#39;, STANDALONE YES)
  AS xmlroot FROM DUAL; 
</pre>
<p>This results in the following output:</p>
<pre dir="ltr">XMLROOT
--------------------------------------
&lt;?xml version=&#34;1.0&#34; standalone=&#34;yes&#34;?&gt;
&lt;poid&gt;143598&lt;/poid&gt;

1 row selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5042"></a><a id="ADXDB5043"></a><a id="ADXDB5041"></a>
<div class="props_rev_3"><a id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F"></a>
<h3 id="ADXDB-GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" class="sect3"><span class="enumeration_section">8.2.10</span> XMLCOLATTVAL Oracle SQL Function</h3>
<div>
<p>Oracle SQL function <code>XMLColAttVal</code> generates a forest of XML <code>column</code> elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__i1032066">Figure 8-11</a> shows the <code>XMLColAttVal</code> syntax.</p>
<div class="figure" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__i1032066">
<p class="titleinfigure">Figure 8-11 XMLCOLATTVAL Syntax</p>
<img width="596" height="110" src="img/GUID-6AA40E7D-C1B3-4B98-BCD2-D8A009ED44A6-default.gif" alt="Description of Figure 8-11 follows" title="Description of Figure 8-11 follows"/><br/>
<a href="img_text/GUID-6AA40E7D-C1B3-4B98-BCD2-D8A009ED44A6-print.htm">Description of &#34;Figure 8-11 XMLCOLATTVAL Syntax&#34;</a></div>
<!-- class="figure" -->
<p>The arguments are used as the values of the <code>name</code> attribute of the <code>column</code> element. The <span class="italic"><code>c_alias</code></span> values are used as the attribute identifiers.</p>
<p>As an alternative to using keyword <code>AS</code> followed by a <span class="italic">literal</span> string <span class="italic"><code>c_alias</code></span>, you can use <code>AS EVALNAME</code> followed by an expression that evaluates to a string to be used as the attribute identifier.</p>
<p>Because argument values <span class="italic"><code>value_expr</code></span> are used only as attribute <span class="italic">values</span>, they need <span class="italic">not</span> be escaped in any way. This is in contrast to function <code>XMLForest</code>. It means that you can use <code>XMLColAttVal</code> to transport SQL columns and values without escaping.</p>
<p><a href="xdb13gen.htm#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">Example 8-20</a> uses <code>XMLColAttVal</code> to generate an <code>Emp</code> element for each employee, with a <code>name</code> attribute, and with <code>column</code> elements that have the employee hire date and department as the content.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">
<p class="titleinexample">Example 8-20 XMLCOLATTVAL: Generating Elements with Attribute and Child Elements</p>
<pre dir="ltr">SELECT XMLElement(&#34;Emp&#34;, 
                  XMLAttributes(e.first_name ||&#39; &#39;||e.last_name AS &#34;fullname&#34; ),
                  XMLColAttVal(e.hire_date, e.department_id AS &#34;department&#34;))
  AS &#34;RESULT&#34; 
  FROM hr.employees e
  WHERE e.department_id = 30;
</pre>
<p>This query produces the following XML result. (The result is shown here pretty-printed, for clarity.)</p>
<pre dir="ltr">RESULT
-----------------------------------------------------------
&lt;Emp fullname=&#34;Den Raphaely&#34;&gt;
  &lt;column name = &#34;HIRE_DATE&#34;&gt;2002-12-07&lt;/column&gt;
  &lt;column name = &#34;department&#34;&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname=&#34;Alexander Khoo&#34;&gt;
  &lt;column name = &#34;HIRE_DATE&#34;&gt;2003-05-18&lt;/column&gt;
  &lt;column name = &#34;department&#34;&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname=&#34;Shelli Baida&#34;&gt;
  &lt;column name = &#34;HIRE_DATE&#34;&gt;2005-12-24&lt;/column&gt;
  &lt;column name = &#34;department&#34;&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname=&#34;Sigal Tobias&#34;&gt;
  &lt;column name = &#34;HIRE_DATE&#34;&gt;2005-07-24&lt;/column&gt;
  &lt;column name = &#34;department&#34;&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname=&#34;Guy Himuro&#34;&gt;
  &lt;column name = &#34;HIRE_DATE&#34;&gt;2006-11-15&lt;/column&gt;
  &lt;column name = &#34;department&#34;&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname=&#34;Karen Colmenares&#34;&gt;
  &lt;column name = &#34;HIRE_DATE&#34;&gt;2007-08-10&lt;/column&gt;
  &lt;column name = &#34;department&#34;&gt;30&lt;/column&gt;
&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__GUID-7F5A3F48-C1D6-4917-9D7C-189CC87BC835">
<p class="notep1">See Also:</p>
<p><a href="xdb13gen.htm#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">Example 8-8</a></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5045"></a><a id="ADXDB5046"></a><a id="ADXDB5044"></a>
<div class="props_rev_3"><a id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130"></a>
<h3 id="ADXDB-GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" class="sect3"><span class="enumeration_section">8.2.11</span> XMLCDATA Oracle SQL Function</h3>
<div>
<p>You use Oracle SQL function <code>XMLCDATA</code> to generate an XML <code>CDATA</code> section.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHDFIDBF">Figure 8-12</a> shows the syntax:</p>
<div class="figure" id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHDFIDBF">
<p class="titleinfigure">Figure 8-12 XMLCDATA Syntax</p>
<img width="248" height="27" src="img/GUID-341F853F-05E6-488E-91E2-4E2613376181-default.gif" alt="Description of Figure 8-12 follows" title="Description of Figure 8-12 follows"/><br/>
<a href="img_text/GUID-341F853F-05E6-488E-91E2-4E2613376181-print.htm">Description of &#34;Figure 8-12 XMLCDATA Syntax&#34;</a></div>
<!-- class="figure" -->
<p>Argument <span class="italic"><code>value_expr</code></span> is evaluated to a string, and the result is used as the body of the generated XML <code>CDATA</code> section, <code>&lt;![CDATA[</code><span class="italic"><code>string-result</code></span><code>]]&gt;</code>, where <span class="italic"><code>string-result</code></span> is the result of evaluating <span class="italic"><code>value_expr</code></span>. If <span class="italic"><code>string-result</code></span> is the empty string, then the <code>CDATA</code> section is empty: <code>&lt;![CDATA[]]&gt;</code>.</p>
<p>An error is raised if the constructed XML is not a legal XML <code>CDATA</code> section. In particular, <span class="italic"><code>string-result</code></span> must <span class="italic">not</span> contain two consecutive right brackets (<code>]</code>): &#34;<code>]]</code>&#34;.</p>
<p>Function <code>XMLCDATA</code> returns an instance of <code>XMLType</code>. If <span class="italic"><code>string-result</code></span> is <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="xdb13gen.htm#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHEHADIH">Example 8-21</a> uses <code>XMLCDATA</code> to generate an XML <code>CDATA</code> section.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHEHADIH">
<p class="titleinexample">Example 8-21 Using Oracle SQL Function XMLCDATA</p>
<pre dir="ltr">SELECT XMLElement(&#34;PurchaseOrder&#34;,
                  XMLElement(&#34;Address&#34;,
                             XMLCDATA(&#39;100 Pennsylvania Ave.&#39;),
                             XMLElement(&#34;City&#34;, &#39;Washington, D.C.&#39;)))
  AS RESULT FROM DUAL;
                            
</pre>
<p>This results in the following output. (The result is shown here pretty-printed, for clarity.)</p>
<pre dir="ltr">RESULT
--------------------------
&lt;PurchaseOrder&gt;
  &lt;Address&gt;
    &lt;![CDATA[100 Pennsylvania Ave.]]&gt;
    &lt;City&gt;Washington, D.C.&lt;/City&gt;
  &lt;/Address&gt;
&lt;/PurchaseOrder&gt;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB5047"></a>
<div class="props_rev_3"><a id="GUID-1490DB76-5832-4023-8F0B-28427901C912"></a>
<h2 id="ADXDB-GUID-1490DB76-5832-4023-8F0B-28427901C912" class="sect2"><span class="enumeration_section">8.3</span> Generation of XML Data Using DBMS_XMLGEN</h2>
<div>
<p>PL/SQL package <code>DBMS_XMLGEN</code> creates XML documents from SQL query results. It retrieves an XML document as a <code>CLOB</code> or <code>XMLType</code> value.</p>
<p>It provides a <span class="italic">fetch</span> interface, whereby you can specify the maximum number of rows to retrieve and the number of rows to skip. For example, the first fetch could retrieve a maximum of ten rows, skipping the first four. This is especially useful for pagination requirements in Web applications.</p>
<p>Package <code>DBMS_XMLGEN</code> also provides options for changing tag names for <code>ROW</code>, <code>ROWSET</code>, and so on. The parameters of the package can restrict the number of rows retrieved and the enclosing tag names.</p>
<div class="infoboxnotealso" id="GUID-1490DB76-5832-4023-8F0B-28427901C912__GUID-D632695B-2D11-4F88-8760-EB332942519E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ARPLS374" target="_blank" href="../ARPLS/d_xmlgen.htm#ARPLS374"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
<li>
<p><a class="olink ADXDK070" target="_blank" href="../ADXDK/adx_j_xsu.htm#ADXDK070"><span class="italic">Oracle XML Developer&#39;s Kit Programmer&#39;s Guide</span></a> (compare <code>OracleXMLQuery</code> with <code>DBMS_XMLGEN</code>)</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB5049"></a><a id="ADXDB5048"></a>
<div class="props_rev_3"><a id="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC"></a>
<h3 id="ADXDB-GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC" class="sect3"><span class="enumeration_section">8.3.1</span> Using PL/SQL Package DBMS_XMLGEN</h3>
<div>
<p>You can use package <code>DBMS_XMLGEN</code> to generate XML data from relational data.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC__i1025437">Figure 8-13</a> illustrates how to use package <code>DBMS_XMLGEN</code>. The steps are as follows:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Get the context from the package by supplying a SQL query and calling PL/SQL function <code>newContext</code>.</span></li>
<li class="stepexpand"><span>Pass the context to all procedures or functions in the package to set the various options. For example, to set the <code>ROW</code> element name, use <code>setRowTag(ctx)</code>, where <code>ctx</code> is the context got from the previous <code>newContext</code> call.</span></li>
<li class="stepexpand"><span>Get the XML result, using PL/SQL function <code>getXML</code> or <code>getXMLType</code>. By setting the maximum number of rows to be retrieved for each fetch using PL/SQL procedure <code>setMaxRows</code>, you can call either of these functions repeatedly, retrieving up to the maximum number of rows for each call. These functions return XML data (as a <code>CLOB</code> value and as an instance of <code>XMLType</code>, respectively), unless there are no rows retrieved. In that case, these functions return <code>NULL</code>. To determine how many rows were retrieved, use PL/SQL function <code>getNumRowsProcessed</code>.</span></li>
<li class="stepexpand"><span>You can reset the query to start again and repeat step 3.</span></li>
<li class="stepexpand"><span>Call PL/SQL procedure <code>closeContext</code> to free up any previously allocated resources.</span></li>
</ol>
<div class="section">
<div class="figure" id="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC__i1025437">
<p class="titleinfigure">Figure 8-13 Using PL/SQL Package DBMS_XMLGEN</p>
<img width="683" height="365" src="img/GUID-0BC4DE65-72AC-46FA-846A-0233E43ECE7A-default.gif" alt="Description of Figure 8-13 follows" title="Description of Figure 8-13 follows"/><br/>
<a href="img_text/GUID-0BC4DE65-72AC-46FA-846A-0233E43ECE7A-print.htm">Description of &#34;Figure 8-13 Using PL/SQL Package DBMS_XMLGEN&#34;</a></div>
<!-- class="figure" -->
<p>In conjunction with a SQL query, PL/SQL method <code>DBMS_XMLGEN.getXML()</code> typically returns a result similar to the following, as a <code>CLOB</code> value:</p>
<pre dir="ltr">&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Steven&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;SKING&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;17-JUN-87&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_PRES&lt;/JOB_ID&gt;
  &lt;SALARY&gt;24000&lt;/SALARY&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-89&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
</pre>
<p>The default mapping between relational data and XML data is as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>Each row returned by the SQL query maps to an XML element with the default element name <code>ROW</code>.</p>
</li>
<li>
<p>Each column returned by the SQL query maps to a child element of the <code>ROW</code> element.</p>
</li>
<li>
<p>The entire result is wrapped in a <code>ROWSET</code> element.</p>
</li>
<li>
<p>Binary data is transformed to its hexadecimal representation.</p>
</li>
</ul>
<p>Element names <code>ROW</code> and <code>ROWSET</code> can be replaced with names you choose, using <code>DBMS_XMLGEN</code> procedures <code>setRowTagName</code> and <code>setRowSetTagName</code>, respectively.</p>
<p>The <code>CLOB</code> value returned by <code>getXML</code> has the same encoding as the database character set. If the database character set is SHIFTJIS, then the XML document returned is also SHIFTJIS.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5051"></a><a id="ADXDB5050"></a>
<div class="props_rev_3"><a id="GUID-458675AB-E020-4BFF-8CA9-34D309186F62"></a>
<h3 id="ADXDB-GUID-458675AB-E020-4BFF-8CA9-34D309186F62" class="sect3"><span class="enumeration_section">8.3.2</span> Functions and Procedures of Package DBMS_XMLGEN</h3>
<div>
<p>PL/SQL package <code>DBMS_XMLGEN</code> provides functions and procedures for generating XML data from relational data.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-458675AB-E020-4BFF-8CA9-34D309186F62__G1033764" title="This table describes DBMS_XMLGEN functions and procedures.">Table 8-1</a> describes the functions and procedures of package <code>DBMS_XMLGEN</code>.</p>
</div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-458675AB-E020-4BFF-8CA9-34D309186F62__G1033764">
<p class="titleintable">Table 8-1 DBMS_XMLGEN Functions and Procedures</p>
<table class="cellalignment3431" title="DBMS_XMLGEN Functions and Procedures" summary="This table describes DBMS_XMLGEN functions and procedures.">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3562" id="d57804e3361">Function or Procedure</th>
<th class="cellalignment3562" id="d57804e3364">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3369" headers="d57804e3361">
<pre dir="ltr">SUBTYPE ctxHandle IS NUMBER
</pre></td>
<td class="cellalignment3411" headers="d57804e3369 d57804e3364">
<p>The context handle used by all functions.</p>
<p>Document Type Definition (DTD) or schema specifications:</p>
<p><code>NONE CONSTANT NUMBER:= 0;</code></p>
<p><code>DTD CONSTANT NUMBER:= 1;</code></p>
<p><code>SCHEMA CONSTANT NUMBER:= 2;</code></p>
<p>Can be used in function <code>getXML</code> to specify whether to generate a DTD or XML schema or neither (<code>NONE</code>). Only the <code>NONE</code> specification is supported.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3399" headers="d57804e3361">
<pre dir="ltr">newContext()
</pre></td>
<td class="cellalignment3411" headers="d57804e3399 d57804e3364">
<p>Given a query string, generate a new context handle to be used in subsequent functions.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3406" headers="d57804e3361">
<pre dir="ltr">newContext(
  queryString IN VARCHAR2)
</pre></td>
<td class="cellalignment3411" headers="d57804e3406 d57804e3364">
<p>Returns a new context</p>
<p><span class="italic">Parameter:</span> <code>queryString</code> <code>(IN)</code>- the query string, the result of which must be converted to XML</p>
<p><span class="italic">Returns:</span> Context handle. Call this function first to obtain a handle that you can use in the <code>getXML</code> and other functions to get the XML back from the result.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3430" headers="d57804e3361">
<pre dir="ltr">newContext(
  queryString IN SYS_REFCURSOR)
  RETURN ctxHandle;
</pre></td>
<td class="cellalignment3411" headers="d57804e3430 d57804e3364">
<p>Creates a new context handle from a PL/SQL cursor variable. The context handle can be used for the rest of the functions.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3437" headers="d57804e3361">
<pre dir="ltr">newContextFromHierarchy(
  queryString IN VARCHAR2)
  RETURN ctxHandle;
</pre></td>
<td class="cellalignment3411" headers="d57804e3437 d57804e3364">
<p><span class="italic">Parameter:</span> <code>queryString (IN)</code> - the query string, the result of which must be converted to XML. The query is a hierarchical query typically formed using a <code>CONNECT BY</code> clause, and the result must have the same property as the result set generated by a <code>CONNECT BY</code> query. The result set must have only two columns, the level number and an XML value. The level number is used to determine the hierarchical position of the XML value within the result XML document.</p>
<p><span class="italic">Returns:</span> Context handle. Call this function first to obtain a handle that you can use in the <code>getXML</code> and other functions to get a hierarchical XML with recursive elements back from the result.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3462" headers="d57804e3361">
<pre dir="ltr">setRowTag()
</pre></td>
<td class="cellalignment3411" headers="d57804e3462 d57804e3364">
<p>Sets the name of the element separating all the rows. The default name is <code>ROW</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3472" headers="d57804e3361">
<pre dir="ltr">setRowTag(ctx IN ctxHandle,
          rowTag IN VARCHAR2);
</pre></td>
<td class="cellalignment3411" headers="d57804e3472 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle obtained from the <code>newContext</code> call.</p>
<p><code>rowTag(IN)</code> - the name of the <code>ROW</code> element. A <code>NULL</code> value for <code>rowTag</code> indicates that you do not want the <code>ROW</code> element to be present.</p>
<p>Call this procedure to set the name of the <code>ROW</code> element, if you do not want the default <code>ROW</code> name to show up. You can also set <code>rowTag</code> to <code>NULL</code> to suppress the <code>ROW</code> element itself.</p>
<p>However, since getXML returns complete XML documents, not XML fragments, there must be a (single) root element. Therefore, an error is raised if both the <code>rowTag</code> value and the <code>rowSetTag</code> value (see <code>setRowSetTag</code>, next) are <code>NULL</code> and there is more than one column or row in the output.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3535" headers="d57804e3361">
<pre dir="ltr">setRowSetTag()
</pre></td>
<td class="cellalignment3411" headers="d57804e3535 d57804e3364">
<p>Sets the name of the document root element. The default name is <code>ROWSET</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3545" headers="d57804e3361">
<pre dir="ltr">setRowSetTag(ctx IN ctxHandle, 
             rowSetTag IN VARCHAR2);
</pre></td>
<td class="cellalignment3411" headers="d57804e3545 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> &ndash; the context handle obtained from the <code>newContext</code> call.</p>
<p><code>rowSetTag(IN)</code> &ndash; the name of the document root element to be used in the output. A <code>NULL</code> value for <code>rowSetTag</code> indicates that you do <span class="italic">not</span> want the <code>ROWSET</code> element to be present.</p>
<p>Call this procedure to set the name of the document root element, if you do not want the default name <code>ROWSET</code> to be used. You can set <code>rowSetTag</code> to <code>NULL</code> to suppress printing of the document root element.</p>
<p>However, since function <code>getXML</code> returns complete XML documents, not XML fragments, there must be a (single) root element. Therefore, an error is raised if both the <code>rowTag</code> value and the <code>rowSetTag</code> value (see <code>setRowTag</code>, previous) are <code>NULL</code> and there is more than one column or row in the output, or if the <code>rowSetTag</code> value is <code>NULL</code> and there is more than one row in the output.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3611" headers="d57804e3361">
<pre dir="ltr">getXML()
</pre></td>
<td class="cellalignment3411" headers="d57804e3611 d57804e3364">
<p>Gets the XML document by fetching the maximum number of rows specified. It appends the XML document to the <code>CLOB</code> passed in.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3621" headers="d57804e3361">
<pre dir="ltr">getXML(ctx IN ctxHandle, 
       clobval IN OUT NCOPY clob, 
       dtdOrSchema IN number:= NONE);
</pre></td>
<td class="cellalignment3411" headers="d57804e3621 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - The context handle obtained from calling <code>newContext</code>.</p>
<p><code>clobval(IN/OUT)</code> - the <code>CLOB</code> to which the XML document is to be appended,</p>
<p><code>dtdOrSchema(IN)</code> - whether you should generate the DTD or Schema. This parameter is NOT supported.</p>
<p>Use this version of the getXML function, to avoid any extra <code>CLOB</code> copies and if you want to reuse the same <code>CLOB</code> for subsequent calls. This <code>getXML</code> call is more efficient than the next flavor, though this involves that you create the LOB locator. When generating the XML, the number of rows indicated by the <code>setSkipRows</code> call are skipped, then the maximum number of rows as specified by the <code>setMaxRows</code> call (or the entire result if not specified) is fetched and converted to XML. Use the <code>getNumRowsProcessed</code> function to check if any rows were retrieved or not.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3670" headers="d57804e3361">
<pre dir="ltr">getXML()
</pre></td>
<td class="cellalignment3411" headers="d57804e3670 d57804e3364">
<p>Generates the XML document and returns it as a <code>CLOB</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3680" headers="d57804e3361">
<pre dir="ltr">getXML(ctx IN ctxHandle, 
       dtdOrSchema IN number:= NONE) 
  RETURN clob;
</pre></td>
<td class="cellalignment3411" headers="d57804e3680 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - The context handle obtained from calling <code>newContext</code>.</p>
<p><code>dtdOrSchema(IN)</code> - whether to generate a DTD or XML schema. This parameter is <span class="italic">not</span> supported.</p>
<p><span class="italic">Returns:</span> A temporary <code>CLOB</code> containing the document. Free the temporary <code>CLOB</code> obtained from this function using the <code>DBMS_LOB.freeTemporary</code> call.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3715" headers="d57804e3361">
<pre dir="ltr">getXMLType(
  ctx IN ctxHandle, 
  dtdOrSchema IN number:= NONE)
  RETURN XMLType;
</pre></td>
<td class="cellalignment3411" headers="d57804e3715 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - The context handle obtained from calling <code>newContext</code>.</p>
<p><code>dtdOrSchema(IN)</code> - whether to generate a DTD or XML schema. This parameter is <span class="italic">not</span> supported.</p>
<p><span class="italic">Returns:</span> An <code>XMLType</code> instance containing the document.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3744" headers="d57804e3361">
<pre dir="ltr">getXML(
  sqlQuery IN VARCHAR2, 
  dtdOrSchema IN NUMBER := NONE)
  RETURN CLOB;
</pre></td>
<td class="cellalignment3411" headers="d57804e3744 d57804e3364">
<p>Converts the query results from the SQL query string <code>sqlQuery</code> to XML format.</p>
<p><span class="italic">Returns:</span> A <code>CLOB</code> instance.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3761" headers="d57804e3361">
<pre dir="ltr">getXMLType(
  sqlQuery IN VARCHAR2, 
  dtdOrSchema IN NUMBER := NONE)   
  RETURN XMLType;
</pre></td>
<td class="cellalignment3411" headers="d57804e3761 d57804e3364">
<p>Converts the query results from the SQL query string <code>sqlQuery</code> to XML format.</p>
<p><span class="italic">Returns:</span> An <code>XMLType</code> instance.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3778" headers="d57804e3361">
<pre dir="ltr">getNumRowsProcessed()
</pre></td>
<td class="cellalignment3411" headers="d57804e3778 d57804e3364">
<p>Gets the number of SQL rows processed when generating XML data using function <code>getXML</code>. This count does not include the number of rows <span class="italic">skipped</span> before generating XML data.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3792" headers="d57804e3361">
<pre dir="ltr">getNumRowsProcessed(ctx IN ctxHandle) 
  RETURN number;
</pre></td>
<td class="cellalignment3411" headers="d57804e3792 d57804e3364">
<p><span class="italic">Parameter:</span> <code>queryString(IN)</code>- the query string, the result of which must be converted to XML</p>
<p><span class="italic">Returns:</span> The number of SQL rows that were processed in the last call to <code>getXML</code>.</p>
<p>You can call this to find out if the end of the result set has been reached. This does not include the number of rows <span class="italic">skipped</span> before generating XML data. Use this function to determine the terminating condition if you are calling <code>getXML</code> in a loop. Note that <code>getXML</code> would always generate an XML document even if there are no rows present.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3822" headers="d57804e3361">
<pre dir="ltr">setMaxRows()
</pre></td>
<td class="cellalignment3411" headers="d57804e3822 d57804e3364">
<p>Sets the maximum number of rows to fetch from the SQL query result for every invocation of the <code>getXML</code> call. It is an error to call this function on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3835" headers="d57804e3361">
<pre dir="ltr">setMaxRows(ctx IN ctxHandle, 
           maxRows IN NUMBER);
</pre></td>
<td class="cellalignment3411" headers="d57804e3835 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle corresponding to the query executed,</p>
<p><code>maxRows(IN)</code> - the maximum number of rows to get for each call to <code>getXML</code>.</p>
<p>The <code>maxRows</code> parameter can be used when generating paginated results using this utility. For instance when generating a page of XML or HTML data, you can restrict the number of rows converted to XML and then in subsequent calls, you can get the next set of rows and so on. This also can provide for faster response times. It is an error to call this procedure on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3862" headers="d57804e3361">
<pre dir="ltr">setSkipRows()
</pre></td>
<td class="cellalignment3411" headers="d57804e3862 d57804e3364">
<p>Skips a given number of rows before generating the XML output for every call to <code>getXML</code>. It is an error to call this function on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3875" headers="d57804e3361">
<pre dir="ltr">setSkipRows(ctx IN ctxHandle, 
            skipRows IN NUMBER);
</pre></td>
<td class="cellalignment3411" headers="d57804e3875 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle corresponding to the query executed,</p>
<p><code>skipRows(IN)</code> - the number of rows to skip for each call to <code>getXML</code>.</p>
<p>The <code>skipRows</code> parameter can be used when generating paginated results for stateless Web pages using this utility. For instance when generating the first page of XML or HTML data, you can set <code>skipRows</code> to zero. For the next set, you can set the <code>skipRows</code> to the number of rows that you got in the first case. It is an error to call this function on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3909" headers="d57804e3361">
<pre dir="ltr">setConvertSpecialChars()
</pre></td>
<td class="cellalignment3411" headers="d57804e3909 d57804e3364">
<p>Determines whether or not special characters in the XML data must be converted into their escaped XML equivalent. For example, the <code>&lt;</code> sign is converted to <code>&amp;lt;</code>. The default behavior is to perform escape conversions.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3922" headers="d57804e3361">
<pre dir="ltr">setConvertSpecialChars(
  ctx IN ctxHandle, 
  conv IN BOOLEAN);
</pre></td>
<td class="cellalignment3411" headers="d57804e3922 d57804e3364">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle to use,</p>
<p><code>conv(IN)</code> - true indicates that conversion is needed.</p>
<p>You can use this function to speed up the XML processing whenever you are sure that the input data cannot contain any special characters such as <span class="bold"><code>&lt;</code></span>, <span class="bold"><code>&gt;</code></span>, <span class="bold"><code>&#34;</code></span>, <span class="bold"><code>&#39;</code></span>, and so on, which must be preceded by an escape character. It is expensive to scan the character data to replace the special characters, particularly if it involves a lot of data. So, in cases when the data is XML-safe, this function can be called to improve performance.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3956" headers="d57804e3361">
<pre dir="ltr">useItemTagsForColl()
</pre></td>
<td class="cellalignment3411" headers="d57804e3956 d57804e3364">
<p>Sets the name of the collection elements. The default name for collection elements is the type name itself. You can override that to use the name of the column with the <code>_ITEM</code> tag appended to it using this function.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3966" headers="d57804e3361">
<pre dir="ltr">useItemTagsForColl(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment3411" headers="d57804e3966 d57804e3364">
<p><span class="italic">Parameter:</span> <code>ctx(IN)</code> - the context handle.</p>
<p>If you have a collection of <code>NUMBER</code>, say, the default tag name for the collection elements is <code>NUMBER</code>. You can override this action and generate the collection column name with the <code>_ITEM</code> tag appended to it, by calling this procedure.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3989" headers="d57804e3361">
<pre dir="ltr">restartQuery()
</pre></td>
<td class="cellalignment3411" headers="d57804e3989 d57804e3364">
<p>Restarts the query and generate the XML from the first row again.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e3996" headers="d57804e3361">
<pre dir="ltr">restartQuery(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment3411" headers="d57804e3996 d57804e3364">
<p><span class="italic">Parameter:</span> <code>ctx(IN)</code> - the context handle corresponding to the current query. You can call this to start executing the query again, without having to create a new context.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4008" headers="d57804e3361">
<pre dir="ltr">closeContext()
</pre></td>
<td class="cellalignment3411" headers="d57804e4008 d57804e3364">
<p>Closes a given context and releases all resources associated with that context, including the SQL cursor and bind and define buffers, and so on.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4015" headers="d57804e3361">
<pre dir="ltr">closeContext(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment3411" headers="d57804e4015 d57804e3364">
<p><span class="italic">Parameter:</span> <code>ctx(IN)</code> - the context handle to close. Closes all resources associated with this handle. After this you cannot use the handle for any other <code>DBMS_XMLGEN</code> function call.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4030" headers="d57804e3361">
<p><span class="italic">Conversion Functions</span></p>
<pre dir="ltr">convert(
  xmlData IN varchar2, 
  flag IN NUMBER := ENTITY_ENCODE)    
  RETURN VARCHAR2;
</pre></td>
<td class="cellalignment3411" headers="d57804e4030 d57804e3364">
<p>Encodes or decodes the XML data string argument.</p>
<ul style="list-style-type: disc;">
<li>
<p>Encoding refers to replacing entity references such as <code>&lt;</code> to their escaped equivalent, such as <code>&amp;lt;</code>.</p>
</li>
<li>
<p>Decoding refers to the reverse conversion.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4053" headers="d57804e3361">
<pre dir="ltr">convert(
  xmlData IN CLOB, 
  flag IN NUMBER := ENTITY_ENCODE) 
  RETURN CLOB;
</pre></td>
<td class="cellalignment3411" headers="d57804e4053 d57804e3364">
<p>Encodes or decodes the passed in XML <code>CLOB</code> data.</p>
<ul style="list-style-type: disc;">
<li>
<p>Encoding refers to replacing entity references such as <code>&lt;</code> to their escaped equivalent, such as <code>&amp;lt;</code>.</p>
</li>
<li>
<p>Decoding refers to the reverse conversion.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4076" headers="d57804e3361">
<p><span class="italic">NULL Handling</span></p>
<pre dir="ltr">setNullHandling(ctx IN ctxHandle, 
                flag IN NUMBER);
</pre></td>
<td class="cellalignment3411" headers="d57804e4076 d57804e3364">
<p>The <code>setNullHandling</code> flag values are:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>DROP_NULLS CONSTANT NUMBER := 0;</code></p>
<p>This is the default setting and leaves out the tag for <code>NULL</code> elements.</p>
</li>
<li>
<p><code>NULL_ATTR CONSTANT NUMBER := 1;</code></p>
<p>This sets <code>xsi:nil = &#34;true&#34;</code>.</p>
</li>
<li>
<p><code>EMPTY_TAG CONSTANT NUMBER := 2;</code></p>
<p>This sets, for example, <code>&lt;foo/&gt;</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4121" headers="d57804e3361">
<pre dir="ltr">useNullAttributeIndicator(
  ctx IN ctxHandle, 
  attrind IN BOOLEAN := TRUE);
</pre></td>
<td class="cellalignment3411" headers="d57804e4121 d57804e3364">
<p><code>useNullAttributeIndicator</code> is a shortcut for <code>setNullHandling(ctx, NULL_ATTR)</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4133" headers="d57804e3361">
<pre dir="ltr">setBindValue(
  ctx IN ctxHandle, 
  bindVariableName IN VARCHAR2, 
  bindValue IN VARCHAR2);
</pre></td>
<td class="cellalignment3411" headers="d57804e4133 d57804e3364">
<p>Sets bind value for the bind variable appearing in the query string associated with the context handle. The query string with bind variables cannot be executed until all of the bind variables are set values using <code>setBindValue</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3411" id="d57804e4143" headers="d57804e3361">
<pre dir="ltr">clearBindValue(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment3411" headers="d57804e4143 d57804e3364">
<p>Clears all the bind values for all the bind variables appearing in the query string associated with the context handle. Afterwards, all of the bind variables must rebind new values using <code>setBindValue</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDB5053"></a><a id="ADXDB5054"></a><a id="ADXDB5055"></a><a id="ADXDB5056"></a><a id="ADXDB5057"></a><a id="ADXDB5058"></a><a id="ADXDB5059"></a><a id="ADXDB5060"></a><a id="ADXDB5061"></a><a id="ADXDB5052"></a>
<div class="props_rev_3"><a id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45"></a>
<h3 id="ADXDB-GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45" class="sect3"><span class="enumeration_section">8.3.3</span> DBMS_XMLGEN Examples</h3>
<div>
<p>Examples here illustrate the use of PL/SQL package <code>DBMS_XMLGEN</code>.</p>
<div class="section">
<p><a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025636">Example 8-22</a> uses <code>DBMS_XMLGEN</code> to create an XML document by selecting employee data from an object-relational table and putting the resulting <code>CLOB</code> value into a table.</p>
<p>Instead of generating all of the XML data for all rows, you can use the fetch interface of package <code>DBMS_XMLGEN</code> to retrieve a fixed number of rows each time. This speeds up response time and can help in scaling applications that need a Document Object Model (DOM) Application Program Interface (API) on the resulting XML, particularly if the number of rows is large.</p>
<p><a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025688">Example 8-23</a> uses <code>DBMS_XMLGEN</code> to retrieve results from table <code>HR.employees</code>:</p>
<p><a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__BABFCBFF">Example 8-24</a> uses <code>DBMS_XMLGEN</code> with object types to represent nested structures.</p>
<p>With relational data, the result is an XML document without nested elements. To obtain nested XML structures, you can use object-relational data, where the mapping is as follows:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">Object types</span> map to XML elements &ndash; see <a href="xdb05sto.htm#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema is a standard for describing the content and structure of XML documents. You can register, update, and delete an XML schema used with Oracle XML&nbsp;DB. You can define storage structures to use for your XML schema-based data and map XML Schema data types to SQL data types.">XML Schema Storage and Query: Basic</a>.</p>
</li>
<li>
<p><span class="italic">Attributes of the type</span> map to sub-elements of the parent element</p>
<div class="infobox-note" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__GUID-49DF9813-DEF6-420C-A51F-1D19FB56E4E8">
<p class="notep1">Note:</p>
<p>Complex structures can be obtained by using object types and creating object views or object tables. A canonical mapping is used to map object instances to XML.</p>
<p>When used in column names or attribute names, the at-sign (<code>@</code>) is translated into an attribute of the enclosing XML element in the mapping.</p>
</div>
</li>
</ul>
<p>When you provide a user-defined data-type instance to <code>DBMS_XMLGEN</code> functions, the user-defined data-type instance is mapped to an XML document using a canonical mapping: the <span class="italic">attributes</span> of the user-defined data type are mapped to XML <span class="italic">elements</span>. Attributes with names starting with an at-sign character (<code>@</code>) are mapped to attributes of the preceding element.</p>
<p>User-defined data-type instances can be used for nesting in the resulting XML document.</p>
<p>For example, consider the tables <code>emp</code> and <code>dept</code> defined in <a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025801">Example 8-25</a>. To generate a hierarchical view of the data, that is, departments with their employees, <a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025801">Example 8-25</a> defines suitable object types to create the structure inside the database.</p>
<p>The default name <code>ROW</code> is not present because it was set to <code>NULL</code>. The <code>deptno</code> and <code>empno</code> have become attributes of the enclosing element.</p>
<p><a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1032455">Example 8-26</a> uses <code>DBMS_XMLGEN.getXMLType</code> to generate a purchase order document in XML format using object views.</p>
<p><a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEEGHEC">Example 8-27</a> shows how to open a cursor variable for a query and use that cursor variable to create a new context handle for <code>DBMS_XMLGEN</code>.</p>
<div class="infoboxnotealso" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__GUID-FF45D59E-95C4-422A-8FB3-473410F46631">
<p class="notep1">See Also:</p>
<p><a class="olink LNPLS01312" target="_blank" href="../LNPLS/cursor_variable.htm#LNPLS01312"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about cursor variables (<code>REF CURSOR</code>)</p>
</div>
<p><a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHDBFI">Example 8-28</a> shows how to specify <code>NULL</code> handling when using <code>DBMS_XMLGEN</code>.</p>
<p>Function <code>DBMS_XMLGEN.newContextFromHierarchy</code> takes as argument a hierarchical query string, which is typically formulated with a <code>CONNECT BY</code> clause. It returns a context that can be used to generate a hierarchical XML document with recursive elements.</p>
<p>The hierarchical query returns two columns, the level number (a pseudocolumn generated by <code>CONNECT BY</code> query) and an <code>XMLType</code> instance. The level is used to determine the position of the <code>XMLType</code> value within the hierarchy of the result XML document.</p>
<p>It is an error to set the skip number of rows or the maximum number of rows for a context created using <code>newContextFromHierarchy</code>.</p>
<p><a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHECHBFE">Example 8-29</a> uses <code>DBMS_ XMLGEN.newContextFromHierarchy</code> to generate a manager&ndash;employee hierarchy.</p>
<p>If the query string used to create a context contains host variables, you can use PL/SQL method <code>setBindValue()</code> to give the variables values before query execution. <a href="xdb13gen.htm#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHABDH">Example 8-30</a> illustrates this.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025636">
<p class="titleinexample">Example 8-22 DBMS_XMLGEN: Generating Simple XML</p>
<pre dir="ltr">CREATE TABLE temp_clob_tab (result CLOB);

DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  qryCtx := DBMS_XMLGEN.newContext(
              &#39;SELECT * FROM hr.employees WHERE employee_id = 101&#39;);
  -- Set the row header to be EMPLOYEE
  DBMS_XMLGEN.setRowTag(qryCtx, &#39;EMPLOYEE&#39;);
  -- Get the result
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  --Close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
</pre>
<p>That generates the following XML document:</p>
<pre dir="ltr">SELECT * FROM temp_clob_tab;

RESULT
-------------------------------------------------------
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-05&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025688">
<p class="titleinexample">Example 8-23 DBMS_XMLGEN: Generating Simple XML with Pagination (Fetch)</p>
<pre dir="ltr">-- Create a table to hold the results
CREATE TABLE temp_clob_tab (result clob);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  -- Get the query context;
  qryCtx := DBMS_XMLGEN.newContext(&#39;SELECT * FROM hr.employees&#39;);
  -- Set the maximum number of rows to be 2
  DBMS_XMLGEN.<span class="bold">setMaxRows</span>(qryCtx, 2);
  LOOP
    -- Get the result
    result := DBMS_XMLGEN.getXML(qryCtx);
    -- If no rows were processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
 
    -- Do some processing with the lob data
    --   Insert the results into a table.
    --   You can print the lob out, output it to a stream,
    --   put it in a queue, or do any other processing.
    INSERT INTO temp_clob_tab VALUES(result);
  END LOOP;
  --close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/

SELECT * FROM temp_clob_tab WHERE rownum &lt; 3;

RESULT
----------------------------------------------------------
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Steven&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;SKING&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;17-JUN-03&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_PRES&lt;/JOB_ID&gt;
  &lt;SALARY&gt;24000&lt;/SALARY&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-05&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;102&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Lex&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;De Haan&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;LDEHAAN&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4569&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;13-JAN-01&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;103&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Alexander&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Hunold&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;AHUNOLD&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;590.423.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;03-JAN-06&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;IT_PROG&lt;/JOB_ID&gt;
  &lt;SALARY&gt;9000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;102&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;60&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__BABFCBFF">
<p class="titleinexample">Example 8-24 DBMS_XMLGEN: Generating XML Using Object Types</p>
<pre dir="ltr">CREATE TABLE new_departments (department_id   NUMBER PRIMARY KEY,
                              department_name VARCHAR2(20));
CREATE TABLE new_employees (employee_id       NUMBER PRIMARY KEY,
                            last_name         VARCHAR2(20),
                            department_id     NUMBER REFERENCES new_departments);
CREATE TYPE emp_t AS OBJECT (&#34;@employee_id&#34;   NUMBER,
                             last_name        VARCHAR2(20));
/
INSERT INTO new_departments VALUES (10, &#39;SALES&#39;);
INSERT INTO new_departments VALUES (20, &#39;ACCOUNTING&#39;);
INSERT INTO new_employees   VALUES (30, &#39;Scott&#39;, 10);
INSERT INTO new_employees   VALUES (31, &#39;Mary&#39;,  10);
INSERT INTO new_employees   VALUES (40, &#39;John&#39;,  20);
INSERT INTO new_employees   VALUES (41, &#39;Jerry&#39;, 20);
COMMIT;
CREATE TYPE emplist_t AS TABLE OF emp_t;
/
CREATE TYPE dept_t AS OBJECT (&#34;@department_id&#34; NUMBER,
                              department_name  VARCHAR2(20),
                              emplist          emplist_t);
/
CREATE TABLE temp_clob_tab (result CLOB);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  DBMS_XMLGEN.setRowTag(qryCtx, NULL);
  qryCtx := DBMS_XMLGEN.newContext
    (&#39;SELECT dept_t(department_id,
                    department_name,
                    cast(MULTISET
                         (SELECT e.employee_id, e.last_name
                            FROM new_employees e
                            WHERE e.department_id = d.department_id)
                         AS emplist_t))
        AS deptxml
        FROM new_departments d&#39;);
  -- now get the result
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES (result);
  -- close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
SELECT * FROM temp_clob_tab;
</pre>
<p>Here is the resulting XML:</p>
<pre dir="ltr">RESULT
--------------------------------------------
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;DEPTXML department_id=&#34;10&#34;&gt;
   &lt;DEPARTMENT_NAME&gt;SALES&lt;/DEPARTMENT_NAME&gt;
   &lt;EMPLIST&gt;
    &lt;EMP_T employee_id=&#34;30&#34;&gt;
     &lt;LAST_NAME&gt;Scott&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
    &lt;EMP_T employee_id=&#34;31&#34;&gt;
     &lt;LAST_NAME&gt;Mary&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
   &lt;/EMPLIST&gt;
  &lt;/DEPTXML&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;DEPTXML department_id=&#34;20&#34;&gt;
   &lt;DEPARTMENT_NAME&gt;ACCOUNTING&lt;/DEPARTMENT_NAME&gt;
   &lt;EMPLIST&gt;
    &lt;EMP_T employee_id=&#34;40&#34;&gt;
     &lt;LAST_NAME&gt;John&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
    &lt;EMP_T employee_id=&#34;41&#34;&gt;
     &lt;LAST_NAME&gt;Jerry&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
   &lt;/EMPLIST&gt;
  &lt;/DEPTXML&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1025801">
<p class="titleinexample">Example 8-25 DBMS_XMLGEN: Generating XML Using User-Defined Data-Type Instances</p>
<pre dir="ltr">CREATE TABLE dept (deptno NUMBER PRIMARY KEY, dname VARCHAR2(20));
CREATE TABLE emp (empno   NUMBER PRIMARY KEY, ename VARCHAR2(20), 
                  deptno  NUMBER REFERENCES dept);
</pre>
<pre dir="ltr">-- empno is preceded by an at-sign (@) to indicate that it must 
-- be mapped as an attribute of the enclosing Employee element. 
CREATE TYPE emp_t AS OBJECT (&#34;@empno&#34; NUMBER,  -- empno defined as attribute
                              ename   VARCHAR2(20));
/
INSERT INTO DEPT VALUES (10, &#39;Sports&#39;);
INSERT INTO DEPT VALUES(20, &#39;Accounting&#39;);
INSERT INTO EMP VALUES(200, &#39;John&#39;,  10);
INSERT INTO EMP VALUES(300, &#39;Jack&#39;,  10);
INSERT INTO EMP VALUES(400, &#39;Mary&#39;,  20);
INSERT INTO EMP VALUES(500, &#39;Jerry&#39;, 20);
COMMIT;
CREATE TYPE emplist_t AS TABLE OF emp_t;
/
CREATE TYPE dept_t AS OBJECT(&#34;@deptno&#34; NUMBER, 
                             dname     VARCHAR2(20),
                             emplist   emplist_t);
/
-- Department type dept_t contains a list of employees.
-- You can now query the employee and department tables and get 
-- the result as an XML document, as follows:
CREATE TABLE temp_clob_tab (result CLOB);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  RESULT CLOB;
BEGIN
  -- get query context
  qryCtx := DBMS_XMLGEN.newContext(
    &#39;SELECT <span class="bold">dept_t</span>(deptno,
                   dname,
                   <span class="bold">cast</span>(<span class="bold">MULTISET</span>
                        (SELECT empno, ename FROM emp e WHERE e.deptno = d.deptno)
                        AS <span class="bold">emplist_t</span>))
       AS deptxml
       FROM dept d&#39;);
  -- set maximum number of rows to 5
  DBMS_XMLGEN.setMaxRows(qryCtx, 5);
  -- set no row tag for this result, since there is a single ADT column
  DBMS_XMLGEN.<span class="bold">setRowTag</span>(qryCtx, <span class="bold">NULL</span>);
  LOOP 
    -- get result
    result := DBMS_XMLGEN.getXML(qryCtx);
    -- if there were no rows processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
    -- do something with the result
    INSERT INTO temp_clob_tab VALUES (result);
  END LOOP;
END;
/
</pre>
<p>The <code>MULTISET</code> keyword for Oracle SQL function <code>cast</code> treats the employees working in the department as a list, which <code>cast</code> assigns to the appropriate collection type. A department instance is created using constructor <code>dept_t</code>, and <code>DBMS_XMLGEN</code> routines create the XML data for the object instance.</p>
<pre dir="ltr">SELECT * FROM temp_clob_tab;

RESULT
---------------------------------
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;DEPTXML deptno=&#34;10&#34;&gt;
  &lt;DNAME&gt;Sports&lt;/DNAME&gt;
  &lt;EMPLIST&gt;
   &lt;EMP_T empno=&#34;200&#34;&gt;
    &lt;ENAME&gt;John&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
   &lt;EMP_T empno=&#34;300&#34;&gt;
    &lt;ENAME&gt;Jack&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
  &lt;/EMPLIST&gt;
 &lt;/DEPTXML&gt;
 &lt;DEPTXML deptno=&#34;20&#34;&gt;
  &lt;DNAME&gt;Accounting&lt;/DNAME&gt;
  &lt;EMPLIST&gt;
   &lt;EMP_T empno=&#34;400&#34;&gt;
    &lt;ENAME&gt;Mary&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
   &lt;EMP_T empno=&#34;500&#34;&gt;
    &lt;ENAME&gt;Jerry&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
  &lt;/EMPLIST&gt;
 &lt;/DEPTXML&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__i1032455">
<p class="titleinexample">Example 8-26 DBMS_XMLGEN: Generating an XML Purchase Order</p>
<pre dir="ltr">-- Create relational schema and define object views
-- DBMS_XMLGEN maps user-defined data-type attribute names that start
--    with an at-sign (@) to XML attributes
 
-- Purchase Order Object View Model
 
-- PhoneList varray object type
CREATE TYPE phonelist_vartyp AS VARRAY(10) OF VARCHAR2(20)
/
-- Address object type
CREATE TYPE address_typ AS OBJECT(Street VARCHAR2(200),
                                  City   VARCHAR2(200),
                                  State  CHAR(2),
                                  Zip    VARCHAR2(20))
/
-- Customer object type
CREATE TYPE customer_typ AS OBJECT(CustNo    NUMBER,
                                   CustName  VARCHAR2(200),
                                   Address   address_typ,
                                   PhoneList phonelist_vartyp)
/
-- StockItem object type
CREATE TYPE stockitem_typ AS OBJECT(&#34;@StockNo&#34; NUMBER,
                                    Price      NUMBER,
                                    TaxRate    NUMBER)
/
-- LineItems object type
CREATE TYPE lineitem_typ AS OBJECT(&#34;@LineItemNo&#34; NUMBER,
                                   Item          stockitem_typ,
                                   Quantity      NUMBER,
                                   Discount      NUMBER)
/
-- LineItems ordered collection table
CREATE TYPE lineitems_ntabtyp AS TABLE OF lineitem_typ 
/
-- Purchase Order object type
CREATE TYPE po_typ AUTHID CURRENT_USER
  AS OBJECT(PONO            NUMBER,
            Cust_ref        REF customer_typ,
            OrderDate       DATE,
            ShipDate        TIMESTAMP,
            LineItems_ntab  lineitems_ntabtyp,
            ShipToAddr      address_typ)
/
-- Create Purchase Order relational model tables
-- Customer table
CREATE TABLE customer_tab (CustNo     NUMBER NOT NULL,
                           CustName   VARCHAR2(200),
                           Street     VARCHAR2(200),
                           City       VARCHAR2(200),
                           State      CHAR(2),
                           Zip        VARCHAR2(20),
                           Phone1     VARCHAR2(20),
                           Phone2     VARCHAR2(20),
                           Phone3     VARCHAR2(20),
                           CONSTRAINT cust_pk PRIMARY KEY (CustNo));
-- Purchase Order table
CREATE TABLE po_tab (PONo       NUMBER,        /* purchase order number */
                     Custno     NUMBER     /*  foreign KEY referencing customer */
                                CONSTRAINT po_cust_fk REFERENCES customer_tab, 
                     OrderDate  DATE,          /*  date of order */  
                     ShipDate   TIMESTAMP,     /* date to be shipped */    
                     ToStreet   VARCHAR2(200), /* shipto address */    
                     ToCity     VARCHAR2(200),    
                     ToState    CHAR(2),    
                     ToZip      VARCHAR2(20),
                     CONSTRAINT po_pk PRIMARY KEY(PONo));    
--Stock Table
CREATE TABLE stock_tab (StockNo NUMBER CONSTRAINT stock_uk UNIQUE,
                        Price   NUMBER,
                        TaxRate NUMBER);
--Line Items table
CREATE TABLE lineitems_tab (LineItemNo NUMBER,
                            PONo       NUMBER
                                       CONSTRAINT li_po_fk REFERENCES po_tab,
                            StockNo    NUMBER,
                            Quantity   NUMBER,
                            Discount   NUMBER,
                            CONSTRAINT li_pk PRIMARY KEY (PONo, LineItemNo));
-- Create Object views
-- Customer Object View
CREATE OR REPLACE VIEW customer OF customer_typ
  WITH OBJECT IDENTIFIER(CustNo)
  AS SELECT c.custno, c.custname,
            address_typ(c.street, c.city, c.state, c.zip),
            phonelist_vartyp(phone1, phone2, phone3)
       FROM customer_tab c;
--Purchase order view
CREATE OR REPLACE VIEW po OF po_typ
  WITH OBJECT IDENTIFIER (PONo)
  AS SELECT p.pono, make_ref(Customer, P.Custno), p.orderdate, p.shipdate,
            cast(MULTISET
                 (SELECT lineitem_typ(l.lineitemno,
                                      stockitem_typ(l.stockno, s.price,
                                                    s.taxrate),
                                      l.quantity, l.discount)
                    FROM lineitems_tab l, stock_tab s
                    WHERE l.pono = p.pono AND s.stockno=l.stockno)
                 AS lineitems_ntabtyp),
            address_typ(p.tostreet,p.tocity, p.tostate, p.tozip)
       FROM po_tab p;
-- Create table with XMLType column to store purchase order in XML format
CREATE TABLE po_xml_tab (poid  NUMBER, podoc XMLType)
/
-- Populate data
-------------------
-- Establish Inventory
INSERT INTO stock_tab VALUES(1004, 6750.00, 2);
INSERT INTO stock_tab VALUES(1011, 4500.23, 2);
INSERT INTO stock_tab VALUES(1534, 2234.00, 2);
INSERT INTO stock_tab VALUES(1535, 3456.23, 2);
-- Register Customers
INSERT INTO customer_tab
  VALUES (1, &#39;Jean Nance&#39;, &#39;2 Avocet Drive&#39;,
          &#39;Redwood Shores&#39;, &#39;CA&#39;, &#39;95054&#39;,
          &#39;415-555-1212&#39;, NULL, NULL);
INSERT INTO customer_tab
  VALUES (2, &#39;John Nike&#39;, &#39;323 College Drive&#39;,
          &#39;Edison&#39;, &#39;NJ&#39;, &#39;08820&#39;,
          &#39;609-555-1212&#39;, &#39;201-555-1212&#39;, NULL);
-- Place orders
INSERT INTO po_tab
  VALUES (1001, 1, &#39;10-APR-1997&#39;, &#39;10-MAY-1997&#39;,
          NULL, NULL, NULL, NULL);
INSERT INTO po_tab
  VALUES (2001, 2, &#39;20-APR-1997&#39;, &#39;20-MAY-1997&#39;,
          &#39;55 Madison Ave&#39;, &#39;Madison&#39;, &#39;WI&#39;, &#39;53715&#39;);
-- Detail line items
INSERT INTO lineitems_tab VALUES(01, 1001, 1534, 12,  0);
INSERT INTO lineitems_tab VALUES(02, 1001, 1535, 10, 10);
INSERT INTO lineitems_tab VALUES(01, 2001, 1004,  1,  0);
INSERT INTO lineitems_tab VALUES(02, 2001, 1011,  2,  1);
 
-- Use package DBMS_XMLGEN to generate purchase order in XML format
--   and store XMLType in table po_xml 
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  pxml XMLType;
  cxml CLOB;
BEGIN
  -- get query context;
  qryCtx := DBMS_XMLGEN.newContext(&#39;SELECT pono,deref(cust_ref) customer,
                                           p.orderdate,
                                           p.shipdate,
                                           lineitems_ntab lineitems,
                                           shiptoaddr
                                      FROM po p&#39;);
  -- set maximum number of rows to be 1,
  DBMS_XMLGEN.setMaxRows(qryCtx, 1);
  -- set ROWSET tag to NULL and ROW tag to PurchaseOrder
  DBMS_XMLGEN.<span class="bold">setRowSetTag</span>(qryCtx, <span class="bold">NULL</span>);
  DBMS_XMLGEN.<span class="bold">setRowTag</span>(qryCtx, &#39;<span class="bold">PurchaseOrder</span>&#39;);
  LOOP 
    -- get purchase order in XML format
    pxml := DBMS_XMLGEN.getXMLType(qryCtx);
    -- if there were no rows processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
    -- Store XMLType po in po_xml table (get the pono out)
    INSERT INTO po_xml_tab(poid, poDoc)
      VALUES(XMLCast(XMLQuery(&#39;//PONO/text()&#39; PASSING pxml RETURNING CONTENT)
                     AS NUMBER),
             pxml);
  END LOOP;
END;
/
</pre>
<p>This query then produces two XML purchase-order documents:</p>
<pre dir="ltr">SELECT XMLSerialize(DOCUMENT x.podoc AS CLOB) xpo FROM po_xml_tab x;

XPO
---------------------------------------------------
 &lt;PurchaseOrder&gt;
  &lt;PONO&gt;1001&lt;/PONO&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTNO&gt;1&lt;/CUSTNO&gt;
   &lt;CUSTNAME&gt;Jean Nance&lt;/CUSTNAME&gt;
   &lt;ADDRESS&gt;
    &lt;STREET&gt;2 Avocet Drive&lt;/STREET&gt;
    &lt;CITY&gt;Redwood Shores&lt;/CITY&gt;
    &lt;STATE&gt;CA&lt;/STATE&gt;
    &lt;ZIP&gt;95054&lt;/ZIP&gt;
   &lt;/ADDRESS&gt;
   &lt;PHONELIST&gt;
    &lt;VARCHAR2&gt;415-555-1212&lt;/VARCHAR2&gt;
   &lt;/PHONELIST&gt;
  &lt;/CUSTOMER&gt;
  &lt;ORDERDATE&gt;10-APR-97&lt;/ORDERDATE&gt;
  &lt;SHIPDATE&gt;10-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
  &lt;LINEITEMS&gt;
   &lt;LINEITEM_TYP LineItemNo=&#34;1&#34;&gt;
    &lt;ITEM StockNo=&#34;1534&#34;&gt;
     &lt;PRICE&gt;2234&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;12&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;0&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
   &lt;LINEITEM_TYP LineItemNo=&#34;2&#34;&gt;
    &lt;ITEM StockNo=&#34;1535&#34;&gt;
     &lt;PRICE&gt;3456.23&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;10&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;10&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
  &lt;/LINEITEMS&gt;
  &lt;SHIPTOADDR/&gt;
 &lt;/PurchaseOrder&gt;
 
 &lt;PurchaseOrder&gt;
  &lt;PONO&gt;2001&lt;/PONO&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTNO&gt;2&lt;/CUSTNO&gt;
   &lt;CUSTNAME&gt;John Nike&lt;/CUSTNAME&gt;
   &lt;ADDRESS&gt;
    &lt;STREET&gt;323 College Drive&lt;/STREET&gt;
    &lt;CITY&gt;Edison&lt;/CITY&gt;
    &lt;STATE&gt;NJ&lt;/STATE&gt;
    &lt;ZIP&gt;08820&lt;/ZIP&gt;
   &lt;/ADDRESS&gt;
   &lt;PHONELIST&gt;
    &lt;VARCHAR2&gt;609-555-1212&lt;/VARCHAR2&gt;
    &lt;VARCHAR2&gt;201-555-1212&lt;/VARCHAR2&gt;
   &lt;/PHONELIST&gt;
  &lt;/CUSTOMER&gt;
  &lt;ORDERDATE&gt;20-APR-97&lt;/ORDERDATE&gt;
  &lt;SHIPDATE&gt;20-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
  &lt;LINEITEMS&gt;
   &lt;LINEITEM_TYP LineItemNo=&#34;1&#34;&gt;
    &lt;ITEM StockNo=&#34;1004&#34;&gt;
     &lt;PRICE&gt;6750&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;1&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;0&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
   &lt;LINEITEM_TYP LineItemNo=&#34;2&#34;&gt;
    &lt;ITEM StockNo=&#34;1011&#34;&gt;
     &lt;PRICE&gt;4500.23&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;2&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;1&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
  &lt;/LINEITEMS&gt;
  &lt;SHIPTOADDR&gt;
   &lt;STREET&gt;55 Madison Ave&lt;/STREET&gt;
   &lt;CITY&gt;Madison&lt;/CITY&gt;
   &lt;STATE&gt;WI&lt;/STATE&gt;
   &lt;ZIP&gt;53715&lt;/ZIP&gt;
  &lt;/SHIPTOADDR&gt;
 &lt;/PurchaseOrder&gt;
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEEGHEC">
<p class="titleinexample">Example 8-27 DBMS_XMLGEN: Generating a New Context Handle from a REF Cursor</p>
<pre dir="ltr">CREATE TABLE emp_tab (emp_id       NUMBER PRIMARY KEY,
                      name         VARCHAR2(20),
                      dept_id      NUMBER);
Table created.
INSERT INTO emp_tab VALUES (122, &#39;Scott&#39;,  301);
1 row created.
INSERT INTO emp_tab VALUES (123, &#39;Mary&#39;,   472);
1 row created.
INSERT INTO emp_tab VALUES (124, &#39;John&#39;,   93);
1 row created.
INSERT INTO emp_tab VALUES (125, &#39;Howard&#39;, 488);
1 row created.
INSERT INTO emp_tab VALUES (126, &#39;Sue&#39;,    16);
1 row created.
COMMIT;
 
DECLARE
  ctx     NUMBER;
  maxrow  NUMBER;
  xmldoc  CLOB;
  refcur  SYS_REFCURSOR;
BEGIN
  DBMS_LOB.createtemporary(xmldoc, TRUE);
  maxrow := 3;
  OPEN refcur FOR &#39;SELECT * FROM emp_tab WHERE ROWNUM &lt;= :1&#39; USING maxrow;
  ctx := DBMS_XMLGEN.newContext(refcur);
   -- xmldoc will have 3 rows
  DBMS_XMLGEN.getXML(ctx, xmldoc, DBMS_XMLGEN.NONE);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_LOB.freetemporary(xmldoc);
  CLOSE refcur;
  DBMS_XMLGEN.closeContext(ctx);
END;
/
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;122&lt;/EMP_ID&gt;
  &lt;NAME&gt;Scott&lt;/NAME&gt;
  &lt;DEPT_ID&gt;301&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;123&lt;/EMP_ID&gt;
  &lt;NAME&gt;Mary&lt;/NAME&gt;
  &lt;DEPT_ID&gt;472&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;124&lt;/EMP_ID&gt;
  &lt;NAME&gt;John&lt;/NAME&gt;
  &lt;DEPT_ID&gt;93&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHDBFI">
<p class="titleinexample">Example 8-28 DBMS_XMLGEN: Specifying NULL Handling</p>
<pre dir="ltr">CREATE TABLE emp_tab (emp_id       NUMBER PRIMARY KEY,
                      name         VARCHAR2(20),
                      dept_id      NUMBER);
Table created.
INSERT INTO emp_tab VALUES (30, &#39;Scott&#39;, NULL);
1 row created.
INSERT INTO emp_tab VALUES (31, &#39;Mary&#39;, NULL);
1 row created.
INSERT INTO emp_tab VALUES (40, &#39;John&#39;, NULL);
1 row created.
COMMIT;
CREATE TABLE temp_clob_tab (result CLOB);
Table created.
 
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  qryCtx := DBMS_XMLGEN.newContext(&#39;SELECT * FROM emp_tab where name = :NAME&#39;);
  -- Set the row header to be EMPLOYEE
  DBMS_XMLGEN.setRowTag(qryCtx, &#39;EMPLOYEE&#39;);
  -- Drop nulls
  DBMS_XMLGEN.setBindValue(qryCtx, &#39;NAME&#39;, &#39;Scott&#39;);
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.DROP_NULLS);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  -- Null attribute
  DBMS_XMLGEN.setBindValue(qryCtx, &#39;NAME&#39;, &#39;Mary&#39;);
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.NULL_ATTR);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  -- Empty tag
  DBMS_XMLGEN.setBindValue(qryCtx, &#39;NAME&#39;, &#39;John&#39;);
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.EMPTY_TAG);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  --Close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
 
PL/SQL procedure successfully completed.
 
SELECT * FROM temp_clob_tab;
 
RESULT
-------------------------------------------
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;30&lt;/EMP_ID&gt;
  &lt;NAME&gt;Scott&lt;/NAME&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET xmlns:xsi = &#34;http://www.w3.org/2001/XMLSchema-instance&#34;&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;31&lt;/EMP_ID&gt;
  &lt;NAME&gt;Mary&lt;/NAME&gt;
  &lt;DEPT_ID xsi:nil = &#34;true&#34;/&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;40&lt;/EMP_ID&gt;
  &lt;NAME&gt;John&lt;/NAME&gt;
  &lt;DEPT_ID/&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHECHBFE">
<p class="titleinexample">Example 8-29 DBMS_XMLGEN: Generating Recursive XML with a Hierarchical Query</p>
<pre dir="ltr">CREATE TABLE sqlx_display (id NUMBER, xmldoc XMLType);
Table created.

DECLARE
  qryctx DBMS_XMLGEN.ctxhandle;
  result XMLType;
BEGIN
  qryctx := 
    DBMS_XMLGEN.<span class="bold">newContextFromHierarchy</span>(
      &#39;SELECT level, 
              XMLElement(&#34;employees&#34;, 
                         XMLElement(&#34;enumber&#34;, employee_id),
                         XMLElement(&#34;name&#34;, last_name),
                         XMLElement(&#34;Salary&#34;, salary),
                         XMLElement(&#34;Hiredate&#34;, hire_date))
         FROM hr.employees
         START WITH last_name=&#39;&#39;De Haan&#39;&#39; CONNECT BY PRIOR employee_id=manager_id
         ORDER SIBLINGS BY hire_date&#39;);
  result := DBMS_XMLGEN.getxmltype(qryctx);
  DBMS_OUTPUT.put_line(&#39;<span class="bold">&lt;result num rows&gt;</span>&#39;);
  DBMS_OUTPUT.put_line(<span class="bold">to_char(DBMS_XMLGEN.getNumRowsProcessed(qryctx))</span>);
  DBMS_OUTPUT.put_line(&#39;<span class="bold">&lt;/result num rows&gt;</span>&#39;);
  INSERT INTO sqlx_display VALUES (2, result);
  COMMIT;
  DBMS_XMLGEN.closecontext(qryctx);
END;
/
<span class="bold">&lt;result num rows&gt;</span>
<span class="bold">6</span>
<span class="bold">&lt;/result num rows&gt;</span>
PL/SQL procedure successfully completed.

SELECT xmldoc FROM sqlx_display WHERE id = 2;

XMLDOC
-----------------------------------------------------
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;employees&gt;
  &lt;enumber&gt;102&lt;/enumber&gt;
  &lt;name&gt;De Haan&lt;/name&gt;
  &lt;Salary&gt;17000&lt;/Salary&gt;
  &lt;Hiredate&gt;2001-01-13&lt;/Hiredate&gt;
  &lt;employees&gt;
    &lt;enumber&gt;103&lt;/enumber&gt;
    &lt;name&gt;Hunold&lt;/name&gt;
    &lt;Salary&gt;9000&lt;/Salary&gt;
    &lt;Hiredate&gt;2006-01-03&lt;/Hiredate&gt;
    &lt;employees&gt;
      &lt;enumber&gt;105&lt;/enumber&gt;
      &lt;name&gt;Austin&lt;/name&gt;
      &lt;Salary&gt;4800&lt;/Salary&gt;
      &lt;Hiredate&gt;2005-06-25&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;106&lt;/enumber&gt;
      &lt;name&gt;Pataballa&lt;/name&gt;
      &lt;Salary&gt;4800&lt;/Salary&gt;
      &lt;Hiredate&gt;2006-02-05&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;107&lt;/enumber&gt;
      &lt;name&gt;Lorentz&lt;/name&gt;
      &lt;Salary&gt;4200&lt;/Salary&gt;
      &lt;Hiredate&gt;2007-02-07&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;104&lt;/enumber&gt;
      &lt;name&gt;Ernst&lt;/name&gt;
      &lt;Salary&gt;6000&lt;/Salary&gt;
      &lt;Hiredate&gt;2007-05-21&lt;/Hiredate&gt;
    &lt;/employees&gt;
  &lt;/employees&gt;
&lt;/employees&gt;

1 row selected.
</pre>
<p>By default, the <code>ROWSET</code> tag is <code>NULL</code>: there is no default <code>ROWSET</code> tag used to enclose the XML result. However, you can explicitly set the <code>ROWSET</code> tag by using procedure <code>setRowSetTag</code>, as follows:</p>
<pre dir="ltr">CREATE TABLE gg (x XMLType);
Table created.

DECLARE
  qryctx DBMS_XMLGEN.ctxhandle;
  result CLOB;
BEGIN
  qryctx := DBMS_XMLGEN.newContextFromHierarchy(
              &#39;SELECT level,
                      XMLElement(&#34;NAME&#34;, last_name) AS myname FROM hr.employees
               CONNECT BY PRIOR employee_id=manager_id
               START WITH employee_id = 102&#39;);
  DBMS_XMLGEN.<span class="bold">setRowSetTag</span>(qryctx, &#39;<span class="bold">mynum_hierarchy</span>&#39;);
  result:=DBMS_XMLGEN.getxml(qryctx);
  DBMS_OUTPUT.put_line(&#39;&lt;result num rows&gt;&#39;);
  DBMS_OUTPUT.put_line(to_char(DBMS_XMLGEN.getNumRowsProcessed(qryctx)));
  DBMS_OUTPUT.put_line(&#39;&lt;/result num rows&gt;&#39;);
  INSERT INTO gg VALUES(XMLType(result));
  COMMIT;
  DBMS_XMLGEN.closecontext(qryctx);
END;
/
&lt;result num rows&gt;
6
&lt;/result num rows&gt;
PL/SQL procedure successfully completed.

SELECT * FROM gg;
 
X
----------------------------------------------------------
&lt;?xml version=&#34;1.0&#34;?&gt;
<span class="bold">&lt;mynum_hierarchy&gt;</span>
  &lt;NAME&gt;De Haan
    &lt;NAME&gt;Hunold
      &lt;NAME&gt;Ernst&lt;/NAME&gt;
      &lt;NAME&gt;Austin&lt;/NAME&gt;
      &lt;NAME&gt;Pataballa&lt;/NAME&gt;
      &lt;NAME&gt;Lorentz&lt;/NAME&gt;
    &lt;/NAME&gt;
  &lt;/NAME&gt;
<span class="bold">&lt;/mynum_hierarchy&gt;</span>
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHABDH">
<p class="titleinexample">Example 8-30 DBMS_XMLGEN: Binding Query Variables Using SETBINDVALUE()</p>
<pre dir="ltr">-- <span class="bold">Bind one variable</span>
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext(
           &#39;SELECT * FROM employees WHERE employee_id = <span class="bold">:NO</span>&#39;);
  DBMS_XMLGEN.<span class="bold">setBindValue</span>(ctx, &#39;<span class="bold">NO</span>&#39;, &#39;<span class="bold">145</span>&#39;);
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;<span class="bold">145</span>&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;01-OCT-04&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
PL/SQL procedure successfully completed.
</pre>
<pre dir="ltr">-- <span class="bold">Bind one variable twice with different values</span>
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext(&#39;SELECT * FROM employees
                                   WHERE hire_date = <span class="bold">:MDATE</span>&#39;);
  DBMS_XMLGEN.setBindValue(ctx, &#39;<span class="bold">MDATE</span>&#39;, &#39;<span class="bold">01-OCT-04</span>&#39;);
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.setBindValue(ctx, &#39;<span class="bold">MDATE</span>&#39;, &#39;<span class="bold">10-MAR-05</span>&#39;);
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;145&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">01-OCT-04</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;147&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Alberto&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Errazuriz&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;AERRAZUR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429278&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">10-MAR-05</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;12000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.3&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;159&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Lindsey&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Smith&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;LSMITH&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1345.729268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">10-MAR-97</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_REP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;8000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.3&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;146&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
PL/SQL procedure successfully completed.
</pre>
<pre dir="ltr">-- <span class="bold">Bind two variables</span> 
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext(&#39;SELECT * FROM employees
                                   WHERE employee_id = <span class="bold">:NO</span>
                                     AND hire_date = <span class="bold">:MDATE</span>&#39;);
  DBMS_XMLGEN.setBindValue(ctx, &#39;<span class="bold">NO</span>&#39;, &#39;<span class="bold">145</span>&#39;);
  DBMS_XMLGEN.setBindValue(ctx, &#39;<span class="bold">MDATE</span>&#39;, &#39;<span class="bold">01-OCT-04</span>&#39;);
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;<span class="bold">145</span>&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">01-OCT-04</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB5077"></a><a id="ADXDB5076"></a>
<div class="props_rev_3"><a id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42"></a>
<h2 id="ADXDB-GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" class="sect2"><span class="enumeration_section">8.4</span> SYS_XMLAGG Oracle SQL Function</h2>
<div>
<p>Oracle SQL function <code>sys_XMLAgg</code> aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named <code>ROWSET</code> (by default).</p>
<div class="section">
<p>Oracle function <code>sys_XMLAgg</code> is similar to standard SQL/XML function <code>XMLAgg</code>, but <code>sys_XMLAgg</code> returns a single node and it accepts an <code>XMLFormat</code> parameter. You can use that parameter to format the resulting XML document in various ways.</p>
<div class="figure" id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42__GUID-44EF0E58-5359-4AE0-B6BF-14DAE9668D71">
<p class="titleinfigure">Figure 8-14 SYS_XMLAGG Syntax</p>
<img width="348" height="46" src="img/GUID-E81A09B4-36B0-4884-BF6A-52E108A54217-default.gif" alt="Description of Figure 8-14 follows" title="Description of Figure 8-14 follows"/><br/>
<a href="img_text/GUID-E81A09B4-36B0-4884-BF6A-52E108A54217-print.htm">Description of &#34;Figure 8-14 SYS_XMLAGG Syntax&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42__GUID-B288356C-F8AA-42FB-941B-5F450F25C773">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF51840" target="_blank" href="../SQLRF/functions205.htm#SQLRF51840"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>sys_XMLAgg</code></p>
</li>
<li>
<p><a class="olink SQLRF51092" target="_blank" href="../SQLRF/sql_elements004.htm#SQLRF51092"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about an <code>XMLFormat</code> parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5085"></a><a id="ADXDB5084"></a>
<div class="props_rev_3"><a id="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130"></a>
<h2 id="ADXDB-GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130" class="sect2"><span class="enumeration_section">8.5</span> Ordering Query Results Before Aggregating, Using XMLAGG ORDER BY Clause</h2>
<div>
<p>To use the <code>XMLAgg ORDER BY</code> clause before aggregation, specify the <code>ORDER BY</code> clause following the first <code>XMLAGG</code> argument.</p>
<div class="section">
<p>This is illustrated in <a href="xdb13gen.htm#GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130__CHEEJJDE">Example 8-31</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130__CHEEJJDE">
<p class="titleinexample">Example 8-31 Using XMLAGG ORDER BY Clause</p>
<pre dir="ltr">CREATE TABLE dev_tab (dev         NUMBER,
                      dev_total   NUMBER,
                      devname     VARCHAR2(20));
Table created.
INSERT INTO dev_tab VALUES (16, 5,  &#39;Alexis&#39;);
1 row created.
INSERT INTO dev_tab VALUES (2,  14, &#39;Han&#39;);
1 row created.
INSERT INTO dev_tab VALUES (1,  2,  &#39;Jess&#39;);
1 row created.
INSERT INTO dev_tab VALUES (9,  88, &#39;Kurt&#39;);
1 row created.
COMMIT;
</pre>
<p>The result of the following query is aggregated according to the order of the <code>dev</code> column. (The result is shown here pretty-printed, for clarity.)</p>
<pre dir="ltr">SELECT XMLAgg(XMLElement(&#34;Dev&#34;, 
                         XMLAttributes(dev AS &#34;id&#34;, dev_total AS &#34;total&#34;),
                         devname) 
              ORDER BY dev) 
  FROM dev_tab dev_total;

XMLAGG(XMLELEMENT(&#34;DEV&#34;,XMLATTRIBUTES(DEVAS&#34;ID&#34;,DEV_TOTALAS&#34;TOTAL&#34;),DEVNAME)ORDE
--------------------------------------------------------------------------------
&lt;Dev id=&#34;<span class="bold">1</span>&#34; total=&#34;2&#34;&gt;Jess&lt;/Dev&gt;
&lt;Dev id=&#34;<span class="bold">2</span>&#34; total=&#34;14&#34;&gt;Han&lt;/Dev&gt;
&lt;Dev id=&#34;<span class="bold">9</span>&#34; total=&#34;88&#34;&gt;Kurt&lt;/Dev&gt;
&lt;Dev id=&#34;<span class="bold">16</span>&#34; total=&#34;5&#34;&gt;Alexis&lt;/Dev&gt;
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5087"></a><a id="ADXDB5086"></a>
<div class="props_rev_3"><a id="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384"></a>
<h2 id="ADXDB-GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384" class="sect2"><span class="enumeration_section">8.6</span> Returning a Rowset Using XMLTABLE</h2>
<div>
<p>You can use standard SQL/XML function <code>XMLTable</code> to return a rowset with relevant portions of a document extracted as multiple rows.</p>
<div class="section">
<p>This is shown in <a href="xdb13gen.htm#GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384__CHDGBFFC">Example 8-32</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384__CHDGBFFC">
<p class="titleinexample">Example 8-32 Returning a Rowset Using XMLTABLE</p>
<pre dir="ltr">CONNECT oe
Enter password: <span class="italic">password</span>

Connected.

SELECT item.descr, item.partid
  FROM purchaseorder,
       XMLTable(&#39;$p/PurchaseOrder/LineItems/LineItem&#39; PASSING OBJECT_VALUE
                COLUMNS descr  VARCHAR2(256) PATH &#39;Description&#39;,
                        partid VARCHAR2(14)  PATH &#39;Part/@Id&#39;) item
  WHERE item.partid = &#39;715515012027&#39;
     OR item.partid = &#39;715515011921&#39;
  ORDER BY partid;
</pre>
<p>This returns a rowset with just the descriptions and part IDs, ordered by part ID.</p>
<pre dir="ltr">DESCR
--------------
PARTID
--------------
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921

My Man Godfrey
715515011921

My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
16 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
<hr/>
<br/>
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:
<p>The SQL/XML standard requires argument <span class="italic"><code>data-type</code></span> to be present, but it is <span class="italic">optional</span> in the Oracle XML&nbsp;DB implementation of the standard, for ease of use.</p>
<br/>
Footnote&nbsp;2:
<p>The limit is 32767 or 4000 bytes, depending on the value of initialization parameter <code>MAX_STRING_SIZE</code>.&thinsp; See <a class="olink SQLRF55623" target="_blank" href="../SQLRF/sql_elements001.htm#SQLRF55623"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<br/></div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3410">
<tr>
<td class="cellalignment3417">
<table class="cellalignment3415">
<tr>
<td class="cellalignment3414"><a href="partpg4.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3414"><a href="xdb_rel_views.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3419">
<table class="cellalignment3413">
<tr>
<td class="cellalignment3414"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3414"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3414"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3414"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3414"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3414"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>


</body></html>