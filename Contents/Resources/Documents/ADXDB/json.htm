<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-1585"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/JSON%20in%20Oracle%20Database"></a><title>JSON in Oracle Database</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Oracle Database supports JavaScript Object Notation (JSON) data natively with relational database features, including transactions, indexing, declarative querying, and views."/>
<meta name="keywords" content="JSON, overview, JSON, syntax, JavaScript Object Notation (JSON), JSON, JavaScript notation compared with JSON, compared with JavaScript notation, value, scalar value, JavaScript, object, object, object literal, object literal, Javascript, array element, element, array, SQL conditions, IS (NOT) NULL and JSON null, object member, array, JavaScript, field, compared with XML, XML, compared with JSON, character-set conversion, character encoding, ASCII escape sequences, JSON, ASCII escape sequences, path expression, path expression, JSON, Oracle JSON path expression, syntax, context item, Oracle JSON path expression, step, Oracle JSON path expression, object step, Oracle JSON path expression, array step, Oracle JSON path expression, relaxed, RETURNING clause, JSON SQL functions, ASCII keyword, JSON SQL functions, PRETTY keyword, JSON SQL functions, PRETTY keyword, json_query, json_query SQL function, PRETTY keyword, wrapper clause, JSON SQL functions, WRAPPER keyword, JSON SQL functions, UNCONDITIONAL keyword, JSON SQL functions, WITH WRAPPER keywords, JSON SQL functions, JSON SQL function, WITH WRAPPER keywords, error clause, JSON SQL functions, is json SQL condition, is not json SQL condition, SQL conditions, is json, is not json, well formed JSON data, check constraint used to ensure well-formed JSON, DBA_JSON_COLUMNS view, view, DBA_JSON_COLUMNS, USER_JSON_COLUMNS view, USER_JSON_COLUMNS, ALL_JSON_COLUMNS view, ALL_JSON_COLUMNS, unique field names in JSON objects, duplicate field names in JSON objects, WITH UNIQUE KEYS keywords, JSON condition is json, WITHOUT UNIQUE KEYS keywords, JSON condition is json, strict JSON syntax, syntax, strict, lax JSON syntax, lax, STRICT keyword for is (not) json syntax, STRICT keyword, is not json SQL condition, json_exists SQL condition, json_exists, as json_table, json_value SQL function, functions, SQL, json_value, JSON SQL functions, json_query, json_table SQL function, json_table, child COLUMNS clause, json_table SQL function, parent COLUMNS clause, json_table SQL function, row source, JSON, definition, FOR ORDINALITY keywords, json_table SQL function, FOR ORDINALITY keywords, sibling COLUMNS clauses, json_table SQL function, EXISTS keyword, json_table SQL function, EXISTS keyword, FORMAT JSON keywords, json_table SQL function, FORMAT JSON keywords, COLUMNS clause, json_table SQL function, PATH clause, json_table, PATH clause, NESTED PATH clause, json_table, json_table SQL function, NESTED PATH clause, indexing JSON data, indexing, json_exists SQL condition, indexing, json_value SQL function, indexing for json_table queries, for json_table queries, indexing for queries, data type considerations, composite B-tree index for multiple fields, full-text search, JSON data, JSON search index, json_textcontains SQL condition, json_textcontains, for search, CTXSYS.JSON_SECTION_GROUP Oracle Text section group"/>
<meta name="dcterms.created" content="2016-12-08T13:53:25Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="XML DB Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E41152-15"/>
<meta name="dcterms.isVersionOf" content="ADXDB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="partpgjson.htm" title="Previous" type="text/html"/>
<link rel="Next" href="partpg7.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41152-15.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-A8A58B49-13A5-4F42-8EA0-508951DAE0BB"></a> <span id="PAGE" style="display:none;">54/61</span> <!-- End Header -->
<script>
//<![CDATA[
window.name='json'
//]]>
</script> <script>
    function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote&amp;nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
</script><noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="ADXDB6246"></a>
<h1 id="ADXDB-GUID-A8A58B49-13A5-4F42-8EA0-508951DAE0BB" class="sect1"><span class="enumeration_chapter">39</span> JSON in Oracle Database</h1>
<div>
<p>Oracle Database supports JavaScript Object Notation (JSON) data natively with relational database features, including transactions, indexing, declarative querying, and views.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="json.htm#GUID-B2D82ED4-B007-4019-8B53-9D0CDA81C4FA" title="JavaScript Object Notation (JSON) is defined in standards ECMA-404 (JSON Data Interchange Format) and ECMA-262 (ECMAScript Language Specification, third edition). The JavaScript dialect of ECMAScript is a general programming language used widely in web browsers and web servers.">Overview of JSON</a></p>
</li>
<li>
<p><a href="json.htm#GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E" title="JSON data and XML data can be used in Oracle Database in similar ways. Unlike relational data, both can be stored, indexed, and queried without any need for a schema that defines the data. Oracle Database supports JSON natively with relational database features, including transactions, indexing, declarative querying, and views.">Overview of JSON in Oracle Database</a></p>
</li>
<li>
<p><a href="json.htm#GUID-2BD7911A-0201-4BEC-906E-D174267B438A" title="Textual JSON data always uses the Unicode character set. In this respect, JSON data is simpler to use than XML data. This is an important part of the JSON Data Interchange Format (RFC 4627). For JSON data processed by Oracle Database, any needed character-set conversions are performed automatically.">JSON: Character Sets and Character Encoding in Oracle Database</a></p>
</li>
<li>
<p><a href="json.htm#GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" title="Oracle Database provides SQL access to JSON data using Oracle JSON path expressions.">Oracle JSON Path Expressions</a></p>
</li>
<li>
<p><a href="json.htm#GUID-9E6455EC-FE3B-428C-B958-1D535726EA26" title="Oracle provides SQL functions and conditions you can use to create, query, and operate on JSON data stored in Oracle Database. Some of these take as argument an Oracle JSON path expression as a literal SQL string, followed possibly by a RETURNING clause, a wrapper clause, or an error clause.">Oracle SQL Functions and Conditions for Use with JSON Data</a></p>
</li>
<li>
<p><a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576" title="A simple dot-notation syntax is provided for queries, as an alternative to using the more verbose but more flexible Oracle SQL functions json_query and json_value. The dot notation is designed to return JSON values whenever possible.">Simple Dot-Notation Access to JSON Data</a></p>
</li>
<li>
<p><a href="json.htm#GUID-BD09DB8A-26F4-43A9-9B39-9E0E20C0D192" title="You can index JSON data as you would any data of the type you use to store it. In addition, you can define a JSON search index, which is useful for both ad hoc structural queries and full-text queries.">Indexes for JSON Data</a></p>
</li>
<li>
<p><a href="json.htm#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8" title="You can use Oracle SQL condition json_textcontains in a CASE expression or the WHERE clause of a SELECT statement to perform a full-text search of JSON data that is stored in a VARCHAR2, BLOB, or CLOB column.">Full-Text Search of JSON Data</a></p>
</li>
<li>
<p><a href="json.htm#GUID-52EFC452-5E65-4148-8070-1FA588A6E697" title="You can create a database table of JSON data from the content of a JSON dump file.">Loading External JSON Data</a></p>
</li>
<li>
<p><a href="json.htm#GUID-EE961220-A9F9-4B04-B371-6131D524B1FB" title="You can use Oracle GoldenGate to replicate tables with columns containing JSON data.">Replication of JSON Data</a></p>
</li>
<li>
<p><a href="json.htm#GUID-A2BC5593-7F70-482E-89D1-B32C3798E0E4" title="Oracle Database support for JavaScript Object Notation (JSON) is designed to provide the best fit between the worlds of relational storage and querying JSON data, allowing relational and JSON queries to work well together.">Oracle Database Support for JSON</a></p>
</li>
</ul>
</div>
<a id="ADXDB6247"></a>
<div class="props_rev_3"><a id="GUID-B2D82ED4-B007-4019-8B53-9D0CDA81C4FA"></a>
<h2 id="ADXDB-GUID-B2D82ED4-B007-4019-8B53-9D0CDA81C4FA" class="sect2"><span class="enumeration_section">39.1</span> Overview of JSON</h2>
<div>
<p><strong class="term">JavaScript Object Notation</strong> (<strong class="term">JSON</strong>) is defined in standards ECMA-404 (JSON Data Interchange Format) and ECMA-262 (ECMAScript Language Specification, third edition). The JavaScript dialect of ECMAScript is a general programming language used widely in web browsers and web servers.</p>
<p>JSON is almost a subset of the object literal notation of JavaScript.<a id="fn_1" href="#fn_1" onclick="footdisplay(1,&#34;JSON differs from JavaScript notation in this respect: JSON allows unescaped Unicode characters U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) in strings. JavaScript notation requires control characters such as these to be escaped in strings. This difference can be important when generating JSONP (JSON with padding) data. &#34;)"><sup>Foot&nbsp;1</sup></a> Because it can be used to represent JavaScript object literals, JSON commonly serves as a data-interchange language. In this it has much in common with XML.</p>
<p>Because it is (almost a subset of) JavaScript notation, JSON can often be used in JavaScript programs without any need for parsing or serializing. It is a text-based way of representing JavaScript object literals, arrays, and scalar data.</p>
<p>Although it was defined in the context of JavaScript, JSON is in fact a language-independent data format. A variety of programming languages can parse and generate JSON data.</p>
<p>JSON is relatively easy for humans to read and write, and easy for software to parse and generate. It is often used for serializing structured data and exchanging it over a network, typically between a server and web applications.</p>
<div class="infoboxnotealso" id="GUID-B2D82ED4-B007-4019-8B53-9D0CDA81C4FA__GUID-19DE75F5-6E51-40B3-B5BF-D8AF2DFEF4B9">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank"><code>http://www.ecma-international.org/publications/standards/Ecma-404.htm</code></a> and <a href="http://tools.ietf.org/html/rfc4627" target="_blank"><code>http://tools.ietf.org/html/rfc4627</code></a> for the definition of the JSON Data Interchange Format</p>
</li>
<li>
<p><a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank"><code>http://www.ecma-international.org/publications/standards/Ecma-262.htm</code></a> for the ECMAScript Language Specification</p>
</li>
<li>
<p><a href="http://www.json.org" target="_blank"><code>http://www.json.org</code></a> for information about JSON</p>
</li>
<li>
<p><a href="http://www.ecmascript.org" target="_blank"><code>http://www.ecmascript.org</code></a> for information about ECMAScript (JavaScript)</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6369"></a><a id="ADXDB6248"></a>
<div class="props_rev_3"><a id="GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C"></a>
<h3 id="ADXDB-GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C" class="sect3"><span class="enumeration_section">39.1.1</span> Overview of JSON Syntax and the Data It Represents</h3>
<div>
<p>JSON (and JavaScript) values, scalars, objects, and arrays are described.</p>
<p>A JSON <strong class="term">value</strong> is one of the following: object, array, number, string, , , or <span class="bold"><code>null</code></span>. All values except objects and arrays are <strong class="term">scalar</strong>.</p>
<div class="infobox-note" id="GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C__GUID-15195CA1-04B2-4911-9529-99DB18A84237">
<p class="notep1">Note:</p>
<p>A JSON value of <code>null</code> is a <span class="italic">value</span> as far as SQL is concerned. It is not <code>NULL</code>, which in SQL represents the <span class="italic">absence</span> of a value (missing, unknown, or inapplicable data). In particular, SQL condition <code>IS NULL</code> condition returns false for a JSON null value, and SQL condition <code>IS NOT NULL</code> returns true.</p>
</div>
<p>A <strong class="term">JavaScript object</strong> is an associative array, or dictionary, of zero or more pairs of <span class="bold">property</span> names and associated JSON values.<a id="fn_2" href="#fn_2" onclick="footdisplay(2,&#34;JavaScript objects are thus similar to hash tables in C and C++, HashMaps in Java, associative arrays in PHP, dictionaries in Python, and hashes in Perl and Ruby. &#34;)"><sup>Foot&nbsp;2</sup></a> A <strong class="term">JSON object</strong> is a <strong class="term">JavaScript object literal</strong>.<a id="fn_3" href="#fn_3" onclick="footdisplay(3,&#34;An object is created in JavaScript using either constructor Object or object literal syntax: {...}. &#34;)"><sup>Foot&nbsp;3</sup></a> It is written as such a property list enclosed in braces (<span class="bold"><code>{</code></span>, <span class="bold"><code>}</code></span>), with name-value pairs separated by commas (<span class="bold"><code>,</code></span>), and with the name and value of each pair separated by a colon (<span class="bold"><code>:</code></span>).</p>
<p>In JSON each property name and each string value <span class="italic">must</span> be enclosed in double quotation marks (<span class="bold"><code>&#34;</code></span>). In JavaScript notation, a property name used in an object literal can be, but need not be, enclosed in double quotation marks. It can also be enclosed in single quotation marks (<span class="bold"><code>&#39;</code></span>).</p>
<p>As a result of this difference, in practice, data that is represented using unquoted or single-quoted property names is sometimes referred to loosely as being represented in JSON, and some implementations of JSON, including the Oracle Database implementation, support the lax syntax that allows the use of unquoted and single-quoted property names.</p>
<p>A string in JSON is composed of Unicode characters, with backslash (<span class="bold"><code>\</code></span>) escaping. A JSON number (numeral) is represented in decimal notation, possibly signed and possibly including a decimal exponent.</p>
<p>An object property is often called a <span class="bold"><strong class="term">field</strong></span>. An object property name-value pair is often called an object <span class="bold"><strong class="term">member</strong></span>. Order is not significant among object members.</p>
<div class="infobox-note" id="GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C__GUID-D184BB33-A7E2-4DED-B1C0-C7D0570BFC5B">
<p class="notep1">Note:</p>
<ul style="list-style-type: disc;">
<li>
<p>A JSON field name can be <span class="italic">empty</span> (<code><span class="bold">&#34;&#34;</span></code>).<a id="fn_4" href="#fn_4" onclick="footdisplay(4,&#34;In a few contexts an empty field name cannot be used with Oracle Database. Wherever it can be used, the name must be wrapped with double quotation marks.&#34;)"><sup>Foot&nbsp;4</sup></a></p>
</li>
<li>
<p>Each field name in a given JSON object is not necessarily unique; the same field name may be repeated. The JSON path evaluation that Oracle Database employs always uses only one of the object members that have a given field name; any other members with the same name are ignored. It is unspecified which of multiple such members is used.</p>
<p>See also <span class="q">&#34;<a href="json.htm#GUID-305EFFC0-B7AA-4752-90A0-3DA895A93FAE" title="By default, object fields (object properties) need not be unique for a given JSON object, but you can specify that particular JSON data is to be considered well-formed only if none of its objects have duplicate field names.">Unique Versus Duplicate Fields in JSON Objects</a>&#34;</span>.</p>
</li>
</ul>
</div>
<p>A <strong class="term">JavaScript array</strong> has zero or more elements. In JSON an array is represented by brackets (<span class="bold"><code>[</code></span>, <span class="bold"><code>]</code></span>) surrounding the representations of the array <strong class="term">elements</strong>, which are separated by commas (<span class="bold"><code>,</code></span>), and each of which is an object, an array, or a scalar value. Array element order is significant.</p>
<p><a href="json.htm#GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C__CACCBBAI">Example 39-1</a> shows a JSON object that represents a purchase order, with top-level field names <code>PONumber</code>, <code>Reference</code>, <code>Requestor</code>, <code>User</code>, <code>Costcenter</code>, <code>ShippingInstruction</code>, <code>Special Instructions</code>, <code>AllowPartialShipment</code> and <code>LineItems</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p>Most of the fields have string values. For example: field <code>User</code> has value <code>&#34;ABULL&#34;</code>.</p>
</li>
<li>
<p>Fields <code>PONumber</code> and <code>zipCode</code> have numeric values: <code>1600</code> and <code>99236</code>.</p>
</li>
<li>
<p>Field <code>Shipping Instructions</code> has an object as value. This object has three members, with fields <code>name</code>, <code>Address</code>, and <code>Phone</code>. Field <code>name</code> has a string value (<code>&#34;Alexis Bull&#34;</code>). Fields <code>Address</code> and <code>Phone</code> each have an object value.</p>
</li>
<li>
<p>The value of field <code>Address</code> is an object with fields <code>street</code>, <code>city</code>, <code>state</code>, <code>zipCode</code>, and <code>country</code>. Field <code>zipCode</code> has a numeric value; the others have string values.</p>
</li>
<li>
<p>Field <code>Phone</code> has an array as value. This array has two elements, each of which represents an object literal. Each of these objects has two members: fields <code>type</code> and <code>number</code> and their values.</p>
</li>
<li>
<p>Field <code>Special Instructions</code> has a <code>null</code> value.</p>
</li>
<li>
<p>Field <code>AllowPartialShipment</code> has the Boolean value <code>true</code>.</p>
</li>
<li>
<p>Field <code>LineItems</code> has an array as value. This array has two elements, each of which is an object. Each of these objects has three members, with fields <code>ItemNumber</code>, <code>Part</code>, and <code>Quantity</code>.</p>
</li>
<li>
<p>Fields <code>ItemNumber</code> and <code>Quantity</code> have numeric values. Field <code>Part</code> has an object as value, with fields <code>Description</code>, <code>UnitPrice</code>, and <code>UPCCode</code>. Field <code>Description</code> has a string value. Fields <code>UnitPrice</code> and <code>UPCCode</code> have numeric values.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C__GUID-7D0470D1-C63B-48CB-B611-EFDB2C1CC6A6">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20" title="The Oracle default syntax for JSON is lax. In particular: it reflects the JavaScript syntax for object fields; the Boolean and null values are not case-sensitive; and it is more permissive with respect to numerals, whitespace, and escaping of Unicode characters.">About Strict and Lax JSON Syntax</a>&#34;</span></p>
</li>
<li>
<p><a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">Example 39-4</a></p>
</li>
</ul>
</div>
<div class="example" id="GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C__CACCBBAI">
<p class="titleinexample">Example 39-1 A JSON Object (Representation of a JavaScript Object Literal)</p>
<pre>{ &#34;<span class="bold">PONumber</span>&#34;             : 1600,
  &#34;<span class="bold">Reference</span>&#34;            : &#34;ABULL-20140421&#34;,
  &#34;<span class="bold">Requestor</span>&#34;            : &#34;Alexis Bull&#34;,
  &#34;<span class="bold">User</span>&#34;                 : &#34;ABULL&#34;,
  &#34;<span class="bold">CostCenter</span>&#34;           : &#34;A50&#34;,
  &#34;<span class="bold">ShippingInstructions</span>&#34; : { &#34;<span class="bold">name</span>&#34;   : &#34;Alexis Bull&#34;,
                             &#34;<span class="bold">Address</span>&#34;: { &#34;<span class="bold">street</span>&#34;  : &#34;200 Sporting Green&#34;,
                                          &#34;<span class="bold">city</span>&#34;    : &#34;South San Francisco&#34;,
                                          &#34;<span class="bold">state</span>&#34;   : &#34;CA&#34;,
                                          &#34;<span class="bold">zipCode</span>&#34; : 99236,
                                          &#34;<span class="bold">country</span>&#34; : &#34;United States of America&#34; },
                             &#34;<span class="bold">Phone</span>&#34; : [ { &#34;<span class="bold">type</span>&#34; : &#34;Office&#34;, &#34;<span class="bold">number</span>&#34; : &#34;909-555-7307&#34; },
                                         { &#34;<span class="bold">type</span>&#34; : &#34;Mobile&#34;, &#34;<span class="bold">number</span>&#34; : &#34;415-555-1234&#34; } ] },
  &#34;<span class="bold">Special Instructions</span>&#34; : null,
  &#34;<span class="bold">AllowPartialShipment</span>&#34; : false,
  &#34;<span class="bold">LineItems</span>&#34;            : [ { &#34;<span class="bold">ItemNumber</span>&#34; : 1,
                               &#34;<span class="bold">Part</span>&#34;       : { &#34;<span class="bold">Description</span>&#34; : &#34;One Magic Christmas&#34;,
                                                &#34;<span class="bold">UnitPrice</span>&#34;   : 19.95,
                                                &#34;<span class="bold">UPCCode</span>&#34;     : 13131092899 },
                               &#34;<span class="bold">Quantity</span>&#34;   : 9.0 },
                             { &#34;<span class="bold">ItemNumber</span>&#34; : 2,
                               &#34;<span class="bold">Part</span>&#34;       : { &#34;<span class="bold">Description</span>&#34; : &#34;Lethal Weapon&#34;,
                                                &#34;<span class="bold">UnitPrice</span>&#34;   : 19.95,
                                                &#34;<span class="bold">UPCCode</span>&#34;     : 85391628927 },
                               &#34;<span class="bold">Quantity</span>&#34;   : 5.0 } ] }
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6250"></a>
<div class="props_rev_3"><a id="GUID-C347AC02-31E4-49CE-9F74-C7C0F339D68E"></a>
<h3 id="ADXDB-GUID-C347AC02-31E4-49CE-9F74-C7C0F339D68E" class="sect3"><span class="enumeration_section">39.1.2</span> Overview of JSON Compared with XML</h3>
<div>
<p>Both JSON and XML (Extensible Markup Language) are commonly used as data-interchange languages. Their main differences are listed here.</p>
<ul style="list-style-type: disc;">
<li>
<p>JSON data types are few and predefined. XML data can be either typeless or based on an XML schema or a document type definition (DTD).</p>
</li>
<li>
<p>JSON has simple structure-defining and document-combining constructs: it lacks attributes, namespaces, inheritance and substitution.</p>
</li>
<li>
<p>The order of the members of a JavaScript object literal is insignificant. In general, order matters within an XML document.</p>
</li>
<li>
<p>JSON lacks an equivalent of XML text nodes (XPath node test <code>text()</code>). In particular, this means that there is no mixed content.</p>
</li>
</ul>
<p>JSON is most useful with simple, structured data. XML is useful for both structured and semi-structured data. JSON is generally data-centric, not document-centric; XML can be either. JSON is not a markup language; it is designed only for data representation. XML is both a document markup language and a data representation language.</p>
<p>Because of its simple definition and features, JSON data is generally easier to generate, parse, and process than XML data. Use cases that involve combining different data sources generally lend themselves well to the use of XML, because it offers namespaces and other constructs facilitating modularity and inheritance.</p>
<p>JSON, unlike XML (and unlike JavaScript), has no date data type. A date is represented in JSON using the available data types, such as string. There are some de facto standards for converting between real dates and strings. But programs using JSON must, one way or another, deal with date representation conversion.</p>
</div>
</div>
</div>
<a id="ADXDB6370"></a><a id="ADXDB6251"></a>
<div class="props_rev_3"><a id="GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E"></a>
<h2 id="ADXDB-GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E" class="sect2"><span class="enumeration_section">39.2</span> Overview of JSON in Oracle Database</h2>
<div>
<p>JSON data and XML data can be used in Oracle Database in similar ways. Unlike relational data, both can be stored, indexed, and queried <span class="italic">without any need for a schema</span> that defines the data. Oracle Database supports JSON natively with relational database features, including transactions, indexing, declarative querying, and views.</p>
<p>JSON data has often been stored in NoSQL databases such as Oracle NoSQL Database and Oracle Berkeley DB. These allow for storage and retrieval of data that is not based on any schema, but they do not offer the rigorous consistency models of relational databases.</p>
<p>To compensate for this shortcoming, a relational database is sometimes used in parallel with a NoSQL database. Applications using JSON data stored in the NoSQL database must then ensure data integrity themselves.</p>
<p>Native support for JSON by Oracle Database obviates such workarounds. It provides all of the benefits of relational database features for use with JSON, including transactions, indexing, declarative querying, and views.</p>
<p>Oracle Database queries are declarative. You can join JSON data with relational data. And you can project JSON data relationally, making it available for relational processes and tools. You can also query, from within the database, JSON data that is stored outside the database in an external table.</p>
<p>You can access JSON data stored in the database the same way you access other database data, including using OCI, .NET, and JDBC.</p>
<p>Unlike XML data, which is stored using SQL data type <code>XMLType</code>, JSON data is stored in Oracle Database using SQL data types <code>VARCHAR2</code>, <code>CLOB</code>, and <code>BLOB</code>. Oracle recommends that you always use an <code>is_json</code> check constraint to ensure that column values are valid JSON instances (see <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACHFFCE">Example 39-3</a>).</p>
<p>JSON data in the database is textual, but the text can be stored using data type <code>BLOB</code>, as well as <code>VARCHAR2</code> or <code>CLOB</code>. When possible, Oracle recommends that you use <code>BLOB</code> storage. In particular, doing so obviates the need for any character-set conversion (see <a href="json.htm#GUID-2BD7911A-0201-4BEC-906E-D174267B438A" title="Textual JSON data always uses the Unicode character set. In this respect, JSON data is simpler to use than XML data. This is an important part of the JSON Data Interchange Format (RFC 4627). For JSON data processed by Oracle Database, any needed character-set conversions are performed automatically.">JSON: Character Sets and Character Encoding in Oracle Database</a>).</p>
<div class="infobox-note" id="GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E__GUID-807FEE39-CA76-45F7-BD64-3B6E15E3DBBA">
<p class="notep1">Note:</p>
<p>JSON data that is stored in an external table that is based on Hadoop Distributed File System (HDFS) is not offloaded to Oracle Big Data SQL when LOB storage is used. See <a class="olink BIGUG21115" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=BIGUG21115"><span class="italic">Oracle Big Data Appliance Software User&#39;s Guide</span></a></p>
</div>
<p>When JSON data is stored in a <code>BLOB</code> column you must use keywords <code>FORMAT JSON</code> in queries that use Oracle SQL functions or conditions for JSON (<code>json_value</code>, <code>json_query</code>, <code>json_table</code>, <code>json_exists</code>), to declare that the data is JSON. Otherwise, an error is raised, letting you know that the JSON input data is binary and you have not specified its format.</p>
<div class="infobox-note" id="GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E__GUID-EA775E4E-18FE-4188-8608-F87DFF25D050">
<p class="notep1">Note:</p>
<p>Oracle recommends that whenever you store JSON data in a <code>BLOB</code> or <code>CLOB</code> column you <span class="italic">turn on the LOB cache option</span> for that column. This option is turned off by default. See <a class="olink ADLOB45285" target="_blank" href="../ADLOB/adlob_tables.htm#ADLOB45285"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a>.</p>
</div>
<p>By definition, textual JSON data is encoded using a Unicode encoding, either UTF-8 or UTF-16. You can use textual data that is stored in a non-Unicode character set as if it were JSON data, but in that case Oracle Database automatically converts the character set to UTF-8 when processing the data.</p>
<p>In SQL, you can access JSON data stored in Oracle Database using the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Functions <code>json_value</code>, <code>json_query</code>, <code>and json_table</code>.</p>
</li>
<li>
<p>Conditions <code>json_exists</code>, <code>is json</code>, <code>is not json</code>, and <code>json_textcontains</code>.</p>
</li>
<li>
<p>A dot notation that acts similar to a combination of <code>json_value</code> and <code>json_query</code> and resembles a SQL object access expression, that is, attribute dot notation for an abstract data type (ADT).</p>
</li>
</ul>
<p>As a simple illustration, <a href="json.htm#GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E__CACEFDIF">Example 39-2</a> uses the dot notation to query JSON column <code>po_document</code> for all purchase-order requestors (JSON field <code>Requestor</code>).</p>
<div class="infoboxnotealso" id="GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E__GUID-67BA1626-6D4B-4E8E-A6C9-14C20A1ABC3D">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" title="Oracle Database provides SQL access to JSON data using Oracle JSON path expressions.">Oracle JSON Path Expressions</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-9E6455EC-FE3B-428C-B958-1D535726EA26" title="Oracle provides SQL functions and conditions you can use to create, query, and operate on JSON data stored in Oracle Database. Some of these take as argument an Oracle JSON path expression as a literal SQL string, followed possibly by a RETURNING clause, a wrapper clause, or an error clause.">Oracle SQL Functions and Conditions for Use with JSON Data</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576" title="A simple dot-notation syntax is provided for queries, as an alternative to using the more verbose but more flexible Oracle SQL functions json_query and json_value. The dot notation is designed to return JSON values whenever possible.">Simple Dot-Notation Access to JSON Data</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-A2BC5593-7F70-482E-89D1-B32C3798E0E4" title="Oracle Database support for JavaScript Object Notation (JSON) is designed to provide the best fit between the worlds of relational storage and querying JSON data, allowing relational and JSON queries to work well together.">Oracle Database Support for JSON</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-2BD7911A-0201-4BEC-906E-D174267B438A" title="Textual JSON data always uses the Unicode character set. In this respect, JSON data is simpler to use than XML data. This is an important part of the JSON Data Interchange Format (RFC 4627). For JSON data processed by Oracle Database, any needed character-set conversions are performed automatically.">JSON: Character Sets and Character Encoding in Oracle Database</a>&#34;</span> for information about automatic character-set conversion</p>
</li>
</ul>
</div>
<div class="example" id="GUID-D7BCE045-EF6D-47E9-9BB2-30C01933248E__CACEFDIF">
<p class="titleinexample">Example 39-2 Simple SQL Query of JSON Data</p>
<pre dir="ltr">SELECT po.po_document.<span class="bold">Requestor</span> FROM j_purchaseorder po;
</pre></div>
<!-- class="example" --></div>
<a id="ADXDB6371"></a>
<div class="props_rev_3"><a id="GUID-F6282E67-CBDF-442E-946F-5F781BC14F33"></a>
<h3 id="ADXDB-GUID-F6282E67-CBDF-442E-946F-5F781BC14F33" class="sect3"><span class="enumeration_section">39.2.1</span> Getting Started Using JSON with Oracle Database</h3>
<div>
<p>In general, you will perform the following tasks when working with JSON data in Oracle Database: (1) create a JSON column with an <code>is json</code> check constraint, (2) insert JSON data into the column, and (3) query the JSON data.</p>
<div class="section"></div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a relational table with a JSON column, and add an <code>is json</code> <span class="italic">check constraint</span> to ensure that the column contains only well-formed JSON data.</span>
<div>
<p>The following statement creates relational table <code>j_purchaseorder</code> with JSON column <code>po_document</code> (see also <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACHFFCE">Example 39-3</a>):</p>
<pre dir="ltr">CREATE TABLE j_purchaseorder
   (id          RAW (16) NOT NULL,
    date_loaded TIMESTAMP WITH TIME ZONE,
    <span class="bold">po_document</span> CLOB
    <span class="bold">CONSTRAINT</span> ensure_json <span class="bold">CHECK</span> (po_document <span class="bold">IS JSON</span>));
</pre></div>
</li>
<li class="stepexpand"><span>Insert JSON data into the JSON column, using any of the methods available for Oracle Database.</span>
<div>
<p>The following statement uses a SQL <code>INSERT</code> statement to insert some simple JSON data. Some of the data is elided here (<code>...</code>). See <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">Example 39-4</a> for these details.</p>
<pre dir="ltr">INSERT INTO j_purchaseorder
  VALUES (SYS_GUID(),
          SYSTIMESTAMP,
          &#39;{&#34;PONumber&#34;             : 1600,
            &#34;Reference&#34;            : &#34;ABULL-20140421&#34;,
            &#34;Requestor&#34;            : &#34;Alexis Bull&#34;,
            &#34;User&#34;                 : &#34;ABULL&#34;,
            &#34;CostCenter&#34;           : &#34;A50&#34;,
            &#34;ShippingInstructions&#34; : {...},
            &#34;Special Instructions&#34; : null,
            &#34;AllowPartialShipment&#34; : true,
            &#34;LineItems&#34;            : [...]}&#39;);
</pre></div>
</li>
<li class="stepexpand"><span>Query the JSON data. The return value is always a <code>VARCHAR2</code> instance that represents a JSON value. Here are some simple examples.</span>
<div>
<p>The following query extracts, from each JSON document in column <code>po_document</code>, a <span class="italic">scalar</span> value, the JSON number that is the value of field <code>PONumber</code> for the objects in JSON column <code>po_document</code> (see also <a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576__CACGDHDB">Example 39-18</a>):</p>
<pre dir="ltr">SELECT po.po_document.<span class="bold">PONumber</span> FROM j_purchaseorder po;
</pre>
<p>The following query extracts, from each document in JSON column <code>po_document</code>, an <span class="italic">array</span> of JSON phone objects, which is the value of field <code>Phone</code> of the value of field <code>ShippingInstructions</code> (see also <a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576__CACCBEGC">Example 39-19</a>):</p>
<pre dir="ltr">SELECT po.po_document.<span class="bold">ShippingInstructions.Phone</span> FROM j_purchaseorder po;
</pre>
<p>The following query extracts, from each JSON document, <span class="italic">multiple</span> values as an array: the value of field <code>type</code> for each object in array <code>Phone</code>. The returned array is not part of the stored data but is constructed automatically by the query. (The order of the array elements is unspecified.)</p>
<pre dir="ltr">SELECT po.po_document.<span class="bold">ShippingInstructions.Phone.type</span> FROM j_purchaseorder po;
</pre></div>
</li>
</ol>
<div class="section">
<div class="infoboxnotealso" id="GUID-F6282E67-CBDF-442E-946F-5F781BC14F33__GUID-109E845D-81A0-4552-AB04-3743A0EB6B89">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0" title="A typical use of SQL condition is json is as a check constraint, to ensure that the data in a JSON column is (well-formed) JSON data. Oracle recommends that you always use an is_json check constraint when you create a column intended for JSON data.">Using a Check Constraint To Ensure that a Column Contains JSON Data</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576" title="A simple dot-notation syntax is provided for queries, as an alternative to using the more verbose but more flexible Oracle SQL functions json_query and json_value. The dot notation is designed to return JSON values whenever possible.">Simple Dot-Notation Access to JSON Data</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB6252"></a>
<div class="props_rev_3"><a id="GUID-2BD7911A-0201-4BEC-906E-D174267B438A"></a>
<h2 id="ADXDB-GUID-2BD7911A-0201-4BEC-906E-D174267B438A" class="sect2"><span class="enumeration_section">39.3</span> JSON: Character Sets and Character Encoding in Oracle Database</h2>
<div>
<p>Textual JSON data always uses the Unicode character set. In this respect, JSON data is simpler to use than XML data. This is an important part of the JSON Data Interchange Format (RFC 4627). For JSON data processed by Oracle Database, any needed character-set conversions are performed automatically.</p>
<p>Oracle Database uses UTF-8 internally when it processes JSON data (parsing, querying). If the data that is input to such processing, or the data that is output from it, must be in a different character set from UTF-8, then appropriate character-set conversion is carried out automatically.</p>
<p>Character-set conversion can affect performance. And in some cases it can be lossy: Conversion of input data to UTF-8 is a lossless operation, but conversion to output can result in <span class="italic">information loss</span> in the case of characters that cannot be represented in the output character set.</p>
<p>If your textual JSON data is stored in the database as Unicode then no character-set conversion is needed. This is the case if the database character set is AL32UTF8 (Unicode UTF-8). Oracle recommends this if at all possible.</p>
<p>JSON data that is not stored textually, that is, as characters, never undergoes character-set conversion: there are no characters to convert. This means that JSON data stored using data type <code>BLOB</code> suffers no character-set conversion.</p>
<p>If your JSON data is stored as non-Unicode character data, that is, using non-Unicode <code>VARCHAR2</code> or <code>CLOB</code> storage, then consider doing the following to avoid character-set conversion:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use <code>NUMBER</code>, not <code>VARCHAR2</code>, for the return value of Oracle SQL functions such as <code>json_value</code>.</p>
</li>
<li>
<p>Escape particular Unicode characters on input&thinsp;&mdash;&thinsp;see <span class="q">&#34;<a href="json.htm#GUID-6636B08A-4344-4932-9FAE-C1995032E428" title="ASCII characters correspond directly to the first 128 Unicode characters. If your application can use an ASCII escape sequence to represent input Unicode characters that might otherwise require character-set conversion, then you will avoid any possible performance penalty or information loss from such conversion.">Escape of Unicode Characters in JSON Data</a>&#34;</span></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-2BD7911A-0201-4BEC-906E-D174267B438A__GUID-A7F1F2A6-7D65-43C1-A2A0-53AA31EA0E9A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="http://www.unicode.org" target="_blank"><code>http://www.unicode.org</code></a> for information about Unicode</p>
</li>
<li>
<p><a href="http://tools.ietf.org/html/rfc4627" target="_blank"><code>http://tools.ietf.org/html/rfc4627</code></a> and <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank"><code>http://www.ecma-international.org/publications/standards/Ecma-404.htm</code></a> for the JSON Data Interchange Format</p>
</li>
<li>
<p><a class="olink DUMAG101" target="_blank" href="../DUMAG/ch1overview.htm#DUMAG101"><span class="italic">Oracle Database Migration Assistant for Unicode Guide</span></a> for information about using different character sets with the database</p>
</li>
<li>
<p><a class="olink NLSPG463" target="_blank" href="../NLSPG/ch11charsetmig.htm#NLSPG463"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about character-set conversion in the database</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6253"></a>
<div class="props_rev_3"><a id="GUID-6636B08A-4344-4932-9FAE-C1995032E428"></a>
<h3 id="ADXDB-GUID-6636B08A-4344-4932-9FAE-C1995032E428" class="sect3"><span class="enumeration_section">39.3.1</span> Escape of Unicode Characters in JSON Data</h3>
<div>
<p>ASCII characters correspond directly to the first 128 Unicode characters. If your application can use an ASCII escape sequence to represent input Unicode characters that might otherwise require character-set conversion, then you will avoid any possible performance penalty or information loss from such conversion.</p>
<div class="section">
<p>An ASCII escape sequence for a Unicode character is <span class="bold"><code>\u</code></span> followed by four ASCII hexadecimal digits representing the Unicode code point for the character.</p>
<p>For example, the Unicode euro character &euro;, which is named <code>EURO SIGN</code>, has code point <code>20AC</code> (using hexadecimal digits), so it can be represented using the ASCII escape sequence <code>\u20AC</code>.</p>
<p>You can use explicit ASCII escaping on <span class="italic">input</span> data. Because JSON data uses Unicode internally, when it is <span class="italic">output</span>, character-set conversion still applies, by default. However, for Oracle SQL functions <code>json_value</code>, <code>json_query</code>, and <code>json_table</code> you can use keyword <span class="bold"><code>ASCII</code></span> to specify the automatic use of ASCII escape sequences for non-ASCII Unicode characters.</p>
<div class="infoboxnotealso" id="GUID-6636B08A-4344-4932-9FAE-C1995032E428__GUID-2416DDEE-230F-4FFA-9BB1-8885A92356D0">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="Oracle SQL functions json_value and json_query accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB6254"></a>
<div class="props_rev_3"><a id="GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F"></a>
<h2 id="ADXDB-GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" class="sect2"><span class="enumeration_section">39.4</span> Overview of Oracle JSON Path Expressions</h2>
<div>
<p>Oracle Database provides SQL access to JSON data using Oracle JSON path expressions.</p>
<p>JSON is a notation for JavaScript values. When JSON data is stored in the database you can query it using path expressions that are somewhat analogous to XQuery or XPath expressions for XML data. Similar to the way that SQL/XML allows SQL access to XML data using XQuery expressions, Oracle Database provides SQL access to JSON data using Oracle JSON path expressions.</p>
<p>Oracle JSON path expressions have a simple syntax. An Oracle JSON path expression selects zero or more JSON values that match, or satisfy, it.</p>
<p>Oracle SQL condition <code>json_exists</code> returns true if at least one value matches, and false if no value matches. If a single value matches, then SQL function <code>json_value</code> returns that value if it is scalar and raises an error if it is non-scalar. If no value matches the path expression then <code>json_value</code> returns SQL <code>NULL</code>.</p>
<p>Oracle SQL function <code>json_query</code> returns all of the matching values, that is, it can return multiple values. You can think of this behavior as returning a sequence of values, as in XQuery, or you can think of it as returning multiple values. (No user-visible sequence is manifested.)</p>
<p>In all cases, path-expression matching attempts to match each <span class="italic">step</span> of the path expression, in turn. If matching any step fails then no attempt is made to match the subsequent steps, and matching of the path expression fails. If matching each step succeeds then matching of the path expression succeeds.</p>
<div class="infoboxnotealso" id="GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F__GUID-89AE7279-E7A6-41D7-AE32-56E547AD11E7">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-7B610884-39CD-4910-85E7-C251D342D879" title="Oracle JSON path expressions are matched by Oracle SQL functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges.">Oracle JSON Path Expression Syntax</a>&#34;</span> for information about path-expression steps</p>
</div>
</div>
<a id="ADXDB6255"></a>
<div class="props_rev_3"><a id="GUID-7B610884-39CD-4910-85E7-C251D342D879"></a>
<h3 id="ADXDB-GUID-7B610884-39CD-4910-85E7-C251D342D879" class="sect3"><span class="enumeration_section">39.4.1</span> Oracle JSON Path Expression Syntax</h3>
<div>
<p>Oracle JSON path expressions are matched by Oracle SQL functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges.</p>
<p>You pass an Oracle JSON path expression and some JSON data to an Oracle SQL function or condition. The path expression is matched against the data, and the matching data is processed by the particular SQL function or condition. You can think of this matching process in terms of the path expression <span class="italic">returning</span> the matched data to the function or condition.</p>
<div class="infoboxnotealso" id="GUID-7B610884-39CD-4910-85E7-C251D342D879__GUID-91950E85-E062-477C-87A3-F767AF34901C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of an Oracle JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item. Examples are provided.">Oracle JSON Basic Path Expression Syntax</a> &#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic Oracle JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">Oracle JSON Path Expression Syntax Relaxation</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-9E6455EC-FE3B-428C-B958-1D535726EA26" title="Oracle provides SQL functions and conditions you can use to create, query, and operate on JSON data stored in Oracle Database. Some of these take as argument an Oracle JSON path expression as a literal SQL string, followed possibly by a RETURNING clause, a wrapper clause, or an error clause.">Oracle SQL Functions and Conditions for Use with JSON Data</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20" title="The Oracle default syntax for JSON is lax. In particular: it reflects the JavaScript syntax for object fields; the Boolean and null values are not case-sensitive; and it is more permissive with respect to numerals, whitespace, and escaping of Unicode characters.">About Strict and Lax JSON Syntax</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6372"></a>
<div class="props_rev_3"><a id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618"></a>
<h4 id="ADXDB-GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" class="sect4"><span class="enumeration_section">39.4.1.1</span> Oracle JSON Basic Path Expression Syntax</h4>
<div>
<p>The basic syntax of an Oracle JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item. Examples are provided.</p>
<div class="section">
<p>However, this basic syntax is extended by relaxing the matching of arrays and non-arrays against non-array and array patterns, respectively: see <span class="q">&#34;<a href="json.htm#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic Oracle JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">Oracle JSON Path Expression Syntax Relaxation</a>&#34;</span>.</p>
<ul style="list-style-type: disc;">
<li>
<p>An Oracle JSON path expression begins with a dollar sign (<code>$</code>), which represents the path-expression <strong class="term">context item</strong>, that is, the JSON data to be matched. That data is the result of evaluating a SQL expression that is passed as argument to the Oracle SQL function.</p>
<p>The dollar sign is followed by zero or more <strong class="term">steps</strong>, each of which can be an object step or an array step, depending on whether the context item represents a JSON object or a JSON array.</p>
</li>
<li>
<p>An <strong class="term">object step</strong> is a period (<span class="bold"><code>.</code></span>), sometimes read as &#34;dot&#34;, followed by an object key (object property name) or an asterisk (<span class="bold"><code>*</code></span>) wildcard, which stands for (the values of) <span class="italic">all</span> keys. A key must start with an uppercase or lowercase letter A to Z and contain only such letters or decimal digits (0-9), or else it must be enclosed in double quotation marks (<span class="bold"><code>&#34;</code></span>). An object step returns the <span class="italic">value</span> of the key that is specified. If a wildcard is used for the key then the step returns the <span class="italic">values</span> of all keys, in no special order.</p>
</li>
<li>
<p>An <strong class="term">array step</strong> is a left bracket (<span class="bold"><code>[</code></span>) followed by <span class="italic">either</span> an asterisk (<span class="bold"><code>*</code></span>) wildcard, which stands for <span class="italic">all</span> array elements, <span class="italic">or</span> one or more specific array indexes or range specifications separated by commas, followed by a right bracket (<span class="bold"><code>]</code></span>). In a path expression, array indexing is zero-based (0, 1, 2,...), as in the JavaScript convention for arrays. A range specification has the form <span class="italic"><code>N</code></span> to <span class="italic"><code>M</code></span>, where <span class="italic"><code>N</code></span> and <span class="italic"><code>M</code></span> are array indexes and <span class="italic"><code>N</code></span> is strictly less than <span class="italic"><code>M</code></span>. (An error is raised at query compilation time if <span class="italic"><code>N</code></span> is not less than <span class="italic"><code>M</code></span>.) An error is raised if you use both an asterisk and either an array index or range specification.</p>
<p>When indexes or range specifications are used, the array elements they collectively specify must be specified in ascending order, without repetitions, or else a compile-time error is raised. For example, an error is raised for each of <code>[3, 1 to 4]</code>, <code>[4, 2]</code>, <code>[2, 3 to 3]</code>, and <code>[2, 3, 3]</code>, the first two because the order is not ascending and the last two because of the repeated element <code>3</code>.</p>
<p>Similarly, the elements in the array value that results from matching are in ascending order, with no repetitions. If an asterisk is used in the path expression then all of the array elements are returned, in array order.</p>
</li>
</ul>
<p>Here are some examples of path expressions, with their meanings spelled out in detail.</p>
<ul style="list-style-type: disc;">
<li>
<p><code>$</code> &ndash; The context item.</p>
</li>
<li>
<p><code>$.friends</code> &ndash; The value of key <code>friends</code> of the context-item object. The dotted notation indicates that the context item is a JSON object.</p>
</li>
<li>
<p><code>$.friends[0]</code> &ndash; The object that is the first element of the array that is the value of key <code>friends</code> of the context-item object. The bracket notation indicates that the value of key <code>friends</code> is an array.</p>
</li>
<li>
<p><code>$.friends[0].name</code> &ndash; Value of key <code>name</code> of the object that is the first element of the array that is the value of key <code>friends</code> of the context-item object. The second dot indicates that the first element of array <code>friends</code> is an object (with a <code>name</code> key).</p>
</li>
<li>
<p><code>$.friends[*].name</code> &ndash; Value of key <code>name</code> of <span class="italic">each</span> object in the array that is the value of key <code>friends</code> of the context-item object.</p>
</li>
<li>
<p><code>$.*[*].name</code> &ndash; Key <code>name</code> values for each object in an array value of a key of the context-item object.</p>
</li>
<li>
<p><code>$.friends[3, 8 to 10, 12]</code> &ndash; The third, eighth, ninth, tenth, and twelfth elements of array <code>friends</code> (key of the context-item object). The elements must be specified in ascending order, and they are returned in that order: third, eighth, ninth, tenth, twelfth.</p>
</li>
<li>
<p><code>$friends[3].cars</code> &ndash; The value of key <code>cars</code> of the object that is the third element of array <code>friends</code>. The dot indicates that the third element is an object (with a <code>cars</code> key).</p>
</li>
<li>
<p><code>$friends[3].*</code> &ndash; The values of <span class="italic">all</span> of the keys of the object that is the third element of array <code>friends</code>.</p>
</li>
<li>
<p><code>$friends[3].cars[0].year</code> &ndash; The value of key <code>year</code> of the object that is the first element of the array that is the value of key <code>cars</code> of the object that is the third element of the array that is bound to variable <code>friends</code>.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__GUID-F6FF8FF6-3773-4E1A-BDEA-6DAE47639138">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic Oracle JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">Oracle JSON Path Expression Syntax Relaxation</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6373"></a>
<div class="props_rev_3"><a id="GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77"></a>
<h4 id="ADXDB-GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" class="sect4"><span class="enumeration_section">39.4.1.2</span> Oracle JSON Path Expression Syntax Relaxation</h4>
<div>
<p>The basic Oracle JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.</p>
<p><span class="q">&#34;<a href="json.htm#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of an Oracle JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item. Examples are provided.">Oracle JSON Basic Path Expression Syntax</a> &#34;</span> defines the basic Oracle JSON path-expression syntax. The actual path expression syntax supported relaxes that definition as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>If a path-expression step targets (expects) an array but the actual data presents no array then the data is implicitly wrapped in an array.</p>
</li>
<li>
<p>If a path-expression step targets (expects) a non-array but the actual data presents an array then the array is implicitly unwrapped.</p>
</li>
</ul>
<p>This relaxation allows for the following abbreviation: <span class="bold"><code>[*]</code></span> can be elided whenever it precedes the object accessor, <span class="bold"><code>.</code></span>, followed by an object field name, with no change in effect. The reverse is also true: <span class="bold"><code>[*]</code></span> can always be inserted in front of the object accessor, <span class="bold"><code>.</code></span>, with no change in effect.</p>
<p>This means that the object step <code>[*].</code><span class="italic"><code>prop</code></span>, which stands for the value of field <span class="italic"><code>prop</code></span> of each element of a given array of objects, can be abbreviated as <span class="italic"><code>.prop</code></span>, and the object step <span class="italic"><code>.prop</code></span>, which looks as though it stands for the <span class="italic"><code>prop</code></span> value of a single object, stands also for the <span class="italic"><code>prop</code></span> value of each element of an array to which the object accessor is applied.</p>
<p>This is an important feature, because it means that you need not change a path expression in your code if your data evolves to replace a given JSON value with an array of such values, or vice versa.</p>
<p>For example, if your data originally contains objects that have field <code>Phone</code> whose value is a single object with fields <code>type</code> and <code>number</code>, the path expression <code>$.Phone.number</code>, which matches a single phone number, can still be used if the data evolves to represent an array of phones. Path expression <code>$.Phone.number</code> matches either a single phone object, selecting its number, or an array of phone objects, selecting the number of each.</p>
<p>Similarly, if your data mixes both kinds of representation&thinsp;&mdash;&thinsp;there are some data entries that use a single phone object and some that use an array of phone objects, or even some entries that use both&thinsp;&mdash;&thinsp;you can use the same path expression to access the phone information from these different kinds of entry.</p>
<p>Here are some example path expressions from section <span class="q">&#34;<a href="json.htm#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of an Oracle JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item. Examples are provided.">Oracle JSON Basic Path Expression Syntax</a> &#34;</span>, together with an explanation of equivalences.</p>
<ul style="list-style-type: disc;">
<li>
<p><code>$.friends</code> &ndash; The value of field <code>friends</code> of <span class="italic">either</span>:</p>
<ul style="list-style-type: disc;">
<li>
<p>The (single) context-item object.</p>
</li>
<li>
<p>(equivalent to <code>$[*].friends</code>) Each object in the context-item array.</p>
</li>
</ul>
</li>
<li>
<p><code>$.friends[0].name</code> &ndash; Value of field <code>name</code> for <span class="italic">any</span> of these objects:</p>
<ul style="list-style-type: disc;">
<li>
<p>The first element of the array that is the value of field <code>friends</code> of the context-item object.</p>
</li>
<li>
<p>(equivalent to <code>$.friends.name</code>) The value of field <code>friends</code> of the context-item object.</p>
</li>
<li>
<p>(equivalent to <code>$[*].friends.name</code>) The value of field <code>friends</code> of each object in the context-item array.</p>
</li>
<li>
<p>(equivalent to <code>$[*].friends[0].name</code>) The first element of each array that is the value of field <code>friends</code> of each object in the context-item array.</p>
</li>
</ul>
<p>The context item can be an object or an array of objects. In the latter case, each object in the array is matched for a field <code>friends</code>.</p>
<p>The value of field <code>friends</code> can be an object or an array of objects. In the latter case, the first object in the array is used.</p>
</li>
<li>
<p><code>$.*[*].name</code> &ndash; Value of field <code>name</code> for <span class="italic">any</span> of these objects:</p>
<ul style="list-style-type: disc;">
<li>
<p>An element of an array value of a field of the context-item object.</p>
</li>
<li>
<p>(equivalent to <code>$.*.name</code>) The value of a field of the context-item object.</p>
</li>
<li>
<p>(equivalent to <code>$[*].*.name</code>) The value of a field of an object in the context-item array.</p>
</li>
<li>
<p>(equivalent to <code>$[*].*[*].name</code>) Each object in an array value of a field of an object in the context-item array.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77__GUID-C345CCD6-3AF3-45FA-B88A-D6A735211059">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of an Oracle JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item. Examples are provided.">Oracle JSON Basic Path Expression Syntax</a> &#34;</span></p>
</div>
</div>
</div>
</div>
</div>
<a id="ADXDB6256"></a>
<div class="props_rev_3"><a id="GUID-9E6455EC-FE3B-428C-B958-1D535726EA26"></a>
<h2 id="ADXDB-GUID-9E6455EC-FE3B-428C-B958-1D535726EA26" class="sect2"><span class="enumeration_section">39.5</span> Oracle SQL Functions and Conditions for Use with JSON Data</h2>
<div>
<p>Oracle provides SQL functions and conditions you can use to create, query, and operate on JSON data stored in Oracle Database. Some of these take as argument an Oracle JSON path expression as a literal SQL string, followed possibly by a <code>RETURNING</code> clause, a wrapper clause, or an error clause.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="json.htm#GUID-8F897ED9-791B-4F53-AFAE-690DE38111D1" title="Oracle SQL conditions is json and is not json are complementary. They test whether their argument is syntactically correct, that is, well-formed, as JSON data. You can use them in a CASE expression or the WHERE clause of a SELECT statement.">Oracle SQL Conditions IS JSON and IS NOT JSON</a> &ndash; test whether some data is well-formed JSON data. Used especially as a check constraint.</p>
</li>
<li>
<p><a href="json.htm#GUID-D60A7E52-8819-4D33-AEDB-223AB7BDE60A" title="Oracle SQL condition json_exists lets you use an Oracle JSON path expression as a row filter, to select rows based on the content of JSON documents. You can use condition json_exists in a CASE expression or the WHERE clause of a SELECT statement.">Oracle SQL Condition JSON_EXISTS</a> &ndash; test for the existence of a particular value within some JSON data.</p>
</li>
<li>
<p><a href="json.htm#GUID-0565F0EE-5F13-44DD-8321-2AC142959215" title="Oracle SQL function json_value selects a scalar value from JSON data and returns it as a SQL value.">Oracle SQL Function JSON_VALUE</a> &ndash; select a scalar value from some JSON data, as a SQL value.</p>
</li>
<li>
<p><a href="json.htm#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB" title="Oracle SQL function json_query selects one or more values from JSON data and returns a string (VARCHAR2) that represents the JSON values. (Unlike function json_value, the return data type cannot be NUMBER). You can thus use json_query to retrieve fragments of a JSON document.">Oracle SQL Function JSON_QUERY</a> &ndash; select one or more values from some JSON data, as a SQL string representing the JSON values. Used especially to retrieve fragments of a JSON document, typically a JSON object or array.</p>
</li>
<li>
<p><a href="json.htm#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="Oracle SQL function json_table projects JSON data into a relational format. You use json_table to decompose the result of JSON expression evaluation into the relational rows and columns of a new, virtual table, which you can also think of as an inline relational view.">Oracle SQL Function JSON_TABLE</a> &ndash; project some JSON data to a relational format as a virtual table, which you can also think of as an inline relational view.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-9E6455EC-FE3B-428C-B958-1D535726EA26__GUID-12662C1D-FB2D-4A50-93CE-F214AC58397F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" title="Oracle Database provides SQL access to JSON data using Oracle JSON path expressions.">Oracle JSON Path Expressions</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-941C5E44-75C7-4BF1-BB0A-18AD48EDE9EB" title="Clauses RETURNING, wrapper, and error handling are described. Each is used in one or more of the Oracle SQL functions and conditions json_value, json_query, json_table, is json, is not json, and json_exists.">Clauses Used in Oracle SQL Functions and Conditions for JSON</a>&#34;</span></p>
</li>
<li>
<p><a class="olink SQLRF56667" target="_blank" href="../SQLRF/functions002.htm#SQLRF56667"><span class="italic">Oracle Database SQL Language Reference</span></a> for complete information about the syntax and semantics of the Oracle SQL functions that create, query, and operate on JSON data.</p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576" title="A simple dot-notation syntax is provided for queries, as an alternative to using the more verbose but more flexible Oracle SQL functions json_query and json_value. The dot notation is designed to return JSON values whenever possible.">Simple Dot-Notation Access to JSON Data</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8" title="You can use Oracle SQL condition json_textcontains in a CASE expression or the WHERE clause of a SELECT statement to perform a full-text search of JSON data that is stored in a VARCHAR2, BLOB, or CLOB column.">Full-Text Search of JSON Data</a>&#34;</span> for information about full-text searching JSON data using Oracle SQL condition <code>json_textcontains</code></p>
</li>
<li>
<p><a class="olink SQLRF56963" target="_blank" href="../SQLRF/conditions010.htm#SQLRF56963"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about Oracle SQL condition <code>json_textcontains</code></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6374"></a>
<div class="props_rev_3"><a id="GUID-941C5E44-75C7-4BF1-BB0A-18AD48EDE9EB"></a>
<h3 id="ADXDB-GUID-941C5E44-75C7-4BF1-BB0A-18AD48EDE9EB" class="sect3"><span class="enumeration_section">39.5.1</span> Clauses Used in Oracle SQL Functions and Conditions for JSON</h3>
<div>
<p>Clauses <code>RETURNING</code>, wrapper, and error handling are described. Each is used in one or more of the Oracle SQL functions and conditions <code>json_value</code>, <code>json_query</code>, <code>json_table</code>, <code>is json</code>, <code>is not json</code>, and <code>json_exists</code>.</p>
<div class="section"></div>
<!-- class="section" --></div>
<a id="ADXDB6375"></a>
<div class="props_rev_3"><a id="GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2"></a>
<h4 id="ADXDB-GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" class="sect4"><span class="enumeration_section">39.5.1.1</span> RETURNING Clause for Oracle SQL Functions for JSON</h4>
<div>
<p>Oracle SQL functions <code>json_value</code> and <code>json_query</code> accept an optional <span class="bold"><code>RETURNING</code></span> clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no <code>RETURNING</code> clause) are described here.</p>
<div class="section">
<p>For <code>json_value</code>, you can use <code>VARCHAR2</code> or <code>NUMBER</code> in a <code>RETURNING</code> clause. For <code>json_query</code>, you can use only <code>VARCHAR2</code>.</p>
<p>You can optionally specify a length for <code>VARCHAR2</code> (default: <code>4000</code>) and a precision and scale for <code>NUMBER</code>.</p>
<p>The default behavior (no <code>RETURNING</code> clause) is to use <code>VARCHAR2(4000)</code>.</p>
<p>The <code>RETURNING</code> clause also accepts two optional keywords, <code>PRETTY</code> and <code>ASCII</code>. If both are present then <code>PRETTY</code> must come before <code>ASCII</code>. <code>ASCII</code> is allowed only for Oracle SQL functions <code>json_value</code> and <code>json_query</code>. <code>PRETTY</code> is allowed only for <code>json_query</code>.</p>
<p>The effect of keyword <span class="bold"><code>PRETTY</code></span> is to pretty-print the returned data, by inserting newline characters and indenting. The default behavior is not to pretty-print.</p>
<p>The effect of keyword <span class="bold"><code>ASCII</code></span> is to automatically escape all non-ASCII Unicode characters in the returned data, using standard ASCII Unicode escape sequences. The default behavior is not to escape non-ASCII Unicode characters.</p>
<div class="infoboxnotealso" id="GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2__GUID-3F6DAB52-5AFE-409C-91FB-EDCF78888340">
<p class="notep1">Tip:</p>
<p>You can pretty-print the entire context item by using only <code>$</code> as the path expression.</p>
</div>
<div class="infoboxnotealso" id="GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2__GUID-951909CB-055A-4427-8BA7-578C14742C55">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-6636B08A-4344-4932-9FAE-C1995032E428" title="ASCII characters correspond directly to the first 128 Unicode characters. If your application can use an ASCII escape sequence to represent input Unicode characters that might otherwise require character-set conversion, then you will avoid any possible performance penalty or information loss from such conversion.">Escape of Unicode Characters in JSON Data</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6285"></a><a id="ADXDB6376"></a>
<div class="props_rev_3"><a id="GUID-9079CD9C-3783-4857-9F6B-84D746C91317"></a>
<h4 id="ADXDB-GUID-9079CD9C-3783-4857-9F6B-84D746C91317" class="sect4"><span class="enumeration_section">39.5.1.2</span> Wrapper Clause for Oracle SQL Functions JSON_QUERY and JSON_TABLE</h4>
<div>
<p>Oracle SQL functions <code>json_query</code> and <code>json_table</code> accept an optional wrapper clause, which specifies the form of the value returned by <code>json_query</code> or used for the data in a <code>json_table</code> relational column. This clause and the default behavior (no wrapper clause) are described here. Examples are provided.</p>
<div class="section">
<p>The wrapper clause takes one of these forms:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold"><code>WITH WRAPPER</code></span> &ndash; Use a string value that represents a JSON array containing <span class="italic">all</span> of the JSON values that match the path expression. The order of the array elements is unspecified.</p>
</li>
<li>
<p><span class="bold"><code>WITHOUT WRAPPER</code></span> &ndash; Use a string value that represents the <span class="italic">single</span> JSON <span class="italic">object</span> or <span class="italic">array</span> that matches the path expression. Raise an error if the path expression matches either a scalar value (not an object or array) or more than one value.</p>
</li>
<li>
<p><span class="bold"><code>WITH CONDITIONAL WRAPPER</code></span> &ndash; Use a string value that represents <span class="italic">all</span> of the JSON values that match the path expression. For zero values, a single scalar value, or multiple values, <code>WITH CONDITIONAL WRAPPER</code> is the same as <code>WITH WRAPPER</code>. For a single JSON object or array value, it is the same as <code>WITHOUT WRAPPER</code>.</p>
</li>
</ul>
<p>The default behavior is <code>WITHOUT WRAPPER</code>.</p>
<p>You can add the optional keyword <span class="bold"><code>UNCONDITIONAL</code></span> immediately after keyword <code>WITH</code>, if you find it clearer: <code>WITH WRAPPER</code> and <code>WITH UNCONDITIONAL WRAPPER</code> mean the same thing.</p>
<p>You can add the optional keyword <span class="bold"><code>ARRAY</code></span> immediately before keyword <code>WRAPPER</code>, if you find it clearer: <code>WRAPPER</code> and <code>ARRAY WRAPPER</code> mean the same thing.</p>
<p><a href="json.htm#GUID-9079CD9C-3783-4857-9F6B-84D746C91317__CACFFGGH" title="JSON_QUERY Wrapper Clause Examples">Table 39-1</a> illustrates the wrapper clause possibilities. The array wrapper is shown in bold.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-9079CD9C-3783-4857-9F6B-84D746C91317__CACFFGGH">
<p class="titleintable">Table 39-1 JSON_QUERY Wrapper Clause Examples</p>
<table class="cellalignment3420" title="JSON_QUERY Wrapper Clause Examples" summary="JSON_QUERY Wrapper Clause Examples">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3474" id="d173580e2728">JSON Values Matching Path Expression</th>
<th class="cellalignment3474" id="d173580e2731">WITH WRAPPER</th>
<th class="cellalignment3432" id="d173580e2734">WITHOUT WRAPPER</th>
<th class="cellalignment3492" id="d173580e2737">WITH CONDITIONAL WRAPPER</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d173580e2742" headers="d173580e2728">
<p><code>{&#34;id&#34;: 38327}</code> (single object)</p>
</td>
<td class="cellalignment3477" headers="d173580e2742 d173580e2731">
<p><span class="bold"><code>[</code></span><code>{&#34;id&#34;: 38327}</code><span class="bold"><code>]</code></span></p>
</td>
<td class="cellalignment3434" headers="d173580e2742 d173580e2734">
<p><code>{&#34;id&#34;: 38327}</code></p>
</td>
<td class="cellalignment3493" headers="d173580e2742 d173580e2737">
<p><code>{&#34;id&#34;: 38327}</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d173580e2766" headers="d173580e2728">
<p><code>[42, &#34;a&#34;, true]</code> (single array)</p>
</td>
<td class="cellalignment3477" headers="d173580e2766 d173580e2731">
<p><span class="bold"><code>[</code></span><code>[42, &#34;a&#34;, true]</code><span class="bold"><code>]</code></span></p>
</td>
<td class="cellalignment3434" headers="d173580e2766 d173580e2734">
<p><code>[42, &#34;a&#34;, true]</code></p>
</td>
<td class="cellalignment3493" headers="d173580e2766 d173580e2737">
<p><code>[42, &#34;a&#34;, true]</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d173580e2790" headers="d173580e2728">
<p><code>42</code></p>
</td>
<td class="cellalignment3477" headers="d173580e2790 d173580e2731">
<p><span class="bold"><code>[</code></span><code>42</code><span class="bold"><code>]</code></span></p>
</td>
<td class="cellalignment3434" headers="d173580e2790 d173580e2734">
<p>Error (scalar)</p>
</td>
<td class="cellalignment3493" headers="d173580e2790 d173580e2737">
<p><span class="bold"><code>[</code></span><code>42</code><span class="bold"><code>]</code></span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d173580e2818" headers="d173580e2728">
<p><code>42</code>, <code>&#34;a&#34;</code>, <code>true</code></p>
</td>
<td class="cellalignment3477" headers="d173580e2818 d173580e2731">
<p><span class="bold"><code>[</code></span><code>42, &#34;a&#34;, true</code><span class="bold"><code>]</code></span></p>
</td>
<td class="cellalignment3434" headers="d173580e2818 d173580e2734">
<p>Error (multiple values)</p>
</td>
<td class="cellalignment3493" headers="d173580e2818 d173580e2737">
<p><span class="bold"><code>[</code></span><code>42, &#34;a&#34;, true</code><span class="bold"><code>]</code></span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d173580e2852" headers="d173580e2728">
<p>none</p>
</td>
<td class="cellalignment3477" headers="d173580e2852 d173580e2731">
<p><span class="bold"><code>[]</code></span></p>
</td>
<td class="cellalignment3434" headers="d173580e2852 d173580e2734">
<p>Error (no values)</p>
</td>
<td class="cellalignment3493" headers="d173580e2852 d173580e2737">
<p><span class="bold"><code>[]</code></span></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p>Consider, for example, a <code>json_query</code> query to retrieve a JSON object. What happens if the path expression matches a JSON scalar value instead of an object, or it matches multiple JSON values (of any kind)? You might want to retrieve the matched values instead of raising an error. For example, you might want to pick one of the values that is an object, for further processing. Using an array wrapper lets you do this.</p>
<p>A conditional wrapper can be convenient if the only reason you are using a wrapper is to avoid raising an error and you do not need to distinguish those error cases from non-error cases. If your application is looking for a single object or array and the data matched by a path expression is just that, then there is no need to wrap that expected value in a singleton array.</p>
<p>On the other hand, with an unconditional wrapper you know that the resulting array is always a wrapper&thinsp;&mdash;&thinsp;your application can count on that. If you use a conditional wrapper then your application might need extra processing to interpret a returned array. In <a href="json.htm#GUID-9079CD9C-3783-4857-9F6B-84D746C91317__CACFFGGH" title="JSON_QUERY Wrapper Clause Examples">Table 39-1</a>, for instance, note that the same array (<code>[42, &#34;a&#34;, true]</code>) is returned for the very different cases of a path expression matching that array and a path expression matching each of its elements.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6377"></a>
<div class="props_rev_3"><a id="GUID-55344240-B1F0-490A-89BF-1526FA0546D4"></a>
<h4 id="ADXDB-GUID-55344240-B1F0-490A-89BF-1526FA0546D4" class="sect4"><span class="enumeration_section">39.5.1.3</span> Error Clause for Oracle SQL Functions and Conditions for JSON</h4>
<div>
<p>Some Oracle SQL functions and conditions for JSON accept an optional error clause, which specifies handling for an error that is raised by the Oracle SQL function or condition. This clause and the default behavior (no error clause) are described here.</p>
<div class="section">
<p>The optional error clause specifies handling for an error that is raised by the Oracle SQL function or condition.</p>
<p>The clause takes one of these forms:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold"><code>ERROR ON ERROR</code></span> &ndash; Raise the error (no special handling).</p>
</li>
<li>
<p><span class="bold"><code>NULL ON ERROR</code></span> &ndash; Return <code>NULL</code> instead of raising the error.</p>
</li>
<li>
<p><span class="bold"><code>TRUE ON ERROR</code></span> &ndash; Return true instead of raising the error. This form of the clause is available only for Oracle SQL condition <code>json_exists</code>.</p>
</li>
<li>
<p><span class="bold"><code>FALSE ON ERROR</code></span> &ndash; Return false instead of raising the error. This form of the clause is available only for Oracle SQL condition <code>json_exists</code>.</p>
</li>
<li>
<p><span class="bold"><code>EMPTY ON ERROR</code></span> &ndash; Return an empty array (<code>[]</code>) instead of raising the error. This form of the clause is available only for Oracle SQL function <code>json_query</code>.</p>
</li>
<li>
<p><span class="bold"><code>DEFAULT &#39;</code></span><span class="italic"><code>literal_return_value</code></span><span class="bold"><code>&#39; ON ERROR</code></span> &ndash; Return the specified value instead of raising the error. The value must be a constant at query compile time.</p>
<p>This form of the clause is <span class="italic">not</span> available for <code>json_query</code>.</p>
</li>
</ul>
<p>The <span class="italic">default</span> behavior is <code>NULL ON ERROR</code>.</p>
<div class="infobox-note" id="GUID-55344240-B1F0-490A-89BF-1526FA0546D4__GUID-F142C4B2-1D3E-4570-BAFF-E55CD0658B84">
<p class="notep1">Note:</p>
<p>The <code>ON ERROR</code> clause takes effect only for runtime errors that arise when a syntactically correct Oracle JSON path expression is matched against JSON data. A path expression that is syntactically incorrect results in a compile-time syntax error; it is not handled by the <code>ON ERROR</code> clause.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB6257"></a>
<div class="props_rev_3"><a id="GUID-8F897ED9-791B-4F53-AFAE-690DE38111D1"></a>
<h3 id="ADXDB-GUID-8F897ED9-791B-4F53-AFAE-690DE38111D1" class="sect3"><span class="enumeration_section">39.5.2</span> Oracle SQL Conditions IS JSON and IS NOT JSON</h3>
<div>
<p>Oracle SQL conditions <code>is json</code> and <code>is not json</code> are complementary. They test whether their argument is syntactically correct, that is, <span class="italic">well-formed</span>, as JSON data. You can use them in a <code>CASE</code> expression or the <code>WHERE</code> clause of a <code>SELECT</code> statement.</p>
<p>If the argument is syntactically correct then <code>is json</code> returns true and <code>is not json</code> returns false. If the argument cannot be evaluated for some reason (for example, if an error occurs during parsing) then the data is simply considered to not be well-formed: <code>is json</code> returns false; <code>is not json</code> returns true. <strong class="term">Well-formedness</strong> implies that the data is syntactically correct. (JSON data can be well formed in two senses, which we refer to as strict and lax syntax.)</p>
<div class="infoboxnotealso" id="GUID-8F897ED9-791B-4F53-AFAE-690DE38111D1__GUID-ABD196C8-A594-4B96-B340-4FA6410BB81F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF56661" target="_blank" href="../SQLRF/conditions010.htm#SQLRF56661"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>is json</code> and <code>is not json</code>.</p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20" title="The Oracle default syntax for JSON is lax. In particular: it reflects the JavaScript syntax for object fields; the Boolean and null values are not case-sensitive; and it is more permissive with respect to numerals, whitespace, and escaping of Unicode characters.">About Strict and Lax JSON Syntax</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6324"></a><a id="ADXDB6378"></a><a id="ADXDB6333"></a>
<div class="props_rev_3"><a id="GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0"></a>
<h4 id="ADXDB-GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0" class="sect4"><span class="enumeration_section">39.5.2.1</span> Using a Check Constraint To Ensure that a Column Contains JSON Data</h4>
<div>
<p>A typical use of SQL condition <code>is json</code> is as a check constraint, to ensure that the data in a JSON column is (well-formed) JSON data. Oracle recommends that you <span class="italic">always</span> use an <code>is_json</code> check constraint when you create a column intended for JSON data.</p>
<div class="section">
<p><a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACHFFCE">Example 39-3</a> and <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">Example 39-4</a> illustrate this. They create and fill a table that holds data used in examples elsewhere.</p>
<p>For brevity, only one row of data (one JSON document) is inserted in <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">Example 39-4</a>. See <span class="q">&#34;<a href="json.htm#GUID-52EFC452-5E65-4148-8070-1FA588A6E697" title="You can create a database table of JSON data from the content of a JSON dump file.">Loading External JSON Data</a>&#34;</span> for examples that insert a full set of data.</p>
<div class="infobox-note" id="GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__GUID-9650753C-5AAB-4527-B3C4-E5084FFBA0E7">
<p class="notep1">Note:</p>
<p>Oracle SQL conditions <code>IS JSON</code> and <code>IS NOT JSON</code> return true or false for any non-<code>NULL</code> SQL value. But they both return unknown (neither true nor false) for SQL <code>NULL</code>. When used in a check constraint, they do not prevent a <code>NULL</code> value from being inserted. But when used in a SQL <code>WHERE</code> clause, <code>NULL</code> is never selected (returned).</p>
</div>
<p>It is true that a check constraint can reduce performance for data insertion. If you are sure that your application inserts only well-formed JSON data into a particular column, then consider <span class="italic">disabling</span> the check constraint, but <span class="italic">do not drop</span> the constraint.</p>
<div class="infoboxnotealso" id="GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__GUID-91A9DD8E-31CE-4D77-8BAF-7602DB529340">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-74BBD890-EE42-425E-AF09-FEFC5F9093AF" title="How can you tell whether a given column has a check constraint that ensures that its data is well-formed JSON data? Whenever this is the case, the column is listed in the following static data dictionary views: DBA_JSON_COLUMNS, USER_JSON_COLUMNS, and ALL_JSON_COLUMNS.">Determining Whether a Column Necessarily Contains JSON Data</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-52EFC452-5E65-4148-8070-1FA588A6E697" title="You can create a database table of JSON data from the content of a JSON dump file.">Loading External JSON Data</a>&#34;</span> for the creation of the full table <code>j_purchaseorder</code></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACHFFCE">
<p class="titleinexample">Example 39-3 Using IS JSON in a Check Constraint to Ensure JSON Data is Well-Formed</p>
<pre dir="ltr">CREATE TABLE j_purchaseorder
   (id          RAW (16) NOT NULL,
    date_loaded TIMESTAMP (6) WITH TIME ZONE,
    po_document CLOB
    <span class="bold">CONSTRAINT</span> ensure_json <span class="bold">CHECK</span> (po_document <span class="bold">IS JSON</span>));
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">
<p class="titleinexample">Example 39-4 Inserting Data into a Relational Table with a JSON Column</p>
<pre dir="ltr">INSERT INTO j_purchaseorder
  VALUES (
    SYS_GUID(),
    SYSTIMESTAMP,
    &#39;{&#34;PONumber&#34;             : 1600,
      &#34;Reference&#34;            : &#34;ABULL-20140421&#34;,
      &#34;Requestor&#34;            : &#34;Alexis Bull&#34;,
      &#34;User&#34;                 : &#34;ABULL&#34;,
      &#34;CostCenter&#34;           : &#34;A50&#34;,
      &#34;ShippingInstructions&#34; : {&#34;name&#34;   : &#34;Alexis Bull&#34;,
                                &#34;Address&#34;: {&#34;street&#34;  : &#34;200 Sporting Green&#34;,
                                            &#34;city&#34;    : &#34;South San Francisco&#34;,
                                            &#34;state&#34;   : &#34;CA&#34;,
                                            &#34;zipCode&#34; : 99236,
                                            &#34;country&#34; : &#34;United States of America&#34;},
                                &#34;Phone&#34; : [{&#34;type&#34; : &#34;Office&#34;, &#34;number&#34; : &#34;909-555-7307&#34;},
                                           {&#34;type&#34; : &#34;Mobile&#34;, &#34;number&#34; : &#34;415-555-1234&#34;}]},
      &#34;Special Instructions&#34; : null,
      &#34;AllowPartialShipment&#34; : true,
      &#34;LineItems&#34;            : [{&#34;ItemNumber&#34; : 1,
                                 &#34;Part&#34;       : {&#34;Description&#34; : &#34;One Magic Christmas&#34;,
                                                 &#34;UnitPrice&#34;   : 19.95,
                                                 &#34;UPCCode&#34;     : 13131092899},
                                 &#34;Quantity&#34;   : 9.0},
                                {&#34;ItemNumber&#34; : 2,
                                 &#34;Part&#34;       : {&#34;Description&#34; : &#34;Lethal Weapon&#34;,
                                                 &#34;UnitPrice&#34;   : 19.95,
                                                 &#34;UPCCode&#34;     : 85391628927},
                                 &#34;Quantity&#34;   : 5.0}]}&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6334"></a>
<div class="props_rev_3"><a id="GUID-74BBD890-EE42-425E-AF09-FEFC5F9093AF"></a>
<h4 id="ADXDB-GUID-74BBD890-EE42-425E-AF09-FEFC5F9093AF" class="sect4"><span class="enumeration_section">39.5.2.2</span> Determining Whether a Column Necessarily Contains JSON Data</h4>
<div>
<p>How can you tell whether a given column has a check constraint that ensures that its data is well-formed JSON data? Whenever this is the case, the column is listed in the following static data dictionary views: <span class="bold"><code>DBA_JSON_COLUMNS</code></span>, <span class="bold"><code>USER_JSON_COLUMNS</code></span>, and <span class="bold"><code>ALL_JSON_COLUMNS</code></span>.</p>
<div class="section">
<p>Each view lists the names of the owner, table, and column, as well as the data type of the column. You can query this data to find JSON columns.<a id="fn_5" href="#fn_5" onclick="footdisplay(5,&#34;If the check constraint combines condition is json with another condition using logical condition OR, then the column is not listed in these views. In this case, it is not certain that data in the column is JSON data. For example, the constraint jcol is json OR length(jcol) &lt; 1000 does not ensure that the data in column jcol is JSON data. &#34;)"><sup>Foot&nbsp;5</sup></a></p>
<p>Note that even if the check constraint that ensures that the data is JSON is <span class="italic">deactivated</span>, the column remains listed in the views. If the check constraint is <span class="italic">dropped</span> then the column is removed from the views.</p>
<div class="infoboxnotealso" id="GUID-74BBD890-EE42-425E-AF09-FEFC5F9093AF__GUID-ECE22FDF-5025-4221-ABA6-0CAAA8C58D4D">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0" title="A typical use of SQL condition is json is as a check constraint, to ensure that the data in a JSON column is (well-formed) JSON data. Oracle recommends that you always use an is_json check constraint when you create a column intended for JSON data.">Using a Check Constraint To Ensure that a Column Contains JSON Data</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6331"></a>
<div class="props_rev_3"><a id="GUID-305EFFC0-B7AA-4752-90A0-3DA895A93FAE"></a>
<h4 id="ADXDB-GUID-305EFFC0-B7AA-4752-90A0-3DA895A93FAE" class="sect4"><span class="enumeration_section">39.5.2.3</span> Unique Versus Duplicate Fields in JSON Objects</h4>
<div>
<p>By default, object fields (object properties) need not be unique for a given JSON object, but you can specify that particular JSON data is to be considered well-formed only if none of its objects have duplicate field names.</p>
<p>The JSON standard does not specify whether field names must be unique for a given JSON object. This means that, a priori, a well-formed JSON object can have multiple members that have the same field name. This is the default behavior for handling JSON data in Oracle Database.</p>
<p>You can specify that particular JSON data is to be considered well-formed only if all objects it contains have unique field names, that is, no object has duplicate field names. You do this by using the keywords <span class="bold"><code>WITH UNIQUE KEYS</code></span> with Oracle SQL condition <code>is json</code>.<a id="fn_6" href="#fn_6" onclick="footdisplay(6,&#34; An object field is sometimes called an object &ldquo;key&rdquo;.&#34;)"><sup>Foot&nbsp;6</sup></a> If you do not specify <code>UNIQUE KEYS</code>, or if you use the keywords <span class="bold"><code>WITHOUT UNIQUE KEYS</code></span>, then objects can have duplicate field names and still be considered well-formed.</p>
<p>The evaluation that Oracle Database employs always uses only one of the object members that have a given field name; any other members with the same field name are ignored. It is unspecified which of multiple such members is used.</p>
<p>Whether duplicate field names are allowed in well-formed JSON data is orthogonal to whether Oracle uses strict or lax syntax to determine well-formedness.</p>
</div>
</div>
<a id="ADXDB6260"></a><a id="ADXDB6259"></a>
<div class="props_rev_3"><a id="GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20"></a>
<h4 id="ADXDB-GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20" class="sect4"><span class="enumeration_section">39.5.2.4</span> About Strict and Lax JSON Syntax</h4>
<div>
<p>The Oracle default syntax for JSON is lax. In particular: it reflects the JavaScript syntax for object fields; the Boolean and null values are not case-sensitive; and it is more permissive with respect to numerals, whitespace, and escaping of Unicode characters.</p>
<p>Standard ECMA-404, the <span class="italic">JSON Data Interchange Format</span>, and ECMA-262, the <span class="italic">ECMAScript Language Specification</span>, define JSON syntax.</p>
<p>According to these specifications, each JSON field and each string value must be enclosed in double quotation marks (<span class="bold"><code>&#34;</code></span>). Oracle supports this <strong class="term">strict JSON syntax</strong>, but it is <span class="italic">not</span> the default syntax.</p>
<p>In JavaScript notation, a field used in an object literal can be, but need not be, enclosed in double quotation marks. It can also be enclosed in single quotation marks (<span class="bold"><code>&#39;</code></span>). Oracle also supports this <strong class="term">lax JSON syntax</strong>, and it is the <span class="italic">default</span> syntax.</p>
<p>In addition, in practice, some JavaScript implementations (but not the JavaScript standard) allow one or more of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Case variations for keywords <code>true</code>, <code>false</code>, and <code>null</code> (for example, <code>TRUE</code>, <code>True</code>, <code>TrUe</code>, <code>fALSe</code>, <code>NulL</code>).</p>
</li>
<li>
<p>An extra comma (<span class="bold"><code>,</code></span>) after the last element of an array or the last member of an object (for example, <code>[a, b, c</code><span class="bold"><code>,</code></span><code>]</code>, <code>{a:b, c:d</code><span class="bold"><code>,</code></span><code>}</code>).</p>
</li>
<li>
<p>Numerals with one or more leading zeros (for example, <code>0042.3</code>).</p>
</li>
<li>
<p>Fractional numerals that lack <code>0</code> before the decimal point (for example, <code>.14</code> instead of <code>0.14</code>).</p>
</li>
<li>
<p>Numerals with no fractional part after the decimal point (for example, <code>342.</code> or <code>1.e27</code>).</p>
</li>
<li>
<p>A plus sign (<code>+</code>) preceding a numeral, meaning that the number is non-negative (for example, <code>+1.3</code>).</p>
</li>
</ul>
<p>This syntax too is allowed as part of the Oracle default (lax) JSON syntax. (See the JSON standard for the strict numeral syntax.)</p>
<p>In addition to the ASCII space character (U+0020), the JSON standard defines the following characters as insignificant (ignored) whitespace when used outside a quoted field or a string value:</p>
<ul style="list-style-type: disc;">
<li>
<p>Tab, horizontal tab (<code>HT</code>, <code>^I</code>, decimal 9, U+0009, <code>\t</code>)</p>
</li>
<li>
<p>Line feed, newline (<code>LF</code>, <code>^J</code>, decimal 10, U+000A, <code>\n</code>)</p>
</li>
<li>
<p>Carriage return (<code>CR</code>, <code>^M</code>, decimal 13, U+000D, <code>\r</code>)</p>
</li>
</ul>
<p>The Oracle JSON lax syntax, however, treats <span class="italic">all</span> of the ASCII control characters (Control+0 through Control+31), as well as the ASCII space character (decimal 32, U+0020), as (insignificant) whitespace characters. The following are among the control characters:</p>
<ul style="list-style-type: disc;">
<li>
<p>Null (<code>NUL</code>, <code>^@</code>, decimal 0, U+0000, <code>\0</code>)</p>
</li>
<li>
<p>Bell (<code>NEL</code>, <code>^G</code>, decimal 7, U+0007, <code>\a</code>)</p>
</li>
<li>
<p>Vertical tab (<code>VT</code>, <code>^K</code>, decimal 11, U+000B)</p>
</li>
<li>
<p>Escape (<code>ESC</code>, <code>^[</code>, decimal 27, U+001B, <code>\e</code>)</p>
</li>
<li>
<p>Delete (<code>DEL</code>, <code>^?</code>, decimal 127, U+007F)</p>
</li>
</ul>
<p>An ASCII space character (U+0020) is the only whitespace character allowed, unescaped, within a quoted field or a string value. This is true for both the lax and strict Oracle JSON syntaxes.</p>
<p>For both strict and lax Oracle JSON syntax, quoted object field and string values can contain any Unicode character, but some of them must be escaped, as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>ASCII control characters are not allowed, except for those represented by the following escape sequences: <span class="bold"><code>\b</code></span> (backspace), <span class="bold"><code>\f</code></span> (form feed), <span class="bold"><code>\n</code></span> (newline, line feed), <span class="bold"><code>\r</code></span> (carriage return), and <span class="bold"><code>\t</code></span> (tab, horizontal tab).</p>
</li>
<li>
<p>Double quotation mark (<span class="bold"><code>&#34;</code></span>), slash (<span class="bold"><code>/</code></span>), and backslash (<span class="bold"><code>\</code></span>) characters must also be escaped (preceded by a backslash): <span class="bold"><code>\&#34;</code></span>, <span class="bold"><code>\/</code></span>, and <span class="bold"><code>\\</code></span>, respectively.</p>
</li>
</ul>
<p>In the lax Oracle syntax, an object field that is <span class="italic">not</span> quoted can contain any Unicode character except whitespace and the JSON structural characters&thinsp;&mdash;&thinsp;left and right brackets (<span class="bold"><code>[</code></span>, <span class="bold"><code>]</code></span>) and curly braces (<span class="bold"><code>{</code></span>, <span class="bold"><code>}</code></span>), colon (<span class="bold"><code>:</code></span>), and comma (<span class="bold"><code>,</code></span>), but escape sequences are not allowed.</p>
<p>Any Unicode character can also be included in a name or string by using the ASCII escape syntax <span class="bold"><code>\u</code></span> followed by the four ASCII hexadecimal digits that represent the Unicode code point.</p>
<p>Note that other Unicode characters that are not printable or that might appear as whitespace, such as a no-break space character (U+00A0), are <span class="italic">not</span> considered whitespace for either the strict or the lax Oracle JSON syntax.</p>
<p><a href="json.htm#GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20__CACBCEIC" title="JSON Syntax Examples">Table 39-2</a> shows some examples of JSON syntax.</p>
<div class="tblformalwide" id="GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20__CACBCEIC">
<p class="titleintable">Table 39-2 JSON Object Field Syntax Examples</p>
<table class="cellalignment3431" title="JSON Object Field Syntax Examples" summary="JSON Syntax Examples">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3492" id="d173580e3789">Example</th>
<th class="cellalignment3494" id="d173580e3792">Well-Formed?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3797" headers="d173580e3789">
<p><code>&#34;part number&#34;: 1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3797 d173580e3792">
<p>Lax and strict: yes. Space characters are allowed.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3805" headers="d173580e3789">
<p><code>part number: 1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3805 d173580e3792">
<p>Lax (and strict): <span class="bold">no</span>. Whitespace characters, including space characters, are not allowed in unquoted names.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3816" headers="d173580e3789">
<p><code>&#34;part\tnumber&#34;: 1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3816 d173580e3792">
<p>Lax and strict: yes. Escape sequence for tab character is allowed.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3824" headers="d173580e3789">
<p><code>&#34;part&nbsp;&nbsp;&nbsp;&nbsp;number&#34;: 1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3824 d173580e3792">
<p>Lax and strict: <span class="bold">no</span>. Unescaped tab character is not allowed. Space is the only unescaped whitespace character allowed.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3835" headers="d173580e3789">
<p><code>&#34;\&#34;part\&#34;number&#34;: 1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3835 d173580e3792">
<p>Lax and strict: yes. Escaped double quotation marks are allowed, if name is quoted.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3843" headers="d173580e3789">
<p><code>\&#34;part\&#34;number: 1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3843 d173580e3792">
<p>Lax and strict: <span class="bold">no</span>. Name must be quoted.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3854" headers="d173580e3789">
<p><code>&#39;\&#34;part\&#34;number&#39;: 1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3854 d173580e3792">
<p>Lax: yes, <span class="bold">strict: no</span>. Single-quoted names (object fields and strings) are allowed for lax syntax only. Escaped double quotation mark is allowed in a quoted name.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3865" headers="d173580e3789">
<p><code>&#34;p&auml;rt number&#34;:1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3865 d173580e3792">
<p>Lax and strict: yes. Any Unicode character is allowed in a quoted name.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3873" headers="d173580e3789">
<p><code>part:number:1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3873 d173580e3792">
<p>Lax (and strict): <span class="bold">no</span>. Structural characters are not allowed in unquoted names.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3493" id="d173580e3884" headers="d173580e3789">
<p><code>&#34;p&auml;rt:number&#34;:1234</code></p>
</td>
<td class="cellalignment3495" headers="d173580e3884 d173580e3792">
<p><span class="bold">Lax: yes</span>, strict: no. Structural and Unicode characters other than whitespace are allowed in a quoted name for lax syntax only.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="infoboxnotealso" id="GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20__GUID-650A0F5C-039E-4160-9E4D-1E818AAA45A3">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="http://tools.ietf.org/html/rfc4627" target="_blank"><code>http://tools.ietf.org/html/rfc4627</code></a> and <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank"><code>http://www.ecma-international.org/publications/standards/Ecma-404.htm</code></a> for the syntax of JSON Data Interchange Format</p>
</li>
<li>
<p><a href="http://www.ecmascript.org" target="_blank"><code>http://www.ecmascript.org</code></a>, http://www.ecma-international.org, and <a href="http://www.json.org" target="_blank"><code>http://www.json.org</code></a> for more information about JSON and JavaScript</p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-FBC22D72-AA64-4B0A-92A2-837B32902E2C" title="JSON (and JavaScript) values, scalars, objects, and arrays are described.">Overview of JSON Syntax and the Data It Represents</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-6636B08A-4344-4932-9FAE-C1995032E428" title="ASCII characters correspond directly to the first 128 Unicode characters. If your application can use an ASCII escape sequence to represent input Unicode characters that might otherwise require character-set conversion, then you will avoid any possible performance penalty or information loss from such conversion.">Escape of Unicode Characters in JSON Data</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB6379"></a><a id="ADXDB6261"></a>
<div class="props_rev_3"><a id="GUID-C0AF532C-1E69-4584-8FBA-BD5EFB778975"></a>
<h4 id="ADXDB-GUID-C0AF532C-1E69-4584-8FBA-BD5EFB778975" class="sect4"><span class="enumeration_section">39.5.2.5</span> Specifying Strict or Lax Oracle JSON Syntax</h4>
<div>
<p>The default Oracle JSON syntax is lax. Strict or lax syntax matters <span class="italic">only</span> for SQL conditions <code>is json</code> and <code>is not json</code>. All other Oracle SQL functions and conditions use lax syntax for interpreting input and strict syntax when returning output.</p>
<div class="section">
<p>If you need to be sure that particular JSON input data has strictly correct syntax, then check it first using <code>is json</code> or <code>is not json</code>.</p>
<p>You specify that data is to be checked as strictly well-formed according to the JSON standard by appending <span class="bold"><code>(STRICT)</code></span> (parentheses included) to an <code>is json</code> or an <code>is not json</code> expression.</p>
<p><a href="json.htm#GUID-C0AF532C-1E69-4584-8FBA-BD5EFB778975__CACDEAAD">Example 39-5</a> illustrates this. It is identical to <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACHFFCE">Example 39-3</a> except that it uses <code>(STRICT)</code> to ensure that all data inserted into the column is well-formed according to the JSON standard.</p>
<div class="infoboxnotealso" id="GUID-C0AF532C-1E69-4584-8FBA-BD5EFB778975__GUID-1297CFDE-3245-4C68-B8D3-42FB1F97E622">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20" title="The Oracle default syntax for JSON is lax. In particular: it reflects the JavaScript syntax for object fields; the Boolean and null values are not case-sensitive; and it is more permissive with respect to numerals, whitespace, and escaping of Unicode characters.">About Strict and Lax JSON Syntax</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-C0AF532C-1E69-4584-8FBA-BD5EFB778975__CACDEAAD">
<p class="titleinexample">Example 39-5 Using IS JSON in a Check Constraint to Ensure JSON Data is Strictly Well-Formed (Standard)</p>
<pre dir="ltr">CREATE TABLE j_purchaseorder
   (id          RAW (16) NOT NULL,
    date_loaded TIMESTAMP WITH TIME ZONE,
    po_document CLOB
    CONSTRAINT ensure_json CHECK (po_document IS JSON (<span class="bold">STRICT</span>)));
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB6262"></a>
<div class="props_rev_3"><a id="GUID-D60A7E52-8819-4D33-AEDB-223AB7BDE60A"></a>
<h3 id="ADXDB-GUID-D60A7E52-8819-4D33-AEDB-223AB7BDE60A" class="sect3"><span class="enumeration_section">39.5.3</span> Oracle SQL Condition JSON_EXISTS</h3>
<div>
<p>Oracle SQL condition <code>json_exists</code> lets you use an Oracle JSON path expression as a row filter, to select rows based on the content of JSON documents. You can use condition <code>json_exists</code> in a <code>CASE</code> expression or the <code>WHERE</code> clause of a <code>SELECT</code> statement.</p>
<p>Condition <code>json_exists</code> checks for the existence of a particular value within JSON data: it returns true if the value is present and false if it is absent. More precisely, <code>json_exists</code> returns true if the data it targets matches one or more JSON values. If no JSON values are matched then it returns false.</p>
<p>You can also use <code>json_exists</code> to create bitmap indexes for use with JSON data&thinsp;&mdash;&thinsp;see <a href="json.htm#GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACCCEBD">Example 39-20</a>.</p>
<p>Error handlers <code>ERROR ON ERROR</code>, <code>FALSE ON ERROR</code>, and <code>TRUE ON ERROR</code> apply. The default is <code>FALSE ON ERROR</code>. The handler takes effect when any error occurs, but typically an error occurs when the given JSON data is not well-formed (using lax syntax). Unlike the case for conditions <code>is json</code> and <code>is not json</code>, condition <code>json_exists</code> <span class="italic">expects</span> the data it examines to be well-formed JSON data.</p>
<p>The second argument to <code>json_exists</code> is an Oracle JSON path expression followed by an optional <code>RETURNING</code> clause and an optional error clause. The path expression must target a single scalar value, or else a compile-time error is raised.</p>
<div class="infobox-note" id="GUID-D60A7E52-8819-4D33-AEDB-223AB7BDE60A__GUID-88D449FE-C842-4E37-A29A-AF46587378C6">
<p class="notep1">Note:</p>
<p>Oracle SQL condition <code>json_exists</code> applied to JSON value <code>null</code> returns the SQL string <code>&#39;true&#39;</code>.</p>
</div>
<div class="infoboxnotealso" id="GUID-D60A7E52-8819-4D33-AEDB-223AB7BDE60A__GUID-A433F849-0880-4650-B9E3-48196942998A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="Oracle SQL functions json_value and json_query accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="Some Oracle SQL functions and conditions for JSON accept an optional error clause, which specifies handling for an error that is raised by the Oracle SQL function or condition. This clause and the default behavior (no error clause) are described here.">Error Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
<li>
<p><a class="olink SQLRF56668" target="_blank" href="../SQLRF/functions093.htm#SQLRF56668"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>json_value</code></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6381"></a><a id="ADXDB6380"></a>
<div class="props_rev_3"><a id="GUID-E5085C55-ECFB-4463-A6CA-D9D2EDF7BDE3"></a>
<h4 id="ADXDB-GUID-E5085C55-ECFB-4463-A6CA-D9D2EDF7BDE3" class="sect4"><span class="enumeration_section">39.5.3.1</span> JSON_EXISTS as JSON_TABLE</h4>
<div>
<p>Oracle SQL condition <code>json_exists</code> can be viewed as a special case of Oracle SQL function <code>json_table</code>.</p>
<p><a href="json.htm#GUID-E5085C55-ECFB-4463-A6CA-D9D2EDF7BDE3__CACHEBGH">Example 39-6</a> illustrates the equivalence: the two <code>SELECT</code> statements have the same effect.</p>
<p>In addition to perhaps helping you understand <code>json_exists</code> better, this equivalence is important practically, because it means that you can use either to get the same effect.</p>
<p>In particular, if you use <code>json_exists</code> more than once, or you use it in combination with <code>json_value</code> or <code>json_query</code> (which can also be expressed using <code>json_table</code>), to access the same data, then a single invocation of <code>json_table</code> presents the advantage that the data is parsed only once.</p>
<p>Because of this, the optimizer often automatically rewrites multiple invocations of <code>json_exists</code>, <code>json_value</code> and <code>json_query</code> (any combination) to fewer invocations of <code>json_table</code>.</p>
<div class="infoboxnotealso" id="GUID-E5085C55-ECFB-4463-A6CA-D9D2EDF7BDE3__GUID-DDD41873-CAB1-4938-B420-C9BA98E9464C">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" title="Oracle SQL function json_table generalizes SQL condition json_exists and SQL functions json_valueand json_query. Everything that you can do using these functions you can do using json_table. For the jobs that they do, the syntax of these functions is simpler to use than is the syntax of json_table.">JSON_TABLE Generalizes Other Oracle SQL Functions</a>&#34;</span></p>
</div>
<div class="example" id="GUID-E5085C55-ECFB-4463-A6CA-D9D2EDF7BDE3__CACHEBGH">
<p class="titleinexample">Example 39-6 JSON_EXISTS Expressed Using JSON_TABLE</p>
<pre dir="ltr">SELECT <span class="italic">select_list</span>
  FROM <span class="italic">table</span> <span class="bold">WHERE json_exists</span>(<span class="italic">column</span>, <span class="italic">json_path</span> <span class="italic">error_handler</span> ON ERROR);
       
SELECT <span class="italic">select_list</span>
  FROM <span class="italic">table</span>,
       <span class="bold">json_table</span>(<span class="italic">column</span>, <span class="bold">&#39;$&#39;</span> <span class="italic">error_handler</span> ON ERROR
         <span class="bold">COLUMNS</span> (&#34;<span class="italic">COLUMN_ALIAS</span>&#34; <span class="bold">NUMBER EXISTS PATH</span> <span class="italic">json_path</span>)) <span class="bold">AS</span> &#34;<span class="italic">JT</span>&#34;
  <span class="bold">WHERE</span> <span class="italic">jt.column_alias</span> <span class="bold">= 1</span>;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB6263"></a>
<div class="props_rev_3"><a id="GUID-0565F0EE-5F13-44DD-8321-2AC142959215"></a>
<h3 id="ADXDB-GUID-0565F0EE-5F13-44DD-8321-2AC142959215" class="sect3"><span class="enumeration_section">39.5.4</span> Oracle SQL Function JSON_VALUE</h3>
<div>
<p>Oracle SQL function <code>json_value</code> selects a <span class="italic">scalar</span> value from JSON data and returns it as a SQL value.</p>
<p>You can also use <code>json_value</code> to create function-based B-tree indexes for use with JSON data&thinsp;&mdash;&thinsp;see <span class="q">&#34;<a href="json.htm#GUID-BD09DB8A-26F4-43A9-9B39-9E0E20C0D192" title="You can index JSON data as you would any data of the type you use to store it. In addition, you can define a JSON search index, which is useful for both ad hoc structural queries and full-text queries.">Indexes for JSON Data</a>&#34;</span>.</p>
<p>Function <code>json_value</code> has two required arguments and accepts optional returning and error clauses.</p>
<p>The first argument to <code>json_value</code> is a SQL expression that returns an instance of a scalar SQL data type (that is, not an object or collection data type). It can be of data type <code>VARCHAR2</code>, <code>BLOB</code>, <code>or CLOB</code>. It can be a table or view column value, a PL/SQL variable, or a bind variable with proper casting. The result of evaluating the SQL expression is used as the <span class="italic">context item</span> for evaluating the path expression.</p>
<p>The second argument to <code>json_value</code> is an Oracle JSON path expression followed by an optional <code>RETURNING</code> clause and an optional error clause. The path expression must target a single scalar value, or else an error occurs.</p>
<p>Note that the <span class="italic">default</span> error-handling behavior is <code>NULL ON ERROR</code>, which means that no value is returned if an error occurs&thinsp;&mdash;&thinsp;an error is not raised. In particular, if the path expression targets a non-scalar value, such as an array, no error is raised, by default. To ensure that an error is raised, use <code>ERROR ON ERROR</code>.</p>
<div class="infobox-note" id="GUID-0565F0EE-5F13-44DD-8321-2AC142959215__GUID-42EC1D20-D6AC-40FC-935E-11F83178558D">
<p class="notep1">Note:</p>
<p>Each field name in a given JSON object is not necessarily unique; the same field name may be repeated. The streaming evaluation that Oracle Database employs always uses only one of the object members that have a given field name; any other members with the same field name are ignored. It is unspecified which of multiple such members is used.</p>
<p>See also <span class="q">&#34;<a href="json.htm#GUID-305EFFC0-B7AA-4752-90A0-3DA895A93FAE" title="By default, object fields (object properties) need not be unique for a given JSON object, but you can specify that particular JSON data is to be considered well-formed only if none of its objects have duplicate field names.">Unique Versus Duplicate Fields in JSON Objects</a>&#34;</span>.</p>
</div>
<div class="infoboxnotealso" id="GUID-0565F0EE-5F13-44DD-8321-2AC142959215__GUID-F1A8DDCD-EFB9-45C1-968F-0935A3E4D865">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="Oracle SQL functions json_value and json_query accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="Some Oracle SQL functions and conditions for JSON accept an optional error clause, which specifies handling for an error that is raised by the Oracle SQL function or condition. This clause and the default behavior (no error clause) are described here.">Error Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
<li>
<p><a class="olink SQLRF56668" target="_blank" href="../SQLRF/functions093.htm#SQLRF56668"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>json_value</code></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6265"></a><a id="ADXDB6264"></a>
<div class="props_rev_3"><a id="GUID-FD4E6FFA-8865-4682-B66A-79F77CBACD50"></a>
<h4 id="ADXDB-GUID-FD4E6FFA-8865-4682-B66A-79F77CBACD50" class="sect4"><span class="enumeration_section">39.5.4.1</span> Using Oracle SQL Function JSON_VALUE With a Boolean JSON Value</h4>
<div>
<p>JSON has the Boolean values <code>true</code> and <code>false</code>. Oracle SQL has no Boolean data type. When Oracle SQL function <code>json_value</code> evaluates an Oracle JSON path expression and the result is <code>true</code> or <code>false</code>, there are two ways to handle the result in SQL: as a string or as a number.</p>
<div class="section">
<p>By default, the returned data type is a SQL string (<code>VARCHAR2</code>), meaning that the result is the string <code>&#39;true&#39;</code> or <code>&#39;false&#39;</code>. You can alternatively return the result as a SQL number, in which case the JSON value <code>true</code> is returned as the number <code>1</code>, and <code>false</code> is returned as <code>0</code>.</p>
<p><a href="json.htm#GUID-FD4E6FFA-8865-4682-B66A-79F77CBACD50__CACFHCDC">Example 39-7</a> illustrates this. The first query returns the string <code>&#39;true&#39;</code>; the second query returns the number <code>1</code>.</p>
<div class="infobox-note" id="GUID-FD4E6FFA-8865-4682-B66A-79F77CBACD50__GUID-D1F4BF20-0D90-4A65-990E-00D555C26B75">
<p class="notep1">Note:</p>
<p>Although you can return a Boolean value as a number, a JSON search index will not be picked up for such a value. For this reason, Oracle recommends that you use the default return-value data type, <code>VARCHAR2</code>.</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-FD4E6FFA-8865-4682-B66A-79F77CBACD50__CACFHCDC">
<p class="titleinexample">Example 39-7 JSON_VALUE: Two Ways to Return a JSON Boolean Value in SQL</p>
<pre dir="ltr">SELECT json_value(po_document, &#39;$.AllowPartialShipment&#39;)
 FROM j_purchaseorder;

SELECT json_value(po_document, &#39;$.AllowPartialShipment&#39; <span class="bold">RETURNING NUMBER</span>)
  FROM j_purchaseorder;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6286"></a>
<div class="props_rev_3"><a id="GUID-932E0BDE-E78E-4052-A053-A0618276FD7A"></a>
<h4 id="ADXDB-GUID-932E0BDE-E78E-4052-A053-A0618276FD7A" class="sect4"><span class="enumeration_section">39.5.4.2</span> Oracle SQL Function JSON_VALUE Applied to a null JSON Value</h4>
<div>
<p>Oracle SQL function <code>json_value</code> applied to JSON value <code>null</code> returns SQL <code>NULL</code>, not the SQL string <code>&#39;null&#39;</code>. This means, in particular, that you cannot use <code>json_value</code> to distinguish the JSON value <code>null</code> from the absence of a value; SQL <code>NULL</code> indicates both cases.</p>
</div>
</div>
<a id="ADXDB6383"></a><a id="ADXDB6382"></a>
<div class="props_rev_3"><a id="GUID-EE2FCC3C-3CAC-428D-9A33-85A563ABB00F"></a>
<h4 id="ADXDB-GUID-EE2FCC3C-3CAC-428D-9A33-85A563ABB00F" class="sect4"><span class="enumeration_section">39.5.4.3</span> JSON_VALUE as JSON_TABLE</h4>
<div>
<p>Oracle SQL function <code>json_value</code> can be viewed as a special case of function <code>json_table</code>.</p>
<p><a href="json.htm#GUID-EE2FCC3C-3CAC-428D-9A33-85A563ABB00F__CACFCDEI">Example 39-8</a> illustrates the equivalence: the two <code>SELECT</code> statements have the same effect.</p>
<p>In addition to perhaps helping you understand <code>json_value</code> better, this equivalence is important practically, because it means that you can use either function to get the same effect.</p>
<p>In particular, if you use <code>json_value</code> more than once, or you use it in combination with <code>json_exists</code> or <code>json_query</code> (which can also be expressed using <code>json_table</code>), to access the same data, then a single invocation of <code>json_table</code> presents the advantage that the data is parsed only once.</p>
<p>Because of this, the optimizer often automatically rewrites multiple invocations of <code>json_exists</code>, <code>json_value</code> and <code>json_query</code> (any combination) to fewer invocations of <code>json_table</code>.</p>
<div class="infoboxnotealso" id="GUID-EE2FCC3C-3CAC-428D-9A33-85A563ABB00F__GUID-42C44009-8897-4B53-9752-A7F3FAB8CA27">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" title="Oracle SQL function json_table generalizes SQL condition json_exists and SQL functions json_valueand json_query. Everything that you can do using these functions you can do using json_table. For the jobs that they do, the syntax of these functions is simpler to use than is the syntax of json_table.">JSON_TABLE Generalizes Other Oracle SQL Functions</a>&#34;</span></p>
</div>
<div class="example" id="GUID-EE2FCC3C-3CAC-428D-9A33-85A563ABB00F__CACFCDEI">
<p class="titleinexample">Example 39-8 JSON_VALUE Expressed Using JSON_TABLE</p>
<pre dir="ltr">SELECT <span class="bold">json_value</span>(<span class="italic">column</span>, <span class="italic">json_path</span> <span class="bold">RETURNING</span> <span class="italic">data_type</span> <span class="italic">error_hander</span> <span class="bold">ON ERROR</span>)
  FROM <span class="italic">table</span>;

SELECT <span class="italic">jt.column_alias</span>
  FROM <span class="italic">table</span>,
       <span class="bold">json_table</span>(<span class="italic">column</span>, <span class="bold">&#39;$&#39;</span> <span class="italic">error_handler</span> ON ERROR
         <span class="bold">COLUMNS</span> (&#34;<span class="italic">COLUMN_ALIAS</span>&#34; <span class="italic">data_type</span> <span class="bold">PATH</span> <span class="italic">json_path</span>)) <span class="bold">AS</span> &#34;<span class="italic">JT</span>&#34;;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB6332"></a><a id="ADXDB6277"></a>
<div class="props_rev_3"><a id="GUID-D64C7BE9-335D-449C-916D-1123539BF1FB"></a>
<h3 id="ADXDB-GUID-D64C7BE9-335D-449C-916D-1123539BF1FB" class="sect3"><span class="enumeration_section">39.5.5</span> Oracle SQL Function JSON_QUERY</h3>
<div>
<p>Oracle SQL function <code>json_query</code> selects one or more values from JSON data and returns a string (<code>VARCHAR2</code>) that represents the JSON values. (Unlike function <code>json_value</code>, the return data type cannot be <code>NUMBER</code>). You can thus use <code>json_query</code> to retrieve <span class="italic">fragments</span> of a JSON document.</p>
<p>The first argument to <code>json_query</code> is a SQL expression that returns an instance of a scalar SQL data type (that is, not an object or collection data type). It can be of data type <code>VARCHAR2</code>, <code>BLOB</code>, or <code>CLOB</code>. It can be a table or view column value, a PL/SQL variable, or a bind variable with proper casting. The result of evaluating the SQL expression is used as the <span class="italic">context item</span> for evaluating the path expression.</p>
<p>The second argument to <code>json_query</code> is an Oracle JSON path expression followed by an optional <code>RETURNING</code> clause, an optional wrapper clause, and an optional error clause. The path expression can target any number of JSON values.</p>
<p>In the <code>RETURNING</code> clause you can specify only data type <code>VARCHAR2</code>; you cannot specify <code>NUMBER</code>.</p>
<p>The wrapper clause determines the form of the returned string value.</p>
<p>Note that the error clause for <code>json_query</code> can specify <code>EMPTY ON ERROR</code>, which means that an empty array (<code>[]</code>) is returned in case of error (no error is raised).</p>
<p><a href="json.htm#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB__CACEAIBD">Example 39-9</a> shows an example of the use of Oracle SQL function <code>json_query</code> with an array wrapper. For each document it returns a <code>VARCHAR2</code> value whose contents represent a JSON array with elements the phone types, in an unspecified order. For the document in <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">Example 39-4</a> the phone types are <code>&#34;Office&#34;</code> and <code>&#34;Mobile&#34;</code>, and the array returned is either <code>[&#34;Mobile&#34;, &#34;Office&#34;]</code> or <code>[&#34;Office&#34;, &#34;Mobile&#34;]</code>.</p>
<p>Note that if path expression <code>$.ShippingInstructions.Phone.type</code> were used in <a href="json.htm#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB__CACEAIBD">Example 39-9</a> it would give the same result. Because of Oracle JSON path-expression syntax relaxation, <code>[*].type</code> is equivalent to <code>.type</code>.</p>
<div class="infoboxnotealso" id="GUID-D64C7BE9-335D-449C-916D-1123539BF1FB__GUID-B764F8A6-D501-4D6A-9048-4AE111FD72C3">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF56718" target="_blank" href="../SQLRF/functions091.htm#SQLRF56718"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>json_query</code></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic Oracle JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">Oracle JSON Path Expression Syntax Relaxation</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="Oracle SQL functions json_value and json_query accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-9079CD9C-3783-4857-9F6B-84D746C91317" title="Oracle SQL functions json_query and json_table accept an optional wrapper clause, which specifies the form of the value returned by json_query or used for the data in a json_table relational column. This clause and the default behavior (no wrapper clause) are described here. Examples are provided.">Wrapper Clause for Oracle SQL Functions JSON_QUERY and JSON_TABLE</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="Some Oracle SQL functions and conditions for JSON accept an optional error clause, which specifies handling for an error that is raised by the Oracle SQL function or condition. This clause and the default behavior (no error clause) are described here.">Error Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
</ul>
</div>
<div class="example" id="GUID-D64C7BE9-335D-449C-916D-1123539BF1FB__CACEAIBD">
<p class="titleinexample">Example 39-9 Selecting JSON Values Using JSON_QUERY</p>
<pre dir="ltr">SELECT json_query(po_document, &#39;$.ShippingInstructions.Phone[*].type&#39;
                               WITH WRAPPER)
  FROM j_purchaseorder;
</pre></div>
<!-- class="example" --></div>
<a id="ADXDB6385"></a><a id="ADXDB6384"></a>
<div class="props_rev_3"><a id="GUID-555D8633-8AA9-4878-A72A-C665FA769D91"></a>
<h4 id="ADXDB-GUID-555D8633-8AA9-4878-A72A-C665FA769D91" class="sect4"><span class="enumeration_section">39.5.5.1</span> JSON_QUERY as JSON_TABLE</h4>
<div>
<p>Oracle SQL function <code>json_query</code> can be viewed as a special case of function <code>json_table</code>.</p>
<p><a href="json.htm#GUID-555D8633-8AA9-4878-A72A-C665FA769D91__CACCFCEB">Example 39-10</a> illustrates the equivalence: the two <code>SELECT</code> statements have the same effect.</p>
<p>In addition to perhaps helping you understand <code>json_query</code> better, this equivalence is important practically, because it means that you can use either function to get the same effect.</p>
<p>In particular, if you use <code>json_query</code> more than once, or you use it in combination with <code>json_exists</code> or <code>json_value</code> (which can also be expressed using <code>json_table</code>), to access the same data, then a single invocation of <code>json_table</code> presents the advantage that the data is parsed only once.</p>
<p>Because of this, the optimizer often automatically rewrites multiple invocations of <code>json_exists</code>, <code>json_value</code> and <code>json_query</code> (any combination) to fewer invocations of <code>json_table</code>.</p>
<div class="infoboxnotealso" id="GUID-555D8633-8AA9-4878-A72A-C665FA769D91__GUID-5F288884-B943-4671-B2D8-FDE558FFDF92">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" title="Oracle SQL function json_table generalizes SQL condition json_exists and SQL functions json_valueand json_query. Everything that you can do using these functions you can do using json_table. For the jobs that they do, the syntax of these functions is simpler to use than is the syntax of json_table.">JSON_TABLE Generalizes Other Oracle SQL Functions</a>&#34;</span></p>
</div>
<div class="example" id="GUID-555D8633-8AA9-4878-A72A-C665FA769D91__CACCFCEB">
<p class="titleinexample">Example 39-10 JSON_QUERY Expressed Using JSON_TABLE</p>
<pre dir="ltr">SELECT <span class="bold">json_query</span>(<span class="italic">column</span>, <span class="italic">json_path</span>
                  <span class="bold">RETURNING</span> <span class="italic">data_type</span> <span class="italic">array_wrapper</span> <span class="italic">error_hander</span> <span class="bold">ON ERROR</span>)
  FROM <span class="italic">table</span>;

SELECT <span class="italic">jt.column_alias</span>
  FROM <span class="italic">table</span>,
       <span class="bold">json_table</span>(<span class="italic">column</span>, <span class="bold">&#39;$&#39;</span> <span class="italic">error_handler</span> ON ERROR
         <span class="bold">COLUMNS</span> (&#34;<span class="italic">COLUMN_ALIAS</span>&#34; <span class="italic">data_type</span> <span class="bold">FORMAT JSON</span> <span class="italic">array_wrapper</span>
                  <span class="bold">PATH</span> <span class="italic">json_path</span>)) <span class="bold">AS</span> &#34;<span class="italic">JT</span>&#34;;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB6287"></a>
<div class="props_rev_3"><a id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A"></a>
<h3 id="ADXDB-GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" class="sect3"><span class="enumeration_section">39.5.6</span> Oracle SQL Function JSON_TABLE</h3>
<div>
<p>Oracle SQL function <code>json_table</code> projects JSON data into a relational format. You use <code>json_table</code> to decompose the result of JSON expression evaluation into the relational rows and columns of a new, virtual table, which you can also think of as an inline relational view.</p>
<p>You can then insert this virtual table into a pre-existing database table, or you can query it using SQL&thinsp;&mdash;&thinsp;in a join expression, for example.</p>
<p>In particular, a common use of <code>json_table</code> is to create a relational view of JSON data. You can use such a view just as you would use any relational table or view. This lets applications, tools, and programmers operate on JSON data as if it were relational, that is, without consideration of the syntax of JSON or JSON path expressions.</p>
<p>Defining a relational view over JSON data in effect maps a kind of <span class="italic">schema</span> onto that data. This mapping is <span class="italic">after the fact</span>: the underlying JSON data can be defined and created without any regard to a schema or any particular pattern of use. Data first, schema later.</p>
<p>Such a schema (mapping) imposes no restriction on the kind of JSON documents that can be stored in the underlying table (other than being well-formed JSON data). The relational view exposes only data that conforms to the mapping (schema) that defines the view. To change the schema, just redefine the view&thinsp;&mdash;&thinsp;no need to reorganize the underlying JSON data. <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACBGFFH">Example 39-17</a> illustrates the creation of a relational view using <code>json_table</code>.</p>
<p>You use <code>json_table</code> in a SQL <code>FROM</code> clause. It is thus a <strong class="term">row source</strong>: it generates a row of relational data for each JSON value selected by a <span class="italic">row path expression</span> (row pattern).</p>
<p>The rows created by a <code>json_table</code> invocation are laterally joined, implicitly, to the row that generated them. That is, you need not explicitly join the virtual table produced by <code>json_table</code> with the table that contains the JSON data.</p>
<p>The first argument to <code>json_table</code> is a SQL expression that returns an instance of a scalar SQL data type (that is, not an object or collection data type). It can be of data type <code>VARCHAR2</code>, <code>BLOB</code>, or <code>CLOB</code>. It can be a table or view column value, a PL/SQL variable, or a bind variable with proper casting. The result of evaluating the SQL expression is used as the <span class="italic">context item</span> for evaluating the row path expression.</p>
<p>The second argument to <code>json_table</code> is an Oracle JSON row path expression followed by an optional error clause for handling the row and a (required) <code>COLUMNS</code> clause. (There is no <code>RETURNING</code> clause.) The path expression can target any number of JSON values.</p>
<p>The row path expression acts as a pattern for the rows of the generated virtual table. It is matched against the context item provided by the SQL <code>FROM</code> clause, producing rows of SQL data that are organized into relational columns, which you specify in the <code>COLUMNS</code> clause. Each of those rows is matched against zero or more <span class="italic">column path expressions</span> to generate the relational columns of the virtual table.</p>
<p>There are two levels of error handling for <code>json_table</code>, corresponding to the two levels of path expressions: row and column. When present, a column error handler overrides row-level error handling. The default error handler for both levels is <code>NULL ON ERROR</code>.</p>
<p>The mandatory <code>COLUMNS</code> clause defines the columns of the virtual table to be created by <code>json_table</code>. It consists of the keyword <span class="bold"><code>COLUMNS</code></span> followed by the following entries enclosed in parentheses:</p>
<ul style="list-style-type: disc;">
<li>
<p>At most one entry in the <code>COLUMNS</code> clause can be a column name followed by the keywords <span class="bold"><code>FOR ORDINALITY</code></span>, which specifies a column of generated row numbers (SQL data type <code>NUMBER</code>). These numbers start with one.</p>
</li>
<li>
<p>Other than the optional <code>FOR ORDINALITY</code> entry, each entry in the <code>COLUMNS</code> clause is either a regular column specification or a nested columns specification.</p>
</li>
<li>
<p>A <span class="italic">regular column</span> specification consists of a column name followed by an optional scalar data type for the column, which can be SQL data type <code>VARCHAR2</code> or <code>NUMBER</code> (the same as for the <code>RETURNING</code> clause of other Oracle SQL functions for JSON), followed by an optional value clause and a mandatory <code>PATH</code> clause. The default data type is <code>VARCHAR2(4000)</code>.</p>
</li>
<li>
<p>A <span class="italic">nested columns</span> specification consists of the keyword <span class="bold"><code>NESTED</code></span> followed by an optional <code>PATH</code> keyword, an Oracle JSON row path expression, and then a <code>COLUMNS</code> clause. This <code>COLUMNS</code> clause specifies columns that represent nested data. The row path expression used here provides a refined context for the specified nested columns: each nested column path expression is relative to the row path expression.</p>
<p>A <code>COLUMNS</code> clause at any level (nested or not) has the same characteristics. In other words, <code>COLUMNS</code> clause is defined recursively. For each level of nesting (that is, for each use of keyword <code>NESTED</code>), the nested <code>COLUMNS</code> clause is said to be the <strong class="term">child</strong> of the <code>COLUMNS</code> clause within which it is nested, which is its <strong class="term">parent</strong>. Two or more <code>COLUMNS</code> clauses that have the same parent clause are <strong class="term">siblings</strong>.</p>
<p>The virtual tables defined by parent and child <code>COLUMNS</code> clauses are joined using an <span class="italic">outer</span> join, with the parent being the outer table. The virtual columns defined by sibling <code>COLUMNS</code> clauses are joined using a <code>union</code> join.</p>
<p><a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">Example 39-16</a> illustrates the use of a nested columns clause.</p>
</li>
<li>
<p>The optional value clause specifies how to handle the data projected to the column: whether to handle it as would <code>json_value</code>, <code>json_exists</code>, or <code>json_query</code>. This value handling includes the return data type, return format (pretty or ascii), wrapper, and error treatment.</p>
<p>By default, the projected data is handled as if by <code>json_value</code>. If you use keyword <span class="bold"><code>EXISTS</code></span> then it is handled as if by <code>json_exists</code>. If you use keywords <span class="bold"><code>FORMAT JSON</code></span> then it is handled as if by <code>json_query</code>.</p>
<p>For <code>FORMAT JSON</code> you can override the default wrapping behavior by adding an explicit wrapper clause.</p>
<p>You can override the default error handling for the given handler (<code>json_value</code>, <code>json_exists</code>, or <code>json_query</code>) by adding an explicit <code>ERROR</code> clause appropriate for it.</p>
</li>
<li>
<p>The mandatory <span class="bold"><code>PATH</code></span> clause specifies the portion of the row that is to be used as the column content. The column path expression following keyword <code>PATH</code> is matched against the context item provided by the virtual row. The column path expression must represent a <span class="italic">relative</span> path; it is relative to the path specified by the row path expression.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-10170DA4-D38A-4502-8DC3-58B1CB24AA1E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="Oracle SQL functions json_value and json_query accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-9079CD9C-3783-4857-9F6B-84D746C91317" title="Oracle SQL functions json_query and json_table accept an optional wrapper clause, which specifies the form of the value returned by json_query or used for the data in a json_table relational column. This clause and the default behavior (no wrapper clause) are described here. Examples are provided.">Wrapper Clause for Oracle SQL Functions JSON_QUERY and JSON_TABLE</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="Some Oracle SQL functions and conditions for JSON accept an optional error clause, which specifies handling for an error that is raised by the Oracle SQL function or condition. This clause and the default behavior (no error clause) are described here.">Error Clause for Oracle SQL Functions for JSON</a>&#34;</span></p>
</li>
<li>
<p><a class="olink SQLRF56973" target="_blank" href="../SQLRF/functions092.htm#SQLRF56973"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>json_table</code></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6289"></a><a id="ADXDB6290"></a><a id="ADXDB6288"></a>
<div class="props_rev_3"><a id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903"></a>
<h4 id="ADXDB-GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" class="sect4"><span class="enumeration_section">39.5.6.1</span> JSON_TABLE Generalizes Other Oracle SQL Functions</h4>
<div>
<p>Oracle SQL function <code>json_table</code> generalizes SQL condition <code>json_exists</code> and SQL functions <code>json_value</code>and <code>json_query</code>. Everything that you can do using these functions you can do using <code>json_table</code>. For the jobs that they do, the syntax of these functions is simpler to use than is the syntax of <code>json_table</code>.</p>
<p>If you use any of <code>json_exists</code>, <code>json_value</code>, or <code>json_query</code> more than once, or in combination, to access the same data then a single invocation of <code>json_table</code> presents the advantage that the data is parsed only once.</p>
<p>Because of this, the optimizer often automatically rewrites multiple invocations of <code>json_exists</code>, <code>json_value</code> and <code>json_query</code> (any combination) to fewer invocations of <code>json_table</code> instead, so the data is parsed only once.</p>
<p><a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">Example 39-11</a> and <a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 39-12</a> illustrate this. They each select the requestor and the set of phones used by each object in column <code>j_purchaseorder.po_document</code>. But <a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 39-12</a> parses that column only once, not four times.</p>
<p>Note the following in connection with <a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 39-12</a>:</p>
<ul style="list-style-type: disc;">
<li>
<p>A JSON value of <code>null</code> is a <span class="italic">value</span> as far as SQL is concerned; it is <span class="italic">not</span> <code>NULL</code>, which in SQL represents the absence of a value (missing, unknown, or inapplicable data). In <a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 39-12</a>, if the JSON value of object attribute <code>zipCode</code> is <code>null</code> then the SQL string <code>&#39;true&#39;</code> is returned.</p>
</li>
<li>
<p>Although <code>json_exists</code> returns a Boolean value, as a SQL value this is represented by the SQL string <code>&#39;true&#39;</code> or <code>&#39;false&#39;</code>. If <code>json_exists</code> is used directly as a condition in a SQL <code>WHERE</code> clause or <code>CASE</code> statement then you need not test this return value explicitly; you can simply write <code>json_exists(...)</code>. But if <code>json_exists</code> is used elsewhere, to obtain a <span class="italic">value</span>, then the only way to test that value is as an explicit string. That is the case in <a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 39-12</a>: the value is stored in column <code>jt.has_zip</code>, and it is then tested explicitly for equality against the SQL string <code>&#39;true&#39;</code>.</p>
</li>
<li>
<p>The JSON object attribute <code>AllowPartialShipment</code> has a JSON Boolean value. When <code>json_value</code> is applied to that value it can be returned as either a string or a number. In <a href="json.htm#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 39-12</a> the <span class="italic">implicit</span> use of <code>json_value</code> returns the value as data type <code>NUMBER</code>, and this value is then tested for equality against the number <code>1</code>.</p>
</li>
</ul>
<div class="example" id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">
<p class="titleinexample">Example 39-11 Accessing JSON Data Multiple Times To Extract Data</p>
<pre dir="ltr">SELECT json_<span class="bold">value</span>(po_document, &#39;$.Requestor&#39; RETURNING VARCHAR2(32)),
       json_<span class="bold">query</span>(po_document, &#39;$.ShippingInstructions.Phone&#39;
                               RETURNING VARCHAR2(100))
  FROM j_purchaseorder
  WHERE json_<span class="bold">exists</span>(po_document, &#39;$.ShippingInstructions.Address.zipCode&#39;)
    AND json_<span class="bold">value</span>(po_document,  &#39;$.AllowPartialShipment&#39; RETURNING NUMBER(1))
        = 1;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">
<p class="titleinexample">Example 39-12 Using JSON_TABLE to Extract Data Without Multiple Parses</p>
<pre dir="ltr">SELECT jt.requestor, jt.phones
  FROM j_purchaseorder,
       json_table(po_document, &#39;$&#39;
         COLUMNS (requestor VARCHAR2(32 CHAR) PATH &#39;$.Requestor&#39;,
                  phones    VARCHAR2(100 CHAR) FORMAT JSON
                            PATH &#39;$.ShippingInstructions.Phone&#39;,
                  partial   <span class="bold">NUMBER</span>(1) PATH &#39;$.AllowPartialShipment&#39;,
                  has_zip   VARCHAR2(5 CHAR) <span class="bold">EXISTS</span>
                            PATH &#39;$.ShippingInstructions.Address.zipCode&#39;)) jt
  WHERE <span class="bold">jt.partial = 1</span> AND <span class="bold">has_zip = &#39;true&#39;</span>;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6386"></a><a id="ADXDB6387"></a><a id="ADXDB6388"></a><a id="ADXDB6389"></a><a id="ADXDB6390"></a><a id="ADXDB6291"></a>
<div class="props_rev_3"><a id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5"></a>
<h4 id="ADXDB-GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5" class="sect4"><span class="enumeration_section">39.5.6.2</span> Using JSON_TABLE with JSON Arrays</h4>
<div>
<p>A JSON value can be an array or can include one or more arrays, nested to any number of levels inside other JSON arrays or objects. You can use a <code>json_table</code> <code>NESTED</code> path clause to project specific elements of an array.</p>
<div class="section">
<p><a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">Example 39-13</a> projects the requestor and associated phone numbers from the JSON data in column <code>po_document</code>. The entire JSON array <code>Phone</code> is projected as a relational column of JSON data, <code>ph_arr</code>. To format this JSON data as a <code>VARCHAR2</code> column, the keywords <code>FORMAT JSON</code> are needed.</p>
<p>What if you wanted to project the individual <span class="italic">elements</span> of JSON array <code>Phone</code> and not the array as a whole? <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">Example 39-14</a> shows one way to do this, which you can use if the array elements are the only data you need to project.</p>
<p>If you want to project both the requestor and the corresponding phone data then the row path expression of <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">Example 39-14</a> (<code>$.Phone[*]</code>) is not appropriate: it targets only the (phone object) elements of array <code>Phone</code>.</p>
<p><a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">Example 39-15</a> shows one way to target both: use a <span class="italic">row path expression</span> that targets both the name and the entire phones array, and use <span class="italic">column path expressions</span> that target fields <code>type</code> and <code>number</code> of individual phone objects.</p>
<p>In <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">Example 39-15</a> as in <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">Example 39-13</a>, keywords <code>FORMAT JSON</code> are needed because the resulting <code>VARCHAR2</code> columns contain JSON data, namely arrays of phone types or phone numbers, with one array element for each phone. In addition, unlike the case for <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">Example 39-13</a>, a wrapper clause is needed for column <code>phone_type</code> and column <code>phone_num</code>, because array <code>Phone</code> contains multiple objects with fields <code>type</code> and <code>number</code>.</p>
<p>The effect of <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">Example 39-15</a> might not be what you want in some cases. For example, you might want a relational column that contains a single phone number (one row per number), rather than one that contains a JSON array of phone numbers (one row for all numbers for a given purchase order).</p>
<p>For that you need to tell <code>json_table</code> to project the array elements, by using a <code>json_table</code> <span class="bold"><code>NESTED</code></span> path clause for the array. A <code>NESTED</code> path clause acts, in effect, as an additional row source (row pattern). <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">Example 39-16</a> illustrates this.</p>
<p>You can use any number of <code>NESTED</code> keywords in a given <code>json_table</code> invocation.</p>
<p>In <a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">Example 39-16</a> the outer <code>COLUMNS</code> clause is the parent of the nested (inner) <code>COLUMNS</code> clause. The virtual tables defined are joined using an outer join, with the table defined by the parent clause being the outer table in the join.</p>
<p>(If there were a second columns clause nested directly under the same parent, the two nested clauses would be sibling <code>COLUMNS</code> clauses.)</p>
<p><a href="json.htm#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACBGFFH">Example 39-17</a> defines a relational view over JSON data. It uses a <code>NESTED</code> path clause to project the elements of array <code>LineItems</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">
<p class="titleinexample">Example 39-13 Projecting an Entire JSON Array as JSON Data</p>
<pre dir="ltr">SELECT jt.*
  FROM j_purchaseorder,
       json_table(po_document, &#39;$&#39;
         COLUMNS (requestor VARCHAR2(32 CHAR) PATH &#39;$.Requestor&#39;,
                  ph_arr    VARCHAR2(100 CHAR) <span class="bold">FORMAT JSON</span>
                            PATH &#39;$.ShippingInstructions.<span class="bold">Phone</span>&#39;)) AS &#34;JT&#34;;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">
<p class="titleinexample">Example 39-14 Projecting Elements of a JSON Array</p>
<pre dir="ltr">SELECT jt.*
  FROM j_purchaseorder,
       json_table(po_document, &#39;$.ShippingInstructions.<span class="bold">Phone[*]</span>&#39;
         COLUMNS (phone_type VARCHAR2(10) PATH &#39;$.type&#39;,
                  phone_num  VARCHAR2(20) PATH &#39;$.number&#39;)) AS &#34;JT&#34;;

PHONE_TYPE     PHONE_NUM
----------     ---------
Office         909-555-7307
Mobile         415-555-1234
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">
<p class="titleinexample">Example 39-15 Projecting Elements of a JSON Array Plus Other Data</p>
<pre dir="ltr">SELECT jt.*
  FROM j_purchaseorder,
       json_table(po_document, &#39;$&#39;
         COLUMNS (
           requestor  VARCHAR2(32 CHAR) PATH &#39;$.Requestor&#39;,
           phone_type VARCHAR2(50 CHAR) <span class="bold">FORMAT JSON WITH WRAPPER</span>
                      PATH &#39;$.ShippingInstructions.<span class="bold">Phone[*]</span>.type&#39;,
           phone_num  VARCHAR2(50 CHAR) <span class="bold">FORMAT JSON WITH WRAPPER</span>
                      PATH &#39;$.ShippingInstructions.<span class="bold">Phone[*]</span>.number&#39;)) AS &#34;JT&#34;;

REQUESTOR    PHONE_TYPE            PHONE_NUM
---------    ----------            ---------
Alexis Bull  [&#34;Office&#34;, &#34;Mobile&#34;]  [&#34;909-555-7307&#34;, &#34;415-555-1234&#34;]
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">
<p class="titleinexample">Example 39-16 JSON_TABLE: Projecting Array Elements Using NESTED</p>
<pre dir="ltr">SELECT jt.*
  FROM j_purchaseorder,
       <span class="bold">json_table</span>(po_document, &#39;$&#39;
         COLUMNS (
           requestor VARCHAR2(32 CHAR) PATH &#39;$.Requestor&#39;,
           <span class="bold">NESTED</span>                      PATH &#39;$.ShippingInstructions.<span class="bold">Phone[*]</span>&#39;
             COLUMNS (phone_type VARCHAR2(32 CHAR) PATH &#39;$.type&#39;,
                      phone_num  VARCHAR2(20 CHAR) PATH &#39;$.number&#39;))) AS &#34;JT&#34;;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACBGFFH">
<p class="titleinexample">Example 39-17 Defining a Relational View Over JSON Data</p>
<pre dir="ltr">CREATE OR REPLACE VIEW j_purchaseorder_detail_view AS
  SELECT d.*
    FROM j_purchaseorder po,
         json_table(po.po_document, &#39;$&#39;
           COLUMNS (
             po_number        NUMBER(10)         PATH &#39;$.PONumber&#39;,
             reference        VARCHAR2(30 CHAR)  PATH &#39;$.Reference&#39;,
             requestor        VARCHAR2(128 CHAR) PATH &#39;$.Requestor&#39;,
             userid           VARCHAR2(10 CHAR)  PATH &#39;$.User&#39;,
             costcenter       VARCHAR2(16)       PATH &#39;$.CostCenter&#39;,
             ship_to_name     VARCHAR2(20 CHAR)
                              PATH &#39;$.ShippingInstructions.name&#39;,
             ship_to_street   VARCHAR2(32 CHAR)
                              PATH &#39;$.ShippingInstructions.Address.street&#39;,
             ship_to_city     VARCHAR2(32 CHAR)
                              PATH &#39;$.ShippingInstructions.Address.city&#39;,
             ship_to_county   VARCHAR2(32 CHAR)
                              PATH &#39;$.ShippingInstructions.Address.county&#39;,
             ship_to_postcode VARCHAR2(10 CHAR)
                              PATH &#39;$.ShippingInstructions.Address.postcode&#39;,
             ship_to_state    VARCHAR2(2 CHAR)
                              PATH &#39;$.ShippingInstructions.Address.state&#39;,
             ship_to_zip      VARCHAR2(8 CHAR)
                              PATH &#39;$.ShippingInstructions.Address.zipCode&#39;,
             ship_to_country  VARCHAR2(32 CHAR)
                              PATH &#39;$.ShippingInstructions.Address.country&#39;,
             ship_to_phone    VARCHAR2(24 CHAR)
                              PATH &#39;$.ShippingInstructions.Phone[0].number&#39;,
             NESTED PATH &#39;$.LineItems[*]&#39;
               COLUMNS (
                 itemno      NUMBER(38)         PATH &#39;$.ItemNumber&#39;, 
                 description VARCHAR2(256 CHAR) PATH &#39;$.Part.Description&#39;, 
                 upc_code    VARCHAR2(14 CHAR)  PATH &#39;$.Part.UPCCode&#39;, 
                 quantity    NUMBER(12,4)       PATH &#39;$.Quantity&#39;, 
                 unitprice   NUMBER(14,2)       PATH &#39;$.Part.UnitPrice&#39;))) d;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="ADXDB6392"></a><a id="ADXDB6393"></a><a id="ADXDB6391"></a>
<div class="props_rev_3"><a id="GUID-7249417B-A337-4854-8040-192D5CEFD576"></a>
<h2 id="ADXDB-GUID-7249417B-A337-4854-8040-192D5CEFD576" class="sect2"><span class="enumeration_section">39.6</span> Simple Dot-Notation Access to JSON Data</h2>
<div>
<p>A simple dot-notation syntax is provided for queries, as an alternative to using the more verbose but more flexible Oracle SQL functions <code>json_query</code> and <code>json_value</code>. The dot notation is designed to return JSON values whenever possible.</p>
<p>Oracle SQL functions <code>json_query</code> and <code>json_value</code> accept an Oracle JSON path expression as argument and match it against the target JSON data. They accept optional returning, wrapper, and error handling clauses, to specify the following, respectively: the data type of the return value, whether or not to wrap multiple values as an array, and how to handle errors.</p>
<p>As an alternative for simple use cases, you can use a dot-notation syntax to query JSON data without using <code>json_query</code> or <code>json_value</code>.</p>
<p>The behavior of a query using the dot notation is different from both <code>json_query</code> and <code>json_value</code>. In effect, it combines their behavior to return one or more JSON values whenever possible.</p>
<p>Where one or the other of these SQL functions might return <code>NULL</code> or raise an error because the path expression does not match the JSON data, a dot-notation query often returns a useful JSON value. The return value is always a string (data type <code>VARCHAR2</code>) representing JSON data. The content of the string depends on the targeted JSON data, as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>If a <span class="italic">single</span> JSON value is targeted, then that value is the string content, whether it is a JSON scalar, object, or array.</p>
</li>
<li>
<p>If <span class="italic">multiple</span> JSON values are targeted, then the string content is a JSON array whose elements are those values.</p>
</li>
</ul>
<p>In the first case, the behavior is similar to that of <code>json_value</code> for a <span class="italic">scalar</span> value, and it is similar to that of <code>json_query</code> for an <span class="italic">object</span> or <span class="italic">array</span> value.</p>
<p>In the second case, the behavior is similar to that of <code>json_query</code> with an array wrapper.</p>
<p>The dot-notation <span class="italic">syntax</span> is a table alias (mandatory) followed by a dot (<span class="bold"><code>.</code></span>), the name of a JSON column, and one or more pairs of the form <span class="bold"><code>.</code></span> <span class="italic"><code>json_key</code></span> or <span class="bold"><code>.</code></span> <span class="italic"><code>json_key</code></span> followed by <span class="italic"><code>array_step</code></span>, where <span class="italic"><code>json_key</code></span> is a JSON key and <span class="italic"><code>array_step</code></span> is an array step expression as described in <a href="json.htm#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of an Oracle JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item. Examples are provided.">Oracle JSON Basic Path Expression Syntax</a>.</p>
<p>Each <span class="italic"><code>json_key</code></span> must be a valid SQL identifier, and the column must have an <code>is json</code> check constraint, which ensures that it contains well-formed JSON data. If either of these rules is not respected then an error is raised at query compile time. (The check constraint must be present to avoid raising an error; however, it need not be active. If you deactivate the constraint then this error is not raised.)</p>
<p>For this JSON dot notation, <span class="italic">unlike the case generally for SQL</span>, unquoted identifiers (after the column name) are treated <span class="italic">case sensitively</span>, that is, just as if they were quoted. This is a convenience: you can use JSON keys as identifiers here without quoting them. For example, you can write just <code>jcolumn.friends</code> instead of <code>jcolumn.&#34;friends&#34;</code>. And if a JSON object is named using uppercase, such as <code>FRIENDS</code>, then you must write <code>jcolumn.FRIENDS</code>, not <code>jcolumn.friends</code>.</p>
<p>Here are some examples of the simple dot notation syntax. All refer to JSON column <code>po_document</code> of a table that has alias <code>po</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p><code>po.po_document.PONumber</code> &ndash; The value of key <code>PONumber</code>.</p>
</li>
<li>
<p><code>po.po_document.LineItems[1]</code> &ndash; The second element of array <code>LineItems</code> (array positions are zero-based).</p>
</li>
<li>
<p><code>po.po_document.LineItems[*]</code> &ndash; All of the elements of array <code>LineItems</code> (<code>*</code> is a wildcard).</p>
</li>
<li>
<p><code>po.po_document.ShippingInstructions.name</code> &ndash; The value of key <code>name</code>, a child of object <code>ShippingInstructions</code>.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-7249417B-A337-4854-8040-192D5CEFD576__GUID-70273649-FEBB-4437-8E6A-A6938CBF7245">
<p class="notep1">Note:</p>
<ul style="list-style-type: disc;">
<li>
<p>Each component of the dot-notation syntax is limited to a maximum of 30 bytes.</p>
<p>See <a class="olink SQLRF51129" target="_blank" href="../SQLRF/sql_elements008.htm#SQLRF51129"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about SQL dot-notation syntax and SQL identifiers.</p>
</li>
<li>
<p>A simple dot-notation JSON query cannot return a value longer than 4K bytes. If the value surpasses this limit then SQL <code>NULL</code> is returned instead. To obtain the actual value, use the normal query syntax instead of dot notation. That is, use Oracle SQL function <code>json_query</code> or <code>json_value</code>, specifying an appropriate return type with a <code>RETURNING</code> clause.</p>
<p>See <a class="olink SQLRF57024" target="_blank" href="../SQLRF/expressions010.htm#SQLRF57024"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about JSON dot-notation syntax.</p>
</li>
</ul>
</div>
<p><span class="italic">Matching</span> of a JSON dot-notation expression against JSON data is the same as for an Oracle JSON path expression, including the relaxation to allow implied array iteration (see <span class="q">&#34;<a href="json.htm#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic Oracle JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">Oracle JSON Path Expression Syntax Relaxation</a>&#34;</span>). The JSON column of a dot-notation expression corresponds to the context item of a path expression, and each identifier used in the dot notation corresponds to an identifier used in a path expression.</p>
<p>For example, if JSON column <code>jcolumn</code> corresponds to the path-expression context item, then dot-notation expression <code>jcolumn.friends</code> corresponds to path expression <code>$.friends</code>, and <code>jcolumn.friends.name</code> corresponds to <code>$.friends.name</code>.</p>
<p>For the latter, the context item can be an object or an array of objects. If it is an array of objects then each of the objects is matched for a key <code>friends</code>. The value of key <code>friends</code> can itself be an object or an array of objects. In the latter case, the first object in the array is used.</p>
<p>Other than the implied use of a wildcard for array elements (see <span class="q">&#34;<a href="json.htm#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic Oracle JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">Oracle JSON Path Expression Syntax Relaxation</a>&#34;</span>), a path expression with wildcards <span class="italic">cannot</span> be expressed using the dot-notation syntax. Dot-notation syntax is a handy alternative to using simple path expressions; it is not a replacement for using path expressions in general.</p>
<p><a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576__CACGDHDB">Example 39-18</a> shows equivalent dot-notation and <code>json_value</code> queries. Given the data from <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">Example 39-4</a>, each of the queries returns the string <code>&#34;1600&#34;</code>, a <code>VARCHAR2</code> value representing the JSON number <code>1600</code>.</p>
<p><a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576__CACCBEGC">Example 39-19</a> shows equivalent dot-notation and <code>json_query</code> queries. Each query in the first pair returns (a <code>VARCHAR2</code> value representing) a JSON array of phone objects. Each query in the second pair returns (a <code>VARCHAR2</code> value representing) an array of phone types, just as in <a href="json.htm#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB__CACEAIBD">Example 39-9</a>.</p>
<div class="infoboxnotealso" id="GUID-7249417B-A337-4854-8040-192D5CEFD576__GUID-F22876BA-5F7B-4D42-A26A-58F522EE2A0F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF57024" target="_blank" href="../SQLRF/expressions010.htm#SQLRF57024"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about dot notation used for SQL object and object attribute access (object access expressions)</p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" title="Oracle Database provides SQL access to JSON data using Oracle JSON path expressions.">Oracle JSON Path Expressions</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0" title="A typical use of SQL condition is json is as a check constraint, to ensure that the data in a JSON column is (well-formed) JSON data. Oracle recommends that you always use an is_json check constraint when you create a column intended for JSON data.">Using a Check Constraint To Ensure that a Column Contains JSON Data</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="json.htm#GUID-9E6455EC-FE3B-428C-B958-1D535726EA26" title="Oracle provides SQL functions and conditions you can use to create, query, and operate on JSON data stored in Oracle Database. Some of these take as argument an Oracle JSON path expression as a literal SQL string, followed possibly by a RETURNING clause, a wrapper clause, or an error clause.">Oracle SQL Functions and Conditions for Use with JSON Data</a>&#34;</span></p>
</li>
</ul>
</div>
<div class="example" id="GUID-7249417B-A337-4854-8040-192D5CEFD576__CACGDHDB">
<p class="titleinexample">Example 39-18 JSON Dot-Notation Query Compared with JSON_VALUE</p>
<pre dir="ltr">SELECT <span class="bold">po</span>.po_document<span class="bold">.</span>PONumber FROM j_purchaseorder <span class="bold">po</span>;

SELECT json_value(po_document, &#39;$.PONumber&#39;) FROM j_purchaseorder;

</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7249417B-A337-4854-8040-192D5CEFD576__CACCBEGC">
<p class="titleinexample">Example 39-19 JSON Dot-Notation Query Compared with JSON_QUERY</p>
<pre dir="ltr">SELECT <span class="bold">po</span>.po_document<span class="bold">.</span>ShippingInstructions<span class="bold">.</span>Phone FROM j_purchaseorder <span class="bold">po</span>;

SELECT json_query(po_document, &#39;$.ShippingInstructions.Phone&#39;)
  FROM j_purchaseorder;

SELECT <span class="bold">po</span>.po_document.ShippingInstructions<span class="bold">.</span>Phone<span class="bold">.</span>type FROM j_purchaseorder <span class="bold">po</span>;

SELECT json_query(po_document, &#39;$.ShippingInstructions.Phone.type&#39; <span class="bold">WITH WRAPPER</span>)
  FROM j_purchaseorder;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6266"></a>
<div class="props_rev_3"><a id="GUID-BD09DB8A-26F4-43A9-9B39-9E0E20C0D192"></a>
<h2 id="ADXDB-GUID-BD09DB8A-26F4-43A9-9B39-9E0E20C0D192" class="sect2"><span class="enumeration_section">39.7</span> Indexes for JSON Data</h2>
<div>
<p>You can index JSON data as you would any data of the type you use to store it. In addition, you can define a JSON search index, which is useful for both ad hoc structural queries and full-text queries.</p>
<div class="infoboxnotealso" id="GUID-BD09DB8A-26F4-43A9-9B39-9E0E20C0D192__GUID-610C6744-58D8-44F6-B72F-1DD669F2A42F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="json.htm#GUID-7DD291FB-F22C-4AB9-ABDD-9D55CFB6CCAD" title="To determine whether a given query picks up a given function-based index, look for the index name in the execution plan for the query.">How To Tell Whether a Function-Based Index for JSON Data Is Picked Up</a></p>
</li>
<li>
<p><a href="json.htm#GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866" title="You can create a bitmap index for the value returned by json_exists. This is the right kind of index to use for json_exists, because there are only two possible return values for a condition (true and false).">Creating Bitmap Indexes for Oracle SQL Condition JSON_EXISTS</a></p>
</li>
<li>
<p><a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B" title="You can create a function-based index for SQL function json_value. You can use the standard syntax for this, explicitly specifying function json_value, or you can use the simple dot-notation syntax. Indexes created in either of these ways can be used with both dot-notation queries and json_value queries.">Creating JSON_VALUE Function-Based Indexes</a></p>
</li>
<li>
<p><a href="json.htm#GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939" title="An index created using json_value with ERROR ON ERROR can be used for a query involving json_table, if the WHERE clause refers to a column projected by json_table, and the effective JSON path that targets that column matches the indexed path expression.">Using a JSON_VALUE Function-Based Index with JSON_TABLE Queries</a></p>
</li>
<li>
<p><a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D" title="By default, the Oracle SQL functions for JSON return a VARCHAR2 value. When you create a function-based index using json_value, unless you use a RETURNING clause to specify a different return data type, the index is not picked up for a query that expects a non-VARCHAR2 value.">Data Type Considerations for JSON_VALUE Indexing and Querying</a></p>
</li>
<li>
<p><a href="json.htm#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F" title="To index multiple fields of a JSON object, you first create virtual columns for them. Then you create a composite B-tree index on the virtual columns.">Indexing Multiple JSON Fields Using a Composite B-Tree Index</a></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6394"></a>
<div class="props_rev_3"><a id="GUID-7DD291FB-F22C-4AB9-ABDD-9D55CFB6CCAD"></a>
<h3 id="ADXDB-GUID-7DD291FB-F22C-4AB9-ABDD-9D55CFB6CCAD" class="sect3"><span class="enumeration_section">39.7.1</span> How To Tell Whether a Function-Based Index for JSON Data Is Picked Up</h3>
<div>
<p>To determine whether a given query picks up a given function-based index, look for the index name in the execution plan for the query.</p>
<div class="section">
<p>For example, given the index defined in <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">Example 39-22</a>, an execution plan for the <code>json_value</code> query of <a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576__CACGDHDB">Example 39-18</a> references an index scan with index <code>po_num_id1</code>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6271"></a><a id="ADXDB6396"></a><a id="ADXDB6395"></a>
<div class="props_rev_3"><a id="GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866"></a>
<h3 id="ADXDB-GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866" class="sect3"><span class="enumeration_section">39.7.2</span> Creating Bitmap Indexes for Oracle SQL Condition JSON_EXISTS</h3>
<div>
<p>You can create a bitmap index for the value returned by <code>json_exists</code>. This is the right kind of index to use for <code>json_exists</code>, because there are only two possible return values for a condition (true and false).</p>
<div class="section">
<p>This is illustrated by <a href="json.htm#GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACCCEBD">Example 39-20</a>.</p>
<p><a href="json.htm#GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACEIFEE">Example 39-21</a> creates a bitmap index for a value returned by <code>json_value</code>. This is an appropriate index to use <span class="italic">if</span> there are only few possible values for field <code>CostCenter</code> in your data.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACCCEBD">
<p class="titleinexample">Example 39-20 Creating a Bitmap Index for JSON_EXISTS</p>
<pre dir="ltr">CREATE BITMAP INDEX has_zipcode_idx
  ON j_purchaseorder (<span class="bold">json_exists</span>(po_document, 
                                  &#39;$.ShippingInstructions.Address.zipCode&#39;));
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACEIFEE">
<p class="titleinexample">Example 39-21 Creating a Bitmap Index for JSON_VALUE</p>
<pre dir="ltr">CREATE BITMAP INDEX cost_ctr_idx
  ON j_purchaseorder (<span class="bold">json_value</span>(po_document, &#39;$.CostCenter&#39;));
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6267"></a><a id="ADXDB6398"></a><a id="ADXDB6397"></a>
<div class="props_rev_3"><a id="GUID-FEE83855-780A-424B-9916-B899BFF2077B"></a>
<h3 id="ADXDB-GUID-FEE83855-780A-424B-9916-B899BFF2077B" class="sect3"><span class="enumeration_section">39.7.3</span> Creating JSON_VALUE Function-Based Indexes</h3>
<div>
<p>You can create a function-based index for SQL function <code>json_value</code>. You can use the standard syntax for this, explicitly specifying function <code>json_value</code>, or you can use the simple dot-notation syntax. Indexes created in either of these ways can be used with both dot-notation queries and <code>json_value</code> queries.</p>
<div class="section">
<p><a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">Example 39-22</a> creates a function-based index for <code>json_value</code> on field <code>PONumber</code> of the object that is in column <code>po_document</code> of table <code>j_purchaseorder</code>. The object is passed as the path-expression context item.</p>
<p>The use of <code>ERROR ON ERROR</code> here means that if the data contains a record that either has <span class="italic">no</span> <code>PONumber</code> field or has a <code>PONumber</code> field with a <span class="italic">non-number</span> value then index creation fails. And if the index exists then trying to insert such a record fails.</p>
<p>An alternative is to create an index using the simplified syntax described in <span class="q">&#34;<a href="json.htm#GUID-7249417B-A337-4854-8040-192D5CEFD576" title="A simple dot-notation syntax is provided for queries, as an alternative to using the more verbose but more flexible Oracle SQL functions json_query and json_value. The dot notation is designed to return JSON values whenever possible.">Simple Dot-Notation Access to JSON Data</a>&#34;</span>. <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">Example 39-23</a> illustrates this; it indexes both scalar and non-scalar results, corresponding to what a dot-notation query can return.</p>
<p>The indexes created in both <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">Example 39-22</a> and <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">Example 39-23</a> can be picked up for either a query that uses dot-notation syntax or a query that uses <code>json_value</code>.</p>
<p>If the index of <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">Example 39-23</a> is picked up for a <code>json_value</code> query then filtering is applied after index pickup, to test for the correct field value. Non-scalar values can be stored in this index, since dot-notation queries can return such values, but a <code>json_value</code> query cannot, so such values are filtered out after index pickup.</p>
<p>Oracle recommends that you create a function-based index for <code>json_value</code> using one of these forms:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>A <code>json_value</code> expression that specifies a <span class="bold"><code>RETURNING</code></span> data type and uses <span class="bold"><code>ERROR ON ERROR</code></span>.</p>
<p>The indexed values are only (non-<code>null</code>) scalar values of the specified data type. The index can nevertheless be used in dot-notation queries that lead to such a scalar result.</p>
</li>
<li>
<p>Dot-notation syntax</p>
<p>The indexed values correspond to the flexible behavior of dot-notation queries, which return JSON values whenever possible. They can include non-scalar JSON values (JSON objects and arrays). They can match dot-notation queries in addition to <code>json_value</code> queries. The index is used to come up with an initial set of matches, which are then filtered according to the specifics of the query. For example, any indexed values that are not JSON scalars are filtered out.</p>
</li>
</ul>
<p>Indexes created in either of these ways can thus be used with both dot-notation queries and <code>json_value</code> queries.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">
<p class="titleinexample">Example 39-22 Creating a Function-Based Index for a JSON Object Field: JSON_VALUE</p>
<pre dir="ltr">CREATE UNIQUE INDEX po_num_idx1
  ON j_purchaseorder (<span class="bold">json_value</span>(po_document, &#39;$.<span class="bold">PONumber</span>&#39; 
                                 <span class="bold">RETURNING NUMBER</span> <span class="bold">ERROR ON ERROR</span>));
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">
<p class="titleinexample">Example 39-23 Creating a Function-Based Index for a JSON Object Field: Dot Notation</p>
<pre dir="ltr">CREATE UNIQUE INDEX po_num_idx2 ON j_purchaseorder po (po.po_document.<span class="bold">PONumber</span>);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6400"></a><a id="ADXDB6399"></a>
<div class="props_rev_3"><a id="GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939"></a>
<h3 id="ADXDB-GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939" class="sect3"><span class="enumeration_section">39.7.4</span> Using a JSON_VALUE Function-Based Index with JSON_TABLE Queries</h3>
<div>
<p>An index created using <code>json_value</code> with <code>ERROR ON ERROR</code> can be used for a query involving <code>json_table</code>, if the <code>WHERE</code> clause refers to a column projected by <code>json_table</code>, and the effective JSON path that targets that column matches the indexed path expression.</p>
<div class="section">
<p>The index acts as a constraint on the indexed path, to ensure that only one (non-<code>null</code>) scalar JSON value is projected for each item in the JSON collection.</p>
<p>The query in <a href="json.htm#GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939__CACBJDFA">Example 39-24</a> thus makes use of the index created in <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">Example 39-22</a>.</p>
<div class="infobox-note" id="GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939__GUID-5973FB45-8522-43DA-905D-E56D1D9D8EE6">
<p class="notep1">Note:</p>
<p>A function-based index created using a <code>json_value</code> expression or dot notation can be picked up for a correponding occurrence in a query <code>WHERE</code> clause only if the occurrence is used in a SQL <span class="italic">comparison</span> condition, such as <code>&gt;=</code>. In particular, it is not picked up for an occurrence used in condition <code>IS NULL</code> or <code>IS NOT NULL</code>.</p>
<p>See <a class="olink SQLRF52105" target="_blank" href="../SQLRF/conditions002.htm#SQLRF52105"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL comparison conditions.</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939__CACBJDFA">
<p class="titleinexample">Example 39-24 Use of a JSON_VALUE Function-Based Index with a JSON_TABLE Query</p>
<pre dir="ltr">SELECT jt.*
  FROM j_purchaseorder po,
       json_table(po.po_document, &#39;$&#39;
         COLUMNS po_number  NUMBER(5) PATH &#39;$.<span class="bold">PONumber</span>&#39;,
                 reference  VARCHAR2(30 CHAR) PATH &#39;$.Reference&#39;,
                 requestor  VARCHAR2(32 CHAR) PATH &#39;$.Requestor&#39;,
                 userid     VARCHAR2(10 CHAR) PATH &#39;$.User&#39;,
                 costcenter VARCHAR2(16 CHAR) PATH &#39;$.CostCenter&#39;) jt
  <span class="bold">WHERE po_number = 1600;</span>
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6402"></a><a id="ADXDB6403"></a><a id="ADXDB6404"></a><a id="ADXDB6401"></a>
<div class="props_rev_3"><a id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D"></a>
<h3 id="ADXDB-GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D" class="sect3"><span class="enumeration_section">39.7.5</span> Data Type Considerations for JSON_VALUE Indexing and Querying</h3>
<div>
<p>By default, the Oracle SQL functions for JSON return a <code>VARCHAR2</code> value. When you create a function-based index using <code>json_value</code>, unless you use a <code>RETURNING</code> clause to specify a different return data type, the index is not picked up for a query that expects a non-<code>VARCHAR2</code> value.</p>
<p>For example, in the query of <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">Example 39-25</a>, <code>json_value</code> uses <code>RETURNING NUMBER</code>. The index created in <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">Example 39-22</a> can be picked up for this query, because the indexed <code>json_value</code> expression specifies a return type of <code>NUMBER</code>.</p>
<p>But the index created in <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">Example 39-23</a> does not use <code>RETURNING NUMBER</code> (the return type is <code>VARCHAR2(4000)</code>, by default), so it cannot be picked up for a such a query.</p>
<p>Now consider the queries in <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">Example 39-26</a> and <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">Example 39-27</a>, which use <code>json_value</code> without a <code>RETURNING</code> clause, so that the value returned is of type <code>VARCHAR2</code>.</p>
<p>In <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">Example 39-26</a>, SQL function <code>to_number</code> explicitly converts the <code>VARCHAR2</code> value returned by <code>json_value</code> to a number. Similarly, in <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">Example 39-27</a>, comparison condition &gt; (greater-than) implicitly converts the value to a number.</p>
<p>Neither of the indexes of <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">Example 39-22</a> and <a href="json.htm#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">Example 39-23</a> is picked up for either of these queries. The queries might return the right results in each case, because of type-casting, but the indexes cannot be used to evaluate the queries.</p>
<p>Consider also what happens if some of the data cannot be converted to a particular data type. For example, given the queries in <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">Example 39-25</a>, <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">Example 39-26</a>, and <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">Example 39-27</a>, what happens to a <code>PONumber</code> value such as <code>&#34;alpha&#34;</code>?</p>
<p>For <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">Example 39-26</a> and <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">Example 39-27</a>, the query stops in error because of the attempt to cast the value to a number. For <a href="json.htm#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">Example 39-25</a>, however, because the default error handling behavior is <code>NULL ON ERROR</code>, the non-number value <code>&#34;alpha&#34;</code> is simply filtered out. The value is indexed, but it is ignored for the query.</p>
<p>Similarly, if the query used, say, <code>DEFAULT &#39;1000&#39; ON ERROR</code>, that is, if it specified a numeric default value, then no error would be raised for the value <code>&#34;alpha&#34;</code>: the default value of <code>1000</code> would be used.</p>
<div class="example" id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">
<p class="titleinexample">Example 39-25 JSON_VALUE Query with Explicit RETURNING NUMBER</p>
<pre dir="ltr">SELECT count(*) FROM j_purchaseorder po  WHERE json_value(po_document, &#39;$.PONumber&#39; <span class="bold">RETURNING NUMBER</span>) &gt; 1500;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">
<p class="titleinexample">Example 39-26 JSON_VALUE Query with Explicit Numerical Conversion</p>
<pre dir="ltr">SELECT count(*) FROM j_purchaseorder po  WHERE <span class="bold">to_number(</span>json_value(po_document, &#39;$.PONumber&#39;)<span class="bold">)</span> &gt; 1500;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">
<p class="titleinexample">Example 39-27 JSON_VALUE Query with Implicit Numerical Conversion</p>
<pre dir="ltr">SELECT count(*) FROM j_purchaseorder po  WHERE json_value(po_document, &#39;$.PONumber&#39;) &gt; 1500;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6268"></a><a id="ADXDB6269"></a><a id="ADXDB6270"></a><a id="ADXDB6405"></a>
<div class="props_rev_3"><a id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F"></a>
<h3 id="ADXDB-GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F" class="sect3"><span class="enumeration_section">39.7.6</span> Indexing Multiple JSON Fields Using a Composite B-Tree Index</h3>
<div>
<p>To index multiple fields of a JSON object, you first create virtual columns for them. Then you create a composite B-tree index on the virtual columns.</p>
<div class="section">
<p><a href="json.htm#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">Example 39-28</a> and <a href="json.htm#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACFADBF">Example 39-29</a> illustrate this. <a href="json.htm#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">Example 39-28</a> creates virtual columns <code>userid</code> and <code>costcenter</code> for JSON object fields <code>User</code> and <code>CostCenter</code>, respectively.</p>
<p><a href="json.htm#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACFADBF">Example 39-29</a> creates a composite B-tree index on the virtual columns of <a href="json.htm#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">Example 39-28</a>.</p>
<p>A SQL query that references either the virtual columns or the corresponding JSON data (object fields) picks up the composite index. This is the case for both of the queries in <a href="json.htm#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACGFJBE">Example 39-30</a>.</p>
<p>These two queries have the same effect, including the same performance. However, the first query form does not target the JSON data itself; it targets the virtual columns that are used to index that data.</p>
<p>The data does not depend logically on any indexes implemented to improve query performance. If you want this independence from implementation to be reflected in your code, then use the second query form. Doing that ensures that the query behaves the same functionally with or without the index&thinsp;&mdash;&thinsp;the index serves only to improve performance.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">
<p class="titleinexample">Example 39-28 Creating Virtual Columns for JSON Object Fields</p>
<pre dir="ltr">ALTER TABLE j_purchaseorder ADD (<span class="bold">userid</span> VARCHAR2(20)
  G<span class="bold">ENERATED ALWAYS AS</span> (json_value(po_document, &#39;$.<span class="bold">User</span>&#39; RETURNING VARCHAR2(20))));

ALTER TABLE j_purchaseorder ADD (<span class="bold">costcenter</span> VARCHAR2(6)
  <span class="bold">GENERATED ALWAYS AS</span> (json_value(po_document, &#39;$.<span class="bold">CostCenter</span>&#39;
                       RETURNING VARCHAR2(6))));
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACFADBF">
<p class="titleinexample">Example 39-29 Creating a Composite B-tree Index for JSON Object Fields</p>
<pre dir="ltr">CREATE INDEX user_cost_ctr_idx on j_purchaseorder(<span class="bold">userid</span>, <span class="bold">costcenter</span>);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACGFJBE">
<p class="titleinexample">Example 39-30 Two Ways to Query JSON Data Indexed with a Composite Index</p>
<pre dir="ltr">SELECT po_document FROM j_purchaseorder WHERE <span class="bold">userid</span>      = &#39;ABULL&#39;
                                          AND <span class="bold">costcenter</span>  = &#39;A50&#39;;

SELECT po_document
  FROM j_purchaseorder WHERE <span class="bold">json_value</span>(po_document, <span class="bold">&#39;$.User&#39;</span>)       = &#39;ABULL&#39;
                         AND <span class="bold">json_value</span>(po_document, <span class="bold">&#39;$.CostCenter&#39;</span>) = &#39;A50&#39;;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB6327"></a><a id="ADXDB6294"></a><a id="ADXDB6328"></a><a id="ADXDB6329"></a><a id="ADXDB6293"></a>
<div class="props_rev_3"><a id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8"></a>
<h2 id="ADXDB-GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8" class="sect2"><span class="enumeration_section">39.8</span> Full-Text Search of JSON Data</h2>
<div>
<p>You can use Oracle SQL condition <span class="bold"><code>json_textcontains</code></span> in a <code>CASE</code> expression or the <code>WHERE</code> clause of a <code>SELECT</code> statement to perform a full-text search of JSON data that is stored in a <code>VARCHAR2</code>, <code>BLOB</code>, or <code>CLOB</code> column.</p>
<p>To be able to use condition <code>json_textcontains</code>, you first must create a JSON search index, which is an Oracle Text index designed specifically for use with JSON data. If you do not, then an error is raised when <code>json_textcontains</code> is used.</p>
<p>A JSON search index is appropriate for general, ad hoc queries of JSON data, whether or not those queries make use of full-text search.</p>
<div class="infobox-note" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-2399CB39-6E43-4CA6-AAD7-1C9FCFE915EE">
<p class="notep1">Note:</p>
<p>JSON search index is supported only if your database character set is AL32UTF8, and only for JSON data that uses <code>VARCHAR2</code>,&nbsp;<code>BLOB</code>, or&nbsp;<code>CLOB</code>&nbsp;storage. An error is raised during index creation otherwise.</p>
</div>
<p>You create a JSON search index by specifying an index type of <code>CTXSYS.CONTEXT</code> and section group <span class="bold"><code>CTXSYS.JSON_SECTION_GROUP</code></span> using a <code>PARAMETERS</code> clause. <a href="json.htm#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACJHFGF">Example 39-31</a> illustrates this.</p>
<p><a href="json.htm#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__FULL-TEXTQUERYOFJSONDATA-CEACA609">Example 39-32</a> shows a full-text query that finds purchase-order documents that contain the keyword <code>Magic</code> in any of the line-item part descriptions.</p>
<p><a href="json.htm#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACGJADE">Example 39-33</a> shows some <span class="italic">non</span> full-text queries of JSON data that also make use of the JSON search index created in .</p>
<div class="infobox-note" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-40F2CDD5-AC2A-4F55-A6E4-7B2C289D9462">
<p class="notep1">Note:</p>
<p>When <code>json_value</code> is used, a JSON search index is used as a post-processing filter. The index can be picked up for <code>json_value</code> only if the return value is <code>VARCHAR2</code>, not <code>NUMBER</code>, and only for an equality comparison. For example, it is not picked up for a comparison such as <code>json_value(column, &#39;$.name_first&#39;)</code> <span class="bold"><code>&gt;</code></span> <code>&#39;Nimrod&#39;</code>.</p>
</div>
<p>If the name of your JSON search index is present in the execution plan for your query, then you know that the index was in fact picked up for that query. You will see a line similar to that shown in <a href="json.htm#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACIDIJG">Example 39-34</a>.</p>
<p>A JSON search index is maintained asynchronously, on demand. You can thus defer the cost of index maintenance, performing it at commit time only or at some time when database load is reduced. This can improve DML performance. It can also improve index maintenance performance by enabling bulk loading of unsynchronized index rows when an index is synchronized. On the other hand, asynchronous maintenance of an index means that until it is synchronized the index is not used for data that has been modified or newly inserted.</p>
<div class="infoboxnotealso" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-4B8408A2-8425-4B94-91CE-A84B3DCD2243">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="json.htm#GUID-BD09DB8A-26F4-43A9-9B39-9E0E20C0D192" title="You can index JSON data as you would any data of the type you use to store it. In addition, you can define a JSON search index, which is useful for both ad hoc structural queries and full-text queries.">Indexes for JSON Data</a> for information about other ways to index JSON data</p>
</li>
<li>
<p><a class="olink SQLRF56963" target="_blank" href="../SQLRF/conditions010.htm#SQLRF56963"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about condition <code>json_textcontains</code></p>
</li>
<li>
<p><a class="olink CCREF24098" target="_blank" href="../CCREF/cddlpkg.htm#CCREF24098"><span><cite>Oracle Text Reference</cite></span></a> for information about <code>CTXSYS.CONTEXT</code> indexes</p>
</li>
<li>
<p><a class="olink CCREF2031" target="_blank" href="../CCREF/cdatadic.htm#CCREF2031"><span><cite>Oracle Text Reference</cite></span></a> for information about section group <code>CTXSYS.JSON_SECTION_GROUP</code></p>
</li>
<li>
<p><a class="olink CCREF23731" target="_blank" href="../CCREF/csql.htm#CCREF23731"><span><cite>Oracle Text Reference</cite></span></a> for information about synchronizing a JSON search index</p>
</li>
</ul>
</div>
<div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACJHFGF">
<p class="titleinexample">Example 39-31 Creating a JSON Search Index</p>
<pre dir="ltr">CREATE INDEX po_search_idx ON j_purchaseorder (po_document)
  <span class="bold">INDEXTYPE IS CTXSYS.CONTEXT</span>
  PARAMETERS (&#39;<span class="bold">section group CTXSYS.JSON_SECTION_GROUP</span> SYNC (ON COMMIT)&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__FULL-TEXTQUERYOFJSONDATA-CEACA609">
<p class="titleinexample">Example 39-32 Full-Text Query of JSON Data</p>
<pre dir="ltr">SELECT po_document FROM j_purchaseorder
  WHERE <span class="bold">json_textcontains</span>(po_document, &#39;$.LineItems.Part.Description&#39;, &#39;<span class="bold">Magic</span>&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACGJADE">
<p class="titleinexample">Example 39-33 Ad Hoc Queries of JSON Data</p>
<pre dir="ltr">SELECT po_document FROM j_purchaseorder
  WHERE json_exists(po_document, &#39;$.ShippingInstructions.Address.country&#39;);

SELECT po_document FROM j_purchaseorder
  WHERE json_value(po_document, &#39;$.User&#39;) = &#39;ABULL&#39;;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACIDIJG">
<p class="titleinexample">Example 39-34 Execution Plan Indication that a JSON Search Index Is Used</p>
<pre dir="ltr">|* 2|   DOMAIN INDEX     | <span class="bold">PO_SEARCH_IDX</span> |     |     |     4 (0)
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6407"></a><a id="ADXDB6408"></a><a id="ADXDB6409"></a><a id="ADXDB6410"></a><a id="ADXDB6406"></a>
<div class="props_rev_3"><a id="GUID-52EFC452-5E65-4148-8070-1FA588A6E697"></a>
<h2 id="ADXDB-GUID-52EFC452-5E65-4148-8070-1FA588A6E697" class="sect2"><span class="enumeration_section">39.9</span> Loading External JSON Data</h2>
<div>
<p>You can create a database table of JSON data from the content of a JSON dump file.</p>
<div class="section">
<p><a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACHFFCE">Example 39-3</a> and <a href="json.htm#GUID-E6CC0DCF-3D72-41EF-ACA4-B3BF54EE3CA0__CACCIEFA">Example 39-4</a> create table <code>j_purchaseorder</code> and insert a single row of JSON data into it, for illustrative purposes. This section shows how you can create the full table from the data in JSON dump file <code>$ORACLE_HOME/demo/schema/order_entry/PurchaseOrders.dmp</code>. The format of this file is compatible with the export format produced by common NoSQL databases, including Oracle NoSQL Database. Each row of the file contains a single JSON document represented as a JSON object.</p>
<p><a href="json.htm#GUID-52EFC452-5E65-4148-8070-1FA588A6E697__CACJJBAA">Example 39-35</a> creates a database directory that corresponds to file-system directory <code>$ORACLE_HOME/demo/schema/order_entry</code>. <a href="json.htm#GUID-52EFC452-5E65-4148-8070-1FA588A6E697__CACJJGAD">Example 39-37</a> then uses this database directory to create and fill an <span class="italic">external table</span>, <code>json_dump_file_contents</code>, with the data from the dump file, <code>PurchaseOrders.dmp</code>.</p>
<p><a href="json.htm#GUID-52EFC452-5E65-4148-8070-1FA588A6E697__CACDGAJI">Example 39-38</a> copies the JSON documents from external table <code>json_dump_file_contents</code> to column <code>json_document</code> of relational table <code>j_purchaseorder</code>.</p>
<div class="infoboxnotealso" id="GUID-52EFC452-5E65-4148-8070-1FA588A6E697__GUID-F219F8B4-2A41-44DB-9FCC-916225255E87">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CNCPT1141" target="_blank" href="../CNCPT/tablecls.htm#CNCPT1141"><span class="italic">Oracle Database Concepts</span></a> for overview information about external tables</p>
</li>
<li>
<p><a class="olink SUTIL3407" target="_blank" href="../SUTIL/GUID-038ED956-A6EE-4C6D-B7C9-0D406B8088B6.htm#SUTIL3407"><span class="italic">Oracle Database Utilities</span></a> for detailed information about external tables</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-52EFC452-5E65-4148-8070-1FA588A6E697__CACJJBAA">
<p class="titleinexample">Example 39-35 Creating a Database Directory Object</p>
<pre dir="ltr">CREATE OR REPLACE DIRECTORY <span class="bold">order_entry_dir</span>
  AS &#39;$ORACLE_HOME/demo/schema/order_entry&#39;;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-52EFC452-5E65-4148-8070-1FA588A6E697__GUID-1CE88885-4216-45C3-834F-94AB5FAD167A">
<p class="titleinexample">Example 39-36 Creating a Database Directory Object</p>
<pre dir="ltr">CREATE OR REPLACE DIRECTORY <span class="bold">loader_output_dir</span> AS &#39;/tmp&#39;;<a id="fn_7" href="#fn_7" onclick="footdisplay(7,&#34;This example uses a temporary file-system directory. On UNIX and Linux systems this would typically be /tmp. On MS Windows it would typically be folder temp, for example, c:\temp. &#34;)"><sup>Foot 7</sup></a>
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-52EFC452-5E65-4148-8070-1FA588A6E697__CACJJGAD">
<p class="titleinexample">Example 39-37 Creating an External Table and Filling It from a JSON Dump File</p>
<pre dir="ltr">CREATE TABLE <span class="bold">json_dump_file_contents</span> (<span class="bold">json_document</span> CLOB)
  ORGANIZATION EXTERNAL (TYPE ORACLE_LOADER DEFAULT DIRECTORY order_entry_dir
                         ACCESS PARAMETERS
                           (RECORDS DELIMITED BY 0x&#39;0A&#39;
                            DISABLE_DIRECTORY_LINK_CHECK
                            BADFILE loader_output_dir: &#39;JSONDumpFile.bad&#39;
                            LOGFILE order_entry_dir: &#39;JSONDumpFile.log&#39;
                            FIELDS (json_document CHAR(5000)))
                         LOCATION (order_entry_dir:&#39;<span class="bold">PurchaseOrders.dmp</span>&#39;))
  PARALLEL
  REJECT LIMIT UNLIMITED;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-52EFC452-5E65-4148-8070-1FA588A6E697__CACDGAJI">
<p class="titleinexample">Example 39-38 Copying JSON Data from an External Table to a Relational Table</p>
<pre dir="ltr">INSERT INTO j_purchaseorder
  SELECT SYS_GUID(), SYSTIMESTAMP, json_document FROM json_dump_file_contents
    WHERE json_document IS JSON;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6411"></a>
<div class="props_rev_3"><a id="GUID-EE961220-A9F9-4B04-B371-6131D524B1FB"></a>
<h2 id="ADXDB-GUID-EE961220-A9F9-4B04-B371-6131D524B1FB" class="sect2"><span class="enumeration_section">39.10</span> Replication of JSON Data</h2>
<div>
<p>You can use Oracle GoldenGate to replicate tables with columns containing JSON data.</p>
<p>Be aware that Oracle GoldenGate requires tables to be replicated to have a <span class="italic">nonvirtual</span> primary key column; the primary key column cannot be virtual.</p>
<p>All <span class="italic">indexes</span> on the JSON data will be replicated also. However, you must execute, on the replica database, any Oracle Text operations that you use to maintain a JSON search index. Here are examples of such procedures:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>CTX_DDL.create_section_group</code></p>
</li>
<li>
<p><code>CTX_DDL.drop_section_group</code></p>
</li>
<li>
<p><code>CTX_DDL.set_sec_grp_attr</code></p>
</li>
<li>
<p><code>CTX_DDL.sync_index</code></p>
</li>
<li>
<p><code>CTX_DDL.optimize_index</code></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-EE961220-A9F9-4B04-B371-6131D524B1FB__GUID-0E33BAAF-E3A3-48F3-9817-F0108DD76ABD">
<p class="notep1">See Also:</p>
<p><a class="olink ogg" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ogg"><span class="italic">Oracle GoldenGate</span></a> for information about Oracle GoldenGate</p>
</div>
</div>
</div>
<a id="ADXDB6275"></a>
<div class="props_rev_3"><a id="GUID-A2BC5593-7F70-482E-89D1-B32C3798E0E4"></a>
<h2 id="ADXDB-GUID-A2BC5593-7F70-482E-89D1-B32C3798E0E4" class="sect2"><span class="enumeration_section">39.11</span> Oracle Database Support for JSON</h2>
<div>
<p>Oracle Database support for JavaScript Object Notation (JSON) is designed to provide the best fit between the worlds of relational storage and querying JSON data, allowing relational and JSON queries to work well together.</p>
<div class="section">
<div class="infobox-note" id="GUID-A2BC5593-7F70-482E-89D1-B32C3798E0E4__GUID-E59C8D2F-55EC-4F91-8DF3-79E1D5D931FA">
<p class="notep1">Note:</p>
<p>Oracle is active in standardization efforts regarding SQL access to JSON data as part of a SQL/JSON standard. Oracle Database support for JSON will continue to track the development of such standards and evolve with it.</p>
</div>
<div class="infoboxnotealso" id="GUID-A2BC5593-7F70-482E-89D1-B32C3798E0E4__GUID-FC881A17-398D-4871-AA11-937071874CEB">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="http://www.json.org" target="_blank"><code>http://www.json.org</code></a> and <a href="http://www.ecma-international.org" target="_blank"><code>http://www.ecma-international.org</code></a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<hr/>
<br/>
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:
<p>JSON differs from JavaScript notation in this respect: JSON allows unescaped Unicode characters U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) in strings. JavaScript notation requires control characters such as these to be escaped in strings. This difference can be important when generating JSONP (JSON with padding) data.</p>
<br/>
Footnote&nbsp;2:
<p>JavaScript objects are thus similar to hash tables in C and C++, HashMaps in Java, associative arrays in PHP, dictionaries in Python, and hashes in Perl and Ruby.</p>
<br/>
Footnote&nbsp;3:
<p>An object is created in JavaScript using either constructor <code>Object</code> or object literal syntax: <code>{</code>...<code>}</code>.</p>
<br/>
Footnote&nbsp;4: In a few contexts an empty field name cannot be used with Oracle Database. Wherever it can be used, the name <span class="italic">must</span> be wrapped with double quotation marks.<br/>
Footnote&nbsp;5:
<p>If the check constraint combines condition <code>is json</code> with another condition using logical condition <code>OR</code>, then the column is <span class="italic">not</span> listed in these views. In this case, it is not certain that data in the column is JSON data. For example, the constraint <code>jcol is json</code> <span class="bold"><code>OR</code></span> <code>length(jcol) &lt; 1000</code> does <span class="italic">not</span> ensure that the data in column <code>jcol</code> is JSON data.</p>
<br/>
Footnote&nbsp;6: An object field is sometimes called an object &ldquo;key&rdquo;.<br/>
Footnote&nbsp;7:
<p>This example uses a temporary file-system directory. On UNIX and Linux systems this would typically be <code>/tmp</code>. On MS Windows it would typically be folder <code>temp</code>, for example, <code>c:\temp</code>.</p>
<br/></div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3410">
<tr>
<td class="cellalignment3417">
<table class="cellalignment3415">
<tr>
<td class="cellalignment3414"><a href="partpgjson.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3414"><a href="partpg7.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3419">
<table class="cellalignment3413">
<tr>
<td class="cellalignment3414"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3414"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3414"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3414"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3414"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3414"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>


</body></html>