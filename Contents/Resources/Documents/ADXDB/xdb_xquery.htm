<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-1637"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/XQuery%20and%20Oracle%20XML%C2%A0DB"></a><title>XQuery and Oracle XML&nbsp;DB</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast."/>
<meta name="keywords" content="XQuery language, XPath language, syntax, XQuery Data Model (XDM), XQuery, XDM instance, unordered mode, definition, sequence, item, referential transparency, pending update list, update snapshot, full-text search, XML data, expressions, simple expression, occurrence indicator, FLWOR, FLWOR XQuery expression, predefined namespaces and prefixes, namespaces, namespace, XQuery, XMLQuery and XMLTable SQL functions, functions, SQL, XMLQuery, XMLTable, XMLQuery SQL function, XMLTable SQL function, SQL/XML standard, querying XML data, XMLQuery and XMLTable, XMLNAMESPACES clause, column pattern, XMLTable SQL function, column pattern, row pattern, XMLTable SQL function, row pattern, XMLExists SQL function, XMLExists, XMLCast SQL function, XMLCast, Oracle extension functions, fn:replace XQuery function, replace XQuery function, functions, fn:replace, ora:contains (Oracle), ora:sqrt Oracle XQuery function, sqrt XQuery function (Oracle), ora:sqrt (Oracle), ora:tokenize Oracle XQuery function, ora:tokenize (Oracle), ora:matches Oracle XQuery function (deprecated), ora:matches (deprecated, Oracle), ora:replace Oracle XQuery function (deprecated), ora:replace (deprecated, Oracle), pragmas, XQuery, XQuery pragmas, Oracle, extension expressions, , See, type-checking, static and dynamic, type-checking, static and dynamic, XQuery language, static type-checking, dynamic type-checking, Oracle XML DB support, time zone support, implicit, revalidation mode, XQuery Update, revalidation mode, copy-namespace mode, XQuery, copy-namespace mode, static typing feature, XQuery functions and operators, support, fn:id XQuery function, fn:idref XQuery function, fn:doc XQuery function, fn:collection XQuery function, fn:available XQuery function"/>
<meta name="dcterms.created" content="2016-12-08T13:53:25Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="XML DB Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E41152-15"/>
<meta name="dcterms.isVersionOf" content="ADXDB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="partpg2.htm" title="Previous" type="text/html"/>
<link rel="Next" href="xdb04cre.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41152-15.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1"></a> <span id="PAGE" style="display:none;">13/61</span> <!-- End Header -->
<script>
//<![CDATA[
window.name='xdb_xquery'
//]]>
</script> <script>
    function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote&amp;nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
</script><noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="ADXDB1700"></a>
<h1 id="ADXDB-GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" class="sect1"><span class="enumeration_chapter">4</span> XQuery and Oracle XML&nbsp;DB</h1>
<div>
<p>The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus command<code>XQUERY</code> and SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_xquery.htm#GUID-927FB610-9553-4772-8D3E-FAA7546C4371" title="XQuery is the W3C language designed for querying and updating XML data.">Overview of the XQuery Language</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-7DB63F8C-F441-4635-A185-4016016B22CE" title="Oracle XML&nbsp;DB support for the XQuery language is provided through a native implementation of SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast. As a convenience, SQL*Plus command XQUERY is also provided, which lets you enter XQuery expressions directly&thinsp;&mdash;&thinsp;in effect, this command turns SQL*Plus into an XQuery command-line interpreter.">Overview of XQuery in Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY_ XMLTABLE_ XMLExists_ and XMLCast</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B" title="You can use XQuery function fn:collection to query data that is in database tables and views.">URI Scheme oradb: Querying Table or View Data with XQuery</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948" title="The W3C XQuery specification lets an implementation provide implementation-defined extension expressions. An XQuery extension expression is an XQuery expression that is enclosed in braces ({,&nbsp;}) and prefixed by an implementation-defined pragma. The Oracle implementation provides several such pragmas.">Oracle XQuery Extension-Expression Pragmas</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B" title="When possible, Oracle XML&nbsp;DB performs static (compile time) type-checking of queries.">XQuery Static Type-Checking in Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" title="Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.">Oracle XML&nbsp;DB Support for XQuery</a></p>
</li>
</ul>
</div>
<a id="ADXDB5089"></a>
<div class="props_rev_3"><a id="GUID-927FB610-9553-4772-8D3E-FAA7546C4371"></a>
<h2 id="ADXDB-GUID-927FB610-9553-4772-8D3E-FAA7546C4371" class="sect2"><span class="enumeration_section">4.1</span> Overview of the XQuery Language</h2>
<div>
<p>XQuery is the W3C language designed for querying and updating XML data.</p>
<p>Oracle XML&nbsp;DB supports the following W3C XQuery standards:</p>
<ul style="list-style-type: disc;">
<li>
<p>XQuery 1.0 Recommendation</p>
</li>
<li>
<p><a id="d24143e177" class="indexterm-anchor"></a>XQuery Update Facility 1.0 Recommendation</p>
</li>
<li>
<p>XQuery and XPath Full Text 1.0 Recommendation</p>
</li>
</ul>
<p>This section presents an overview of the XQuery language. For more information, consult a recent book on the language or refer to the standards documents that define it, all of which are available at <a href="http://www.w3c.org/" target="_blank"><code>http://www.w3c.org/</code></a>.</p>
</div>
<a id="ADXDB5805"></a><a id="ADXDB4232"></a>
<div class="props_rev_3"><a id="GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC"></a>
<h3 id="ADXDB-GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC" class="sect3"><span class="enumeration_section">4.1.1</span> XPath Expressions Are XQuery Expressions</h3>
<div>
<p>The XPath language is a W3C Recommendation for navigating XML documents. It is a subset of the XQuery language: an XPath expression is also an XQuery expression.</p>
<div class="section">
<p>XPath models an XML document as a tree of nodes. It provides a set of operations that walk this tree and apply predicates and node-test functions. Applying an XPath expression to an XML document results in a set of nodes. For example, the expression <code>/PO/PONO</code> selects all <code>PONO</code> child elements under the <code>PO</code> root element of a document.</p>
<p><a href="xdb_xquery.htm#GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC__CFHFHBIJ" title="This table describes five common XPath constructs.">Table 4-1</a> lists some common constructs used in XPath.</p>
</div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC__CFHFHBIJ">
<p class="titleintable">Table 4-1 Common XPath Constructs</p>
<table class="cellalignment3431" title="Common XPath Constructs" summary="This table describes five common XPath constructs.">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3427" id="d24143e247">XPath Construct</th>
<th class="cellalignment3428" id="d24143e250">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d24143e255" headers="d24143e247">
<p><code>/</code></p>
</td>
<td class="cellalignment3430" headers="d24143e255 d24143e250">
<p>Denotes the root of the tree in an XPath expression. For example, <code>/PO</code> refers to the child of the root node whose name is <code>PO</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d24143e269" headers="d24143e247">
<p><code>/</code></p>
</td>
<td class="cellalignment3430" headers="d24143e269 d24143e250">
<p>Used as a path separator to identify the child element nodes of a given element node. For example, <code>/PurchaseOrder/Reference</code> identifies <code>Reference</code> elements that are children of <code>PurchaseOrder</code> elements that are children of the root element.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d24143e286" headers="d24143e247">
<p><code>//</code></p>
</td>
<td class="cellalignment3430" headers="d24143e286 d24143e250">
<p>Used to identify all descendants of the current node. For example, <code>PurchaseOrder//ShippingInstructions</code> matches any <code>ShippingInstructions</code> element under the <code>PurchaseOrder</code> element.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d24143e303" headers="d24143e247">
<p><code>*</code></p>
</td>
<td class="cellalignment3430" headers="d24143e303 d24143e250">
<p>Used as a wildcard to match any child node. For example, <code>/PO/*/STREET</code> matches any street element that is a grandchild of the <code>PO</code> element.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d24143e317" headers="d24143e247">
<p><code>[ ]</code></p>
</td>
<td class="cellalignment3430" headers="d24143e317 d24143e250">
<p>Used to denote predicate expressions. XPath supports a rich list of binary operators such as <code>or</code>, <code>and</code>, and <code>not</code>. For example, <code>/PO[PONO = 20 and PNAME = &#34;PO_2&#34;]/SHIPADDR</code> selects the shipping address element of all purchase orders whose purchase-order number is <code>20</code> and whose purchase-order name is <code>PO_2</code>.</p>
<p>Brackets are also used to denote a position (index). For example, <code>/PO/PONO[2]</code> identifies the second purchase-order number element under the <code>PO</code> root element.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d24143e352" headers="d24143e247">
<p>Functions</p>
</td>
<td class="cellalignment3430" headers="d24143e352 d24143e250">
<p>XPath and XQuery support a set of built-in functions such as <code>substring</code>, <code>round</code>, and <code>not</code>. In addition, these languages provide for extension functions through the use of namespaces. Oracle XQuery extension functions use the namespace prefix <code>ora</code>, for namespace <code>http://xmlns.oracle.com/xdb</code>. See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a> &#34;</span>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p>An XPath expression must identify a single node or a set of element, text, or attribute nodes. The result of evaluating an XPath expression is never a Boolean expression.</p>
<p>You can select <code>XMLType</code> data using PL/SQL, C, or Java. You can also use <code>XMLType</code> method <code>getNumberVal()</code> to retrieve XML data as a <code>NUMBER</code> value.</p>
<div class="infobox-note" id="GUID-4CE8BB4C-45F4-4F3A-9BB2-71F62E8A46CC__GUID-4E633027-A075-4466-971F-807F8B922B85">
<p class="notep1">Note:</p>
<p>Oracle SQL functions and <code>XMLType</code> methods respect the W3C XPath recommendation, which states that if an XPath expression targets <span class="italic">no nodes</span> when applied to XML data, then an empty sequence must be returned. An error must <span class="italic">not</span> be raised in this case.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5090"></a>
<div class="props_rev_3"><a id="GUID-498BE184-4F83-4FF8-8799-47D606F9066D"></a>
<h3 id="ADXDB-GUID-498BE184-4F83-4FF8-8799-47D606F9066D" class="sect3"><span class="enumeration_section">4.1.2</span> XQuery: A Functional Language Based on Sequences</h3>
<div>
<p>XQuery is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources.</p>
<p>You can use XQuery to query XML data wherever it is found, whether it is stored in database tables, available through Web Services, or otherwise created on the fly. In addition to querying XML data, XQuery can be used to <span class="italic">construct</span> XML data. In this regard, XQuery can serve as an alternative or a complement to both XSLT and the other SQL/XML publishing functions, such as <code>XMLElement</code>.</p>
<p>XQuery builds on the Post-Schema-Validation Infoset (PSVI) data model, which unites the XML Information Set (Infoset) data model and the XML Schema type system. XQuery defines a new data model, the <strong class="term">XQuery Data Model</strong> (XDM), which is based on <span class="italic">sequences</span>. Another name for an XQuery sequence is an <strong class="term">XDM instance</strong>.</p>
</div>
<a id="ADXDB6035"></a>
<div class="props_rev_3"><a id="GUID-647DE1EC-46E8-44E2-A856-F734DDEE5526"></a>
<h4 id="ADXDB-GUID-647DE1EC-46E8-44E2-A856-F734DDEE5526" class="sect4"><span class="enumeration_section">4.1.2.1</span> XQuery Is About Sequences</h4>
<div>
<p>XQuery is all about manipulating sequences. This makes XQuery similar to a set-manipulation language, except that sequences are ordered and can contain duplicate items. XQuery sequences differ from the sequences in some other languages in that nested XQuery sequences are always <span class="italic">flattened</span> in their effect.</p>
<p>In many cases, sequences can be treated as unordered, to maximize optimization &ndash; where this is available, it is under your control. This <strong class="term">unordered mode</strong> can be applied to join order in the treatment of nested iterations (<code>for</code>), and it can be applied to the treatment of XPath expressions (for example, in <code>/a/b</code>, the matching <code>b</code> elements can be processed without regard to document order).</p>
<p>An XQuery <strong class="term">sequence</strong> consists of zero or more <strong class="term">items</strong>, which can be either <span class="italic">atomic</span> (scalar) values or XML <span class="italic">nodes</span>. Items are typed using a rich type system that is based upon the types of XML Schema. This type system is a major change from that of XPath 1.0, which is limited to simple scalar types such as Boolean, number, and string.</p>
</div>
</div>
<a id="ADXDB6036"></a>
<div class="props_rev_3"><a id="GUID-30341909-E378-4909-B54B-D112A6144C5B"></a>
<h4 id="ADXDB-GUID-30341909-E378-4909-B54B-D112A6144C5B" class="sect4"><span class="enumeration_section">4.1.2.2</span> XQuery Is Referentially Transparent</h4>
<div>
<p>XQuery is a <span class="italic">functional</span> language. As such, it consists of a set of possible <span class="italic">expressions</span> that are <span class="italic">evaluated</span> and whose evaluation returns <span class="italic">values</span> (results). The result of evaluating an XQuery expression has two parts, at least one of which is empty: (a) a sequence (an XDM instance) and (b) a <strong class="term">pending update list</strong>. Informally, the sequence is sometimes spoken of as the expression value, especially when the pending update list is empty, meaning that no data updates are involved.</p>
<p>As a functional language, XQuery is also <strong class="term">referentially transparent</strong>. This means that the <span class="italic">same expression</span> evaluated in the <span class="italic">same context</span> returns the <span class="italic">same value</span>.</p>
<p><span class="italic">Exceptions</span> to this desirable mathematical property include the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>XQuery expressions that derive their value from interaction with the external environment. For example, an expression such as <code>fn:current-time(...)</code> or <code>fn:doc(...)</code> does not necessarily always return the same value, since it depends on external conditions that can change (the time changes; the content of the target document might change).</p>
<p>In some cases, like that of <code>fn:doc</code>, XQuery is defined to be referentially transparent within the execution of a single query: within a query, each invocation of <code>fn:doc</code> with the same argument results in the same document.</p>
</li>
<li>
<p>XQuery expressions that are defined to be dependent on the particular XQuery language implementation. The result of evaluating such expressions might vary between implementations. Function <code>fn:doc</code> is an example of a function that is essentially implementation-defined.</p>
</li>
</ul>
<p>Note that XQuery Update is not in the list; it does <span class="italic">not</span> present an exception to referential transparency. See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB" title="Referential transparency applies to the evaluation of XQuery expressions. It does not imply that this evaluation never has a side effect on your data. In particular, you use XQuery Update to modify your data. That modification is a side effect of evaluating an XQuery updating expression.">XQuery Update Has Side Effects on Your Data</a>&#34;</span>.</p>
<p>Referential transparency applies also to XQuery <span class="italic">variables</span>: the same variable in the same context has the same value. Functional languages are like mathematics formalisms in this respect and unlike procedural, or imperative, programming languages. A variable in a procedural language is really a name for a memory location; it has a <span class="italic">current</span> value, or state, as represented by its content at any time. A variable in a declarative language such as XQuery is really a name for a <span class="italic">static</span> value.</p>
</div>
</div>
<a id="ADXDB6037"></a>
<div class="props_rev_3"><a id="GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB"></a>
<h4 id="ADXDB-GUID-314E4088-CAA8-4A04-A55F-A04AC71444BB" class="sect4"><span class="enumeration_section">4.1.2.3</span> XQuery Update Has Side Effects on Your Data</h4>
<div>
<p>Referential transparency applies to the evaluation of XQuery expressions. It does not imply that this evaluation never has a <span class="italic">side effect</span> on your <span class="italic">data</span>. In particular, you use XQuery Update to modify your data. That modification is a side effect of evaluating an XQuery updating expression.</p>
<p>The side effect is one thing; the expression value is another. The value returned from evaluation includes the pending update list that describes the updates to carry out. For a given XQuery expression, this description is the same regardless of the context in which evaluation occurs (with the above-mentioned exceptions).</p>
<p>The XQuery Update standard defines how the XDM instances of your data are updated. How those updates are propagated to persistent data stores (for example <code>XMLType</code> tables and columns) is implementation-dependent.</p>
</div>
</div>
<a id="ADXDB6038"></a>
<div class="props_rev_3"><a id="GUID-BC615C64-3B5F-4E05-A592-5E3DBC2BB5CE"></a>
<h4 id="ADXDB-GUID-BC615C64-3B5F-4E05-A592-5E3DBC2BB5CE" class="sect4"><span class="enumeration_section">4.1.2.4</span> XQuery Update Snapshots</h4>
<div>
<p>An XQuery expression (query) can call for more than one update operation. XQuery Update performs all such operations for the same query as an <span class="italic">atomic</span> operation: either they all succeed or none of them do (if an error is raised).</p>
<p>The unit of change is thus an entire XQuery query. To effect this atomic update behavior, before evaluating your query XQuery Update takes a <strong class="term">snapshot</strong> of the data (XDM instances) whose modification is called for by the query. It also adds the update operations called for by the query to the pending update list. The snapshot is an evaluation context for an XDM instance that is the update target.</p>
<p>As the last step of XQuery expression evaluation, the pending update list is processed, applying the indicated update operations in an atomic fashion, and terminating the snapshot.</p>
<p>Note that the atomic nature of snapshot semantics means that a set of update operations used in a given query are not necessarily applied in the order written. In fact, the order of applying update operations is fixed and specified by the XQuery Update Feature standard.</p>
<p>This means that <span class="italic">an update operation does not see the result of any other update operation for the same query</span>. There is no notion of an intermediate or interim update state &ndash; all updates for a query are applied together, atomically.</p>
</div>
<a id="ADXDB6039"></a>
<div class="props_rev_3"><a id="GUID-FAD62D45-F2BC-4954-B925-F82551D48A85"></a>
<h5 id="ADXDB-GUID-FAD62D45-F2BC-4954-B925-F82551D48A85" class="sect5"><span class="enumeration_section">4.1.2.4.1</span> Oracle XML Update Functions (Deprecated) Do Not Use Snapshot Semantics</h5>
<div>
<p>The deprecated Oracle SQL functions for updating XML data do <span class="italic">not</span> use snapshot semantics. This means that if an expression has multiple such function calls they are processed in applicative order (innermost first), and the result of applying one such function is seen by the updating functions applied after it.</p>
<p>This is an important behavior difference between the Oracle updating functions (<code>updateXML</code> and so on) and XQuery Update functions. Besides the semantic difference, there is also a performance difference: in general, the atomic updating of XQuery Update performs better than the incremental updating of the Oracle-specific functions.</p>
</div>
</div>
</div>
<a id="ADXDB6140"></a>
<div class="props_rev_3"><a id="GUID-804D83E9-23F3-4E70-B836-FD30793276D9"></a>
<h4 id="ADXDB-GUID-804D83E9-23F3-4E70-B836-FD30793276D9" class="sect4"><span class="enumeration_section">4.1.2.5</span> XQuery Full Text Provides Full-Text Search</h4>
<div>
<p>The XQuery and XPath Full Text 1.0 Recommendation (XQuery Full Text) defines XQuery support for full-text searches in queries. It defines full-text selection operators that perform the search and return instances of the AllMatches model, which complements the XQuery Data Model (XDM). An AllMatches instance describes all possible solutions to a full-text query for a given search context item. Each solution is described by a Match instance, which contains the search-context tokens (StringInclude instances) that must be included and those (StringExclude instances) that must be excluded.</p>
<p>In short, XQuery Full Text adds a full-text contains expression to the XQuery language. You use such an expression in your query to search the text of element nodes and their descendent elements (you can also search the text of attribute nodes).</p>
</div>
</div>
</div>
<a id="ADXDB5091"></a>
<div class="props_rev_3"><a id="GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED"></a>
<h3 id="ADXDB-GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED" class="sect3"><span class="enumeration_section">4.1.3</span> XQuery Expressions</h3>
<div>
<p>XQuery expressions are case-sensitive. An XQuery expression is either a <span class="italic">simple</span> expression or an <span class="italic">updating</span> expression, the latter being an expression that represents data modification. More precisely, these are the possible XQuery expressions:</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><strong class="term">Basic updating expression &ndash;</strong> an <code>insert</code>, <code>delete</code>, <code>replace</code>, or <code>rename</code> expression, or a call to an <span class="italic">updating function</span> (see the XQuery Update Facility 1.0 Recommendation).</p>
</li>
<li>
<p><strong class="term">Updating expression &ndash;</strong> a basic updating expression or an expression (other than a transform expression) that contains another updating expression (this is a recursive definition).</p>
</li>
<li>
<p><strong class="term">Simple expression &ndash;</strong> An XQuery 1.0 expression. It does not call for any updating.</p>
</li>
</ul>
<p>The pending update list that results from evaluating a simple expression is empty. The sequence value that results from evaluating an updating expression is empty.</p>
<p><span class="italic">Simple</span> expressions include the following:</p>
<ul style="list-style-type: disc;">
<li>
<p><strong class="term">Primary expression &ndash;</strong> literal, variable, or function application. A variable name starts with a dollar-sign (<code>$</code>) &ndash; for example, <code>$foo</code>. Literals include numerals, strings, and character or entity references.</p>
</li>
<li>
<p><strong class="term">XPath expression &ndash;</strong> Any XPath expression. The XPath 2.0 standard is a subset of XQuery.</p>
</li>
<li>
<p><strong class="term">FLWOR expression &ndash;</strong> The most important XQuery expression, composed of the following, in order, from which FLWOR takes its name: <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, <code>return</code>.</p>
</li>
<li>
<p><strong class="term">XQuery sequence</strong> &ndash; The comma (<code>,</code>) constructor creates sequences. Sequence-manipulating functions such as <code>union</code> and <code>intersect</code> are also available. All XQuery sequences are effectively <strong class="term">flat</strong>: a nested sequence is treated as its flattened equivalent. Thus, for instance, <code>(1, 2, (3, 4, (5), 6), 7)</code> is treated as <code>(1, 2, 3, 4, 5, 6, 7)</code>. A singleton sequence, such as <code>(42)</code>, acts the same in most XQuery contexts as does its single item, <code>42</code>. Remember that the result of any XQuery expression is a sequence.</p>
</li>
<li>
<p><strong class="term">Direct (literal) constructions</strong> &ndash; XML element and attribute syntax automatically constructs elements and attributes: what you see is what you get. For example, the XQuery expression <code>&lt;a&gt;33&lt;/a&gt;</code> constructs the XML element <code>&lt;a&gt;33&lt;/a&gt;</code>.</p>
</li>
<li>
<p><strong class="term">Computed (dynamic) constructions &ndash;</strong> You can construct XML data at run time using computed values. For example, the following XQuery expression constructs this XML data: <code>&lt;foo toto=&#34;5&#34;&gt;&lt;bar&gt;tata titi&lt;/bar&gt; why? &lt;/foo&gt;</code>.</p>
<pre>&lt;foo&gt;attribute toto {2+3},
     element bar {&#34;tata&#34;, &#34;titi&#34;},
     text {&#34; why? &#34;}&lt;/foo&gt;
</pre>
<p>In this example, element <code>foo</code> is a direct construction; the other constructions are computed. In practice, the arguments to computed constructors are not literals (such as <code>toto</code> and <code>&#34;tata&#34;</code>), but expressions to be evaluated (such as <code>2+3</code>). Both the name and the value arguments of an element or attribute constructor can be computed. Braces (<code>{</code>, <code>}</code>) are used to mark off an XQuery expression to be evaluated.</p>
</li>
<li>
<p><strong class="term">Conditional expression &ndash;</strong> As usual, but remember that each part of the expression is itself an arbitrary expression. For instance, in this conditional expression, each of these subexpressions can be any XQuery expression: <code>something</code>, <code>somethingElse</code>, <code>expression1</code>, and <code>expression2</code>.</p>
<pre dir="ltr"> if (something &lt; somethingElse) then expression1 else expression2
</pre></li>
<li>
<p><strong class="term">Arithmetic, relational expression &ndash;</strong> As usual, but remember that each relational expression returns a (Boolean<a id="fn_1" href="#fn_1" onclick="footdisplay(1,&#34;The value returned is a sequence, as always. However, in XQuery, a sequence of one item is equivalent to that item itself. In this case, the single item is a Boolean value. &#34;)"><sup>Foot&nbsp;1</sup></a>) value. Examples:</p>
<pre dir="ltr">2 + 3
42 &lt; $a + 5
(1, 4) = (1, 2)
5 &gt; 3 eq true()
</pre></li>
<li>
<p><strong class="term">Quantifier expression &ndash;</strong> Universal (<code>every</code>) and existential (<code>some</code>) quantifier functions provide shortcuts to using a FLWOR expression in some cases. Examples:</p>
<pre dir="ltr">every $foo in doc(&#34;bar.xml&#34;)//Whatever satisfies $foo/@bar &gt; 42
some $toto in (42, 5), $titi in (123, 29, 5) satisfies $toto = $titi
</pre></li>
<li>
<p><strong class="term">Regular expression &ndash;</strong> XQuery regular expressions are based on XML Schema 1.0 and Perl. (See <a href="xdb_xquery.htm#GUID-22940B8D-1468-4966-9F55-7DD4518E9612" title="Oracle XML&nbsp;DB supports all of the XQuery functions and operators included in the latest XQuery 1.0 and XPath 2.0 Functions and Operators specification, with a few exceptions.">Support for XQuery Functions and Operators</a>.)</p>
</li>
<li>
<p><strong class="term">Type expression &ndash;</strong> An XQuery expression that represents an XQuery type. Examples: <code>item()</code>, <code>node()</code>, <code>attribute()</code>, <code>element()</code>, <code>document-node()</code>, <code>namespace()</code>, <code>text()</code>, <code>xs:integer</code>, <code>xs:string</code>.<a id="fn_2" href="#fn_2" onclick="footdisplay(2,&#34;Namespace prefix xs is predefined for the XML Schema namespace, http://www.w3.org/2001/XMLSchema. &#34;)"><sup>Foot&nbsp;2</sup></a></p>
<p>Type expressions can have <strong class="term">occurrence indicators</strong>: <span class="bold"><code>?</code></span> (optional: zero or one), <span class="bold"><code>*</code></span> (zero or more), <span class="bold"><code>+</code></span> (one or more). Examples: <code>document-node(element())*</code>, <code>item()+</code>, <code>attribute()?</code>.</p>
<p>XQuery also provides operators for working with types. These include <code>cast as</code>, <code>castable as</code>, <code>treat as</code>, <code>instance of</code>, <code>typeswitch</code>, and <code>validate</code>. For example, <code>&#34;42&#34; cast as xs:integer</code> is an expression whose value is the integer 42. (It is not, strictly speaking, a type expression, because its value does not represent a type.)</p>
</li>
<li>
<p><span class="bold">Full-text contains expression</span> &ndash; An XQuery expression that represents a full-text search. This expression is provided by the XQuery and XPath Full Text 1.0 Recommendation. A full-text contains expression (FTContainsExpr) supported by Oracle has these parts: a <span class="bold">search context</span> that specifies the items to search, and a <span class="bold">full-text selection</span> that filters those items, selecting matches.</p>
<p>The selection part is itself composed of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Tokens and phrases</span> used for matching.</p>
</li>
<li>
<p>Optional <span class="bold">match options</span>, such as the use of stemming.</p>
</li>
<li>
<p>Optional <span class="bold">Boolean operators</span> for combining full-text selections.</p>
</li>
<li>
<p>Optional constraint operators, such as <span class="bold">positional filters</span> (e.g. <code>ordered window</code>).</p>
</li>
</ul>
<p>See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a>&#34;</span>.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5092"></a>
<div class="props_rev_3"><a id="GUID-E40FFA59-701C-43F6-9A89-774321970A19"></a>
<h3 id="ADXDB-GUID-E40FFA59-701C-43F6-9A89-774321970A19" class="sect3"><span class="enumeration_section">4.1.4</span> FLWOR Expressions</h3>
<div>
<p>Just as for XQuery in general, there is a lot to learn about FLWOR expressions in particular. This section provides a brief overview.</p>
<div class="section">
<p>FLWOR is the most general expression syntax in XQuery. FLWOR (pronounced &#34;flower&#34;) stands for <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code>. A FLWOR expression has at least one <code>for</code> or <code>let</code> clause and a <code>return</code> clause; single <code>where</code> and <code>order by</code> clauses are optional. Only the <code>return</code> clause can contain an updating expression; the other clauses cannot.</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold"><code>for</code></span> &ndash; Bind one or more variables each to any number of values, in turn. That is, for each variable, iterate, binding the variable to a different value for each iteration.</p>
<p>At each iteration, the variables are bound in the order they appear, so that the value of a variable <code>$earlier</code> that is listed before a variable <code>$later</code> in the <code>for</code> list, can be used in the binding of variable <code>$later</code>. For example, during its second iteration, this expression binds <code>$i</code> to <code>4</code> and <code>$j</code> to <code>6</code> (2+4):</p>
<pre dir="ltr"> for $i in (3, 4), $j in ($i, 2+$i)
</pre></li>
<li>
<p><span class="bold"><code>let</code></span> &ndash; Bind one or more variables.</p>
<p>Just as with <code>for</code>, a variable can be bound by <code>let</code> to a value computed using another variable that is listed previously in the binding list of the <code>let</code> (or an enclosing <code>for</code> or <code>let</code>). For example, this expression binds <code>$j</code> to <code>5</code> (3+2):</p>
<pre dir="ltr">let $i := 3, $j := $i + 2
</pre></li>
<li>
<p><span class="bold"><code>where</code></span> &ndash; Filter the <code>for</code> and <code>let</code> variable bindings according to some condition. This is similar to a SQL <code>WHERE</code> clause.</p>
</li>
<li>
<p><span class="bold"><code>order by</code></span> &ndash; Sort the result of <code>where</code> filtering.</p>
</li>
<li>
<p><span class="bold"><code>return</code></span> &ndash; Construct a result from the ordered, filtered values. This is the result of the FLWOR expression as a whole. It is a flattened sequence.</p>
<p>If the <code>return</code> clause contains an updating expression then that expression is evaluated for each tuple generated by the other clauses. The pending update lists from these evaluations are then merged as the result of the FLWOR expression.</p>
</li>
</ul>
<p>Expressions <code>for</code> and <code>let</code> act similarly to a SQL <code>FROM</code> clause. Expression <code>where</code> acts like a SQL <code>WHERE</code> clause Expression <code>order by</code> is similar to <code>ORDER BY</code> in SQL. Expression <code>return</code> is like <code>SELECT</code> in SQL. Except for the two keywords whose names are the same in both languages (<code>where</code>, <code>order by</code>), FLWOR clause order is more or less opposite to the SQL clause order, but the meanings of the corresponding clauses are quite similar.</p>
<p>Note that using a FLWOR expression (with <code>order by</code>) is the <span class="italic">only</span> way to construct an XQuery sequence in any order other than document order.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB5088"></a>
<div class="props_rev_3"><a id="GUID-7DB63F8C-F441-4635-A185-4016016B22CE"></a>
<h2 id="ADXDB-GUID-7DB63F8C-F441-4635-A185-4016016B22CE" class="sect2"><span class="enumeration_section">4.2</span> Overview of XQuery in Oracle XML&nbsp;DB</h2>
<div>
<p>Oracle XML&nbsp;DB support for the XQuery language is provided through a native implementation of SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>. As a convenience, SQL*Plus command <code>XQUERY</code> is also provided, which lets you enter XQuery expressions directly&thinsp;&mdash;&thinsp;in effect, this command turns SQL*Plus into an XQuery command-line interpreter.</p>
<p>Oracle XML&nbsp;DB compiles XQuery expressions that are passed as arguments to SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>. This compilation produces SQL query blocks and operator trees that use SQL/XML functions and XPath functions. A SQL statement that includes <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, or <code>XMLCast</code> is compiled and optimized as a whole, leveraging both relational database and XQuery-specific optimization technologies. Depending on the XML storage and indexing methods used, XPath functions can be further optimized. The resulting optimized operator tree is executed in a streaming fashion.</p>
<div class="infobox-note" id="GUID-7DB63F8C-F441-4635-A185-4016016B22CE__GUID-782F88A1-4C1E-49D8-9A87-926C369F0A33">
<p class="notep1">Note:</p>
<p>Oracle XML Developer&#39;s Kit (XDK) supports XQuery on the mid-tier. You do not need access to Oracle Database to use XQuery. XDK lets you evaluate XQuery expressions using XQuery API for Java (XQJ).</p>
</div>
<div class="infoboxnotealso" id="GUID-7DB63F8C-F441-4635-A185-4016016B22CE__GUID-1F192021-649E-4547-B18B-3A10DE22BEAB">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_xquery.htm#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY_ XMLTABLE_ XMLExists_ and XMLCast</a> and <span class="q">&#34;<a href="xdb04cre.htm#GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1" title="You can evaluate an XQuery expression using the SQL*Plus XQUERY command.">Using the SQL*Plus XQUERY Command</a>&#34;</span></p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" title="Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, http://xmlns.oracle.com/xdb, which uses the predefined prefix ora.">Oracle XQuery Extension Functions</a> for Oracle-specific XQuery functions that extend the language</p>
</li>
<li>
<p><a href="xdb_xquery.htm#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" title="Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.">Oracle XML&nbsp;DB Support for XQuery</a> for details about Oracle XML&nbsp;DB support for XQuery</p>
</li>
<li>
<p><a href="xdb04cre.htm#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="There are many ways for applications to query and update XML data that is in Oracle Database, both XML schema-based and non-schema-based.">Query and Update of XML Data</a></p>
</li>
<li>
<p><a class="olink ADXDK99930" target="_blank" href="../ADXDK/adx_j_xqj.htm#ADXDK99930"><span class="italic">Oracle XML Developer&#39;s Kit Programmer&#39;s Guide</span></a> for information about using XQJ</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB5103"></a>
<div class="props_rev_3"><a id="GUID-8686CFE4-C9C3-44A3-8A45-868A5EA34FA8"></a>
<h3 id="ADXDB-GUID-8686CFE4-C9C3-44A3-8A45-868A5EA34FA8" class="sect3"><span class="enumeration_section">4.2.1</span> When To Use XQuery</h3>
<div>
<p>You can use XQuery to do many of the same things that you might do using the SQL/XML generation functions or XSLT; there is a great deal of overlap. The decision to use one or the other tool to accomplish a given task can be based on many considerations, most of which are not specific to Oracle Database. Please consult external documentation on this general question.</p>
<p>A general pattern of use is that XQuery is often used when the focus is the world of XML data, and the SQL/XML generation functions (<code>XMLElement</code>, <code>XMLAgg</code>, and so on) are often used when the focus is the world of relational data.</p>
<p>Other things being equal, if a query constructs an XML document from fragments extracted from existing XML documents, then it is likely that an XQuery FLOWR expression is simpler (simplifying code maintenance) than extracting scalar values from relational data and constructing appropriate XML data using SQL/XML generation functions. If, instead, a query constructs an XML document from existing relational data, the SQL/XML generation functions can often be more suitable.</p>
<p>With respect to Oracle XML&nbsp;DB, you can expect the same general level of performance using the SQL/XML generation functions as with <code>XMLQuery</code> and <code>XMLTable</code>&thinsp;&mdash;&thinsp;all are subject to rewrite optimizations.</p>
</div>
</div>
<a id="ADXDB5105"></a><a id="ADXDB5104"></a>
<div class="props_rev_3"><a id="GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702"></a>
<h3 id="ADXDB-GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702" class="sect3"><span class="enumeration_section">4.2.2</span> Predefined XQuery Namespaces and Prefixes</h3>
<div>
<p>Several namespaces and prefixes are predefined for use with XQuery in Oracle XML&nbsp;DB.</p>
<div class="section"></div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702__GUID-C082A7D9-3289-4D4E-8F2A-BFA3AA934064">
<p class="titleintable">Table 4-2 Predefined Namespaces and Prefixes</p>
<table class="cellalignment3431" title="Predefined Namespaces and Prefixes" summary="Predefined namespaces and prefixes">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3496" id="d24143e1645">Prefix</th>
<th class="cellalignment3497" id="d24143e1648">Namespace</th>
<th class="cellalignment3462" id="d24143e1651">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3498" id="d24143e1656" headers="d24143e1645">
<p><code>ora</code></p>
</td>
<td class="cellalignment3499" headers="d24143e1656 d24143e1648">
<p><code>http://xmlns.oracle.com/xdb</code></p>
</td>
<td class="cellalignment3465" headers="d24143e1656 d24143e1651">
<p>Oracle XML&nbsp;DB namespace</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3498" id="d24143e1668" headers="d24143e1645">
<p><code>local</code></p>
</td>
<td class="cellalignment3499" headers="d24143e1668 d24143e1648">
<p><code>http://www.w3.org/2003/11/xpath-local-functions</code></p>
</td>
<td class="cellalignment3465" headers="d24143e1668 d24143e1651">
<p>XPath local function declaration namespace</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3498" id="d24143e1680" headers="d24143e1645">
<p><code>fn</code></p>
</td>
<td class="cellalignment3499" headers="d24143e1680 d24143e1648">
<p><code>http://www.w3.org/2003/11/xpath-functions</code></p>
</td>
<td class="cellalignment3465" headers="d24143e1680 d24143e1651">
<p>XPath function namespace</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3498" id="d24143e1692" headers="d24143e1645">
<p><code>xml</code></p>
</td>
<td class="cellalignment3499" headers="d24143e1692 d24143e1648">
<p><code>http://www.w3.org/XML/1998/namespace</code></p>
</td>
<td class="cellalignment3465" headers="d24143e1692 d24143e1651">
<p>XML namespace</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3498" id="d24143e1704" headers="d24143e1645">
<p><code>xs</code></p>
</td>
<td class="cellalignment3499" headers="d24143e1704 d24143e1648">
<p><code>http://www.w3.org/2001/XMLSchema</code></p>
</td>
<td class="cellalignment3465" headers="d24143e1704 d24143e1651">
<p>XML Schema namespace</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3498" id="d24143e1716" headers="d24143e1645">
<p><code>xsi</code></p>
</td>
<td class="cellalignment3499" headers="d24143e1716 d24143e1648">
<p><code>http://www.w3.org/2001/XMLSchema-instance</code></p>
</td>
<td class="cellalignment3465" headers="d24143e1716 d24143e1651">
<p>XML Schema instance namespace</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p>You can use these prefixes in XQuery expressions without first declaring them in the XQuery-expression prolog. You can redefine any of them <span class="italic">except</span> <code>xml</code> in the prolog. All of these prefixes except <code>ora</code> are predefined in the XQuery standard.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB5093"></a>
<div class="props_rev_3"><a id="GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392"></a>
<h2 id="ADXDB-GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" class="sect2"><span class="enumeration_section">4.3</span> SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</h2>
<div>
<p>SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code> are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.</p>
<p>They are referred to in this book as SQL/XML <span class="italic">query and update</span> functions. As is the case for the other SQL/XML functions, these functions let you take advantage of the power and flexibility of both SQL and XML. Using these functions, you can construct XML data using relational data, query relational data as if it were XML, and construct relational data from XML data.</p>
<p>SQL functions <code>XMLExists</code> and <code>XMLCast</code> are documented elsewhere in this chapter. This section presents functions <code>XMLQuery</code> and <code>XMLTable</code>, but many of the examples in this chapter use also <code>XMLExists</code> and <code>XMLCast</code>. In terms of typical use:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>XMLQuery</code> and <code>XMLCast</code> are typically used in a <code>SELECT</code> list.</p>
</li>
<li>
<p><code>XMLTable</code> is typically used in a SQL <code>FROM</code> clause.</p>
</li>
<li>
<p><code>XMLExists</code> is typically used in a SQL <code>WHERE</code> clause.</p>
</li>
</ul>
<p>Both <code>XMLQuery</code> and <code>XMLTable</code> evaluate an XQuery expression. In the XQuery language, an expression always returns a sequence of items. Function <code>XMLQuery</code> aggregates the items in this sequence to return a single XML document or fragment. Function <code>XMLTable</code> returns a SQL table whose rows each contain one item from the XQuery sequence.</p>
<div class="infoboxnotealso" id="GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392__GUID-F1AFE77A-6B26-4920-BC53-E8AFFB715196">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF55529" target="_blank" href="../SQLRF/ap_standard_sql010.htm#SQLRF55529"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about Oracle support for the SQL/XML standard</p>
</li>
<li>
<p><a href="http://www.w3.org/" target="_blank"><code>http://www.w3.org/</code></a> for information about the XQuery language</p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb13gen.htm#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML&nbsp;DB provides SQL functions that you can use to construct XML data. Most of these belong to the SQL/XML standard.">Generation of XML Data Using SQL Functions</a>&#34;</span> for information about using other SQL/XML functions with Oracle XML&nbsp;DB</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB5095"></a><a id="ADXDB5096"></a><a id="ADXDB5094"></a>
<div class="props_rev_3"><a id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D"></a>
<h3 id="ADXDB-GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D" class="sect3"><span class="enumeration_section">4.3.1</span> XMLQUERY SQL/XML Function in Oracle XML&nbsp;DB</h3>
<div>
<p>Use SQL/XML function <code>XMLQuery</code> to construct or query XML data.</p>
<div class="section">
<p>The function takes as arguments an <span class="italic">XQuery expression</span>, as a string literal, and an optional XQuery <span class="italic">context item</span>, as a SQL expression. The context item establishes the XPath context in which the XQuery expression is evaluated. Additionally, <code>XMLQuery</code> accepts as arguments any number of SQL expressions whose values are bound to XQuery variables during the XQuery expression evaluation.</p>
<p>The function returns the result of evaluating the XQuery expression, as an <code>XMLType</code> instance.</p>
<div class="figure" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-5949ADC3-2BA0-4D1B-B977-2392E58209CE">
<p class="titleinfigure">Figure 4-1 XMLQUERY Syntax</p>
<img width="742" height="103" src="img/GUID-26809864-8A41-43D1-A8BF-BBB6C1C69F29-default.gif" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows"/><br/>
<a href="img_text/GUID-26809864-8A41-43D1-A8BF-BBB6C1C69F29-print.htm">Description of &#34;Figure 4-1 XMLQUERY Syntax&#34;</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XML_passing_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-8DD05470-F308-4A02-B114-EEFFB46AA784"><img width="484" height="79" src="img/GUID-18777924-2A02-45F2-90BA-82B113F94AA7-default.gif" alt="Description of GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps follows" title="Description of GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps follows"/><br/>
<a href="img_text/GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.htm">Description of the illustration GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps</a></div>
<!-- class="figure" -->
<ul style="list-style-type: disc;">
<li>
<p><span class="italic"><code>XQuery_string</code></span> is a complete XQuery expression, possibly including a prolog, as a literal string.</p>
</li>
<li>
<p>The <span class="italic"><code>XML_passing_clause</code></span> is the keyword <code>PASSING</code> followed by one or more SQL expressions (<span class="italic"><code>expr</code></span>) that each return an <code>XMLType</code> instance or an instance of a SQL scalar data type (that is, not an object or collection data type). Each expression (<span class="italic"><code>expr</code></span>) can be a table or view column value, a PL/SQL variable, or a bind variable with proper casting. All but possibly one of the expressions must each be followed by the keyword <code>AS</code> and an XQuery <span class="italic"><code>identifier</code></span>. The result of evaluating each <span class="italic"><code>expr</code></span> is bound to the corresponding <span class="italic"><code>identifier</code></span> for the evaluation of <span class="italic"><code>XQuery_string</code></span>. If there is an <span class="italic"><code>expr</code></span> that is not followed by an <code>AS</code> clause, then the result of evaluating that <span class="italic"><code>expr</code></span> is used as the <span class="italic">context</span> item for evaluating <span class="italic"><code>XQuery_string</code></span>. Oracle XML&nbsp;DB supports only passing <code>BY VALUE</code>, not passing <code>BY REFERENCE</code>, so the clause <code>BY VALUE</code> is implicit and can be omitted.</p>
</li>
<li>
<p><code>RETURNING</code> <code>CONTENT</code> indicates that the value returned by an application of <code>XMLQuery</code> is an instance of parameterized XML type <code>XML(CONTENT)</code>, not parameterized type <code>XML(SEQUENCE)</code>. It is a document fragment that conforms to the <span class="italic">extended</span> Infoset data model. As such, it is a single document node with any number of children. The children can each be of any XML node type; in particular, they can be text nodes.</p>
<p>Oracle XML&nbsp;DB supports only the <code>RETURNING CONTENT</code> clause of SQL/XML function <code>XMLQuery</code>; it does <span class="italic">not</span> support the <code>RETURNING SEQUENCE</code> clause.</p>
</li>
</ul>
<p>You can pass an <code>XMLType</code> column, table, or view as the context-item argument to function <code>XMLQuery</code>&thinsp;&mdash;&thinsp;see, for example, <a href="xdb04cre.htm#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBADDAEJ">Example 5-8</a>.</p>
<p>To query a relational table or view as if it were XML data, without having to first create a SQL/XML view on top of it, use XQuery function <code>fn:collection</code> within an XQuery expression, passing as argument a URI that uses the URI-scheme name <code>oradb</code> together with the database location of the data. See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B" title="You can use XQuery function fn:collection to query data that is in database tables and views.">URI Scheme oradb: Querying Table or View Data with XQuery</a>&#34;</span>.</p>
<div class="infobox-note" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-26743142-E095-4BF3-91EE-6E9917038A40">
<p class="notep1">Note:</p>
<p>Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL functions <code>extract</code> and <code>extractValue</code> to do some of what can be done better using SQL/XML functions <code>XMLQuery</code> and <code>XMLCast</code>. SQL functions <code>extract</code> and <code>extractValue</code> are <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2.</p>
</div>
<div class="infoboxnotealso" id="GUID-39CDBF4D-258D-4CFE-AEBF-06ECD660C08D__GUID-057688BE-89D5-4DE4-8F00-3BE6BA782D4C">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF06209" target="_blank" href="../SQLRF/functions265.htm#SQLRF06209"><span class="italic">Oracle Database SQL Language Reference</span></a> for reference information about SQL/XML function <code>XMLQuery</code> in Oracle Database</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5098"></a><a id="ADXDB5099"></a><a id="ADXDB5100"></a><a id="ADXDB5101"></a><a id="ADXDB5102"></a><a id="ADXDB5097"></a>
<div class="props_rev_3"><a id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10"></a>
<h3 id="ADXDB-GUID-F4508470-D420-4B5A-B5DF-59A424887F10" class="sect3"><span class="enumeration_section">4.3.2</span> XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</h3>
<div>
<p>You use SQL/XML function <code>XMLTable</code> to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL &mdash; in a join expression, for example.</p>
<div class="section">
<p>See<a href="xdb04cre.htm#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAHBFGE">Example 5-9</a>.</p>
<p>You use <code>XMLTable</code> in a SQL <code>FROM</code> clause.</p>
<div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-B85490F0-F81B-4EBA-B66B-CAA4F604A14F">
<p class="titleinfigure">Figure 4-2 XMLTABLE Syntax</p>
<img width="626" height="46" src="img/GUID-14DE5BFE-8912-4A95-B9F8-BBC6A0FA6BEA-default.gif" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows"/><br/>
<a href="img_text/GUID-14DE5BFE-8912-4A95-B9F8-BBC6A0FA6BEA-print.htm">Description of &#34;Figure 4-2 XMLTABLE Syntax&#34;</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XML_namespaces_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-55CA4B10-7AF2-4267-B4E9-97D32D783A1B"><img width="433" height="91" src="img/GUID-98B4619E-4AD1-47EB-B3C1-26CE1A08B8BA-default.gif" alt="Description of GUID-98B4619E-4AD1-47EB-B3C1-26CE1A08B8BA-print.eps follows" title="Description of GUID-98B4619E-4AD1-47EB-B3C1-26CE1A08B8BA-print.eps follows"/><br/>
<a href="img_text/GUID-98B4619E-4AD1-47EB-B3C1-26CE1A08B8BA-print.htm">Description of the illustration GUID-98B4619E-4AD1-47EB-B3C1-26CE1A08B8BA-print.eps</a>
<p><span class="bold">Note:</span> You can specify at most one DEFAULT <span class="italic">string</span> clause.</p>
</div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XMLTABLE_options ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-1F93FAB4-CDF9-4E02-ADE6-0AAEA6CC6D48"><img width="805" height="70" src="img/GUID-DF8AC90E-0C70-4285-9B37-0E22E0F68450-default.gif" alt="Description of GUID-DF8AC90E-0C70-4285-9B37-0E22E0F68450-print.eps follows" title="Description of GUID-DF8AC90E-0C70-4285-9B37-0E22E0F68450-print.eps follows"/><br/>
<a href="img_text/GUID-DF8AC90E-0C70-4285-9B37-0E22E0F68450-print.htm">Description of the illustration GUID-DF8AC90E-0C70-4285-9B37-0E22E0F68450-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XML_passing_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-447FD369-E6FC-40BE-8617-22B8E9C6DDD5"><img width="484" height="79" src="img/GUID-18777924-2A02-45F2-90BA-82B113F94AA7-default.gif" alt="Description of GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps follows" title="Description of GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps follows"/><br/>
<a href="img_text/GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.htm">Description of the illustration GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XML_table_column ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-C286CD70-ABAA-48B9-92F5-2408B2C78985"><img width="777" height="168" src="img/GUID-1202CC4E-5DD4-45A5-AC2A-23A76594F4ED-default.gif" alt="Description of GUID-1202CC4E-5DD4-45A5-AC2A-23A76594F4ED-print.eps follows" title="Description of GUID-1202CC4E-5DD4-45A5-AC2A-23A76594F4ED-print.eps follows"/><br/>
<a href="img_text/GUID-1202CC4E-5DD4-45A5-AC2A-23A76594F4ED-print.htm">Description of the illustration GUID-1202CC4E-5DD4-45A5-AC2A-23A76594F4ED-print.eps</a></div>
<!-- class="figure" -->
<ul style="list-style-type: disc;">
<li>
<p><span class="italic"><code>XQuery_string</code></span> is sometimes called the <strong class="term">row pattern</strong> of the XMLTable call. It is a complete XQuery expression, possibly including a prolog, as a literal string. The value of the expression serves as input to the <code>XMLTable</code> function; it is this XQuery result that is decomposed and stored as relational data.</p>
</li>
<li>
<p>The optional <code>XMLNAMESPACES</code> clause contains XML namespace declarations that are referenced by <span class="italic"><code>XQuery_string</code></span> and by the XPath expression in the <code>PATH</code> clause of <span class="italic"><code>XML_table_column</code></span>.</p>
</li>
<li>
<p>The <span class="italic"><code>XML_passing_clause</code></span> is the keyword <code>PASSING</code> followed by one or more SQL expressions (<span class="italic"><code>expr</code></span>) that each return an <code>XMLType</code> instance or an instance of a SQL scalar data type (that is, not an object or collection data type). Each expression (<span class="italic"><code>expr</code></span>) can be a table or view column value, a PL/SQL variable, or a bind variables with proper casting. All but possibly one of the expressions must each be followed by the keyword <code>AS</code> and an XQuery <span class="italic"><code>identifier</code></span>. The result of evaluating each <span class="italic"><code>expr</code></span> is bound to the corresponding <span class="italic"><code>identifier</code></span> for the evaluation of <span class="italic"><code>XQuery_string</code></span>. If there is an <span class="italic"><code>expr</code></span> that is not followed by an <code>AS</code> clause, then the result of evaluating that <span class="italic"><code>expr</code></span> is used as the <span class="italic">context</span> item for evaluating <span class="italic"><code>XQuery_string</code></span>. Oracle XML&nbsp;DB supports only passing <code>BY VALUE</code>, not passing <code>BY REFERENCE</code>, so the clause <code>BY VALUE</code> is implicit and can be omitted.</p>
</li>
<li>
<p>The optional <code>COLUMNS</code> clause defines the columns of the virtual table to be created by <code>XMLTable</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p>If you omit the <code>COLUMNS</code> clause, then <code>XMLTable</code> returns a row with a single <code>XMLType</code> pseudo-column, named <span class="bold"><code>COLUMN_VALUE</code></span>.</p>
</li>
<li>
<p><code>FOR ORDINALITY</code> specifies that <span class="italic"><code>column</code></span> is to be a column of generated row numbers (SQL data type <code>NUMBER</code>). The row numbers start with 1. There must be at most one <code>FOR ORDINALITY</code> clause.</p>
</li>
<li>
<p>For each resulting <span class="italic"><code>column</code></span> except the <code>FOR ORDINALITY</code> column, you must specify the column data type, which can be <code>XMLType</code> or any other SQL data type (called <span class="italic"><code>datatype</code></span> in the syntax description).</p>
</li>
<li>
<p>For data type <code>XMLType</code>, if you also include the specification <code>(SEQUENCE) BY REF</code> then a <span class="italic">reference</span> to the source data targeted by the <code>PATH</code> expression (<span class="italic"><code>string</code></span>) is returned as the <span class="italic"><code>column</code></span> content. Otherwise, <span class="italic"><code>column</code></span> contains a <span class="italic">copy</span> of that targeted data.</p>
<p>Returning the <code>XMLType</code> data by reference lets you specify other columns whose paths target nodes in the source data that are outside those targeted by the <code>PATH</code> expression for <span class="italic"><code>column</code></span>. See <a href="xdb04cre.htm#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__BABIDCFE">Example 5-13</a>.</p>
</li>
<li>
<p>The optional <code>PATH</code> clause specifies that the portion of the XQuery result that is addressed by XQuery expression <span class="italic"><code>string</code></span> is to be used as the <span class="italic"><code>column</code></span> content. This XQuery expression is sometimes called the <span class="bold">column pattern</span>. You can use multiple <code>PATH</code> clauses to split the XQuery result into different virtual-table columns.</p>
<p>If you omit <code>PATH</code>, then the XQuery expression <span class="italic"><code>column</code></span> is assumed. For example, these two expressions are equivalent:</p>
<pre dir="ltr">XMLTable(... COLUMNS foo)
XMLTable(... COLUMNS foo PATH &#39;FOO&#39;)
</pre>
<p>The XQuery expression <span class="italic"><code>string</code></span> must represent a <span class="italic">relative</span> path; it is relative to the path <span class="italic"><code>XQuery_string</code></span>.</p>
</li>
<li>
<p>The optional <code>DEFAULT</code> clause specifies the value to use when the <code>PATH</code> expression results in an empty sequence (or <code>NULL</code>). Its <span class="italic"><code>expr</code></span> is an XQuery expression that is evaluated to produce the default value.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-FF0F3AA8-D2A7-457A-97B7-EBB42D7C4ACB">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF06232" target="_blank" href="../SQLRF/functions269.htm#SQLRF06232"><span class="italic">Oracle Database SQL Language Reference</span></a> for reference information about SQL/XML function <code>XMLTable</code> in Oracle Database</p>
</div>
<div class="infobox-note" id="GUID-F4508470-D420-4B5A-B5DF-59A424887F10__GUID-A2D89F13-FE6B-424B-BF70-BC904227B704">
<p class="notep1">Note:</p>
<p>Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL function <code>XMLSequence</code> within a SQL <code>TABLE</code> collection expression, that is, <code>TABLE (XMLSequence(...))</code>, to do some of what can be done better using SQL/XML function <code>XMLTable</code>. Function <code>XMLSequence</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2.</p>
<p>See <a class="olink SQLRF30047" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF30047"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the SQL <code>TABLE</code> collection expression.</p>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDB6416"></a><a id="ADXDB6415"></a>
<div class="props_rev_3"><a id="GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E"></a>
<h4 id="ADXDB-GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E" class="sect4"><span class="enumeration_section">4.3.2.1</span> Chaining Calls to SQL/XML Function XMLTABLE</h4>
<div>
<p>When you need to expose data contained at multiple levels in an <code>XMLType</code> table as individual rows in a relational table (or view), you use the same general approach as for breaking up a single level: Use SQL/XML function <code>XMLTable</code> to define the columns making up the table and map the XML nodes to those columns.</p>
<div class="section">
<p>But in this case you apply function <code>XMLTable</code> to each document level that is to be broken up and stored in relational columns. Use this technique of <a id="d24143e2609" class="indexterm-anchor"></a><strong class="term">chaining</strong> multiple <code>XMLTable</code> calls whenever there is a one-to-<span class="italic">many</span> (1:N) relationship between documents in the <code>XMLType</code> table and the rows in the relational table.</p>
<p>You pass one level of <code>XMLType</code> data from one <code>XMLTable</code> call to the next, specifying its column type as <code>XMLType</code>.</p>
<p>When you chain two <code>XMLTable</code> calls, the <span class="italic">row pattern</span> of each call should target the <span class="italic">deepest node that is a common ancestor</span> to all of the nodes that are referenced in the <span class="italic">column patterns</span> of that call.</p>
<p>This is illustrated in <a href="xdb_xquery.htm#GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E__BABGABBE">Example 4-1</a>.</p>
<p>Each <code>PurchaseOrder</code> element in <code>XMLType</code> table <code>po_binaryxml</code> contains a <code>LineItems</code> element, which in turn contains one or more <code>LineItem</code> elements. Each <code>LineItem</code> element has child elements, such as <code>Description</code>, and an <code>ItemNumber</code> attribute. To make such lower-level data accessible as a relational value, you use <code>XMLTable</code> to project the collection of <code>LineItem</code> elements.</p>
<p>When element <code>PurchaseOrder</code> is decomposed by the first call to <code>XMLTable</code>, its descendant <code>LineItem</code> element is mapped to a column of type <code>XMLType</code>, which contains an XML fragment. That column is then passed to a second call to <code>XMLTable</code> to be broken by it into its various parts as multiple columns of relational values.</p>
<p>The first call to <code>XMLTable</code> uses <code>/PurchaseOrder</code> as the row pattern, because <code>PurchaseOrder</code> is the deepest common ancestor node for the column patterns, <code>Reference</code> and <code>LineItems/LineItem</code>.</p>
<p>The second call to <code>XMLTable</code> uses <code>/LineItem</code> as its row pattern, because that node is the deepest common ancestor node for each of its column patterns (<code>@ItemNumber</code>, <code>Description</code>, <code>Part/@Id</code>, and so on).</p>
<p>The <span class="italic">column pattern</span> (<code>LineItems/LineItem</code>) for the column (<code>po.lineitem</code>) that is passed from the first <code>XMLTable</code> call t o the second <span class="italic">ends with the repeating element</span> (<code>LineItem</code>) that the second <code>XMLTable</code> call decomposes. That repeating element, written with a leading slash (<code>/</code>), is used as the first element of the <span class="italic">row pattern</span> for the second <code>XMLTable</code> call.</p>
<p>The row pattern in each case is thus expressed as an <span class="italic">absolute</span> path; that is, it starts with <code>/</code>. It is the starting point for decomposition by <code>XMLTable</code>. Column patterns, on the other hand, <span class="italic">never</span> start with a slash (<code>/</code>); they are always relative to the row pattern of the same <code>XMLTable</code> call.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-B5B1706E-21E9-4F05-8AD6-C179F705888E__BABGABBE">
<p class="titleinexample">Example 4-1 Chaining XMLTable Calls</p>
<pre dir="ltr">  SELECT po.reference, li.*
    FROM po_binaryxml p,
         XMLTable(&#39;<span class="bold">/PurchaseOrder</span>&#39; PASSING p.OBJECT_VALUE
                  COLUMNS
                    reference VARCHAR2(30) PATH &#39;Reference&#39;,
                    <span class="bold">lineitem</span>  XMLType      PATH &#39;<span class="bold">LineItems/LineItem</span>&#39;) po,
         XMLTable(&#39;<span class="bold">/LineItem</span>&#39; PASSING <span class="bold">po.lineitem</span>
                  COLUMNS
                    itemno      NUMBER(38)    PATH &#39;@ItemNumber&#39;,
                    description VARCHAR2(256) PATH &#39;Description&#39;,
                    partno      VARCHAR2(14)  PATH &#39;Part/@Id&#39;,
                    quantity    NUMBER(12, 2) PATH &#39;Part/@Quantity&#39;,
                    unitprice   NUMBER(8, 4)  PATH &#39;Part/@UnitPrice&#39;) li;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB4239"></a><a id="ADXDB4240"></a><a id="ADXDB4238"></a>
<div class="props_rev_3"><a id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6"></a>
<h3 id="ADXDB-GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6" class="sect3"><span class="enumeration_section">4.3.3</span> XMLEXISTS SQL/XML Function in Oracle XML&nbsp;DB</h3>
<div>
<p>SQL/XML standard function <code>XMLExists</code> checks whether a given XQuery expression returns a non-empty XQuery sequence. If so, the function returns <code>TRUE</code>. Otherwise, it returns <code>FALSE</code>.</p>
<div class="section">
<p><a href="xdb_xquery.htm#GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__CFHIBEGB">Figure 4-3</a> describes the syntax for function <code>XMLExists</code>.</p>
<div class="figure" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__CFHIBEGB">
<p class="titleinfigure">Figure 4-3 XMLExists Syntax</p>
<img width="447" height="46" src="img/GUID-30652CF5-6C90-475A-9CAB-3A6BF28CD88A-default.gif" alt="Description of Figure 4-3 follows" title="Description of Figure 4-3 follows"/><br/>
<a href="img_text/GUID-30652CF5-6C90-475A-9CAB-3A6BF28CD88A-print.htm">Description of &#34;Figure 4-3 XMLExists Syntax&#34;</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XML_passing_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__GUID-8C4E0A2C-FA1A-4D29-BFD8-62AA1CBCE53C"><img width="484" height="79" src="img/GUID-18777924-2A02-45F2-90BA-82B113F94AA7-default.gif" alt="Description of GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps follows" title="Description of GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps follows"/><br/>
<a href="img_text/GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.htm">Description of the illustration GUID-18777924-2A02-45F2-90BA-82B113F94AA7-print.eps</a></div>
<!-- class="figure" -->
<ul style="list-style-type: disc;">
<li>
<p><span class="italic"><code>XQuery_string</code></span> is a complete XQuery expression, possibly including a prolog, as a literal string. It can contain XQuery variables that you bind using the XQuery <code>PASSING</code> clause (<span class="italic"><code>XML_passing_clause</code></span> in the syntax diagram). The predefined namespace prefixes recognized for SQL/XML function <code>XMLQuery</code> are also recognized in <span class="italic"><code>XQuery_string</code></span>&thinsp;&mdash;&thinsp;see <span class="q">&#34;<a href="xdb_xquery.htm#GUID-2DBF9D49-9C20-45F8-BB11-CB68DAF4F702" title="Several namespaces and prefixes are predefined for use with XQuery in Oracle XML&nbsp;DB.">Predefined XQuery Namespaces and Prefixes</a>&#34;</span>.</p>
</li>
<li>
<p>The <span class="italic"><code>XML_passing_clause</code></span> is the keyword <code>PASSING</code> followed by one or more SQL expressions (<span class="italic"><code>expr</code></span>) that each return an <code>XMLType</code> instance or an instance of a SQL scalar data type. All but possibly one of the expressions must each be followed by the keyword <code>AS</code> and an XQuery <span class="italic"><code>identifier</code></span>. The result of evaluating each <span class="italic"><code>expr</code></span> is bound to the corresponding <span class="italic"><code>identifier</code></span> for the evaluation of <span class="italic"><code>XQuery_string</code></span>. If there is an <span class="italic"><code>expr</code></span> that is not followed by an <code>AS</code> clause, then the result of evaluating that <span class="italic"><code>expr</code></span> is used as the <span class="italic">context</span> item for evaluating <span class="italic"><code>XQuery_string</code></span>. Oracle XML&nbsp;DB supports only passing <code>BY VALUE</code>, not passing <code>BY REFERENCE</code>, so the clause <code>BY VALUE</code> is implicit and can be omitted.</p>
</li>
</ul>
<p>If an XQuery expression such as <code>/PurchaseOrder/Reference</code> or <code>/PurchaseOrder/Reference/text()</code> targets a single node, then <code>XMLExists</code> returns <code>true</code> for that expression. If <code>XMLExists</code> is called with an XQuery expression that locates no nodes, then <code>XMLExists</code> returns <code>false</code>.</p>
<p>Function <code>XMLExists</code> can be used in queries, and it can be used to create function-based indexes to speed up evaluation of queries.</p>
<div class="infobox-note" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__GUID-0CE1B7FB-A216-4280-A7D2-CDE65A76F854">
<p class="notep1">Note:</p>
<p>Oracle XML&nbsp;DB limits the use of <code>XMLExists</code> to a SQL <code>WHERE</code> clause or <code>CASE</code> expression. If you need to use <code>XMLExists</code> in a <code>SELECT</code> list, then wrap it in a <code>CASE</code> expression:</p>
<pre dir="ltr">CASE WHEN XMLExists(...) THEN &#39;TRUE&#39; ELSE &#39;FALSE&#39; END
</pre></div>
<div class="infobox-note" id="GUID-46B9D31A-3A4B-4902-A8C8-E6C72E0E74B6__GUID-13AC1800-DF31-4342-9A28-9D11C62444D6">
<p class="notep1">Note:</p>
<p>Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL function <code>existsNode</code> to do some of what can be done better using SQL/XML function <code>XMLExists</code>. Function <code>existsNode</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2. The two functions differ in these important ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>Function <code>existsNode</code> returns <code>0</code> or <code>1</code>. Function <code>XMLExists</code> returns a Boolean value, <code>TRUE</code> or <code>FALSE</code>.</p>
</li>
<li>
<p>You can use <code>existsNode</code> in a query <code>SELECT</code> list. You cannot use <code>XMLExists</code> directly in a <code>SELECT</code> list, but you can use <code>XMLExists</code> within a <code>CASE</code> expression in a <code>SELECT</code> list.</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4241"></a>
<div class="props_rev_3"><a id="GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09"></a>
<h3 id="ADXDB-GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09" class="sect3"><span class="enumeration_section">4.3.4</span> Using XMLExists to Find a Node</h3>
<div>
<p>You can use SQL/XML standard function <code>XMLExists</code> to find a given node. You can create function-based indexes using <code>XMLExists</code>. You can also create an <code>XMLIndex</code> index to help speed up arbitrary XQuery searching.</p>
<div class="section">
<p><a href="xdb_xquery.htm#GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09__CHDIJGAB">Example 4-2</a> uses <code>XMLExists</code> to select rows with <code>SpecialInstructions</code> set to <code>Expedite</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-5BE322B0-9CAD-4FC9-A9B5-4BB24B5A9F09__CHDIJGAB">
<p class="titleinexample">Example 4-2 Finding a Node Using SQL/XML Function XMLExists</p>
<pre dir="ltr">SELECT OBJECT_VALUE
  FROM purchaseorder
  WHERE XMLExists(&#39;/PurchaseOrder[SpecialInstructions=&#34;Expedite&#34;]&#39;
                  PASSING OBJECT_VALUE);
 
OBJECT_VALUE
--------------------------------------------------------------------
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
&lt;PurchaseOrder xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
 
13 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4250"></a><a id="ADXDB4249"></a>
<div class="props_rev_3"><a id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB"></a>
<h3 id="ADXDB-GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB" class="sect3"><span class="enumeration_section">4.3.5</span> XMLCAST SQL/XML Function in Oracle XML&nbsp;DB</h3>
<div>
<p>You can use SQL/XML function <code>XMLCast</code> to cast an XQuery value to a SQL data type.</p>
<div class="section">
<p><a href="xdb_xquery.htm#GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__CFHFDHHJ">Figure 4-4</a> describes the syntax for SQL/XML standard function <code>XMLCast</code>.</p>
<div class="figure" id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__CFHFDHHJ">
<p class="titleinfigure">Figure 4-4 XMLCast Syntax</p>
<img width="383" height="27" src="img/GUID-19827F85-10DC-488C-9950-3AD00C99EEFC-default.gif" alt="Description of Figure 4-4 follows" title="Description of Figure 4-4 follows"/><br/>
<a href="img_text/GUID-19827F85-10DC-488C-9950-3AD00C99EEFC-print.htm">Description of &#34;Figure 4-4 XMLCast Syntax&#34;</a></div>
<!-- class="figure" -->
<p>SQL/XML standard function <code>XMLCast</code> casts its first argument to the scalar SQL data type specified by its second argument. The first argument is a SQL expression that is evaluated. Any of the following SQL data types can be used as the second argument:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>NUMBER</code></p>
</li>
<li>
<p><code>VARCHAR2</code></p>
</li>
<li>
<p><code>CHAR</code></p>
</li>
<li>
<p><code>CLOB</code></p>
</li>
<li>
<p><code>BLOB</code></p>
</li>
<li>
<p><code>REF XMLTYPE</code></p>
</li>
<li>
<p>any SQL date or time data type</p>
</li>
</ul>
<div class="infobox-note" id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__GUID-865D0C07-DE7D-4FB2-A5F1-4A1471F7A912">
<p class="notep1">Note:</p>
<p>Unlike the SQL/XML standard, Oracle XML&nbsp;DB limits the use of <code>XMLCast</code> to cast XML to a SQL scalar data type. Oracle XML&nbsp;DB does not support casting XML to XML or from a scalar SQL type to XML.</p>
</div>
<p>The result of evaluating the first <code>XMLCast</code> argument is an XML value. It is converted to the target SQL data type by using the XQuery atomization process and then casting the XQuery atomic values to the target data type. If this conversion fails, then an error is raised. If conversion succeeds, the result returned is an instance of the target data type.</p>
<div class="infobox-note" id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__GUID-6C201840-E65C-4C21-9AF4-AE2CDE8E6511">
<p class="notep1">Note:</p>
<ul style="list-style-type: disc;">
<li>
<p>Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL function <code>extractValue</code> to do some of what can be done better using SQL/XML functions <code>XMLQuery</code> and <code>XMLCast</code>. Function <code>extractValue</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2.</p>
</li>
<li>
<p>Function <code>extractValue</code> raises an error when its XPath expression argument matches multiple text nodes. <code>XMLCast</code> applied to an <code>XMLQuery</code> result returns the concatenation of the text nodes&thinsp;&mdash;&thinsp;it does <span class="italic">not</span> raise an error.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-5FE935A0-FA5A-447F-8F23-9AE2AF7BB6CB__GUID-8EF6398C-1A0F-4D64-96BD-7106D153A757">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46" title="B-tree indexes can be used advantageously with object-relational XMLType storage&thinsp;&mdash;&thinsp;they provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of XMLIndex.XMLIndex is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to XMLType data that is stored as binary XML.You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.Although the index content tables of an XMLIndex structured component are normal relational tables, they are also read-only: you cannot add or drop their columns or modify (insert, update, or delete) their rows. The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).In exchange partitioning, you exchange a table with a partition of another table. The first table (call it exchange_table) must have the same structure as the partition (call it partition) of the second table (call it table) with which it will be exchanged.Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general. Though you can create secondary indexes on path-table columns, you can generally ignore the path table itself. A secondary index on column VALUE is used with XPath expressions in a WHERE clause that have predicates involving string matches. For example:Even if you do not specify a secondary index for column VALUE when you create an XMLIndex index, a default secondary index is created on column VALUE. This default index has the default properties&thinsp;&mdash;&thinsp;in particular, it is an index for text (string-valued) data only.A few types of XPath expressions are not indexed by XMLIndex.Basic operations on an XMLIndex index include creating it, dropping it, altering it, and examining it. Examples are presented.You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.You can add extra secondary indexes to an XMLIndex unstructured component.An XMLIndex structured component indexes specific islands of structure in your XML data.When you create an XMLIndex index that has a structured component you can specify XML namespaces and storage options to use.You can use ALTER INDEX to add a structured component to an existing XMLIndex index.You can prevent ALTER INDEX from blocking when you add a group or column for the structured component of an XMLIndex index, so that queries that use the index do not need to wait.If an error is raised because some of your data does not match the data type used for the corresponding column of the structured XMLIndex component, you can in some cases simply modify the index by passing keyword MODIFY_COLUMN_TYPE to ALTER INDEX. If an XMLIndex index has both an unstructured and a structured component, then you can use ALTER INDEX to drop the structured component. You do this by dropping all of the structure groups that compose the structured component. Because the tables used for the structured component of an XMLIndex index are normal relational tables, you can index them using any standard relational indexes. To know whether a particular XMLIndex index has been used in resolving a query, you can examine an execution plan for the query. You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */. If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.Some examples are presented of defining XMLIndex indexes on subsets of XPath expressions.Rules that apply to XMLIndex path subsetting are described.There are several guidelines that can help you use XMLIndex with an unstructured component.There are several guidelines that can help you use XMLIndex with a structured component.If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.If a query raises error ORA-08181, check whether the base XMLType table of the query has an XMLIndex index with an unstructured component. If so, then manually synchronize the XMLIndex index using DBMS_XMLINDEX.syncIndex.The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects. Information about the standard database indexes is available in static public views USER_INDEXES, ALL_INDEXES, and DBA_INDEXES. Similar information about XMLIndex indexes is available in static public views USER_XML_INDEXES, ALL_XML_INDEXES, and DBA_XML_INDEXES.Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.The string value used for the PARAMETERS clause of a CREATE INDEX or ALTER INDEX statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures registerParameter and modifyParameter in package DBMS_XMLINDEX.The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.When you create an XMLIndex index, if there is no XMLIndex_parameters_clause, then the new index has only an unstructured component. If there is an XMLIndex_parameters_clause, but the PARAMETERS argument is empty (&#39;&#39;), then the result is the same: an index with only an unstructured component.Certain considerations apply to using XMLIndex_parameters.Certain considerations apply to using the PATHS clause.Certain considerations apply to using create_index_paths_clause and alter_index_paths_clause.Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.Certain considerations apply to using value_clause.Certain considerations apply to using the ASYNC clause.Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX. Certain considerations apply to using XMLIndex_xmltable_clause.Certain considerations apply to using column_clause.">XMLIndex</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4251"></a>
<div class="props_rev_3"><a id="GUID-A96B4300-2478-43AF-855F-7E104CCE925A"></a>
<h3 id="ADXDB-GUID-A96B4300-2478-43AF-855F-7E104CCE925A" class="sect3"><span class="enumeration_section">4.3.6</span> Using XMLCAST to Extract the Scalar Value of an XML Fragment</h3>
<div>
<p>You can use standard SQL/XML function <code>XMLCast</code> to extract the scalar value of an XML fragment.</p>
<div class="section">
<p>The query in <a href="xdb_xquery.htm#GUID-A96B4300-2478-43AF-855F-7E104CCE925A__CHDGFGBA">Example 4-3</a> extracts the scalar value of node <code>Reference</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-A96B4300-2478-43AF-855F-7E104CCE925A__CHDGFGBA">
<p class="titleinexample">Example 4-3 Extracting the Scalar Value of an XML Fragment Using XMLCAST</p>
<pre dir="ltr">SELECT XMLCast(XMLQuery(&#39;/PurchaseOrder/Reference&#39; PASSING OBJECT_VALUE
                                                   RETURNING CONTENT)
               AS VARCHAR2(100)) &#34;REFERENCE&#34;
  FROM purchaseorder
  WHERE XMLExists(&#39;/PurchaseOrder[SpecialInstructions=&#34;Expedite&#34;]&#39;
                  PASSING OBJECT_VALUE);
 
REFERENCE
----------------------------
AMCEWEN-20021009123336271PDT
SKING-20021009123336321PDT
AWALSH-20021009123337303PDT
JCHEN-20021009123337123PDT
AWALSH-20021009123336642PDT
SKING-20021009123336622PDT
SKING-20021009123336822PDT
AWALSH-20021009123336101PDT
WSMITH-20021009123336412PDT
AWALSH-20021009123337954PDT
SKING-20021009123338294PDT
WSMITH-20021009123338154PDT
TFOX-20021009123337463PDT
 
13 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB5995"></a><a id="ADXDB5994"></a>
<div class="props_rev_3"><a id="GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B"></a>
<h2 id="ADXDB-GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B" class="sect2"><span class="enumeration_section">4.4</span> URI Scheme oradb: Querying Table or View Data with XQuery</h2>
<div>
<p>You can use XQuery function <code>fn:collection</code> to query data that is in database tables and views.</p>
<div class="section">
<p>Besides using XQuery functions <code>fn:doc</code> and <code>fn:collection</code> to query resources in Oracle XML&nbsp;DB Repository (see<span class="q">&#34;<a href="xdb04cre.htm#GUID-767E262F-559F-4EBE-84C1-65683879E1D5" title="Examples are presented that use XQuery with XML data in Oracle XML&nbsp;DB Repository. You use XQuery functions fn:doc and fn:collection to query file and folder resources in the repository, respectively.">Querying XML Data in Oracle XML&nbsp;DB Repository Using XQuery</a>&#34;</span>), you can use <code>fn:collection</code> to query data in database tables and views.</p>
<p>To do this, you pass function <code>fn:collection</code> a URI argument that specifies the table or view to query. The Oracle URI scheme <code>oradb</code> identifies this usage: without it, the argument is treated as a repository location.</p>
<p>The table or view that is queried can be relational or of type <code>XMLType</code>. If relational, its data is converted on the fly and treated as XML. The result returned by <code>fn:collection</code> is always an XQuery sequence.</p>
<ul style="list-style-type: disc;">
<li>
<p>For an <code>XMLType</code> table, the root element of each XML document returned by <code>fn:collection</code> is the same as the root element of an XML document in the table.</p>
</li>
<li>
<p>For a relational table, the root element of each XML document returned by <code>fn:collection</code> is <code>ROW</code>. The children of the <code>ROW</code> element are elements with the same names (uppercase) as columns of the table. The content of a child element corresponds to the column data. That content is an XML element if the column is of type <code>XMLType</code>; otherwise (the column is a scalar type), the content is of type <code>xs:string</code>.</p>
</li>
</ul>
<p>The format of the URI argument passed to <code>fn:collection</code> is as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>For an <code>XMLType</code> or relational table or view, <span class="italic"><code>TABLE</code></span>, in database schema <span class="italic"><code>DB-SCHEMA</code></span>:</p>
<pre dir="ltr"><span class="bold">oradb:</span>/<span class="italic">DB-SCHEMA</span>/<span class="italic">TABLE</span>/
</pre>
<p>You can use <span class="bold"><code>PUBLIC</code></span> for <span class="italic"><code>DB-SCHEMA</code></span> if <span class="italic"><code>TABLE</code></span> is a public synonym or <span class="italic"><code>TABLE</code></span> is a table or view that is accessible to the database user currently logged in.</p>
</li>
<li>
<p>For an <code>XMLType</code> column in a <span class="italic">relational</span> table or view:</p>
<pre dir="ltr"><span class="bold">oradb:</span>/<span class="italic">DB-SCHEMA</span>/<span class="italic">REL-TABLE</span>/<span class="bold">ROW</span><span class="italic">PRED</span>/<span class="italic">X-COL</span>
</pre>
<p><span class="italic"><code>REL-TABLE</code></span> is a relational table or view; <span class="italic"><code>PRED</code></span> is an XPath predicate that does not involve any <code>XMLType</code> columns; and <span class="italic"><code>X-COL</code></span> is an <code>XMLType</code> column in <span class="italic"><code>REL-TABLE</code></span>. <span class="italic"><code>PRED</code></span> is optional; <span class="italic"><code>DB-SCHEMA</code></span>, <span class="italic"><code>REL-TABLE</code></span>, and <span class="italic"><code>X-COL</code></span> are required.</p>
</li>
</ul>
<p>Optional XPath predicate <span class="italic"><code>PRED</code></span> must satisfy the following conditions:</p>
<ul style="list-style-type: disc;">
<li>
<p>It does not involve any <code>XMLType</code> columns.</p>
</li>
<li>
<p>It involves only conjunctions (<code>and</code>) and disjunctions (<code>or</code>) of general equality and inequality comparisons (<code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, and <code>&lt;=</code>).</p>
</li>
<li>
<p>For each comparison operation: Either both sides name (non-XML) columns in <span class="italic"><code>REL-TABLE</code></span> or one side names such a column and the other is a value of the proper type, as specified in <a href="xdb_xquery.htm#GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B__BABCEJCJ" title="Column types allowed in comparison expressions of oradb predicates">Table 4-3</a>. Use of any other type raises an error.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B__BABCEJCJ">
<p class="titleintable">Table 4-3 oradb Expressions: Column Types for Comparisons</p>
<table class="cellalignment3420" title="oradb Expressions: Column Types for Comparisons" summary="Column types allowed in comparison expressions of oradb predicates">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3497" id="d24143e3944">Relational Column Type</th>
<th class="cellalignment3500" id="d24143e3947">XQuery Value Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3499" id="d24143e3952" headers="d24143e3944">
<p><code>VARCHAR2</code>, <code>CHAR</code></p>
</td>
<td class="cellalignment3501" headers="d24143e3952 d24143e3947">
<p><code>xs:string</code> or string literal</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3499" id="d24143e3965" headers="d24143e3944">
<p><code>NUMBER</code>, <code>FLOAT</code>, <code>BINARY_FLOAT</code>, <code>BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment3501" headers="d24143e3965 d24143e3947">
<p><code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, or numeric literal</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3499" id="d24143e3990" headers="d24143e3944">
<p><code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP WITH TIMEZONE</code>, <code>TIMESTAMP WITH LOCAL TIMEZONE</code></p>
</td>
<td class="cellalignment3501" headers="d24143e3990 d24143e3947">
<p><code>xs:date</code>, <code>xs:time</code>, or <code>xs:dateTime</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3499" id="d24143e4014" headers="d24143e3944">
<p><code>INTERVAL YEAR TO MONTH</code></p>
</td>
<td class="cellalignment3501" headers="d24143e4014 d24143e3947">
<p><code>xs:yearMonthDuration</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3499" id="d24143e4023" headers="d24143e3944">
<p><code>INTERVAL DAY TO SECOND</code></p>
</td>
<td class="cellalignment3501" headers="d24143e4023 d24143e3947">
<p><code>xs:dayTimeDuration</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3499" id="d24143e4032" headers="d24143e3944">
<p><code>RAW</code></p>
</td>
<td class="cellalignment3501" headers="d24143e4032 d24143e3947">
<p><code>xs:hexBinary</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3499" id="d24143e4041" headers="d24143e3944">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3501" headers="d24143e4041 d24143e3947">
<p><code>xs:string</code> or string literal</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p>For example, this XQuery expression represents all XML documents in <code>XMLType</code> column <code>warehouse_spec</code> of table <code>oe.warehouses</code>, for the rows where column <code>warehouse_id</code> has a value less than 6:</p>
<pre dir="ltr">fn:collection(&#39;oradb:/OE/WAREHOUSES/ROW[WAREHOUSE_ID &lt; 6]/WAREHOUSE_SPEC&#39;)
</pre>
<div class="infoboxnotealso" id="GUID-7B039748-7C2A-4D86-9C54-55F4D08ED59B__GUID-CF1D4523-EA5C-4793-AC76-31D9DBC8B2D6">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb04cre.htm#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0" title="Examples are presented that use XQuery to query relational table or view data as if it were XML data. The examples use XQuery function fn:collection, passing as argument a URI that uses the URI-scheme name oradb together with the database location of the data.">Querying Relational Data Using XQuery and URI Scheme oradb</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5106"></a>
<div class="props_rev_3"><a id="GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513"></a>
<h2 id="ADXDB-GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513" class="sect2"><span class="enumeration_section">4.5</span> Oracle XQuery Extension Functions</h2>
<div>
<p>Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, <code>http://xmlns.oracle.com/xdb</code>, which uses the predefined prefix <span class="bold"><code>ora</code></span>.</p>
<div class="infobox-note" id="GUID-E04FDA5E-EBF1-42C9-8103-C089B2CF7513__GUID-5AC0B0E7-1356-4EBF-854F-111529A1E06D">
<p class="notep1">Note:</p>
<p>Prior to Oracle Database&nbsp;12<span class="italic">c</span> Release 1, standard XQuery functions <code>fn:matches</code> and <code>fn:replace</code> were not supported, and Oracle XML&nbsp;DB provided these Oracle XQuery functions to use in their stead: <code>ora:matches</code> and <code>ora:replace</code>. These Oracle XQuery functions are <span class="italic">deprecated</span> in Oracle Database&nbsp;12<span class="italic">c</span> Release 1 &ndash; use the standard XQuery functions (namespace prefix <code>fn</code>) instead.</p>
</div>
</div>
<a id="ADXDB5110"></a><a id="ADXDB5109"></a>
<div class="props_rev_3"><a id="GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1"></a>
<h3 id="ADXDB-GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1" class="sect3"><span class="enumeration_section">4.5.1</span> ora:contains XQuery Function</h3>
<div>
<p>Oracle XQuery and XPath function <code>ora:contains</code> is described.</p>
<div class="section">
<p class="subhead3">ora:contains Syntax</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">ora:contains (<span class="italic">input_text</span>, <span class="italic">text_query</span> [, <span class="italic">policy_name</span>] [, <span class="italic">policy_owner</span>])
</pre>
<p>Oracle XQuery and XPath function <code>ora:contains</code> can be used in an XQuery expression in a call to SQL/XML function <code>XMLQuery</code>, <code>XMLTable</code>, or <code>XMLExists</code>. It is used to restrict a structural search with a full-text predicate. Function <code>ora:contains</code> returns a positive integer when the <span class="italic"><code>input_text</code></span> matches <span class="italic"><code>text_query</code></span> (the higher the number, the more relevant the match), and zero otherwise. When used in an XQuery expression (that is not also an XPath expression), the XQuery return type is <code>xs:integer()</code>; when used in an XPath expression outside of an XQuery expression, the XPath return type is <code>number</code>.</p>
<p>Argument <span class="italic"><code>input_text</code></span> must evaluate to a single text node or an attribute. The syntax and semantics of <span class="italic"><code>text_query</code></span> in <code>ora:contains</code> are the same as <span class="italic"><code>text_query</code></span> in <code>contains</code>, with a few restrictions.</p>
<div class="infoboxnotealso" id="GUID-E93BBF0C-D473-4988-A132-DB7EE8B6E0C1__GUID-31FF322A-94DC-464F-AADD-14F4A6D5040E">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="app_depr_otext.htm#GUID-BD718D3E-920A-4C81-ADDF-C3C799A78DC5" title="Function ora:contains is an Oracle-defined XQuery (XPath) function for use in the XQuery expression argument to SQL/XML functions XMLQuery, XMLTable, and XMLExists. Function ora:contains always returns a number. It does not return a score. It returns a positive number if the text_query matches the input_text. Otherwise it returns zero.">ora:contains XQuery Function</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5116"></a><a id="ADXDB5115"></a>
<div class="props_rev_3"><a id="GUID-8F31DED8-C232-4E19-8A62-32F5765BE4DB"></a>
<h3 id="ADXDB-GUID-8F31DED8-C232-4E19-8A62-32F5765BE4DB" class="sect3"><span class="enumeration_section">4.5.2</span> ora:sqrt XQuery Function</h3>
<div>
<p>Oracle XQuery function <code>ora:sqrt</code> returns the square root of its numeric argument, which can be of XQuery type <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>. The returned value is of the same XQuery type as the argument.</p>
<div class="section">
<p class="subhead3">ora:sqrt Syntax</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">ora:sqrt (<span class="italic">number</span>)
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5118"></a><a id="ADXDB5117"></a>
<div class="props_rev_3"><a id="GUID-57984592-3A02-4DB4-9FDA-D5E2CCB3A797"></a>
<h3 id="ADXDB-GUID-57984592-3A02-4DB4-9FDA-D5E2CCB3A797" class="sect3"><span class="enumeration_section">4.5.3</span> ora:tokenize XQuery Function</h3>
<div>
<p>Oracle XQuery function <code>ora:tokenize</code> lets you use a regular expression to split the input string <span class="italic"><code>target_string</code></span> into a sequence of strings.</p>
<div class="section"></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">ora:tokenize Syntax</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">ora:tokenize (<span class="italic">target_string</span>, <span class="italic">match_pattern</span> [, <span class="italic">match_parameter</span>])
</pre>
<p>Function <code>ora:tokenize</code> treats each substring that matches the regular-expression <span class="italic"><code>match_pattern</code></span> as a separator indicating where to split. It returns the sequence of tokens as an XQuery value of type <code>xs:string*</code> (a sequence of <code>xs:string</code> values). If <span class="italic"><code>target_string</code></span> is the empty sequence, it is returned. Optional argument <span class="italic"><code>match_parameter</code></span> is a code that qualifies matching: case-sensitivity and so on.</p>
<p>The argument types are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic"><code>target_string</code></span> &ndash; <code>xs:string?</code><a id="fn_3" href="#fn_3" onclick="footdisplay(3,&#34;The question mark (?) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See \&#34;XQuery Expressions\&#34;. &#34;)"><sup>Foot&nbsp;3</sup></a></p>
</li>
<li>
<p><span class="italic"><code>match_pattern</code></span> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><span class="italic"><code>match_parameter</code></span> &ndash; <code>xs:string</code></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5112"></a><a id="ADXDB5111"></a>
<div class="props_rev_3"><a id="GUID-BF9B130C-DF7B-42D0-B6FE-235AEF2DF5ED"></a>
<h3 id="ADXDB-GUID-BF9B130C-DF7B-42D0-B6FE-235AEF2DF5ED" class="sect3"><span class="enumeration_section">4.5.4</span> ora:matches XQuery Function (Deprecated)</h3>
<div>
<p>Oracle XQuery function <code>ora:matches</code> is <span class="italic">deprecated</span>, starting with Oracle Database&nbsp;12<span class="italic">c</span> Release 1 (12.1.0.1) &ndash; use standard XQuery function <code>fn:matches</code> instead.</p>
<div class="section"></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">ora:matches Syntax</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">ora:matches (<span class="italic">target_string</span>, <span class="italic">match_pattern</span> [, <span class="italic">match_parameter</span>])
</pre>
<p>Oracle XQuery function <code>ora:matches</code> lets you use a regular expression to match text in a string. It returns <code>true()</code> if its <span class="italic"><code>target_string</code></span> argument matches its regular-expression <span class="italic"><code>match_pattern</code></span> argument and <code>false()</code> otherwise. If <span class="italic"><code>target_string</code></span> is the empty sequence, <code>false()</code> is returned. Optional argument <span class="italic"><code>match_parameter</code></span> is a code that qualifies matching: case-sensitivity and so on.</p>
<p>The behavior of XQuery function <code>ora:matches</code> is the same as that of SQL condition <code>REGEXP_LIKE</code>, but the types of its arguments are XQuery types instead of SQL data types. The argument types are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic"><code>target_string</code></span> &ndash; <code>xs:string?</code><a id="fn_4" href="#fn_4" onclick="footdisplay(4,&#34;The question mark (?) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See \&#34;XQuery Expressions\&#34;. &#34;)"><sup>Foot&nbsp;4</sup></a></p>
</li>
<li>
<p><span class="italic"><code>match_pattern</code></span> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><span class="italic"><code>match_parameter</code></span> &ndash; <code>xs:string</code></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-BF9B130C-DF7B-42D0-B6FE-235AEF2DF5ED__GUID-CD8AB952-CF2F-4F9C-950C-16E51B0A276C">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF00501" target="_blank" href="../SQLRF/conditions007.htm#SQLRF00501"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL condition <code>REGEXP_LIKE</code></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5114"></a><a id="ADXDB5113"></a>
<div class="props_rev_3"><a id="GUID-436A2486-EAC3-4109-86D5-11C8E13F93F8"></a>
<h3 id="ADXDB-GUID-436A2486-EAC3-4109-86D5-11C8E13F93F8" class="sect3"><span class="enumeration_section">4.5.5</span> ora:replace XQuery Function (Deprecated)</h3>
<div>
<p>Oracle XQuery function <code>ora:replace</code> is <span class="italic">deprecated</span>, starting with Oracle Database&nbsp;12<span class="italic">c</span> Release 1 (12.1.0.1) &ndash; use standard XQuery function <code>fn:replace</code> instead.</p>
<div class="section"></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">ora:replace Syntax</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">ora:replace (<span class="italic">target_string, match_pattern</span>, <span class="italic">replace_string</span> [, <span class="italic">match_parameter</span>])
</pre>
<p>Oracle XQuery function <code>ora:replace</code> lets you use a regular expression to replace matching text in a string. <span class="italic">Each</span> occurrence in <span class="italic"><code>target_string</code></span> that matches regular-expression <span class="italic"><code>match_pattern</code></span> is replaced by <span class="italic"><code>replace_string</code></span>. It returns the new string that results from the replacement. If <span class="italic"><code>target_string</code></span> is the empty sequence, then the empty string (<code>&#34;&#34;</code>) is returned. Optional argument <span class="italic"><code>match_parameter</code></span> is a code that qualifies matching: case-sensitivity and so on.</p>
<p>The behavior of XQuery function <code>ora:replace</code> is the same as that of SQL function <code>regexp_replace</code>, but the types of its arguments are XQuery types instead of SQL data types. The argument types are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic"><code>target_string</code></span> &ndash; <code>xs:string?</code><a id="fn_5" href="#fn_5" onclick="footdisplay(5,&#34;The question mark (?) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See \&#34;XQuery Expressions\&#34;. &#34;)"><sup>Foot&nbsp;5</sup></a></p>
</li>
<li>
<p><span class="italic"><code>match_pattern</code></span> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><span class="italic"><code>replace_string</code></span> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><span class="italic"><code>match_parameter</code></span> &ndash; <code>xs:string</code></p>
</li>
</ul>
<p>In addition, <code>ora:replace</code> requires argument <span class="italic"><code>replace_string</code></span> (it is optional in <code>regexp_replace</code>) and it does not use arguments for position and number of occurrences &ndash; search starts with the first character and all occurrences are replaced.</p>
<div class="infoboxnotealso" id="GUID-436A2486-EAC3-4109-86D5-11C8E13F93F8__GUID-DF2D2BBA-B471-4207-A574-CA865D580F74">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF06302" target="_blank" href="../SQLRF/functions163.htm#SQLRF06302"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL function <code>regexp_replace</code></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB5996"></a>
<div class="props_rev_3"><a id="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948"></a>
<h2 id="ADXDB-GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948" class="sect2"><span class="enumeration_section">4.6</span> Oracle XQuery Extension-Expression Pragmas</h2>
<div>
<p>The W3C XQuery specification lets an implementation provide implementation-defined extension expressions. An XQuery extension expression is an XQuery expression that is enclosed in braces (<code>{</code>,&nbsp;<code>}</code>) and prefixed by an implementation-defined pragma. The Oracle implementation provides several such pragmas.</p>
<div class="section">
<p>No other pragmas are recognized than those listed here. Use of any other pragma, or use of any of these pragmas with incorrect pragma content (for example, <code>(#ora:view_on_null something_else #)</code>), raises an error.</p>
<p>In the <code>ora:view_on_null</code> examples here, assume that table <code>null_test</code> has columns <code>a</code> and <code>b</code> of type <code>VARCHAR2(10)</code>, and that column <code>b</code> (but not <code>a</code>) is empty.</p>
<ul style="list-style-type: disc;">
<li>
<p><code>(#ora:child-element-name</code> <span class="italic"><code>name</code></span> <code>#)</code> &ndash; Specify the name to use for a child element that is inserted. In general, without this pragma the name of the element to be inserted is unknown at compile time. Specifying the name allows for compile-time optimization, to improve runtime performance.</p>
<p>As an example, the following SQL statement specifies <code>LineItem</code> as the name of the element node that is inserted as a child of element <code>LineItems</code>. The element data to be inserted is the value of XQuery variable <code>p2</code>, which comes from bind variable <code>:1</code>.</p>
<pre dir="ltr">UPDATE oe.purchaseorder p SET p.OBJECT_VALUE =
  XMLQuery(
    &#39;copy $i :=
       $p1 modify (for $j in $i/PurchaseOrder/LineItems
                     return <span class="bold">(#ora:child-element-name LineItem #)</span>
                            {insert node $p2 into $j)
                  return $i&#39;
    PASSING p.OBJECT_VALUE AS &#34;p1&#34;, :1 AS &#34;p2&#34; RETURNING CONTENT)
  WHERE XMLQuery(
          &#39;/PurchaseOrder/Reference/text()&#39;
          PASSING p.OBJECT_VALUE RETURNING CONTENT).getStringVal() =
            &#39;EMPTY_LINES&#39;;
</pre>
<p>This pragma applies to <code>XMLType</code> data stored either object-relationally or as binary XML.</p>
</li>
<li>
<p><code>(#ora:defaultTable #)</code> &ndash; Specify the default table used to store repository data. Use this to improve the performance of repository queries that use Query function <code>fn:doc</code> or <code>fn:collection</code>. See <span class="q">&#34;<a href="xdb04cre.htm#GUID-749BD49D-46E2-4B15-8B9E-1097D6952047" title="You can use Oracle XQuery extension-expression pragma ora:defaultTable to improve the performance of querying repository data.">Using Oracle XQuery Pragma ora:defaultTable</a>&#34;</span>.</p>
</li>
<li>
<p><code>(#ora:invalid_path empty #)</code> &ndash; Treat an invalid XPath expression as if its targeted nodes do not exist. For example:</p>
<pre dir="ltr">SELECT XMLQuery(&#39;<span class="bold">(#ora:invalid_path empty #)</span>
                 {exists($p/PurchaseOrder//NotInTheSchema)}&#39;
                PASSING OBJECT_VALUE AS &#34;p&#34; RETURNING CONTENT)
  FROM oe.purchaseorder p;
</pre>
<p>The XML schema for table <code>oe.purchaseorder</code> does not allow any such node <code>NotInTheSchema</code> as a descendant of node <code>PurchaseOrder</code>. Without the pragma, the use of this invalid XPath expression would raise an error. But with the pragma, the calling context acts just as if the XPath expression had targeted no nodes. That calling context in this example is XQuery function <code>exists</code>, which returns XQuery Boolean value <code>false</code> when passed an empty node sequence. (XQuery function <code>exists</code> is used in this example only to illustrate the behavior; the pragma is not especially related to function <code>exists</code>.)</p>
</li>
<li>
<p><code>(#ora:view_on_null empty #)</code> &ndash; XQuery function <code>fn:collection</code> returns an empty XML element for each <code>NULL</code> column. For example, the following query returns <code>&lt;ROW&gt;&lt;A&gt;x&lt;/A&gt;</code><span class="bold"><code>&lt;B&gt;&lt;/B&gt;</code></span><code>&lt;/ROW&gt;</code>:</p>
<pre dir="ltr">SELECT XMLQuery(&#39;<span class="bold">(#ora:view_on_null empty #)</span>
                 {for $i in fn:collection(&#34;oradb:/PUBLIC/NULL_TEST&#34;)/ROW 
                  return $i}&#39;
                RETURNING CONTENT)
  FROM DUAL;
</pre></li>
<li>
<p><code>(#ora:view_on_null null #)</code> &ndash; XQuery function <code>fn:collection</code> returns no element for a <code>NULL</code> column. For example, the following query returns <code>&lt;ROW&gt;&lt;A&gt;x&lt;/A&gt;&lt;/ROW&gt;</code>:</p>
<pre dir="ltr">SELECT XMLQuery(&#39;<span class="bold">(#ora:view_on_null null #)</span>
                 {for $i in fn:collection(&#34;oradb:/PUBLIC/NULL_TEST&#34;)/ROW 
                  return $i}&#39;
                RETURNING CONTENT)
  FROM DUAL;
</pre></li>
<li>
<p><code>(#ora:no_xmlquery_rewrite #)</code><a id="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948__BABBJEDA" href="#GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948__BABBJEDA" onclick="footdisplay(6,&#34;Prior to Oracle Database 12c Release 1 (12.1.0.1), pragmas ora:no_xmlquery_rewrite and ora:xmlquery_rewrite were named ora:xq_proc and ora:xq_qry, respectively. They were renamed for readability, with no change in meaning. &#34;)"><sup>Foot&nbsp;6</sup></a> &ndash; Do not optimize XQuery procedure calls in the XQuery expression that follows the pragma; use functional evaluation instead.</p>
<p>This has the same effect as the SQL hint <code>/*+ NO_XML_QUERY_REWRITE */</code>, but the scope of the pragma is only the XQuery expression that follows it (not an entire SQL statement).</p>
<div class="infoboxnotealso" id="GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948__GUID-6BD8322E-AFDD-4325-B85F-6BEEBBD5837A">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-572DB598-0A31-4143-889B-98D883211FC6" title="You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */.">Turning Off Use of XMLIndex</a>&#34;</span> for information about optimizer hint <code>NO_XML_QUERY_REWRITE</code></p>
</div>
</li>
<li>
<p><code>(#ora:xmlquery_rewrite #)</code><a id="fnsrc_d24143e5077" href="#fnsrc_d24143e5077" onclick="footdisplay(6,&#34;Prior to Oracle Database 12c Release 1 (12.1.0.1), pragmas ora:no_xmlquery_rewrite and ora:xmlquery_rewrite were named ora:xq_proc and ora:xq_qry, respectively. They were renamed for readability, with no change in meaning. &#34;)"><sup>Footref&nbsp;6</sup></a> &ndash; Try to optimize the XQuery expression that follows the pragma. That is, if possible, do not evaluate it functionally.</p>
<p>As an example of using both <code>ora:no_xmlquery_rewrite</code> and <code>ora:xmlquery_rewrite</code>, in the following query the XQuery expression argument to <code>XMLQuery</code> will in general be evaluated functionally, but the <code>fn:collection</code> subexpressions that are preceded by pragma <code>ora:xmlquery_rewrite</code> will be optimized, if possible.</p>
<pre dir="ltr">SELECT XMLQuery(&#39;<span class="bold">(#ora:no_xmlquery_rewrite#)</span> (: Do not optimize expression :)
                 {for $i in <span class="bold">(#ora:xmlquery_rewrite#)</span> (: Optimize subexp. :)
                            {fn:collection(&#34;oradb:/HR/REGIONS&#34;)},
                      $j in <span class="bold">(#ora:xmlquery_rewrite#)</span> (: Optimize subexpr. :)
                            {fn:collection(&#34;oradb:/HR/COUNTRIES&#34;)}
                  where $i/ROW/REGION_ID = $j/ROW/REGION_ID
                    and $i/ROW/REGION_NAME = $regionname
                  return $j}&#39;
         PASSING CAST(&#39;&amp;REGION&#39; AS VARCHAR2(40)) AS &#34;regionname&#34;
           RETURNING CONTENT)
  AS asian_countries FROM DUAL;
</pre></li>
<li>
<p><code>(#ora:no_schema #)</code> &ndash; Do not raise an error if an XQuery Full Text expression is used with XML Schema-based <code>XMLType</code> data. Instead, implicitly cast the data to non XML-Schema-based data. In particular, this means ignore XML Schema data types.</p>
<p>Oracle supports XQuery Full Text only for <code>XMLType</code> data stored as binary XML, so this pragma applies only for the same case.</p>
</li>
<li>
<p><code>(#ora:use_xmltext_idx #)</code> &ndash; Use an XML search index, if available, to evaluate the query. Do not use an <code>XMLIndex</code> index or streaming evaluation.</p>
<p>An XML search index applies only to <code>XMLType</code> data stored as binary XML, so this pragma does also.</p>
</li>
<li>
<p><code>(#ora:transform_keep_schema #)</code> &ndash; Retain XML Schema information for the documents returned by the XQuery expression that follows the pragma. This is useful for XQuery Update, which uses copy semantics.</p>
<p>Without the pragma, when XML schema-based data is copied during an XQuery Update operation, the XML schema information is lost. This is the behavior specified by the XQuery Update standard. If you then try to insert the updated data into an XML schema-based column or table then an error is raised: the data to be inserted is untyped, so it does not conform to the XML schema.</p>
<p>If you use the pragma then the data retains its XML schema information, preventing the insertion error. Here is an example of using the pragma:</p>
<pre dir="ltr">SELECT XMLQuery(&#39;declare default element namespace
                 &#34;http://xmlns.oracle.com/xdb/xdbconfig.xsd&#34;; (: :)
                 <span class="bold">(#ora:transform_keep_schema#)</span>
                 {copy $NEWXML :=
                   $XML modify (for $CFG in $NEWXML/xdbconfig//httpconfig 
                                  return (replace value of node
                                          $CFG/http-port with xs:int($PORTNO)))
                               return $NEWXML}&#39;
                PASSING CFG AS &#34;XML&#34;, 81 as &#34;PORTNO&#34; RETURNING CONTENT)
  FROM DUAL;
</pre></li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5151"></a><a id="ADXDB5152"></a><a id="ADXDB5150"></a>
<div class="props_rev_3"><a id="GUID-B7DB8827-C930-4711-A134-FA2BC58D749B"></a>
<h2 id="ADXDB-GUID-B7DB8827-C930-4711-A134-FA2BC58D749B" class="sect2"><span class="enumeration_section">4.7</span> XQuery Static Type-Checking in Oracle XML&nbsp;DB</h2>
<div>
<p>When possible, Oracle XML&nbsp;DB performs static (compile time) type-checking of queries.</p>
<p>Oracle XML&nbsp;DB type-checks <span class="italic">all</span> XQuery expressions. Doing this at run time can be costly, however. As an optimization technique, whenever there is sufficient static type information available for a given query at compile time, Oracle XML&nbsp;DB performs <span class="italic">static</span> (compile time) type-checking of that query. Whenever sufficient static type information is not available for a given query at compile time, Oracle XML&nbsp;DB uses dynamic (run-time) type checking for that query.</p>
<p>Static type-checking can save execution time by raising errors at compile time. Static type-checking errors include both data-type errors and the use of XPath expressions that are invalid with respect to an XML schema.</p>
<p>Typical ways of providing sufficient static type information at query compile time include the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Using XQuery with <code>fn:doc</code> or <code>fn:collection</code> over relational data.</p>
</li>
<li>
<p>Using XQuery to query an <code>XMLType</code> table, column, or view whose XML Schema information is available at query compile time.</p>
</li>
<li>
<p>Using XQuery Update with a transform expression whose input is from an <code>XMLType</code> table or column that is based on an XML schema.</p>
</li>
</ul>
<p>This section presents examples that demonstrate the utility of static type-checking and the use of these two means of communicating type information.</p>
<p>The XML data produced on the fly by <code>fn:collection</code> together with URI scheme <code>oradb</code> has <code>ROW</code> as its top-level element, but the query of <a href="xdb_xquery.htm#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABFDFHI">Example 4-4</a> incorrectly lacks that <code>ROW</code> wrapper element. This omission raises a query compile-time error. Forgetting that <code>fn:collection</code> with <code>oradb</code> wraps relational data in this way is an easy mistake to make, and one that could be difficult to diagnose without static type-checking. <a href="xdb04cre.htm#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAFCFCF">Example 5-5</a> shows the correct code.</p>
<p>In <a href="xdb_xquery.htm#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABIDDDF">Example 4-5</a>, XQuery static type-checking finds a mismatch between an XPath expression and its target XML schema-based data. Element <code>CostCenter</code> is misspelled here as <code>costcenter</code> (XQuery and XPath are case-sensitive). <a href="xdb04cre.htm#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJEEFD">Example 5-11</a> shows the correct code.</p>
<div class="example" id="GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABFDFHI">
<p class="titleinexample">Example 4-4 Static Type-Checking of XQuery Expressions: oradb URI scheme</p>
<pre dir="ltr">-- This produces a static-type-check error, because &#34;ROW&#34; is missing.
SELECT XMLQuery(&#39;for $i in fn:collection(&#34;oradb:/HR/REGIONS&#34;),
                     $j in fn:collection(&#34;oradb:/HR/COUNTRIES&#34;)
                 where $i/REGION_ID = $j/REGION_ID and $i/REGION_NAME = &#34;Asia&#34;
                 return $j&#39;
                RETURNING CONTENT) AS asian_countries
  FROM DUAL;
SELECT XMLQuery(&#39;for $i in fn:collection(&#34;oradb:/HR/REGIONS&#34;),
*
ERROR at line 1:
ORA-19276: XPST0005 - XPath step specifies an invalid element/attribute name:
(REGION_ID)
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-B7DB8827-C930-4711-A134-FA2BC58D749B__BABIDDDF">
<p class="titleinexample">Example 4-5 Static Type-Checking of XQuery Expressions: XML Schema-Based Data</p>
<pre dir="ltr">-- This results in a static-type-check error: CostCenter is not the right case.
SELECT xtab.poref, xtab.usr, xtab.requestor
  FROM purchaseorder,
       XMLTable(&#39;for $i in /PurchaseOrder where $i/<span class="bold">costcenter</span> eq &#34;A10&#34; return $i&#39;
                PASSING OBJECT_VALUE
                COLUMNS poref     VARCHAR2(20) PATH &#39;Reference&#39;,
                        usr       VARCHAR2(20) PATH &#39;User&#39; DEFAULT &#39;Unknown&#39;,
                        requestor VARCHAR2(20) PATH &#39;Requestor&#39;) xtab;
  FROM purchaseorder,
       *
ERROR at line 2:
ORA-19276: XPST0005 - XPath step specifies an invalid element/attribute name:
(costcenter)
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5159"></a>
<div class="props_rev_3"><a id="GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99"></a>
<h2 id="ADXDB-GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" class="sect2"><span class="enumeration_section">4.8</span> Oracle XML&nbsp;DB Support for XQuery</h2>
<div>
<p>Oracle XML&nbsp;DB support for the XQuery language includes SQL support and support for XQuery functions and operators.</p>
<div class="section"></div>
<!-- class="section" --></div>
<a id="ADXDB5160"></a>
<div class="props_rev_3"><a id="GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D"></a>
<h3 id="ADXDB-GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D" class="sect3"><span class="enumeration_section">4.8.1</span> Support for XQuery and SQL</h3>
<div>
<p>Support for the XQuery language in Oracle XML&nbsp;DB is designed to provide the best fit between the worlds of relational storage and querying XML data. Oracle XML&nbsp;DB is a general XQuery implementation, but it is in addition specifically designed to make relational and XQuery queries work well together.</p>
<div class="section">
<p>The specific properties of the Oracle XML&nbsp;DB XQuery implementation are described in this section. The XQuery standard explicitly calls out certain aspects of the language processing as implementation-defined or implementation-dependent. There are also some features that are specified by the XQuery standard but are not supported by Oracle XML&nbsp;DB.</p>
<div class="infoboxnotealso" id="GUID-B239D5DC-DEA9-401B-A249-9CDCC1A7781D__GUID-BA722DEF-D1FB-45B3-A3BE-D3175090DF71">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDB5161"></a>
<div class="props_rev_3"><a id="GUID-50FD7517-AEBE-4C78-8B20-50DC72FBDB16"></a>
<h4 id="ADXDB-GUID-50FD7517-AEBE-4C78-8B20-50DC72FBDB16" class="sect4"><span class="enumeration_section">4.8.1.1</span> Implementation Choices Specified in the XQuery Standards</h4>
<div>
<p>The XQuery standards specify several aspects of language processing that are to be defined by the implementation.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">Implicit time zone support &ndash;</span> In Oracle XML&nbsp;DB, the implicit time zone is always assumed to be <code>Z</code>, and instances of <code>xs:date</code>, <code>xs:time</code>, and <code>xs:datetime</code> that are missing time zones are&nbsp; automatically converted to UTC.</p>
</li>
<li>
<p><span class="italic"><code>copy-namespaces</code></span> <span class="italic">default value &ndash;</span> The default value for a <code>copy-namespaces</code> declaration (used in XQuery Update) is <code>inherit</code>.</p>
</li>
<li>
<p><span class="italic">Revalidation mode</span> &ndash; The default mode for XQuery Update transform expression revalidation is <code>skip</code>. However, if the result of a transform expression is an update to XML schema-based data in an <code>XMLType</code> table or column, then XML schema validation is enforced.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5162"></a>
<div class="props_rev_3"><a id="GUID-7E668693-38C0-481A-B118-2E1A654D6E0D"></a>
<h4 id="ADXDB-GUID-7E668693-38C0-481A-B118-2E1A654D6E0D" class="sect4"><span class="enumeration_section">4.8.1.2</span> XQuery Features Not Supported by Oracle XML&nbsp;DB</h4>
<div>
<p>The features specified by the XQuery standard that are not supported by Oracle XML&nbsp;DB are specified.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">Copy-namespace mode &ndash;</span> Oracle XML&nbsp;DB supports only <code>preserve</code> and <code>inherit</code> for a <code>copy-namespaces</code> declaration. If an existing element node is copied by an element constructor or a document constructor, all in-scope namespaces of the original element are retained in the copy. Otherwise, the copied node inherits all in-scope namespaces of the constructed node. An error is raised if you specify <code>no-preserve</code> or <code>no-inherit</code>.</p>
</li>
<li>
<p><span class="italic">Version encoding</span> &ndash; Oracle XML&nbsp;DB does not support an optional encoding declaration in a version declaration. That is, you cannot include <code>(encoding</code> <span class="italic"><code>an-encoding</code></span><code>)</code> in a declaration <code>xquery version</code> <span class="italic"><code>a-version</code></span><code>;</code>. In particular, you cannot specify an encoding used in the query. An error is raised if you include an encoding declaration.</p>
</li>
<li>
<p><span class="italic">xml:id</span> &ndash; Oracle XML&nbsp;DB does not support use of <code>xml:id</code>. If you use <code>xml:id</code>, then an error is raised.</p>
</li>
<li>
<p>XQuery prolog default-collation declaration.</p>
</li>
<li>
<p>XQuery prolog boundary-space declaration.</p>
</li>
<li>
<p>XQuery data type <code>xs:duration</code>. Use either <code>xs:yearMonthDuration</code> or <code>xs:DayTimeDuration</code> instead.</p>
</li>
<li>
<p>XQuery Update function <code>fn:put</code>.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5163"></a>
<div class="props_rev_3"><a id="GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E"></a>
<h4 id="ADXDB-GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E" class="sect4"><span class="enumeration_section">4.8.1.3</span> XQuery Optional Features</h4>
<div>
<p>The optional XQuery features that are not supported by Oracle XML&nbsp;DB are specified.</p>
<div class="section">
<p>The XQuery standard specifies that some features are optional for a given implementation. The following optional XQuery features are <span class="italic">not</span> supported by Oracle XML&nbsp;DB:</p>
<ul style="list-style-type: disc;">
<li>
<p>Schema Validation Feature</p>
</li>
<li>
<p>Module Feature</p>
</li>
</ul>
<p>The following optional XQuery features are supported by Oracle XML&nbsp;DB:</p>
<ul style="list-style-type: disc;">
<li>
<p>XQuery Static Typing Feature</p>
</li>
<li>
<p>XQuery Update Static Typing Feature</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E__GUID-82FF65E0-D328-4CBB-BF41-41210FA415A4">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-B7DB8827-C930-4711-A134-FA2BC58D749B" title="When possible, Oracle XML&nbsp;DB performs static (compile time) type-checking of queries.">XQuery Static Type-Checking in Oracle XML&nbsp;DB</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB5164"></a>
<div class="props_rev_3"><a id="GUID-22940B8D-1468-4966-9F55-7DD4518E9612"></a>
<h3 id="ADXDB-GUID-22940B8D-1468-4966-9F55-7DD4518E9612" class="sect3"><span class="enumeration_section">4.8.2</span> Support for XQuery Functions and Operators</h3>
<div>
<p>Oracle XML&nbsp;DB supports all of the XQuery functions and operators included in the latest <span class="italic">XQuery 1.0 and XPath 2.0 Functions and Operators</span> specification, with a few exceptions.</p>
<div class="section">
<p>Oracle XML&nbsp;DB does <span class="italic">not</span> support the following XQuery functions and operators:</p>
<ul style="list-style-type: disc;">
<li>
<p>Function <code>fn:tokenize</code>. Use Oracle XQuery function <code>ora:tokenize</code> instead.</p>
</li>
<li>
<p>Functions <code>fn:id</code> and <code>fn:idref</code>.</p>
</li>
<li>
<p>Function <code>fn:collection</code> without arguments.</p>
</li>
<li>
<p>Optional collation parameters for XQuery functions.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDB5165"></a>
<div class="props_rev_3"><a id="GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1"></a>
<h4 id="ADXDB-GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1" class="sect4"><span class="enumeration_section">4.8.2.1</span> XQuery Functions fn:doc, fn:collection, and fn:doc-available</h4>
<div>
<p>Oracle XML&nbsp;DB supports XQuery functions <code>fn:doc</code>, <code>fn:collection</code>, and <code>fn:doc-available</code> for all resources in Oracle XML&nbsp;DB Repository.</p>
<div class="section">
<p>Function <code>fn:doc</code> returns the repository <span class="italic">file</span> resource that is targeted by its URI argument; it must be a file of well-formed XML data. Function <code>fn:collection</code> is similar, but works on repository <span class="italic">folder</span> resources (each file in the folder must contain well-formed XML data).</p>
<p>When used with Oracle URI scheme <code>oradb</code>, <code>fn:collection</code> can return XML data derived on the fly from existing relational data that is not in the repository.</p>
<p>XQuery function <code>fn:collection</code> raises an error when used with URI scheme <code>oradb</code>, if its targeted table or view, or a targeted column, does not exist. Functions <code>fn:doc</code> and <code>fn:collection</code> do <span class="italic">not</span> raise an error if the repository resource passed as argument is not found. Instead, they return an empty sequence.</p>
<p>You can determine whether a given document exists using XQuery function <code>fn:doc-available</code>. It returns <code>true</code> if its document argument exists, <code>false</code> if not.</p>
<div class="infoboxnotealso" id="GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1__GUID-9C6BF6CF-A679-46EB-8942-0615AE0D9E8D">
<p class="notep1">See Also:</p>
<p><a href="http://www.w3.org/" target="_blank"><code>http://www.w3.org/</code></a> for the definitions of XQuery functions and operators</p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB6134"></a>
<div class="props_rev_3"><a id="GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048"></a>
<h3 id="ADXDB-GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" class="sect3"><span class="enumeration_section">4.8.3</span> Support for XQuery Full Text</h3>
<div>
<p>Oracle XML&nbsp;DB supports XQuery Full Text for <code>XMLType</code> data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.</p>
<div class="section">
<p>Refer to the XQuery and XPath Full Text 1.0 Recommendation (hereafter XQuery Full Text, or XQFT) for information about any terms that are not detailed here.</p>
<p>Oracle supports XQuery Full Text <span class="italic">only</span> for <code>XMLType</code> data that is stored as <span class="italic">binary XML</span>. You can perform a full-text search of <code>XMLType</code> data that is stored object-relationally using an Oracle Text index, but not using XQuery Full Text.</p>
<p>A general rule for understanding Oracle support for XQuery Full Text is that the Oracle implementation of XQFT is based on Oracle Text, which provides full-text indexing and search for Oracle products and for applications developed using them. The XQFT support details provided in this section are a consequence of this Oracle Text based implementation.</p>
<div class="infoboxnotealso" id="GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048__GUID-05F84375-25A7-4C56-ABDD-73AF10606155">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CCAPP" target="_blank" href="../CCAPP/toc.htm"><span class="italic">Oracle Text Application Developer&#39;s Guide</span></a></p>
</li>
<li>
<p><a class="olink CCREF" target="_blank" href="../CCREF/toc.htm"><span class="italic">Oracle Text Reference</span></a></p>
</li>
<li>
<p><a href="app_depr_otext.htm#GUID-1B838D2B-DD94-480A-8D3D-53E0204A2282" title="Oracle-specific full-text search over XML data is described, including how to use Oracle SQL function contains and Oracle XPath function ora:contains.">Full-Text Search over XML Data Without XQuery</a> for information about performing a full-text search of <code>XMLType</code> data stored object-relationally</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDB6141"></a>
<div class="props_rev_3"><a id="GUID-1066B062-BEDE-4384-B0A7-2DEE8D7EA28E"></a>
<h4 id="ADXDB-GUID-1066B062-BEDE-4384-B0A7-2DEE8D7EA28E" class="sect4"><span class="enumeration_section">4.8.3.1</span> XQuery Full Text, XML Schema-Based Data, and Pragma ora:no_schema</h4>
<div>
<p>Use Oracle pragma <code>ora:no_schema</code> with XQuery Full Text to query XML Schema-based <code>XMLType</code> data that is stored as binary XML. The data is treated as if it were non XML Schema-based.</p>
<div class="section">
<p>You can use XQuery Full Text to query <code>XMLType</code> data that is stored as binary XML. However, if you use it with XML Schema-based data then you must also use the XQuery extension-expression pragma <code>ora:no_schema</code> in your query, or else an error is raised.</p>
<p>And if you use <code>ora:no_schema</code> then, for purposes of XQuery Full Text, the XML data is implicitly cast to non XML Schema-based data. In other words, Oracle support of XQuery Full Text treats all XML data as if it were not based on an XML schema.</p>
<p>In particular, this means that if you include in your query an XQuery Full Text condition that makes use of XML Schema data types, such type considerations are ignored. A comparison of two XML Schema date values, for instance, is handled as a simple string comparison. Oracle support for XQuery Full Text is not XML Schema-aware.</p>
<div class="infoboxnotealso" id="GUID-1066B062-BEDE-4384-B0A7-2DEE8D7EA28E__GUID-3D680FFD-DE20-4D16-BD01-B76A9964EFC7">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2" title="Oracle recommends in general that you use non XML Schema-based XMLType data when you use XQuery Full Text and an XML search index. But you can in some circumstances use XML Schema-based XMLType data that is stored as binary XML. Oracle XQuery pragma ora:no_schema can be useful in this context.">Pragma ora:no_schema: Using XML Schema-Based Data with XQuery Full Text</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6142"></a>
<div class="props_rev_3"><a id="GUID-A3A8DD96-851D-4433-955E-3FD697E6EE6A"></a>
<h4 id="ADXDB-GUID-A3A8DD96-851D-4433-955E-3FD697E6EE6A" class="sect4"><span class="enumeration_section">4.8.3.2</span> Restrictions on Using XQuery Full Text with XMLExists</h4>
<div>
<p>Restrictions are specified for using XQuery Full Text with SQL/XML function <code>XMLExists</code>.</p>
<div class="section">
<p>You can pass only one <code>XMLType</code> instance as a SQL expression in the <code>PASSING</code> clause of SQL/XML function <code>XMLExists</code>, and each of the other, non-<code>XMLType</code> SQL expressions in that clause must be either a <span class="italic">compile-time constant</span> of a SQL built-in data type or a <span class="italic">bind variable</span> that is bound to an instance of such a data type. If this restriction is not respected then compile-time error ORA-18177 is raised.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6135"></a>
<div class="props_rev_3"><a id="GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C"></a>
<h4 id="ADXDB-GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C" class="sect4"><span class="enumeration_section">4.8.3.3</span> Supported XQuery Full Text FTSelection Operators</h4>
<div>
<p>Oracle XML&nbsp;DB supports a subset of the XQuery Full Text FTSelection operators.</p>
<div class="section">
<p>Oracle XML&nbsp;DB supports <span class="italic">only</span> the following XQuery Full Text FTSelection operators. Any applicable restrictions are noted. Use of the terms &#34;must&#34; and &#34;must not&#34; means that an error is raised if the specified restriction is not respected. Use of any operators not listed here raises an error.</p>
<ul style="list-style-type: disc;">
<li>
<p>FTAnd (<code>ftand</code>)</p>
</li>
<li>
<p>FTMildNot (<code>not in</code>)</p>
<p>Each operand for operator FTMildNot must be either a term or a phrase, that is, an instance of FTWords. It must not be an expression. Oracle handles FTMildNot the same way it handles Oracle Text operator <code>MNOT</code>.</p>
</li>
<li>
<p>FTOr (<code>ftor</code>)</p>
</li>
<li>
<p>FTOrder (<code>ordered</code>)</p>
<p>Oracle supports the use of FTOrder <span class="italic">only</span> when used in the context of a window (FTWindow). Otherwise, it is not supported. For example, you can use <code>ordered window 5 words</code>, but you cannot use only <code>ordered</code> without also <code>window</code>. Oracle handles FTOrder the same way it handles Oracle Text operator <code>NEAR</code> with a <code>TRUE</code> value for option <code>ORDER</code>.</p>
</li>
<li>
<p>FTUnaryNot (<code>ftnot</code>)</p>
<p>FTUnaryNot must be used with FTAnd. You cannot use FTUnaryNot by itself. For example, you can use <code>ftand ftnot</code>, but you cannot use only <code>ftnot</code> without also <code>ftand</code>. Oracle handles FTUnaryNot the same way it handles Oracle Text operator <code>NOT</code>.</p>
</li>
<li>
<p>FTWindow (<code>window</code>)</p>
<p>Oracle handles FTWindow the same way it handles Oracle Text operator <code>NEAR</code>. You must specify the window size only in words, not in sentences or paragraphs (for example, <code>window 2 paragraphs</code>), and you must specify it as a numeric constant that is less than or equal to 100.</p>
</li>
<li>
<p>FTWords</p>
<p>FTWordsValue must be an XQuery literal string or a SQL bind variable whose value is passed to SQL function <code>XMLExists</code> or <code>XMLQuery</code> from a SQL expression whose evaluation returns a non-<code>XMLType</code> value.</p>
<p>In addition, FTAnyallOption, if present, must be <code>any</code>. That is, FTWords must correspond to a sequence with only one item.</p>
<div class="infobox-note" id="GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C__GUID-C2D9AC8E-1D67-41D3-A06A-A7445EA3454D">
<p class="notep1">Note:</p>
<p>Even though FTWords corresponds to a sequence of only one item, you can still search for a phrase of multiple words, by using a single string for the entire phrase. So for example, although Oracle XML&nbsp;DB does not support using <code>{&#34;found&#34; &#34;necklace&#34;}</code> for FTWords, you can use <code>&#34;found necklace&#34;</code>.</p>
</div>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6136"></a>
<div class="props_rev_3"><a id="GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E"></a>
<h4 id="ADXDB-GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E" class="sect4"><span class="enumeration_section">4.8.3.4</span> Supported XQuery Full Text Match Options</h4>
<div>
<p>Oracle XML&nbsp;DB supports a subset of the XQuery Full Text match options.</p>
<div class="section">
<p>Oracle XML&nbsp;DB supports <span class="italic">only</span> the following XQuery Full Text match options. Any applicable restrictions are noted. Use of the terms &#34;must&#34; and &#34;must not&#34; means that an error is raised if the specified restriction is not respected. Use of any match options not listed here raises an error.</p>
<ul style="list-style-type: disc;">
<li>
<p>FTStemOption (<code>stemming</code>, <code>no stemming</code>)</p>
</li>
</ul>
<p>The default behavior specified in the XQuery and XPath Full Text 1.0 Recommendation is used for each unsupported match option, with the following exceptions:</p>
<ul style="list-style-type: disc;">
<li>
<p>FTLanguage (unsupported) &ndash; The language used is the language defined by the <span class="italic">default lexer</span>, which means the language that was used when the database was installed.</p>
</li>
<li>
<p>FTStopWordOption (unsupported) &ndash; The stoplist used is the stoplist defined for that language.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E__GUID-75B2B68B-5437-4B05-9721-DB9390636137">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CCREF2052" target="_blank" href="../CCREF/cdatadic.htm#CCREF2052"><span class="italic">Oracle Text Reference</span></a> for information about the default lexer</p>
</li>
<li>
<p><a class="olink CCREF1400" target="_blank" href="../CCREF/astopsup.htm#CCREF1400"><span class="italic">Oracle Text Reference</span></a> for information about the stoplist used for each supported language</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6143"></a>
<div class="props_rev_3"><a id="GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6"></a>
<h4 id="ADXDB-GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6" class="sect4"><span class="enumeration_section">4.8.3.5</span> Unsupported XQuery Full Text Features</h4>
<div>
<p>The XQuery Full Text features that are not supported by Oracle XML&nbsp;DB are specified.</p>
<div class="section">
<p>In addition to all FTSelection operators not mentioned in <span class="q">&#34;<a href="xdb_xquery.htm#GUID-6BB43AAA-6C8F-49F4-8EDF-4CBA4EC0E78C" title="Oracle XML&nbsp;DB supports a subset of the XQuery Full Text FTSelection operators.">Supported XQuery Full Text FTSelection Operators</a>&#34;</span> and all match options not mentioned in <span class="q">&#34;<a href="xdb_xquery.htm#GUID-9EA2F0C3-6CB6-41FE-A20B-6A861576786E" title="Oracle XML&nbsp;DB supports a subset of the XQuery Full Text match options.">Supported XQuery Full Text Match Options</a>&#34;</span>, Oracle XML&nbsp;DB does <span class="italic">not</span> support the following XQuery Full Text features:</p>
<ul style="list-style-type: disc;">
<li>
<p>FTIgnoreOption</p>
</li>
<li>
<p>FTWeight (weight declarations, used with FTPrimaryWithOptions)</p>
</li>
<li>
<p>FTScoreVar (score variables, used with XQuery ForClause and LetClause or with XPath 2.0 SimpleForClause)</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6144"></a>
<div class="props_rev_3"><a id="GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD"></a>
<h4 id="ADXDB-GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD" class="sect4"><span class="enumeration_section">4.8.3.6</span> XQuery Full Text Errors</h4>
<div>
<p>Compile-time errors that can be raised when you use XQuery Full Text are described.</p>
<div class="section">
<p>A compile-time error is raised whenever you use an XQuery Full Text (XQFT) feature that Oracle does not support.</p>
<p>In addition, compile-time error ORA-18177 is raised whenever you use a supported XQFT expression in a SQL <code>WHERE</code> clause (typically in <code>XMLExists</code>), if you did not create a corresponding XML search index or if that index is not picked up.</p>
<div class="infoboxnotealso" id="GUID-4F5DE0AB-F407-4A2C-A417-C1EDBCE461AD__GUID-78DB5F8A-98CF-45B1-9CBF-68359076D4A8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-4D1A5EE7-2A6C-4ED8-B4AC-CA2E1E1030C6" title="The XQuery Full Text features that are not supported by Oracle XML&nbsp;DB are specified.">Unsupported XQuery Full Text Features</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a>&#34;</span> for information about creating an XML search index and handling error ORA-18177</p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb04cre.htm#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="A SQL query that involves XQuery expressions can often be automatically rewritten (optimized) in one or more ways. This optimization is referred to as XML query rewrite or optimization. When this happens, the XQuery expression is, in effect, evaluated directly against the XML document without constructing a DOM in memory.">Performance Tuning for XQuery</a>&#34;</span> for information about axes other than forward and descendent</p>
</li>
<li>
<p><a class="olink SQLRF50972" target="_blank" href="../SQLRF/sql_elements001.htm#SQLRF50972"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL built-in data types</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<hr/>
<br/>
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:
<p>The value returned is a sequence, as always. However, in XQuery, a sequence of one item is equivalent to that item itself. In this case, the single item is a Boolean value.</p>
<br/>
Footnote&nbsp;2:
<p>Namespace prefix <code>xs</code> is predefined for the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>.</p>
<br/>
Footnote&nbsp;3:
<p>The question mark (<code>?</code>) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED" title="XQuery expressions are case-sensitive. An XQuery expression is either a simple expression or an updating expression, the latter being an expression that represents data modification. More precisely, these are the possible XQuery expressions:">XQuery Expressions</a>&#34;</span>.</p>
<br/>
Footnote&nbsp;4:
<p>The question mark (<code>?</code>) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED" title="XQuery expressions are case-sensitive. An XQuery expression is either a simple expression or an updating expression, the latter being an expression that represents data modification. More precisely, these are the possible XQuery expressions:">XQuery Expressions</a>&#34;</span>.</p>
<br/>
Footnote&nbsp;5:
<p>The question mark (<code>?</code>) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-1F1A44CF-793C-4033-B91B-F519FB6B3BED" title="XQuery expressions are case-sensitive. An XQuery expression is either a simple expression or an updating expression, the latter being an expression that represents data modification. More precisely, these are the possible XQuery expressions:">XQuery Expressions</a>&#34;</span>.</p>
<br/>
Footnote&nbsp;6:
<p>Prior to Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.1), pragmas <code>ora:no_xmlquery_rewrite</code> and <code>ora:xmlquery_rewrite</code> were named <code>ora:xq_proc</code> and <code>ora:xq_qry</code>, respectively. They were renamed for readability, with no change in meaning.</p>
<br/></div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3410">
<tr>
<td class="cellalignment3417">
<table class="cellalignment3415">
<tr>
<td class="cellalignment3414"><a href="partpg2.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3414"><a href="xdb04cre.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3419">
<table class="cellalignment3413">
<tr>
<td class="cellalignment3414"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3414"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3414"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3414"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3414"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3414"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>


</body></html>