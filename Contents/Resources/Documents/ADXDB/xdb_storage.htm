<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-1634"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Choice%20of%20XMLType%20Storage%20and%20Indexing"></a><title>Choice of XMLType Storage and Indexing</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Important design choices for your application include what XMLType storage model to use and which indexing approaches to use."/>
<meta name="keywords" content="storage models for XMLType, choosing, indexing, XMLType"/>
<meta name="dcterms.created" content="2016-12-08T13:53:25Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="XML DB Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E41152-15"/>
<meta name="dcterms.isVersionOf" content="ADXDB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="partpgschema.htm" title="Previous" type="text/html"/>
<link rel="Next" href="xdb05sto.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41152-15.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1"></a> <span id="PAGE" style="display:none;">28/61</span> <!-- End Header -->
<a id="ADXDB6348"></a>
<h1 id="ADXDB-GUID-F1EE5B88-69E1-47B4-97FC-92F184C0CBA1" class="sect1"><span class="enumeration_chapter">16</span> Choice of XMLType Storage and Indexing</h1>
<div>
<p>Important design choices for your application include what <code>XMLType</code> storage model to use and which indexing approaches to use.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_storage.htm#GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF" title="XMLType is an abstract SQL data type that provides different storage and indexing models to best fit your XML data and your use of it. Because it is an abstract data type, your applications and database queries gain in flexibility: the same interface is available for all XMLType operations.">Introduction to Choosing an XMLType Storage Model and Indexing Approaches</a></p>
</li>
<li>
<p><a href="xdb_storage.htm#GUID-D91AC581-73C0-4211-AA20-E524CCDCB285" title="When choosing an XMLType storage model, consider the nature of your XML data and the ways you use it. There is a spectrum of use cases, ranging from most data-centric to most document-centric.">XMLType Use Case Spectrum: Data-Centric to Document-Centric</a></p>
</li>
<li>
<p><a href="xdb_storage.htm#GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" title="Recommendations are provided for application use cases that correspond to the common use cases for XML data stored as XMLType.">Common Use Cases for XML Data Stored as XMLType</a></p>
</li>
<li>
<p><a href="xdb_storage.htm#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" title="Each XMLType storage model has particular advantages and disadvantages.">XMLType Storage Options: Relative Advantages</a></p>
</li>
<li>
<p><a href="xdb_storage.htm#GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780" title="For XMLType data stored object-relationally, create B-tree and bitmap indexes just as you would for relational data. Use XMLIndex indexing with XMLType data that is stored as binary XML.">XMLType Indexing Considerations</a></p>
</li>
<li>
<p><a href="xdb_storage.htm#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" title="Each XMLType storage model has particular advantages and disadvantages.">XMLType Storage Options: Relative Advantages</a></p>
</li>
</ul>
</div>
<a id="ADXDB6349"></a>
<div class="props_rev_3"><a id="GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF"></a>
<h2 id="ADXDB-GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF" class="sect2"><span class="enumeration_section">16.1</span> Introduction to Choosing an XMLType Storage Model and Indexing Approaches</h2>
<div>
<p><code>XMLType</code> is an abstract SQL data type that provides different storage and indexing models to best fit your XML data and your use of it. Because it is an abstract data type, your applications and database queries gain in flexibility: the same interface is available for all <code>XMLType</code> operations.</p>
<p>Different applications use XML data in different ways. Sometimes it is constructed from relational data sources, so it is relatively structured. Sometimes it is used for extraction, transformation, and loading (ETL) operations, in which case it is also quite structured. Sometimes it is used for free-form documents (unstructured or semi-structured) such as books and articles.</p>
<p>Retrieval approaches can also be different for different kinds of data. Data-centric use cases often involve a fixed set of queries, whereas document-centric use cases often involve arbitrary (ad-hoc) queries.</p>
<p>Because there is a broad spectrum of XML usage, there is no one-size-fits-all storage model that offers optimal performance and flexibility for every use case. Oracle XML&nbsp;DB offers two storage models for <code>XMLType</code>, and several indexing methods appropriate to these different storage models. You can tailor performance and functionality to best fit the kind of XML data you have and the ways you use it.</p>
<p>Therefore, one key decision to make is which <code>XMLType</code> storage model to use for which XML data. This chapter helps you choose the best storage option for a given use case.</p>
<p><code>XMLType</code> tables and columns can be stored in the following ways:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Binary XML storage</span> &ndash; This is also referred to as <strong class="term">post-parse persistence</strong>. It is the default storage model for Oracle XML&nbsp;DB. It is a post-parse, binary format designed specifically for XML data. Binary XML is compact and XML schema-aware. The biggest advantage of Binary XML storage is <span class="italic">flexibility</span>: you can use it for XML schema-based documents or for documents that are not based on an XML schema. You can use it with an XML schema that allows for high data variability or that evolves considerably or unexpectedly. This storage model also provides efficient partial updating and streamable query evaluation.</p>
</li>
<li>
<p><span class="bold">Object-relational storage</span> &ndash; This is also referred to as <a id="d80959e172" class="indexterm-anchor"></a><strong class="term">structured</strong> storage and <strong class="term">object-based persistence</strong>. This storage model represents an entity-relationship (ER) decomposition of the XML data. It provides the best performance for highly structured data with a known and more or less fixed set of queries. Query performance matches that of relational data, and updates can be performed in place.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF__GUID-23E8420B-C100-4F76-A389-F9FB801864A6">
<p class="notep1">Note:</p>
<p>Starting with Oracle Database&nbsp;12<span class="italic">c</span> Release 1 (12.1.0.1), the unstructured (<code>CLOB</code>) storage model for <code>XMLType</code> is <span class="italic">deprecated</span>. Use binary XML storage instead.</p>
<p>If you have exising <code>XMLType</code> data that is stored as <code>CLOB</code> data then consider moving it to binary XML storage format using Oracle GoldenGate. If document fidelity is important for a particular XML document then store a copy of it in a relational <code>CLOB</code> column.</p>
</div>
<p>Oracle XML&nbsp;DB supports the following kinds of indexes on <code>XMLType</code> data.</p>
<ul style="list-style-type: disc;">
<li>
<p>B-tree functional indexes on object-relational storage</p>
</li>
<li>
<p>XML search index on binary XML storage</p>
</li>
<li>
<p><code>XMLIndex</code> with structured and unstructured components on binary XML storage</p>
</li>
<li>
<p>B-tree indexes on the secondary tables created automatically for <code>XMLIndex</code> (both structured and unstructured components) on binary XML storage</p>
</li>
</ul>
<p>Different use cases call for different combinations of <code>XMLType</code> storage model and indexes.</p>
<div class="infoboxnotealso" id="GUID-60132193-FCBB-4A7F-AA11-53CB660F67AF__GUID-5B88CB56-B9A0-4026-A7A0-E3866F430C87">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_indexing.htm#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_storage.htm#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" title="Each XMLType storage model has particular advantages and disadvantages.">XMLType Storage Options: Relative Advantages</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB3979"></a><a id="ADXDB6350"></a>
<div class="props_rev_3"><a id="GUID-D91AC581-73C0-4211-AA20-E524CCDCB285"></a>
<h2 id="ADXDB-GUID-D91AC581-73C0-4211-AA20-E524CCDCB285" class="sect2"><span class="enumeration_section">16.2</span> XMLType Use Case Spectrum: Data-Centric to Document-Centric</h2>
<div>
<p>When choosing an <code>XMLType</code> storage model, consider the nature of your XML data and the ways you use it. There is a spectrum of use cases, ranging from most data-centric to most document-centric.</p>
<p>This is illustrated in <a href="xdb_storage.htm#GUID-D91AC581-73C0-4211-AA20-E524CCDCB285__CHDGBEFE">Figure 16-1</a> , which shows the most data-centric cases at the left and the most document-centric cases at the right.</p>
<div class="figure" id="GUID-D91AC581-73C0-4211-AA20-E524CCDCB285__CHDGBEFE">
<p class="titleinfigure">Figure 16-1 XML Use Cases and XMLType Storage Models</p>
<img width="656" height="308" src="img/GUID-EE9E5208-25E5-4A0F-82AF-E640B4676A34-default.png" alt="Description of Figure 16-1 follows" title="Description of Figure 16-1 follows"/><br/>
<a href="img_text/GUID-EE9E5208-25E5-4A0F-82AF-E640B4676A34-print.htm">Description of &#34;Figure 16-1 XML Use Cases and XMLType Storage Models&#34;</a></div>
<!-- class="figure" -->
<p><strong class="term">Data-centric</strong> data is highly structured, with relatively static and predictable structure, and your applications take advantage of this structure. The data conforms to an XML schema.</p>
<p><strong class="term">Document-centric</strong> data can be divided into two cases:</p>
<ul style="list-style-type: disc;">
<li>
<p>The data is generally without structure or is of variable structure. This includes the case of documents that have both structured and unstructured parts. Document structure can vary over time (evolution), and the content can be <strong class="term">mixed</strong> (<strong class="term">semi-structured</strong>), with many elements containing both text nodes and child elements. Many XML elements can be absent or can appear in different orders. Documents might or might not conform to an XML schema.</p>
</li>
<li>
<p>The data is relatively structured, but your applications do not take advantage of that structure: they treat the data as if it were without structure.</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6351"></a>
<div class="props_rev_3"><a id="GUID-DA44C914-8E2C-4ED0-89E6-91E852592604"></a>
<h2 id="ADXDB-GUID-DA44C914-8E2C-4ED0-89E6-91E852592604" class="sect2"><span class="enumeration_section">16.3</span> Common Use Cases for XML Data Stored as XMLType</h2>
<div>
<p>Recommendations are provided for application use cases that correspond to the common use cases for XML data stored as <code>XMLType</code>.</p>
<p>If your use case is a common one, so that it is not covered here, then refer to the rest of this chapter for information about special cases.</p>
<div class="infobox-note" id="GUID-DA44C914-8E2C-4ED0-89E6-91E852592604__GUID-B4579E66-655F-4C5E-9676-B1B950172DC0">
<p class="notep1">Note:</p>
<p>This section is about the use of XML data that is persisted as <code>XMLType</code>. One common use case for XML data involves the generation of XML data from relational data. That case is not covered here, as it involves relational storage and the generated XML data is not necessarily persisted.</p>
<p>(For cases where generated XML data is persisted as <code>XMLType</code>, see <span class="q">&#34;<a href="xdb_storage.htm#GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D" title="In this use case, data is extracted from outside sources, transformed to fit operational needs (typically relational), and then loaded into the database: extract, transform, load (ETL). In particular, transformation distinguishes this use case.">XMLType Use Case: Staged XML Data for ETL</a>&#34;</span>.)</p>
</div>
<div class="infoboxnotealso" id="GUID-DA44C914-8E2C-4ED0-89E6-91E852592604__GUID-C9C458B3-E482-4ADE-B3CA-718C38008B16">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_storage.htm#GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780" title="For XMLType data stored object-relationally, create B-tree and bitmap indexes just as you would for relational data. Use XMLIndex indexing with XMLType data that is stored as binary XML.">XMLType Indexing Considerations</a>&#34;</span></p>
</li>
<li>
<p><a href="xdb_storage.htm#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" title="Each XMLType storage model has particular advantages and disadvantages.">XMLType Storage Options: Relative Advantages</a></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB6352"></a>
<div class="props_rev_3"><a id="GUID-54A1AD97-7AB8-4880-99FC-26EB35545B23"></a>
<h3 id="ADXDB-GUID-54A1AD97-7AB8-4880-99FC-26EB35545B23" class="sect3"><span class="enumeration_section">16.3.1</span> XMLType Use Case: No XML Fragment Updating or Querying</h3>
<div>
<p>In this use case there is no requirement to update or query fragments of XML data that is stored in the database.</p>
<p>You have these options for this use case:</p>
<ul style="list-style-type: disc;">
<li>
<p>Store it as <code>XMLType</code> using <span class="italic">binary XML storage</span>.</p>
</li>
<li>
<p>Store it in a <span class="italic">relational</span> <code>BLOB</code> or <code>CLOB</code> column, preferably a SecureFiles LOB.</p>
</li>
</ul>
<p>If you store the XML data in a relational LOB column, not as <code>XMLType</code>, Oracle Database does not parse the data and it cannot guarantee its validity. (And you cannot perform <code>XMLType</code> operations on the data.)</p>
</div>
</div>
<a id="ADXDB6353"></a>
<div class="props_rev_3"><a id="GUID-2871EBBB-4724-46B6-BB91-13C76014A263"></a>
<h3 id="ADXDB-GUID-2871EBBB-4724-46B6-BB91-13C76014A263" class="sect3"><span class="enumeration_section">16.3.2</span> XMLType Use Case: Data Integration from Diverse Sources with Different XML Schemas</h3>
<div>
<p>If your XML data comes from multiple data sources that use different XML schemas then use <span class="italic">binary XML storage</span>.</p>
<p>This use case has three subcases:</p>
<ul style="list-style-type: disc;">
<li>
<p>If the XML data contains islands of structured, predictable data, and your queries are known, then use <code>XMLIndex</code> with a <span class="italic">structured component</span> to index the structured islands (even if the data surrounding these islands is unstructured). A structured index component reflects the queries you use. An RSS news aggregator is an example of such a use case.</p>
</li>
<li>
<p>If there are no such structured islands or your queries are unknown ahead of time (ad hoc) then use <code>XMLIndex</code> with an unstructured component.</p>
</li>
<li>
<p>If you use queries that involve full-text search then use an XML search index, together with XQuery pragma <code>ora:no_schema</code>.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-2871EBBB-4724-46B6-BB91-13C76014A263__GUID-6E851D9B-442E-438A-9B3A-428FF51338B8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a>&#34;</span> and <span class="q">&#34;<a href="xdb_xquery.htm#GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948" title="The W3C XQuery specification lets an implementation provide implementation-defined extension expressions. An XQuery extension expression is an XQuery expression that is enclosed in braces ({,&nbsp;}) and prefixed by an implementation-defined pragma. The Oracle implementation provides several such pragmas.">Oracle XQuery Extension-Expression Pragmas</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB6354"></a>
<div class="props_rev_3"><a id="GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D"></a>
<h3 id="ADXDB-GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D" class="sect3"><span class="enumeration_section">16.3.3</span> XMLType Use Case: Staged XML Data for ETL</h3>
<div>
<p>In this use case, data is extracted from outside sources, transformed to fit operational needs (typically relational), and then loaded into the database: <span class="italic">extract</span>, <span class="italic">transform</span>, <span class="italic">load</span> (ETL). In particular, transformation distinguishes this use case.</p>
<p>ETL use cases often integrate data from multiple applications that are maintained or hosted by multiple parties using different software and hardware systems. The data that is extracted is often the responsibility of parties other than those who transform it or use it after transformation.</p>
<p>The XML data involved is typically highly structured and conforms to an XML schema. This use case covers both producing relational data from XML data and generating XML data from relational data.</p>
<p>A subset of ETL use cases involve the need to efficiently <span class="italic">update</span> the XML data. Updating can involve replacement of an entire XML document or changes to only fragments of a document (partial updating).</p>
<p><span class="italic">Object-relational storage</span> of <code>XMLType</code> data is generally appropriate for this use case.</p>
<div class="infoboxnotealso" id="GUID-F3243F0A-6541-4607-AF7F-D2C69DFE253D__GUID-8CA4FD0A-91A5-459F-B4F2-D91C9786C21C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_rel_views.htm#GUID-420496CE-D62F-4EBE-A76E-861B932AE1E6" title="Relational database views over XML data provide conventional, relational access to XML content.">Relational Views over XML Data</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB6355"></a>
<div class="props_rev_3"><a id="GUID-D5020A68-9D12-4EDB-9315-7F027C008226"></a>
<h3 id="ADXDB-GUID-D5020A68-9D12-4EDB-9315-7F027C008226" class="sect3"><span class="enumeration_section">16.3.4</span> XMLType Use Case: Semi-Structured XML Data</h3>
<div>
<p>In this use case, either your XML data is of variable form or large portions of it are not well defined. There might not be an associated XML schema, or the XML schema might allow for high data variability or evolve considerably or in unexpected ways.</p>
<p><span class="italic">Binary XML storage</span> of <code>XMLType</code> data is generally appropriate for this use case.</p>
<p>Use structured-component <code>XMLIndex</code> indexing when query paths are known, and use path-subsetted unstructured-component <code>XMLIndex</code> indexing when paths are not known beforehand (ad hoc queries). Use an XML search index for XQuery Full-Text queries.</p>
<div class="infoboxnotealso" id="GUID-D5020A68-9D12-4EDB-9315-7F027C008226__GUID-58EB4824-7258-4D32-A944-439A88F10F58">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB6356"></a>
<div class="props_rev_3"><a id="GUID-FA28FA05-1E8B-4EB5-BEB4-6B6482ED5BE6"></a>
<h3 id="ADXDB-GUID-FA28FA05-1E8B-4EB5-BEB4-6B6482ED5BE6" class="sect3"><span class="enumeration_section">16.3.5</span> XMLType Use Case: Business Intelligence Queries</h3>
<div>
<p>To enable business-intelligence (BI) queries over XML data, you can use SQL/XML function <code>XMLTable</code> to project values contained in the data as columns of a virtual table. Then use analytic-function windows, together with SQL <code>ORDER BY</code>and <code>GROUP BY</code>, to operate on columns of the virtual table.</p>
<p>For business-intelligence queries, you will generally do all of the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Store your <code>XMLType</code> data as binary XML.</p>
</li>
<li>
<p>Use an <code>XMLIndex</code> index with a structured component.</p>
</li>
<li>
<p>Create relational views over the data using SQL/XML function <code>XMLTable</code>, where the views project all columns of interest to the BI application.</p>
</li>
<li>
<p>Write your application queries against these relational views.</p>
</li>
</ul>
<p>If the <code>XMLIndex</code> index is created in one-to-one correspondence to these views, Oracle Database automatically translates queries over the views to queries over the relational tables of the structured <code>XMLIndex</code> component, providing relational performance.</p>
<p>When you use analytic-function windows, <code>ORDER BY</code>, or <code>GROUP BY</code> on a column of the virtual table, these operations are translated to windows, <code>ORDER BY</code>, and <code>GROUP BY</code> operations on the corresponding physical columns of the structured-component <code>XMLIndex</code> tables.</p>
<div class="infoboxnotealso" id="GUID-FA28FA05-1E8B-4EB5-BEB4-6B6482ED5BE6__GUID-F1844079-7D2D-4F36-989E-7A9DBD155B84">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>&#34;</span></p>
</li>
<li>
<p><a href="xdb_rel_views.htm#GUID-420496CE-D62F-4EBE-A76E-861B932AE1E6" title="Relational database views over XML data provide conventional, relational access to XML content.">Relational Views over XML Data</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB6357"></a>
<div class="props_rev_3"><a id="GUID-681F290F-581D-4344-BDE4-6FF98CD890FA"></a>
<h3 id="ADXDB-GUID-681F290F-581D-4344-BDE4-6FF98CD890FA" class="sect3"><span class="enumeration_section">16.3.6</span> XMLType Use Case: XML Queries Involving Full-Text Search</h3>
<div>
<p>If your application needs to perform full-text searches on XML data then use <span class="italic">binary XML storage</span> and create XML search indexes that correspond to your queries.</p>
<div class="infoboxnotealso" id="GUID-681F290F-581D-4344-BDE4-6FF98CD890FA__GUID-84C46639-1967-4AE4-A34E-EECC9115DCCD">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a>&#34;</span></p>
</div>
</div>
</div>
</div>
<a id="ADXDB6361"></a><a id="ADXDB6360"></a>
<div class="props_rev_3"><a id="GUID-320807FC-DB58-4600-8F92-A1247A354AE5"></a>
<h2 id="ADXDB-GUID-320807FC-DB58-4600-8F92-A1247A354AE5" class="sect2"><span class="enumeration_section">16.4</span> XMLType Storage Model Considerations</h2>
<div>
<p>For most use cases, Oracle recommends that you use binary XML storage of <code>XMLType</code>. Object-relational storage is appropriate in special cases.</p>
<p>Object-relational storage is not appropriate unless <span class="italic">all</span> of the following are true:</p>
<ul style="list-style-type: disc;">
<li>
<p>You have an XML schema that rigorously specifies the detailed data format of all XML documents that you intend to store in a given <code>XMLType</code> column or table. Your applications are data-centric.</p>
</li>
<li>
<p>You do not expect your XML schema to evolve frequently in ways that do not allow in-place schema evolution.</p>
</li>
<li>
<p>Your data is not especially sparse (does not include many elements that are empty or missing).</p>
</li>
<li>
<p>You do not necessarily insert and select whole XML documents at a time. Partial updates and selections are common.</p>
</li>
<li>
<p>You do not need document fidelity (DOM fidelity is sufficient).</p>
</li>
</ul>
<p><a href="xdb_storage.htm#GUID-320807FC-DB58-4600-8F92-A1247A354AE5__BABCJHFI" title="XMLType storage model considerations">Table 16-1</a> provides more detail about this. The guidelines it presents for choosing an <code>XMLType</code> storage model are <span class="italic">not</span> independent: follow them <span class="italic">in the order presented</span>, row by row, until a requirement in column <span class="bold">If...</span> is satisfied.</p>
<div class="tblformal" id="GUID-320807FC-DB58-4600-8F92-A1247A354AE5__BABCJHFI">
<p class="titleintable">Table 16-1 XMLType Storage Model Considerations</p>
<table class="cellalignment3420" title="XMLType Storage Model Considerations" summary="XMLType storage model considerations">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3425" id="d80959e927">If...</th>
<th class="cellalignment3425" id="d80959e930">Then...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e935" headers="d80959e927">
<p>1. You need the property of document fidelity, preserving all original whitespace.</p>
</td>
<td class="cellalignment3426" headers="d80959e935 d80959e930">
<p>Use binary XML storage for database use and XML processing. But also store a copy of the original documents in a <code>CLOB</code> (relational) column.</p>
<p>(It is your responsibility to keep the two versions synchronized, if you update the data.)</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e947" headers="d80959e927">
<p>2. You rarely need to select or update only a portion of your XML data. Instead, you typically insert and select whole XML documents at a time.</p>
</td>
<td class="cellalignment3426" headers="d80959e947 d80959e930">
<p>Use binary XML storage.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e954" headers="d80959e927">
<p>3. You need to store <code>XMLType</code> instances that conform to different XML schemas in the <span class="italic">same</span> <code>XMLType</code> table or column.</p>
<p>(Oracle does <span class="italic">not</span> recommend this practice in general, because it prohibits Oracle XML&nbsp;DB from using the XML schemas to optimize XML queries and other operations.)</p>
</td>
<td class="cellalignment3426" headers="d80959e954 d80959e930">
<p>Use binary XML storage.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e975" headers="d80959e927">
<p>4. You do <span class="italic">not</span> have an XML schema for your data.</p>
</td>
<td class="cellalignment3426" headers="d80959e975 d80959e930">
<p>Use binary XML storage.</p>
<p>If you think that your data could benefit from XML schema validation, then consider also whether you can generate an XML schema for it using a schema-generation tool.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e987" headers="d80959e927">
<p>5. You expect your XML schema to evolve frequently or in unexpected ways, and you <span class="italic">cannot</span> take advantage of in-place XML schema evolution.</p>
<p>In-place evolution is generally permitted only if the changes do not invalidate existing documents and they do not involve changing the storage model. See <a href="xdb07evo.htm#GUID-F2E920B3-C6D7-428B-9E75-5CE9C21F9B5F" title="You can use XML schema evolution to update your XML schema after you have registered it with Oracle XML&nbsp;DB.">XML Schema Evolution</a>.</p>
</td>
<td class="cellalignment3426" headers="d80959e987 d80959e930">
<p>Use binary XML storage.</p>
<p>Use PL/SQL procedure <code>DBMS_XMLSCHEMA.copyEvolve</code> to update the XML schema.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e1011" headers="d80959e927">
<p>6. Your XML data is very sparse.</p>
</td>
<td class="cellalignment3426" headers="d80959e1011 d80959e930">
<p>Use binary XML storage.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e1018" headers="d80959e927">
<p>7. Your XML schema does <span class="italic">not</span> make use of constructs such as elements <code>any</code> and <code>choice</code>, which do not provide a detailed specification of the data format.</p>
<p>(XML schema generators often include such constructs in the generated schemas.)</p>
</td>
<td class="cellalignment3426" headers="d80959e1018 d80959e930">
<p>Use object-relational storage.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e1036" headers="d80959e927">
<p>8. You can modify your XML schema to remove constructs such as <code>any</code> and <code>choice</code> that prevent a rigorous definition of the structure of your XML data.</p>
</td>
<td class="cellalignment3426" headers="d80959e1036 d80959e930">
<p>Remove such constructs, then use object-relational storage.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e1049" headers="d80959e927">
<p>9. You cannot remove such constructs.</p>
</td>
<td class="cellalignment3426" headers="d80959e1049 d80959e930">
<p>Use binary XML storage.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDB6363"></a><a id="ADXDB6362"></a>
<div class="props_rev_3"><a id="GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780"></a>
<h2 id="ADXDB-GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780" class="sect2"><span class="enumeration_section">16.5</span> XMLType Indexing Considerations</h2>
<div>
<p>For <code>XMLType</code> data stored object-relationally, create B-tree and bitmap indexes just as you would for relational data. Use <code>XMLIndex</code> indexing with <code>XMLType</code> data that is stored as binary XML.</p>
<p>For general indexing of document-centric XML data, use <code>XMLIndex</code> with an <span class="italic">unstructured component</span>. This is appropriate for queries that are ad hoc (arbitrary).</p>
<p>For data that contains predictable, fixed parts that you query frequently, use <code>XMLIndex</code> with <span class="italic">structured components</span> for those parts. An example of this use case is a specification that is generally free-form but that has fixed fields for the author, date, and title.</p>
<p>To handle islands of structure within generally unstructured content, create an <code>XMLIndex</code> index that has both structured and unstructured components. A use case where you might use both components would be to support queries that extract an XML fragment from a document whenever some structured data is present. The structured component of the index would be used for a query <code>WHERE</code> clause condition that checks for the structured data. The unstructured component would be used for the fragment extraction.</p>
<p><a href="xdb_storage.htm#GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780__BABDBDBA" title="Checklist for indexing binary XML data">Table 16-2</a> provides simple guidelines for indexing <code>XMLType</code> data that is stored as binary XML. These guidelines are <span class="italic">independent</span>: you can use a combination of indexing approaches if their <span class="bold">If...</span> conditions are satisfied.</p>
<div class="tblformal" id="GUID-93D32688-B8F8-4AD9-BD39-3E4A861FD780__BABDBDBA">
<p class="titleintable">Table 16-2 XMLType Indexing Considerations</p>
<table class="cellalignment3420" title="XMLType Indexing Considerations" summary="Checklist for indexing binary XML data">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3425" id="d80959e1137">If...</th>
<th class="cellalignment3425" id="d80959e1140">Then...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e1145" headers="d80959e1137">
<p>Your data contains predictable islands of structured data.</p>
</td>
<td class="cellalignment3426" headers="d80959e1145 d80959e1140">
<p>Use <code>XMLIndex</code>, with a structured component for each of the structured islands.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e1155" headers="d80959e1137">
<p>You need to support full-text queries.</p>
</td>
<td class="cellalignment3426" headers="d80959e1155 d80959e1140">
<p>Use XML search indexes.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d80959e1162" headers="d80959e1137">
<p>You need to support ad-hoc XML queries involving predicates.</p>
</td>
<td class="cellalignment3426" headers="d80959e1162 d80959e1140">
<p>Use <code>XMLIndex</code>, with an unstructured component.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDB6365"></a><a id="ADXDB6364"></a>
<div class="props_rev_3"><a id="GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7"></a>
<h2 id="ADXDB-GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7" class="sect2"><span class="enumeration_section">16.6</span> XMLType Storage Options: Relative Advantages</h2>
<div>
<p>Each <code>XMLType</code> storage model has particular advantages and disadvantages.</p>
<p><a href="xdb_storage.htm#GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7__BIHIIJBA" title="This table has 3 columns and 8 rows. It summarizes structured and unstructured storage options and their benefits. The first row summarizes throughoutput features, the second row, flexibility, and so on.">Table 16-3</a> summarizes the advantages and disadvantages of each <code>XMLType</code> storage model. Symbols + and &ndash; provide a rough indication of strength and weakness, respectively.</p>
<div class="tblformalwide" id="GUID-DFD4521D-3733-4C2A-BBC2-22D0CC74A7D7__BIHIIJBA">
<p class="titleintable">Table 16-3 XMLType Storage Models: Relative Advantages</p>
<table class="cellalignment3431" title="XMLType Storage Models: Relative Advantages" summary="This table has 3 columns and 8 rows. It summarizes structured and unstructured storage options and their benefits. The first row summarizes throughoutput features, the second row, flexibility, and so on.">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3427" id="d80959e1217">Quality</th>
<th class="cellalignment3441" id="d80959e1220">Binary XML Storage</th>
<th class="cellalignment3441" id="d80959e1223">Object-Relational Storage</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1228" headers="d80959e1217">
<p>Throughput</p>
</td>
<td class="cellalignment3443" headers="d80959e1228 d80959e1220">
<p>(+) High throughput. Fast DOM loading. There is a slight overhead from the binary encoder/decoder.</p>
</td>
<td class="cellalignment3443" headers="d80959e1228 d80959e1223">
<p>(&ndash;) XML decomposition can result in reduced throughput when ingesting or retrieving the entire content of an XML document.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1238" headers="d80959e1217">
<p>Indexing support</p>
</td>
<td class="cellalignment3443" headers="d80959e1238 d80959e1220">
<p><code>XMLIndex</code> and XML search indexes.</p>
</td>
<td class="cellalignment3443" headers="d80959e1238 d80959e1223">
<p>B-tree, bitmap, and Oracle Text indexes on specific elements or attributes.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1250" headers="d80959e1217">
<p>Queries</p>
</td>
<td class="cellalignment3443" headers="d80959e1250 d80959e1220">
<p>(+) Fast when using <code>XMLIndex</code>. Queries that cannot use an index use streaming XPath evaluation, which can also be fast.</p>
</td>
<td class="cellalignment3443" headers="d80959e1250 d80959e1223">
<p>(++) Relational query performance. You can create B-tree indexes on the underlying object-relational columns.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1263" headers="d80959e1217">
<p>Update operations (DML)</p>
</td>
<td class="cellalignment3443" headers="d80959e1263 d80959e1220">
<p>(+) In-place, piecewise update for SecureFiles LOB storage.</p>
</td>
<td class="cellalignment3443" headers="d80959e1263 d80959e1223">
<p>(++) Relational update performance. Columns are updated in place.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1273" headers="d80959e1217">
<p>Data flexibility</p>
</td>
<td class="cellalignment3443" headers="d80959e1273 d80959e1220">
<p>(+) Flexibility in the structure of the XML documents that can be stored in an <code>XMLType</code> column or table.</p>
</td>
<td class="cellalignment3443" headers="d80959e1273 d80959e1223">
<p>(&ndash;) Limited flexibility. Only documents that conform to the XML schema can be stored.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1286" headers="d80959e1217">
<p>XML schema flexibility</p>
</td>
<td class="cellalignment3443" headers="d80959e1286 d80959e1220">
<p>(++) Both XML schema-based and non-schema-based documents can be stored. Documents conforming to any XML schemas that have been registered can be stored in the same <code>XMLType</code> table or column.</p>
</td>
<td class="cellalignment3443" headers="d80959e1286 d80959e1223">
<p>(&ndash;) Only documents that conform to the same XML schema can be stored in a given <code>XMLType</code> table or column.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1302" headers="d80959e1217">
<p>Validation upon insert</p>
</td>
<td class="cellalignment3443" headers="d80959e1302 d80959e1220">
<p>(++) XML schema-based data can be fully validated when it is inserted, but this takes time.</p>
</td>
<td class="cellalignment3443" headers="d80959e1302 d80959e1223">
<p>(+) XML data is partially validated when it is inserted.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3429" id="d80959e1312" headers="d80959e1217">
<p>Compression and Encryption</p>
</td>
<td class="cellalignment3443" headers="d80959e1312 d80959e1220">
<p>(+) Binary XML with SecureFiles LOB storage can be compressed/encrypted.</p>
</td>
<td class="cellalignment3443" headers="d80959e1312 d80959e1223">
<p>(++) Each XML element/attribute can be compressed/encrypted individually.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3410">
<tr>
<td class="cellalignment3417">
<table class="cellalignment3415">
<tr>
<td class="cellalignment3414"><a href="partpgschema.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3414"><a href="xdb05sto.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3419">
<table class="cellalignment3413">
<tr>
<td class="cellalignment3414"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3414"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3414"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3414"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3414"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3414"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>