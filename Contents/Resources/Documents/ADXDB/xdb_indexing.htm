<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-1626"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Indexes%20for%20XMLType%20Data"></a><title>Indexes for XMLType Data</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use."/>
<meta name="keywords" content="XMLType, indexing columns, indexing, XMLIndex, structured component, definition, structured XMLIndex component, unstructured component, unstructured XMLIndex component, procedures, PL/SQL, exchangePreProc, DBMS_XMLSTORAGE_MANAGE PL/SQL package, exchangePreProc procedure, exchangePostProc, exchangePostProc procedure, path index of XMLIndex, path index, order index of XMLIndex, order index, value index of XMLIndex, value index, path table of XMLIndex, path table, effective text value of a node, text value of a node, effective, creating index, renaming index, renaming an XMLIndex index, dropping index, group in an XMLIndex structured component, syncIndex PL/SQL procedure, syncIndex, DBMS_XMLINDEX PL/SQL package, syncIndex procedure, ORA-08181 error, synchronizing if ORA-08181, error, ORA-08181, registerParameter PL/SQL procedure, registerParameter, registerParameter procedure, modifyParameter PL/SQL procedure, modifyParameter, modifyParameter procedure, Oracle Text, XML-enabled, full-text, full-text indexing, Oracle Text, XML-enabled index, XML search index, ora:no_schema Oracle XQuery pragma, XQuery, pragmas, Oracle, ora:no_schema, ora:use_xmltext_idx Oracle XQuery pragma, ora:use_xmltext_idx, XPath rewrite, indexes on singleton elements and attributes"/>
<meta name="dcterms.created" content="2016-12-08T13:53:25Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="XML DB Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E41152-15"/>
<meta name="dcterms.isVersionOf" content="ADXDB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="xdb04cre.htm" title="Previous" type="text/html"/>
<link rel="Next" href="xdb08tra.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41152-15.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC"></a> <span id="PAGE" style="display:none;">15/61</span> <!-- End Header -->
<script>
//<![CDATA[
window.name='xdb_indexing'
//]]>
</script> <script>
    function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote&amp;nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
</script><noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="ADXDB0500"></a>
<h1 id="ADXDB-GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" class="sect1"><span class="enumeration_chapter">6</span> Indexes for XMLType Data</h1>
<div>
<p>You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index <code>XMLType</code> data, whether it is XML schema-based or non-schema-based, and regardless of the <code>XMLType</code> storage model you use.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_indexing.htm#GUID-9F243764-7945-4EF4-9C94-624BE732708F" title="Common tasks involving indexes for XML data are described.">Oracle XML&nbsp;DB Tasks Involving Indexes</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-AEF30229-B377-4479-9627-45494B772392" title="Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.">Overview of Indexing XMLType Data</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46" title="B-tree indexes can be used advantageously with object-relational XMLType storage&thinsp;&mdash;&thinsp;they provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of XMLIndex.XMLIndex is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to XMLType data that is stored as binary XML.You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.Although the index content tables of an XMLIndex structured component are normal relational tables, they are also read-only: you cannot add or drop their columns or modify (insert, update, or delete) their rows. The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).In exchange partitioning, you exchange a table with a partition of another table. The first table (call it exchange_table) must have the same structure as the partition (call it partition) of the second table (call it table) with which it will be exchanged.Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general. Though you can create secondary indexes on path-table columns, you can generally ignore the path table itself. A secondary index on column VALUE is used with XPath expressions in a WHERE clause that have predicates involving string matches. For example:Even if you do not specify a secondary index for column VALUE when you create an XMLIndex index, a default secondary index is created on column VALUE. This default index has the default properties&thinsp;&mdash;&thinsp;in particular, it is an index for text (string-valued) data only.A few types of XPath expressions are not indexed by XMLIndex.Basic operations on an XMLIndex index include creating it, dropping it, altering it, and examining it. Examples are presented.You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.You can add extra secondary indexes to an XMLIndex unstructured component.An XMLIndex structured component indexes specific islands of structure in your XML data.When you create an XMLIndex index that has a structured component you can specify XML namespaces and storage options to use.You can use ALTER INDEX to add a structured component to an existing XMLIndex index.You can prevent ALTER INDEX from blocking when you add a group or column for the structured component of an XMLIndex index, so that queries that use the index do not need to wait.If an error is raised because some of your data does not match the data type used for the corresponding column of the structured XMLIndex component, you can in some cases simply modify the index by passing keyword MODIFY_COLUMN_TYPE to ALTER INDEX. If an XMLIndex index has both an unstructured and a structured component, then you can use ALTER INDEX to drop the structured component. You do this by dropping all of the structure groups that compose the structured component. Because the tables used for the structured component of an XMLIndex index are normal relational tables, you can index them using any standard relational indexes. To know whether a particular XMLIndex index has been used in resolving a query, you can examine an execution plan for the query. You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */. If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.Some examples are presented of defining XMLIndex indexes on subsets of XPath expressions.Rules that apply to XMLIndex path subsetting are described.There are several guidelines that can help you use XMLIndex with an unstructured component.There are several guidelines that can help you use XMLIndex with a structured component.If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.If a query raises error ORA-08181, check whether the base XMLType table of the query has an XMLIndex index with an unstructured component. If so, then manually synchronize the XMLIndex index using DBMS_XMLINDEX.syncIndex.The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects. Information about the standard database indexes is available in static public views USER_INDEXES, ALL_INDEXES, and DBA_INDEXES. Similar information about XMLIndex indexes is available in static public views USER_XML_INDEXES, ALL_XML_INDEXES, and DBA_XML_INDEXES.Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.The string value used for the PARAMETERS clause of a CREATE INDEX or ALTER INDEX statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures registerParameter and modifyParameter in package DBMS_XMLINDEX.The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.When you create an XMLIndex index, if there is no XMLIndex_parameters_clause, then the new index has only an unstructured component. If there is an XMLIndex_parameters_clause, but the PARAMETERS argument is empty (&#39;&#39;), then the result is the same: an index with only an unstructured component.Certain considerations apply to using XMLIndex_parameters.Certain considerations apply to using the PATHS clause.Certain considerations apply to using create_index_paths_clause and alter_index_paths_clause.Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.Certain considerations apply to using value_clause.Certain considerations apply to using the ASYNC clause.Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX. Certain considerations apply to using XMLIndex_xmltable_clause.Certain considerations apply to using column_clause.">XMLIndex</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a></p>
</li>
</ul>
<div class="infobox-note" id="GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC__GUID-9F40EC93-FD49-4583-8ACE-155B1FD58BE8">
<p class="notep1">Note:</p>
<p>The execution plans shown here are for illustration only. If you run the examples presented here in your environment then your execution plans might not be identical.</p>
</div>
<div class="infoboxnotealso" id="GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC__GUID-36013FE2-5AF4-4941-8955-75877975E687">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CNCPT811" target="_blank" href="../CNCPT/indexiot.htm#CNCPT811"><span class="italic">Oracle Database Concepts</span></a> for an overview of indexing</p>
</li>
<li>
<p><a class="olink ADFNS005" target="_blank" href="../ADFNS/adfns_indexes.htm#ADFNS005"><span class="italic">Oracle Database Development Guide</span></a> for information about using indexes in application development</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB5812"></a><a id="ADXDB5813"></a><a id="ADXDB5814"></a><a id="ADXDB5815"></a><a id="ADXDB4308"></a>
<div class="props_rev_3"><a id="GUID-9F243764-7945-4EF4-9C94-624BE732708F"></a>
<h2 id="ADXDB-GUID-9F243764-7945-4EF4-9C94-624BE732708F" class="sect2"><span class="enumeration_section">6.1</span> Oracle XML&nbsp;DB Tasks Involving Indexes</h2>
<div>
<p>Common tasks involving indexes for XML data are described.</p>
<p><a href="xdb_indexing.htm#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGBDDDE" title="Basic tasks involving indexing XML data">Table 6-1</a> identifies the documentation for some basic user tasks involving indexes for XML data.</p>
<div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGBDDDE">
<p class="titleintable">Table 6-1 Basic XML Indexing Tasks</p>
<table class="cellalignment3431" title="Basic XML Indexing Tasks" summary="Basic tasks involving indexing XML data">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3548" id="d38232e467">For information about how to...</th>
<th class="cellalignment3486" id="d38232e470">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e475" headers="d38232e467">
<p>Choose an indexing approach</p>
</td>
<td class="cellalignment3488" headers="d38232e475 d38232e470">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-AEF30229-B377-4479-9627-45494B772392" title="Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.">Overview of Indexing XMLType Data</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e488" headers="d38232e467">
<p>Index <code>XMLType</code> data stored object-relationally</p>
</td>
<td class="cellalignment3488" headers="d38232e488 d38232e470">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>&#34;</span>, <span class="q">&#34;<a href="xdb_rewrite.htm#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4" title="If a collection is stored as an ordered collection table (OCT) or as an XMLType instance, then you can directly access members of the collection. Each member becomes a table row, so you can access it directly with SQL. You can often improve performance by indexing such collection members.">Guideline: Create indexes on ordered collection tables</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e518" headers="d38232e467">
<p>Create, drop, or rename an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3488" headers="d38232e518 d38232e470">
<p><a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-5</a>, <a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDFIGIB">Example 6-7</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e530" headers="d38232e467">
<p>Obtain the name of an <code>XMLIndex</code> index for a given table or column</p>
</td>
<td class="cellalignment3488" headers="d38232e530 d38232e470">
<p><a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDDGHDF">Example 6-6</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e540" headers="d38232e467">
<p>Determine whether a given <code>XMLIndex</code> index is used in evaluating a query</p>
</td>
<td class="cellalignment3488" headers="d38232e540 d38232e470">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52" title="To know whether a particular XMLIndex index has been used in resolving a query, you can examine an execution plan for the query.">How to Tell Whether XMLIndex is Used</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e559" headers="d38232e467">
<p>Turn off use of an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3488" headers="d38232e559 d38232e470">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-572DB598-0A31-4143-889B-98D883211FC6" title="You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */.">Turning Off Use of XMLIndex</a>&#34;</span></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="xdb_indexing.htm#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDECIA" title="Tasks involving XMLIndex indexes with a structured component">Table 6-2</a> identifies the documentation for some user tasks involving <code>XMLIndex</code> indexes that have a <span class="italic">structured</span> component.</p>
<div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDECIA">
<p class="titleintable">Table 6-2 Tasks Involving XMLIndex Indexes with a Structured Component</p>
<table class="cellalignment3431" title="Tasks Involving XMLIndex Indexes with a Structured Component" summary="Tasks involving XMLIndex indexes with a structured component">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3550" id="d38232e605">For information about how to...</th>
<th class="cellalignment3482" id="d38232e608">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e613" headers="d38232e605">
<p>Create an <code>XMLIndex</code> index with a structured component</p>
</td>
<td class="cellalignment3485" headers="d38232e613 d38232e608">
<p><a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a>, <a href="xdb_indexing.htm#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">Example 6-19</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e625" headers="d38232e605">
<p>Drop the structured component of an <code>XMLIndex</code> index (drop all structure groups)</p>
</td>
<td class="cellalignment3485" headers="d38232e625 d38232e608">
<p><a href="xdb_indexing.htm#GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8__BCGJGJAD">Example 6-22</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e635" headers="d38232e605">
<p>Ensure data type correspondence between a query and an <code>XMLIndex</code> index with a structured component</p>
</td>
<td class="cellalignment3485" headers="d38232e635 d38232e608">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" title="The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).">Data Type Considerations for XMLIndex Structured Component</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e654" headers="d38232e605">
<p>Create a B-tree index on a content table of an <code>XMLIndex</code> structured component</p>
</td>
<td class="cellalignment3485" headers="d38232e654 d38232e608">
<p><a href="xdb_indexing.htm#GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9__BCGEGABJ">Example 6-23</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e664" headers="d38232e605">
<p>Create an Oracle Text <code>CONTEXT</code> index on a content table of an <code>XMLIndex</code> structured component</p>
</td>
<td class="cellalignment3485" headers="d38232e664 d38232e608">
<p><a href="xdb_indexing.htm#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-43</a></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="xdb_indexing.htm#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGFHJJE" title="Tasks involving XMLIndex indexes with an unstructured component">Table 6-3</a> identifies the documentation for some user tasks involving <code>XMLIndex</code> indexes that have an <span class="italic">unstructured</span> component.</p>
<div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGFHJJE">
<p class="titleintable">Table 6-3 Tasks Involving XMLIndex Indexes with an Unstructured Component</p>
<table class="cellalignment3431" title="Tasks Involving XMLIndex Indexes with an Unstructured Component" summary="Tasks involving XMLIndex indexes with an unstructured component">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3550" id="d38232e698">For information about how to...</th>
<th class="cellalignment3482" id="d38232e701">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e706" headers="d38232e698">
<p>Create an <code>XMLIndex</code> index with an unstructured component</p>
</td>
<td class="cellalignment3485" headers="d38232e706 d38232e701">
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-8</a>, <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-10</a>, <a href="xdb_indexing.htm#GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDIHICC">Example 6-30</a>, <a href="xdb_indexing.htm#GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDJEICC">Example 6-32</a>, <a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">Example 6-33</a>, <a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">Example 6-34</a>, <a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">Example 6-35</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e729" headers="d38232e698">
<p>Drop the unstructured component of an <code>XMLIndex</code> index (drop the path table)</p>
</td>
<td class="cellalignment3485" headers="d38232e729 d38232e701">
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__BCGHIIFB">Example 6-11</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e739" headers="d38232e698">
<p>Name the path table when creating an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3485" headers="d38232e739 d38232e701">
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-8</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e749" headers="d38232e698">
<p>Specify storage options when creating an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3485" headers="d38232e749 d38232e701">
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-10</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e759" headers="d38232e698">
<p>Show all existing secondary indexes on an <code>XMLIndex</code> path table</p>
</td>
<td class="cellalignment3485" headers="d38232e759 d38232e701">
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">Example 6-12</a>, <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-18</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e771" headers="d38232e698">
<p>Obtain the name of a path table for an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3485" headers="d38232e771 d38232e701">
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">Example 6-9</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e781" headers="d38232e698">
<p>Obtain the name of an <code>XMLIndex</code> index with an unstructured component, given its path table</p>
</td>
<td class="cellalignment3485" headers="d38232e781 d38232e701">
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDBCJIG">Example 6-25</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e791" headers="d38232e698">
<p>Create a secondary index on an <code>XMLIndex</code> path table</p>
</td>
<td class="cellalignment3485" headers="d38232e791 d38232e701">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" title="You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.">Using XMLIndex with an Unstructured Component</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e810" headers="d38232e698">
<p>Obtain information about all of the secondary indexes on an <code>XMLIndex</code> path table</p>
</td>
<td class="cellalignment3485" headers="d38232e810 d38232e701">
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-18</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e820" headers="d38232e698">
<p>Create a function-based index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment3485" headers="d38232e820 d38232e701">
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-13</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e830" headers="d38232e698">
<p>Create a numeric index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment3485" headers="d38232e830 d38232e701">
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">Example 6-15</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e841" headers="d38232e698">
<p>Create a date index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment3485" headers="d38232e841 d38232e701">
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">Example 6-16</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e851" headers="d38232e698">
<p>Create an Oracle Text <code>CONTEXT</code> index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment3485" headers="d38232e851 d38232e701">
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">Example 6-17</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e864" headers="d38232e698">
<p>Exclude or include particular XPath expressions from use by an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3485" headers="d38232e864 d38232e701">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e883" headers="d38232e698">
<p>Specify namespace prefixes for XPath expressions used for <code>XMLIndex</code></p>
</td>
<td class="cellalignment3485" headers="d38232e883 d38232e701">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e901" headers="d38232e698">
<p>Exclude or include particular XPath expressions from use by an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3485" headers="d38232e901 d38232e701">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3551" id="d38232e920" headers="d38232e698">
<p>Specify namespace prefixes for XPath expressions used for <code>XMLIndex</code></p>
</td>
<td class="cellalignment3485" headers="d38232e920 d38232e701">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a>&#34;</span></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="xdb_indexing.htm#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDFDFE" title="Miscellaneous tasks involving XMLIndex indexes">Table 6-4</a> identifies the documentation for some other user tasks involving <code>XMLIndex</code> indexes.</p>
<div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDFDFE">
<p class="titleintable">Table 6-4 Miscellaneous Tasks Involving XMLIndex Indexes</p>
<table class="cellalignment3431" title="Miscellaneous Tasks Involving XMLIndex Indexes" summary="Miscellaneous tasks involving XMLIndex indexes">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3548" id="d38232e956">For information about how to...</th>
<th class="cellalignment3486" id="d38232e959">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e964" headers="d38232e956">
<p>Specify that an <code>XMLIndex</code> index should be created and maintained using parallel processes</p>
</td>
<td class="cellalignment3488" headers="d38232e964 d38232e959">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" title="If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.">XMLIndex Partitioning and Parallelism</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e989" headers="d38232e956">
<p>Change the parallelism of an <code>XMLIndex</code> path table to tune index performance</p>
</td>
<td class="cellalignment3488" headers="d38232e989 d38232e959">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" title="If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.">XMLIndex Partitioning and Parallelism</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e1014" headers="d38232e956">
<p>Schedule maintenance for an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment3488" headers="d38232e1014 d38232e959">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e1039" headers="d38232e956">
<p>Manually synchronize an <code>XMLIndex</code> index and its base table</p>
</td>
<td class="cellalignment3488" headers="d38232e1039 d38232e959">
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a>&#34;</span></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e1064" headers="d38232e956">
<p>Collect statistics on a table or index for the cost-based optimizer</p>
</td>
<td class="cellalignment3488" headers="d38232e1064 d38232e959">
<p><a href="xdb_indexing.htm#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__CHDEHFDF">Example 6-37</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e1071" headers="d38232e956">
<p>Create an XML search index</p>
</td>
<td class="cellalignment3488" headers="d38232e1071 d38232e959">
<p><a href="xdb_indexing.htm#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">Example 6-38</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e1078" headers="d38232e956">
<p>Use an XML search index for full-text search of XML data stored as binary XML</p>
</td>
<td class="cellalignment3488" headers="d38232e1078 d38232e959">
<p><a href="xdb_indexing.htm#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGJABCA">Example 6-39</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e1085" headers="d38232e956">
<p>Show whether an XML search index is used in a query</p>
</td>
<td class="cellalignment3488" headers="d38232e1085 d38232e959">
<p><a href="xdb_indexing.htm#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGCHDFB">Example 6-40</a></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3549" id="d38232e1092" headers="d38232e956">
<p>Create an Oracle Text <code>CONTEXT</code> index on a content table of an <code>XMLIndex</code> structured component</p>
</td>
<td class="cellalignment3488" headers="d38232e1092 d38232e959">
<p><a href="xdb_indexing.htm#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-43</a></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDB6280"></a><a id="ADXDB6281"></a><a id="ADXDB6282"></a><a id="ADXDB4310"></a>
<div class="props_rev_3"><a id="GUID-AEF30229-B377-4479-9627-45494B772392"></a>
<h2 id="ADXDB-GUID-AEF30229-B377-4479-9627-45494B772392" class="sect2"><span class="enumeration_section">6.2</span> Overview of Indexing XMLType Data</h2>
<div>
<p>Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.</p>
<p>The principle way you index XML data is using <code>XMLIndex</code>. You can also use Oracle Text <code>CONTEXT</code> indexes to supplement the use of <code>XMLIndex</code>.</p>
<p>Here is a summary decision tree, as the place to start when choosing ways to index <code>XMLType</code> data stored as binary XML:<a id="fn_1" href="#fn_1" onclick="footdisplay(1,&#34;For XMLType data stored object-relationally, see \&#34;Indexing XMLType Data Stored Object-Relationally\&#34;. If your data is highly structured throughout, or your queries are not known at index creation time, then this approach might be appropriate. &#34;)"><sup>Foot&nbsp;1</sup></a></p>
<div class="section">
<p class="subhead2">If your XML data contains islands of structured, predictable data, and your queries are known</p>
<p>Use <code>XMLIndex</code> with a <span class="italic">structured component</span> to index the structured islands (even if the data surrounding these islands is unstructured).</p>
<p>A structured index component reflects the queries you use. You can change this set of known queries over time, provided you update the index definition accordingly. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">If you need to query full-text content within your XML data</p>
<p>Use an <span class="italic">XML search index</span>. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63" title="Besides accessing XML nodes such as elements and attributes, it is sometimes important to provide fast access to particular passages within XML text nodes. To query such content within XML data, you can use XQuery Full Text (XQFT) or Oracle-specific full-text constructs.">Oracle Text Indexes for XML Data</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">If you need to support ad-hoc XML queries that involve predicates</p>
<p>Use <code>XMLIndex</code> with an <span class="italic">unstructured component</span> &ndash; see <span class="q">&#34;<a href="xdb_indexing.htm#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="section">
<p>Does your XML data contain <span class="italic">islands of data that is highly structured and predictable</span> (even if the surrounding data might be unstructured)?</p>
<ul style="list-style-type: disc;">
<li>
<p>Yes. Use <code>XMLIndex</code> with a structured component to index the islands. See &#34;XMLIndex Structured Component&#34; on page&nbsp;6‐12.</p>
</li>
<li>
<p>No. Do you need to <span class="italic">query full-text content</span> within your XML data?</p>
<ul style="list-style-type: disc;">
<li>
<p>Yes. Use an XML search index. See &#34;Oracle Text Indexes for XML Data&#34; on page&nbsp;6‐5.</p>
</li>
<li>
<p>No. Do you need to support <span class="italic">ad-hoc XML queries that involve predicates</span>? If so, use XMLIndex with an unstructured component &ndash; see &#34;XMLIndex Unstructured Component&#34; on page&nbsp;6‐16. If not, do not bother to index your XML data.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDB5816"></a>
<div class="props_rev_3"><a id="GUID-9AD9EB86-8877-4349-A6ED-69B779783AE0"></a>
<h3 id="ADXDB-GUID-9AD9EB86-8877-4349-A6ED-69B779783AE0" class="sect3"><span class="enumeration_section">6.2.1</span> XMLIndex Addresses the Fine-Grained Structure of XML Data</h3>
<div>
<p>You can create indexes on one or more relational columns, or on a functional expression. XML data, however, has its own, fine-grained structure, which is not necessarily reflected in the structure of the database tables used to store it. For this reason, effectively indexing XML data can be a bit different from indexing most database data.</p>
<p>For object-relational <code>XMLType</code> storage, XML objects such as elements and attributes correspond to object-relational columns and tables. Creating <span class="italic">B-tree indexes</span> on those columns and tables thus provides an excellent way to effectively index the corresponding XML objects. Here, the storage model directly reflects the fine-grained structure of the XML data, so there is no special problem for indexing structured XML data. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>&#34;</span>.</p>
<p>In object-relational <code>XMLType</code> storage, an XML document is broken up and stored object-relationally, but you can choose to store one or more of its XML fragments as embedded <code>CLOB</code> instances. A typical use case for this is mapping an XML-schema <code>complexType</code> or a complex element to <code>CLOB</code> storage, because you generally access the entire fragment as a unit.</p>
<p>But such an embedded <code>CLOB</code> fragment also acts as an opaque unit when it comes to indexing; its parts are not indexed individually.</p>
<p>Similarly, standard indexing is not helpful for binary XML storage. In both of these cases, indexing a database column using the standard sorts of index (B-tree, bitmap) is generally not helpful for accessing particular parts of an XML document.</p>
<p><span class="italic"><code>XMLIndex</code></span> provides a general, XML-specific index that indexes the internal structure of XML data. One of its main purposes is to overcome the indexing limitation presented by binary XML storage.</p>
<ul style="list-style-type: disc;">
<li>
<p>An <code>XMLIndex</code> index with an <span class="italic">unstructured component</span> indexes the XML <span class="italic">tags</span> of your document and identifies document fragments based on XPath expressions that target them. It can also index scalar node <span class="italic">values</span>, to provide quick lookup based on individual values or ranges of values. It also records document <span class="italic">hierarchy</span> information for each node it indexes: relations parent&ndash;child, ancestor&ndash;descendant, and sibling. This index component is particularly useful for queries that extract XML fragments from documents that have little or variable structure.</p>
</li>
<li>
<p>An <code>XMLIndex</code> index with a <span class="italic">structured component</span> indexes highly structured and predictable parts of XML data that is nevertheless for the most part unstructured. This index component is particularly useful for queries that project and use such islands of structured content.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-9AD9EB86-8877-4349-A6ED-69B779783AE0__GUID-B2F00FEC-90AF-4DE7-A02F-BB0157CC2CEC">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46" title="B-tree indexes can be used advantageously with object-relational XMLType storage&thinsp;&mdash;&thinsp;they provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of XMLIndex.XMLIndex is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to XMLType data that is stored as binary XML.You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.Although the index content tables of an XMLIndex structured component are normal relational tables, they are also read-only: you cannot add or drop their columns or modify (insert, update, or delete) their rows. The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).In exchange partitioning, you exchange a table with a partition of another table. The first table (call it exchange_table) must have the same structure as the partition (call it partition) of the second table (call it table) with which it will be exchanged.Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general. Though you can create secondary indexes on path-table columns, you can generally ignore the path table itself. A secondary index on column VALUE is used with XPath expressions in a WHERE clause that have predicates involving string matches. For example:Even if you do not specify a secondary index for column VALUE when you create an XMLIndex index, a default secondary index is created on column VALUE. This default index has the default properties&thinsp;&mdash;&thinsp;in particular, it is an index for text (string-valued) data only.A few types of XPath expressions are not indexed by XMLIndex.Basic operations on an XMLIndex index include creating it, dropping it, altering it, and examining it. Examples are presented.You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.You can add extra secondary indexes to an XMLIndex unstructured component.An XMLIndex structured component indexes specific islands of structure in your XML data.When you create an XMLIndex index that has a structured component you can specify XML namespaces and storage options to use.You can use ALTER INDEX to add a structured component to an existing XMLIndex index.You can prevent ALTER INDEX from blocking when you add a group or column for the structured component of an XMLIndex index, so that queries that use the index do not need to wait.If an error is raised because some of your data does not match the data type used for the corresponding column of the structured XMLIndex component, you can in some cases simply modify the index by passing keyword MODIFY_COLUMN_TYPE to ALTER INDEX. If an XMLIndex index has both an unstructured and a structured component, then you can use ALTER INDEX to drop the structured component. You do this by dropping all of the structure groups that compose the structured component. Because the tables used for the structured component of an XMLIndex index are normal relational tables, you can index them using any standard relational indexes. To know whether a particular XMLIndex index has been used in resolving a query, you can examine an execution plan for the query. You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */. If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.Some examples are presented of defining XMLIndex indexes on subsets of XPath expressions.Rules that apply to XMLIndex path subsetting are described.There are several guidelines that can help you use XMLIndex with an unstructured component.There are several guidelines that can help you use XMLIndex with a structured component.If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.If a query raises error ORA-08181, check whether the base XMLType table of the query has an XMLIndex index with an unstructured component. If so, then manually synchronize the XMLIndex index using DBMS_XMLINDEX.syncIndex.The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects. Information about the standard database indexes is available in static public views USER_INDEXES, ALL_INDEXES, and DBA_INDEXES. Similar information about XMLIndex indexes is available in static public views USER_XML_INDEXES, ALL_XML_INDEXES, and DBA_XML_INDEXES.Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.The string value used for the PARAMETERS clause of a CREATE INDEX or ALTER INDEX statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures registerParameter and modifyParameter in package DBMS_XMLINDEX.The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.When you create an XMLIndex index, if there is no XMLIndex_parameters_clause, then the new index has only an unstructured component. If there is an XMLIndex_parameters_clause, but the PARAMETERS argument is empty (&#39;&#39;), then the result is the same: an index with only an unstructured component.Certain considerations apply to using XMLIndex_parameters.Certain considerations apply to using the PATHS clause.Certain considerations apply to using create_index_paths_clause and alter_index_paths_clause.Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.Certain considerations apply to using value_clause.Certain considerations apply to using the ASYNC clause.Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX. Certain considerations apply to using XMLIndex_xmltable_clause.Certain considerations apply to using column_clause.">XMLIndex</a>&#34;</span></p>
</div>
</div>
</div>
<a id="ADXDB5817"></a>
<div class="props_rev_3"><a id="GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63"></a>
<h3 id="ADXDB-GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63" class="sect3"><span class="enumeration_section">6.2.2</span> Oracle Text Indexes for XML Data</h3>
<div>
<p>Besides accessing XML nodes such as elements and attributes, it is sometimes important to provide fast access to particular passages within XML text nodes. To query such content within XML data, you can use XQuery Full Text (XQFT) or Oracle-specific full-text constructs.</p>
<p>In either case, you create an appropriate Oracle Text (full-text) index. In the case of XQFT, the index is an XML search index, which is designed specifically for use with <code>XMLType</code> data stored as binary XML.</p>
<p>Full-text indexing is particularly useful for <span class="italic">document-centric</span> applications, which often contain a mix of XML elements and text-node content. Full-text searching can often be made more powerful, more focused, by combining it with structural XML searching, that is, by restricting it to certain parts of an XML document, which are identified by using XPath expressions.</p>
<div class="infoboxnotealso" id="GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63__GUID-3F56E944-128A-4AD0-ABCD-9474232568E9">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a>&#34;</span></p>
</div>
</div>
</div>
<a id="ADXDB4319"></a>
<div class="props_rev_3"><a id="GUID-3C109433-1FDA-4A55-8196-CD11FDFCE462"></a>
<h3 id="ADXDB-GUID-3C109433-1FDA-4A55-8196-CD11FDFCE462" class="sect3"><span class="enumeration_section">6.2.3</span> Optimization Chooses the Right Indexes to Use</h3>
<div>
<p>Which indexes are used when more than one might apply in a given case? Cost-based optimization determines the index or indexes to use, so that performance is maximized.</p>
<p>Oracle Text indexes apply only to text, which for XML data means text nodes. Whenever text nodes are targeted and a corresponding Oracle Text index is defined, it is used. If other indexes are also appropriate in a particular context, then they can be used as well. However, just because an index is defined and it might appear applicable in a given situation does not mean that it will be used. It will not be used if the cost-based optimizer deems that its use is not cost-effective.</p>
</div>
</div>
<a id="ADXDB4315"></a>
<div class="props_rev_3"><a id="GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1"></a>
<h3 id="ADXDB-GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" class="sect3"><span class="enumeration_section">6.2.4</span> Function-Based Indexes Are Deprecated for XMLType</h3>
<div>
<p>In releases prior to Oracle Database&nbsp;11<span class="italic">g</span> Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with <code>XMLType</code> data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of <code>XMLIndex</code> instead.</p>
<p>Doing so obviates the overhead associated with maintenance operations on function-based indexes, and it increases the number of situations in which the optimizer can correctly select the index. No changes to existing DML statements are required as a result of this.</p>
<p>It continues to be the case that, for object-relational storage of <code>XMLType</code>, defining an index for (deprecated) Oracle SQL function <code>extractValue</code> often leads, by XPath rewrite, to automatic creation of B-tree indexes on the underlying objects (instead of a function-based index on <code>extractValue</code>). The XPath target here must be a <span class="italic">singleton</span> element or attribute. A similar shortcut exists for <code>XMLCast</code> applied to <code>XMLQuery</code>.</p>
<div class="infoboxnotealso" id="GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1__GUID-FC2ECDA7-D566-416F-A3F4-241E2A6B24B2">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="ADXDB4332"></a>
<div class="props_rev_3"><a id="GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46"></a>
<h2 id="ADXDB-GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46" class="sect2"><span class="enumeration_section">6.3</span> XMLIndex</h2>
<div>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_indexing.htm#GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7" title="B-tree indexes can be used advantageously with object-relational XMLType storage&thinsp;&mdash;&thinsp;they provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of XMLIndex.">Advantages of XMLIndex</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9" title="XMLIndex is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to XMLType data that is stored as binary XML.">Structured and Unstructured XMLIndex Components</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992" title="Basic operations on an XMLIndex index include creating it, dropping it, altering it, and examining it. Examples are presented.">Creating_ Dropping_ Altering_ and Examining an XMLIndex Index</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" title="You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.">Using XMLIndex with an Unstructured Component</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52" title="To know whether a particular XMLIndex index has been used in resolving a query, you can examine an execution plan for the query.">How to Tell Whether XMLIndex is Used</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-572DB598-0A31-4143-889B-98D883211FC6" title="You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */.">Turning Off Use of XMLIndex</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF" title="There are several guidelines that can help you use XMLIndex with an unstructured component.">Guidelines for Using XMLIndex with an Unstructured Component</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-B8FCC742-EE57-4B86-8B61-17CC780A5821" title="There are several guidelines that can help you use XMLIndex with a structured component.">Guidelines for Using XMLIndex with a Structured Component</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" title="If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.">XMLIndex Partitioning and Parallelism</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" title="The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-486E91AE-9FE0-489A-A035-AF320D04350B" title="Information about the standard database indexes is available in static public views USER_INDEXES, ALL_INDEXES, and DBA_INDEXES. Similar information about XMLIndex indexes is available in static public views USER_XML_INDEXES, ALL_XML_INDEXES, and DBA_XML_INDEXES.">Data Dictionary Static Public Views Related to XMLIndex</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
</li>
</ul>
</div>
<a id="ADXDB4333"></a>
<div class="props_rev_3"><a id="GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7"></a>
<h3 id="ADXDB-GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7" class="sect3"><span class="enumeration_section">6.3.1</span> Advantages of XMLIndex</h3>
<div>
<p>B-tree indexes can be used advantageously with object-relational <code>XMLType</code> storage&thinsp;&mdash;&thinsp;they provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of <code>XMLIndex</code>.</p>
<p><code>XMLIndex</code> is a <span class="italic">domain</span> index; it is designed specifically for the domain of XML data. It is a <span class="italic">logical</span> index. An <code>XMLIndex</code> index can be used for SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>.</p>
<p>XMLIndex presents the following advantages over other indexing methods:</p>
<ul style="list-style-type: disc;">
<li>
<p>An <code>XMLIndex</code> index is effective in any part of a query; &thinsp;it is not limited to use in a <code>WHERE</code> clause. This is not the case for any of the other kinds of indexes you might use with XML data.</p>
</li>
<li>
<p>An <code>XMLIndex</code> index with an unstructured component can speed access to both <code>SELECT</code> list data and <code>FROM</code> list data, making it useful for XML <span class="italic">fragment</span> extraction, in particular. Function-based indexes, which are deprecated, cannot be used to extract document fragments.</p>
</li>
<li>
<p>You can use an <code>XMLIndex</code> index with either XML schema-based or non-schema-based XMLType data stored as binary XML. B-tree indexing is appropriate only for XML schema-based data that is stored object-relationally.</p>
</li>
<li>
<p>You can use an <code>XMLIndex</code> index for searches with XPath expressions that target <span class="italic">collections</span>, that is, nodes that occur multiple times within a document. This is not the case for function-based indexes.</p>
</li>
<li>
<p>You need no prior knowledge of the XPath expressions that might be used in queries. The unstructured component of an <code>XMLIndex</code> index can be completely general. This is not the case for function-based indexes.</p>
</li>
<li>
<p>If you have prior knowledge of the XPath expressions to be used in queries, then you can improve performance either by using a <span class="italic">structured</span> <code>XMLIndex</code> component that targets fixed, structured islands of data that are queried often.</p>
</li>
<li>
<p><code>XMLIndex</code> indexing&thinsp;&mdash;&thinsp;both index creation and index maintenance&thinsp;&mdash;&thinsp;can be carried out in parallel, using multiple database processes. This is not the case for function-based indexes, which are deprecated.</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB4337"></a><a id="ADXDB4336"></a>
<div class="props_rev_3"><a id="GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9"></a>
<h3 id="ADXDB-GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9" class="sect3"><span class="enumeration_section">6.3.2</span> Structured and Unstructured XMLIndex Components</h3>
<div>
<p><code>XMLIndex</code> is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to <code>XMLType</code> data that is stored as binary XML.</p>
<p>Semi-structured XML data can sometimes nevertheless contain islands of predictable, structured data. An <code>XMLIndex</code> index can therefore have two components: a <strong class="term">structured component</strong>, used to index such islands, and an <strong class="term">unstructured component</strong>, used to index data that has little or variable structure.</p>
<p>A structured component can help with queries that project and use islands of structured content. A typical example is a free-form specification with fixed fields author, date, and title. An unstructured component can help with queries that extract XML fragments. Either component can be omitted from a given <code>XMLIndex</code> index.</p>
<p>Unlike a structured component, an unstructured component is general and relatively untargeted. It is appropriate for general indexing of document-centric XML data. A typical example is an XML web document or a book chapter.</p>
<p>You can create an <code>XMLIndex</code> index with both structured and unstructured components. A typical use case is supporting queries that extract an XML fragment from a document whenever some structured data is also present. The unstructured component is used for the fragment extraction. The structured component is used for a query predicate that checks for the structured data (for example, in the SQL <code>WHERE</code> clause).</p>
<p>Though you can restrict an unstructured component to apply only to certain XPath subsets, its path table indexes node content that can be of different scalar types, which can require you to create multiple secondary indexes on the <code>VALUE</code> column to deal with the different data types&thinsp;&mdash;&thinsp;see <span class="q">&#34;<a href="xdb_indexing.htm#GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149" title="Even if you do not specify a secondary index for column VALUE when you create an XMLIndex index, a default secondary index is created on column VALUE. This default index has the default properties&thinsp;&mdash;&thinsp;in particular, it is an index for text (string-valued) data only.">Secondary Indexes on Column VALUE</a>&#34;</span>. Using an unstructured component alone can also lead to inefficiencies involving multiple probes and self-joins of its path table, for queries that project structured islands.</p>
<p>On the other hand, a structured component is not suited for queries that involve little structure or queries that extract XML fragments. Use a structured component to index structured islands of data; use an unstructured component to index data that has little structure.</p>
<p>Figure&nbsp;6&ndash;1 is the same as Figure&nbsp;1&ndash;2 in Chapter&nbsp;1.</p>
<p>The last row indicates the applicability of <code>XMLIndex</code> for different XML data use cases. It shows that <code>XMLIndex</code> is appropriate for semi-structured XML data, however it is stored (last three columns). And an <code>XMLIndex</code> index with a structured component is useful for document-centric data that contains structured islands (fourth column).</p>
<div class="figure" id="GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9__GUID-E0FC24F4-FE6D-4B58-B641-C34BB1FA25FA">
<p class="titleinfigure">Figure 6-1 XML Use Cases and XML Indexing</p>
<img width="656" height="308" src="img/GUID-EE9E5208-25E5-4A0F-82AF-E640B4676A34-default.png" alt="Description of Figure 6-1 follows" title="Description of Figure 6-1 follows"/><br/>
<a href="img_text/GUID-EE9E5208-25E5-4A0F-82AF-E640B4676A34-print.htm">Description of &#34;Figure 6-1 XML Use Cases and XML Indexing&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9__GUID-ED6C9B32-3B30-4707-B35A-7D0AAE4379D7">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7" title="B-tree indexes can be used advantageously with object-relational XMLType storage&thinsp;&mdash;&thinsp;they provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of XMLIndex.">Advantages of XMLIndex</a>&#34;</span> for a summary of the advantages provided by each <code>XMLIndex</code> component type</p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB4338"></a>
<div class="props_rev_3"><a id="GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB"></a>
<h3 id="ADXDB-GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" class="sect3"><span class="enumeration_section">6.3.3</span> XMLIndex Structured Component</h3>
<div>
<p>You create and use the structured component of an <code>XMLIndex</code> index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.</p>
<p>A structured <code>XMLIndex</code> component organizes such islands in a <span class="italic">relational</span> format. In this it is similar to SQL/XML <span class="italic">function</span> <code>XMLTable</code>, and the syntax you use to define the structured component reflects this similarity. The relational tables used to store the indexing data are data-type aware, and each column can be of a different scalar data type.</p>
<p>You can thus think of the act of creating the structured component of an <code>XMLIndex</code> index as <span class="italic">decomposing</span> a structured portion of your XML data into relational format. This differs from the object-relational storage model of <code>XMLType</code> in these ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>A structured index component <span class="italic">explicitly</span> decomposes particular <span class="italic">portions</span> of your data, which you specify&thinsp;&mdash;&thinsp;portions that you commonly query. Object-relational <code>XMLType</code> storage involves automatic decomposition of an entire <code>XMLType</code> table or column.</p>
</li>
<li>
<p>The structured component of an <code>XMLIndex</code> index applies to both XML schema-based and non-schema-based data. Object-relational <code>XMLType</code> storage applies only to data that is based on an XML schema.</p>
</li>
<li>
<p>The decomposed data for a structured <code>XMLIndex</code> component is stored in addition to the <code>XMLType</code> data, as an index, rather than being the storage model for the <code>XMLType</code> data itself.</p>
</li>
<li>
<p>For a structured <code>XMLIndex</code> component, the same data can be projected multiple times, as columns of different data type.</p>
</li>
</ul>
<p>The index content tables used for the structured component of an <code>XMLIndex</code> index are part of the index, but because they are normal relational tables you can, in turn, <span class="italic">index</span> them using any standard relational indexes, including indexes that satisfy primary-key and foreign-key constraints. You can also index them using domain indexes, such as an Oracle Text <code>CONTEXT</code> index.</p>
<p>Another way to look at the structured component of an <code>XMLIndex</code> index sees that it acts as a <span class="italic">generalized function-based index</span>. A function-based index is similar to a structured <code>XMLIndex</code> component that has only one relational column.</p>
<p>If you find that for a particular application you are creating multiple function-based indexes, then consider using an <code>XMLIndex</code> index with a structured component instead. Create also B-tree indexes on the columns of the structured index component.</p>
<div class="infobox-note" id="GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB__GUID-A6499653-7B31-4560-9163-BB8CA6299F98">
<p class="notep1">Note:</p>
<ul style="list-style-type: disc;">
<li>
<p>Queries that use SQL/XML function <code>XMLTable</code> can typically be automatically rewritten to use the relational indexing tables of an <code>XMLIndex</code> structured component. In particular, this means that SQL <code>ORDER BY</code>, <code>GROUP BY</code>, and window constructs operating on columns of an <code>XMLTable</code> virtual table are rewritten to the same constructs operating on the real columns of the relational indexing tables of the structured <code>XMLIndex</code> component.</p>
<p>The relational tables used for <code>XMLIndex</code> structured indexing also contain some internal, system-defined columns. These internal columns might change in the future, so do not write code that depends on any assumptions about their existence or contents.</p>
</li>
<li>
<p>Queries that use Oracle SQL function <code>XMLSequence</code> within a SQL <code>TABLE</code> collection expression, that is, <code>TABLE (XMLSequence(...))</code>, are <span class="italic">not</span> rewritten to use the indexing tables of an <code>XMLIndex</code> structured component. Oracle SQL function <code>XMLSequence</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2; use standard SQL/XML function <code>XMLTable</code> instead.</p>
<p>See <a class="olink SQLRF30047" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF30047"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the SQL <code>TABLE</code> collection expression.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB__GUID-A972A2C4-36D4-4718-9DB8-E3ADBDFAA139">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY_ XMLTABLE_ XMLExists_ and XMLCast</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" title="In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with XMLType data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of XMLIndex instead.">Function-Based Indexes Are Deprecated for XMLType</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB4339"></a>
<div class="props_rev_3"><a id="GUID-74E9F37F-4593-4EC1-85B4-5516CF95FD65"></a>
<h4 id="ADXDB-GUID-74E9F37F-4593-4EC1-85B4-5516CF95FD65" class="sect4"><span class="enumeration_section">6.3.3.1</span> Ignore the Index Content Tables; They Are Transparent</h4>
<div>
<p>Although the index content tables of an <code>XMLIndex</code> structured component are normal relational tables, they are also <span class="italic">read-only</span>: you cannot add or drop their columns or modify (insert, update, or delete) their rows.</p>
<p>You can thus generally ignore the relational index content tables. You cannot access them, other than to <code>DESCRIBE</code> them and create (secondary) indexes on them. You need never explicitly gather statistics on them. You need only collect statistics on the <code>XMLIndex</code> index itself or the base table on which the <code>XMLIndex</code> index is defined; statistics are collected and maintained on the index content tables transparently.</p>
<div class="infoboxnotealso" id="GUID-74E9F37F-4593-4EC1-85B4-5516CF95FD65__GUID-7F0617D2-786F-4635-B585-03A5A778C8F9">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" title="The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a>&#34;</span></p>
</div>
</div>
</div>
<a id="ADXDB4341"></a><a id="ADXDB4342"></a><a id="ADXDB4343"></a><a id="ADXDB4340"></a>
<div class="props_rev_3"><a id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254"></a>
<h4 id="ADXDB-GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" class="sect4"><span class="enumeration_section">6.3.3.2</span> Data Type Considerations for XMLIndex Structured Component</h4>
<div>
<p>The relational tables that are used for an <code>XMLIndex</code> structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).</p>
<p>XQuery typing rules can automatically change the data type of a subexpression, to ensure coherence and type-checking. For example, if a document that is queried using XPath expression <code>/PurchaseOrder/LineItem[@ItemNumber = 25]</code> is not XML schema-based, then the subexpression <code>@ItemNumber</code> is untyped, and it is then automatically cast to <code>xs:double</code> by the XQuery <code>=</code> comparison operator. To index this data using an <code>XMLIndex</code> structured component you must use <code>BINARY_DOUBLE</code> as the SQL data type.</p>
<p>This is a general rule. For an <code>XMLIndex</code> index with structured component to apply to a query, the data types must correspond. <a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGFIFFH" title="XML and SQL data type correspondence for XMLIndex">Table 6-5</a> shows the data-type correspondences.</p>
<div class="tblformal" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGFIFFH">
<p class="titleintable">Table 6-5 XML and SQL Data Type Correspondence for XMLIndex</p>
<table class="cellalignment3420" title="XML and SQL Data Type Correspondence for XMLIndex" summary="XML and SQL data type correspondence for XMLIndex">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3425" id="d38232e2760">XML Data Type</th>
<th class="cellalignment3425" id="d38232e2763">SQL Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e2768" headers="d38232e2760">
<p><code>xs:decimal</code></p>
</td>
<td class="cellalignment3426" headers="d38232e2768 d38232e2763">
<p><code>INTEGER</code> or <code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e2780" headers="d38232e2760">
<p><code>xs:double</code></p>
</td>
<td class="cellalignment3426" headers="d38232e2780 d38232e2763">
<p><code>BINARY_DOUBLE</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e2789" headers="d38232e2760">
<p><code>xs:float</code></p>
</td>
<td class="cellalignment3426" headers="d38232e2789 d38232e2763">
<p><code>BINARY_FLOAT</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e2798" headers="d38232e2760">
<p><code>xs:date</code></p>
</td>
<td class="cellalignment3426" headers="d38232e2798 d38232e2763">
<p><code>DATE</code>, <code>TIMESTAMP WITH TIMEZONE</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e2810" headers="d38232e2760">
<p><code>xs:dateTime</code></p>
</td>
<td class="cellalignment3426" headers="d38232e2810 d38232e2763">
<p><code>TIMESTAMP</code>, <code>TIMESTAMP WITH TIMEZONE</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e2822" headers="d38232e2760">
<p><code>xs:dayTimeDuration</code></p>
</td>
<td class="cellalignment3426" headers="d38232e2822 d38232e2763">
<p><code>INTERVAL DAY TO SECOND</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e2831" headers="d38232e2760">
<p><code>xs:yearMonthDuration</code></p>
</td>
<td class="cellalignment3426" headers="d38232e2831 d38232e2763">
<p><code>INTERVAL YEAR TO MONTH</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="infobox-note" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__GUID-AEACAF8C-2578-483E-80BE-C8C5B1593678">
<p class="notep1">Note:</p>
<p>If the XML data type is <code>xs:date</code> or <code>xs:dateTime</code>, and if you know that the data that you will query and for which you are creating an index will <span class="italic">not</span> contain a time-zone component, then you can increase performance by using SQL data type <code>DATE</code> or <code>TIMESTAMP</code>. If the data might contain a time-zone component, then you must use SQL data type <code>TIMESTAMP WITH TIMEZONE</code>.</p>
</div>
<p>If the XML and SQL data types involved do not have a built-in one-to-one correspondence, then you must make them correspond (according to <a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGFIFFH" title="XML and SQL data type correspondence for XMLIndex">Table 6-5</a>), in order for the index to be picked up for your query. There are two ways you can do this:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Make the index correspond to the query &ndash;</span> Define (or redefine) the column in the structured index component, so that it corresponds to the XML data type. For example, if a query that you want to index uses the XML data type <code>xs:double</code>, then define the index to use the corresponding SQL data type, <code>BINARY_DOUBLE</code>.</p>
</li>
<li>
<p><span class="bold">Make the query correspond to the index &ndash;</span> In your query, explicitly cast the relevant parts of an XQuery expression to data types that correspond to the SQL data types used in the index content table.</p>
</li>
</ul>
<p><a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">Example 6-1</a> and <a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">Example 6-2</a> show how you can cast an XQuery expression in your query to match the SQL data type used in the index content table.</p>
<p>Notice that the number <code>25</code> plays a different role in these two examples, even though in both cases it is the purchase-order item number. In <a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">Example 6-1</a>, <code>25</code> is a SQL number of data type <code>INTEGER</code>; in <a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">Example 6-2</a>, <code>25</code> is an XQuery number of data type <code>xs:decimal</code>.</p>
<p>In <a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">Example 6-1</a>, the <code>XMLQuery</code> result is cast to SQL type <code>INTEGER</code>, which is compared with the SQL value 25. In <a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">Example 6-2</a>, the value of attribute <code>ItemNumber</code> is cast (in XQuery) to the XML data type <code>xs:decimal</code>, which is compared with the XQuery value 25 and which corresponds to the SQL data type (<code>INTEGER</code>) used for the index. There are thus two different kinds of data-type conversion in these examples, but they both convert query data to make it type-compatible with the index content table.</p>
<div class="infoboxnotealso" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__GUID-D1F567CA-D4DF-4004-A406-D522210CFE7A">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb06stt.htm#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="You use PL/SQL package DBMS_XMLSCHEMA to map data types for XML Schema attributes and elements to SQL data types.">How to Map XML Schema Data Types to SQL Data Types</a>&#34;</span> for information about the built-in correspondence between XML Schema data types and SQL data types</p>
</div>
<div class="example" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">
<p class="titleinexample">Example 6-1 Making Query Data Compatible with Index Data &ndash; SQL Cast</p>
<pre>SELECT count(*) FROM purchaseorder
  WHERE <span class="bold">XMLCast</span>(XMLQuery(&#39;$p/PurchaseOrder/LineItem/@ItemNumber&#39;
                         PASSING OBJECT_VALUE AS &#34;p&#34; RETURNING CONTENT)
                <span class="bold">AS INTEGER</span>)
        = 25;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">
<p class="titleinexample">Example 6-2 Making Query Data Compatible with Index Data &ndash; XQuery Cast</p>
<pre dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE XMLExists(&#39;$p/PurchaseOrder/LineItem[<span class="bold">xs:decimal</span>(@ItemNumber) = 25]&#39;
                  PASSING OBJECT_VALUE AS &#34;p&#34;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6236"></a><a id="ADXDB6235"></a>
<div class="props_rev_3"><a id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11"></a>
<h4 id="ADXDB-GUID-44226DE7-B9EB-4729-9989-F957D65BEE11" class="sect4"><span class="enumeration_section">6.3.3.3</span> Exchange Partitioning and XMLIndex</h4>
<div>
<p>In exchange partitioning, you exchange a table with a partition of another table. The first table (call it <span class="italic"><code>exchange_table</code></span>) must have the same structure as the partition (call it <span class="italic"><code>partition</code></span>) of the second table (call it <span class="italic"><code>table</code></span>) with which it will be exchanged.</p>
<p>In addition to having the same structure, the two tables must be similar with respect to indexing with an <code>XMLIndex</code> index. One of the following must be true:</p>
<ul style="list-style-type: disc;">
<li>
<p>Neither has an <code>XMLIndex</code> index.</p>
</li>
<li>
<p>Both have an <code>XMLIndex</code> index, and one of the following is true:</p>
<ul style="list-style-type: disc;">
<li>
<p>Neither index has a structured component.</p>
</li>
<li>
<p>Both indexes have a structured component.</p>
</li>
</ul>
</li>
</ul>
<p>If none of those conditions holds then you cannot perform exchange partitioning.</p>
<p>If both tables have an <code>XMLIndex</code> index with a structured component then you must perform some preprocessing before invoking <code>ALTER TABLE EXCHANGE PARTITION</code>, and you must perform some postprocessing after invoking it. Otherwise, the exchange-partition operation raises an error.</p>
<p>You use PL/SQL procedures <code>exchangePreProc</code> and <code>exchangePostProc</code> in package <code>DBMS_XMLSTORAGE_MANAGE</code> to perform this preprocessing and postprocessing, as illustrated in <a href="xdb_indexing.htm#GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__CEGCBJIA">Example 6-3</a>. Each of the <code>XMLType</code> tables, <code>table</code> and <code>exchange_table</code>, has an <code>XMLIndex</code> index that has a structured component.</p>
<div class="infoboxnotealso" id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__GUID-4A0F5F27-7CB6-4BDE-8979-1E74545280D8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF53492" target="_blank" href="../SQLRF/statements_3001.htm#SQLRF53492"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink ADDCI4492" target="_blank" href="../ADDCI/dom_idx.htm#ADDCI4492"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for general information about using <code>ALTER TABLE EXCHANGE PARTITION</code> with tables that have domain indexes (<code>XMLIndex</code> is a domain index)</p>
</li>
</ul>
</div>
<div class="example" id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__CEGCBJIA">
<p class="titleinexample">Example 6-3 Exchange-Partitioning a Table Having an XMLIndex Structured Component</p>
<pre dir="ltr">EXEC DBMS_XMLSTORAGE_MANAGE.exchangePreProc(USER, &#39;table&#39;);
EXEC DBMS_XMLSTORAGE_MANAGE.exchangePreProc(USER, &#39;exchange_table&#39;);

ALTER TABLE table EXCHANGE PARTITION partition WITH TABLE exchange_table
  WITH VALIDATION UPDATE INDEXES;

EXEC DBMS_XMLSTORAGE_MANAGE.exchangePostProc(USER, &#39;table&#39;);
EXEC DBMS_XMLSTORAGE_MANAGE.exchangePostProc(USER, &#39;exchange_table&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB4345"></a><a id="ADXDB4346"></a><a id="ADXDB4344"></a>
<div class="props_rev_3"><a id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C"></a>
<h3 id="ADXDB-GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" class="sect3"><span class="enumeration_section">6.3.4</span> XMLIndex Unstructured Component</h3>
<div>
<p>Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the <code>XMLIndex</code> structured component, which applies to specific, structured document parts, the unstructured component of an <code>XMLIndex</code> index is, by default, very general.</p>
<p>Unless you specify a more narrow focus by detailing specific XPath expressions to use or not to use in indexing, an unstructured <code>XMLIndex</code> component applies to <span class="italic">all possible XPath expressions</span> for your XML data.</p>
<p>The unstructured component of an <code>XMLIndex</code> index has three logical parts:</p>
<ul style="list-style-type: disc;">
<li>
<p>A <strong class="term">path index</strong> &ndash; This indexes the XML <span class="italic">tags</span> of a document and identifies its various document <span class="italic">fragments</span>.</p>
</li>
<li>
<p>An <strong class="term">order index</strong> &ndash; This indexes the hierarchical <span class="italic">positions</span> of the nodes in an XML document. It keeps track of parent&ndash;child, ancestor&ndash;descendant, and sibling relations.</p>
</li>
<li>
<p>A <strong class="term">value index</strong> &ndash; This indexes the <span class="italic">values</span> of an XML document. It provides lookup by either value equality or value range. A value index is used for values in query predicates (<code>WHERE</code> clause).</p>
</li>
</ul>
<p>The unstructured component of an <code>XMLIndex</code> index uses a path table and a set of (local) secondary indexes on the path table, which implement the logical parts described above. Two secondary indexes are created automatically:</p>
<ul style="list-style-type: disc;">
<li>
<p>A <strong class="term">pikey index</strong>, which implements the logical indexes for both path and order.</p>
</li>
<li>
<p>A real <strong class="term">value index</strong>, which implements the logical value index.</p>
</li>
</ul>
<p>You can modify these two indexes or create additional secondary indexes. The path table and its secondary indexes are all owned by the owner of the base table upon which the <code>XMLIndex</code> index is created.</p>
<p>The pikey index handles paths and order relationships together, which gives the best performance in most cases. If you find in some particular case that the value index is not picked up when think it should be, you can replace the pikey index with separate indexes for the paths and order relationships. Such (optional) indexes are called <strong class="term">path id</strong> and <strong class="term">order key</strong> indexes, respectively. For best results, contact Oracle Support if you find that the pikey index is not sufficient for your needs in some case.</p>
<p>The path table contains one row for each indexed node in the XML document. For each indexed node, the <strong class="term">path table</strong> stores:</p>
<ul style="list-style-type: disc;">
<li>
<p>The corresponding <span class="italic">rowid</span> of the table that stores the document.</p>
</li>
<li>
<p>A <span class="italic">locator</span>, which provides fast access to the corresponding document fragment. For binary XML storage of XML schema-based data, it also stores data-type information.</p>
</li>
<li>
<p>An <span class="italic">order key</span>, to record the hierarchical position of the node in the document. You can think of this as a Dewey decimal key like that used in library cataloging and Internet protocol SNMP. In such a system, the key <code>3.21.5</code> represents the node position of the fifth child of the twenty-first child of the third child of the document root node.</p>
</li>
<li>
<p>An identifier that represents an XPath <span class="italic">path</span> to the node.</p>
</li>
<li>
<p>The effective <span class="italic">text value</span> of the node.</p>
</li>
</ul>
<p><a href="xdb_indexing.htm#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDICGFB" title="XMLIndex Path Table">Table 6-6</a> shows the main information<a id="fn_2" href="#fn_2" onclick="footdisplay(2,&#34;The actual path table implementation may be slightly different. &#34;)"><sup>Foot&nbsp;2</sup></a> that is in the path table.</p>
<div class="tblformal" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDICGFB">
<p class="titleintable">Table 6-6 XMLIndex Path Table</p>
<table class="cellalignment3420" title="XMLIndex Path Table" summary="XMLIndex Path Table">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3467" id="d38232e3318">Column</th>
<th class="cellalignment3460" id="d38232e3321">Data Type</th>
<th class="cellalignment3552" id="d38232e3324">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3470" id="d38232e3329" headers="d38232e3318">
<p><code>PATHID</code></p>
</td>
<td class="cellalignment3463" headers="d38232e3329 d38232e3321">
<p><code>RAW(8)</code></p>
</td>
<td class="cellalignment3553" headers="d38232e3329 d38232e3324">
<p>Unique identifier for the XPath path to the node.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3470" id="d38232e3341" headers="d38232e3318">
<p><code>RID</code></p>
</td>
<td class="cellalignment3463" headers="d38232e3341 d38232e3321">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment3553" headers="d38232e3341 d38232e3324">
<p>Rowid of the table used to store the XML data.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3470" id="d38232e3353" headers="d38232e3318">
<p><code>ORDER_KEY</code></p>
</td>
<td class="cellalignment3463" headers="d38232e3353 d38232e3321">
<p><code>RAW(1000)</code></p>
</td>
<td class="cellalignment3553" headers="d38232e3353 d38232e3324">
<p>Decimal order key that identifies the hierarchical position of the node. (Document ordering is preserved.)</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3470" id="d38232e3365" headers="d38232e3318">
<p><code>LOCATOR</code></p>
</td>
<td class="cellalignment3463" headers="d38232e3365 d38232e3321">
<p><code>RAW(2000)</code></p>
</td>
<td class="cellalignment3553" headers="d38232e3365 d38232e3324">
<p>Fragment-location information. Used for fragment extraction. For binary XML storage of XML schema-based data, data-type information is also stored here.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3470" id="d38232e3377" headers="d38232e3318">
<p><code>VALUE</code></p>
</td>
<td class="cellalignment3463" headers="d38232e3377 d38232e3321">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment3553" headers="d38232e3377 d38232e3324">
<p>Effective text value the node.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The pikey index uses path table columns <code>PATHID</code>, <code>RID</code>, and <code>ORDER_KEY</code> to represent the path and order indexes. An optional path id index uses columns <code>PATHID</code> and <code>RID</code> to represent the path index. A value index is an index on the <code>VALUE</code> column.</p>
<p><a href="xdb_indexing.htm#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDJGGDH">Example 6-4</a> explores the contents of the path table for two purchase-order documents.</p>
<div class="example" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDJGGDH">
<p class="titleinexample">Example 6-4 Path Table Contents for Two Purchase Orders</p>
<pre dir="ltr">&lt;PurchaseOrder&gt;
 &lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
 &lt;Actions&gt;
  &lt;Action&gt;
   &lt;User&gt;SVOLLMAN&lt;/User&gt;
  &lt;/Action&gt;
 &lt;/Actions&gt;
 . . .
&lt;/PurchaseOrder&gt;

&lt;PurchaseOrder&gt;
 &lt;Reference&gt;ABEL-20021127121040897PST&lt;/Reference&gt;
 &lt;Actions&gt;
  &lt;Action&gt;
   &lt;User&gt;ZLOTKEY&lt;/User&gt;
  &lt;/Action&gt;
  &lt;Action&gt;
   &lt;User&gt;KING&lt;/User&gt;
  &lt;/Action&gt;
 &lt;/Actions&gt;
 . . .
&lt;/PurchaseOrder&gt;
</pre>
<p>An <code>XMLIndex</code> index on an <code>XMLType</code> table or column storing these purchase orders includes a path table that has one row for each indexed node in the XML documents. Suppose that the system assigns the following <code>PATHID</code>s when indexing the nodes according to their XPath expressions:</p>
<div class="tblformal" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__GUID-698980B2-9DF1-4A47-8B38-0FD0A0DC7841">
<table class="cellalignment3420" summary="PATHIDs for sample XPath expressions">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3461" id="d38232e3437">PATHID</th>
<th class="cellalignment3554" id="d38232e3440">Indexed XPath</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3464" id="d38232e3445" headers="d38232e3437">
<p><code>1</code></p>
</td>
<td class="cellalignment3555" headers="d38232e3445 d38232e3440">
<p><code>/PurchaseOrder</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3464" id="d38232e3454" headers="d38232e3437">
<p><code>2</code></p>
</td>
<td class="cellalignment3555" headers="d38232e3454 d38232e3440">
<p><code>/PurchaseOrder/Reference</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3464" id="d38232e3463" headers="d38232e3437">
<p><code>3</code></p>
</td>
<td class="cellalignment3555" headers="d38232e3463 d38232e3440">
<p><code>/PurchaseOrder/Actions</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3464" id="d38232e3472" headers="d38232e3437">
<p><code>4</code></p>
</td>
<td class="cellalignment3555" headers="d38232e3472 d38232e3440">
<p><code>/PurchaseOrder/Actions/Action</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3464" id="d38232e3481" headers="d38232e3437">
<p><code>5</code></p>
</td>
<td class="cellalignment3555" headers="d38232e3481 d38232e3440">
<p><code>/PurchaseOrder/Actions/Action/User</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The resulting path table would then be something like this (column <code>LOCATOR</code> is not shown):</p>
<div class="tblformal" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__GUID-156D3508-DC4C-42AE-92BB-5EACB61027F6">
<table class="cellalignment3420" summary="Path table corresponding to sample XPath expressions">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3472" id="d38232e3504">PATHID</th>
<th class="cellalignment3496" id="d38232e3507">RID</th>
<th class="cellalignment3545" id="d38232e3510">ORDER_KEY</th>
<th class="cellalignment3548" id="d38232e3513">VALUE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3518" headers="d38232e3504">
<p><code>1</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3518 d38232e3507">
<p><code>R1</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3518 d38232e3510">
<p><code>1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3518 d38232e3513">
<p><code>SBELL-2002100912333601PDTSVOLLMAN</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3535" headers="d38232e3504">
<p><code>2</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3535 d38232e3507">
<p><code>R1</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3535 d38232e3510">
<p><code>1.1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3535 d38232e3513">
<p><code>SBELL-2002100912333601PDT</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3552" headers="d38232e3504">
<p><code>3</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3552 d38232e3507">
<p><code>R1</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3552 d38232e3510">
<p><code>1.2</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3552 d38232e3513">
<p><code>SVOLLMAN</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3569" headers="d38232e3504">
<p><code>4</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3569 d38232e3507">
<p><code>R1</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3569 d38232e3510">
<p><code>1.2.1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3569 d38232e3513">
<p><code>SVOLLMAN</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3586" headers="d38232e3504">
<p><code>5</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3586 d38232e3507">
<p><code>R1</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3586 d38232e3510">
<p><code>1.2.1.1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3586 d38232e3513">
<p><code>SVOLLMAN</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3603" headers="d38232e3504">
<p><code>1</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3603 d38232e3507">
<p><code>R2</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3603 d38232e3510">
<p><code>1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3603 d38232e3513">
<p><code>ABEL-20021127121040897PSTZLOTKEYKING</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3620" headers="d38232e3504">
<p><code>2</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3620 d38232e3507">
<p><code>R2</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3620 d38232e3510">
<p><code>1.1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3620 d38232e3513">
<p><code>ABEL-20021127121040897PST</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3637" headers="d38232e3504">
<p><code>3</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3637 d38232e3507">
<p><code>R2</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3637 d38232e3510">
<p><code>1.2</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3637 d38232e3513">
<p><code>ZLOTKEYKING</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3654" headers="d38232e3504">
<p><code>4</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3654 d38232e3507">
<p><code>R2</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3654 d38232e3510">
<p><code>1.2.1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3654 d38232e3513">
<p><code>ZLOTKEY</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3671" headers="d38232e3504">
<p><code>5</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3671 d38232e3507">
<p><code>R2</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3671 d38232e3510">
<p><code>1.2.1.1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3671 d38232e3513">
<p><code>ZLOTKEY</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3688" headers="d38232e3504">
<p><code>4</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3688 d38232e3507">
<p><code>R2</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3688 d38232e3510">
<p><code>1.2.2</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3688 d38232e3513">
<p><code>KING</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3473" id="d38232e3706" headers="d38232e3504">
<p><code>5</code></p>
</td>
<td class="cellalignment3498" headers="d38232e3706 d38232e3507">
<p><code>R2</code></p>
</td>
<td class="cellalignment3547" headers="d38232e3706 d38232e3510">
<p><code>1.2.2.1</code></p>
</td>
<td class="cellalignment3549" headers="d38232e3706 d38232e3513">
<p><code>KING</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="example" --></div>
<a id="ADXDB4347"></a>
<div class="props_rev_3"><a id="GUID-2331505D-512A-4D65-9403-BF4030E1EFD4"></a>
<h4 id="ADXDB-GUID-2331505D-512A-4D65-9403-BF4030E1EFD4" class="sect4"><span class="enumeration_section">6.3.4.1</span> Ignore the Path Table &ndash; It Is Transparent</h4>
<div>
<p>Though you can create secondary indexes on path-table columns, you can generally ignore the path table itself.</p>
<p>You <span class="italic">cannot access</span> the path table, other than to <code>DESCRIBE</code> it and create (secondary) indexes on it. You need never explicitly gather statistics on the path table. You need only collect statistics on the <code>XMLIndex</code> index or the base table on which the <code>XMLIndex</code> index is defined; statistics are collected and maintained on the path table and its secondary indexes transparently.</p>
<div class="infoboxnotealso" id="GUID-2331505D-512A-4D65-9403-BF4030E1EFD4__GUID-08D27212-7ED4-4512-BAA9-A83956236825">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" title="The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a>&#34;</span></p>
</div>
</div>
</div>
<a id="ADXDB4348"></a>
<div class="props_rev_3"><a id="GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4"></a>
<h4 id="ADXDB-GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4" class="sect4"><span class="enumeration_section">6.3.4.2</span> Column VALUE of an XMLIndex Path Table</h4>
<div>
<p>A secondary index on column <code>VALUE</code> is used with XPath expressions in a <code>WHERE</code> clause that have predicates involving string matches. For example:</p>
<div class="section">
<pre dir="ltr">/PurchaseOrder[Reference/text() = &#34;SBELL-2002100912333601PDT&#34;]
</pre>
<p>Column <code>VALUE</code> stores the <strong class="term">effective text value</strong> of an element or an attribute node&thinsp;&mdash;&thinsp;comments and processing instructions are ignored during indexing.</p>
<ul style="list-style-type: disc;">
<li>
<p>For an <span class="italic">attribute</span>, the effective text value is the attribute value.</p>
</li>
<li>
<p>For a <span class="italic">simple</span> element (an element that has no children), the effective text value is the concatenation of all of the text nodes of the element.</p>
</li>
<li>
<p>For a <span class="italic">complex</span> element (an element that has children), the effective text value is the concatenation of (1) the text nodes of the element itself and (2) the effective text values of all of its simple-element descendants. (This is a recursive definition.)</p>
</li>
</ul>
<p>The effective text value is limited (truncated), however, to 4000 bytes for a simple element or attribute and to 80 bytes for a complex element.</p>
<p>Column <code>VALUE</code> is a fixed size, <code>VARCHAR2(4000)</code>. Any overflow (beyond 4000 bytes) during index creation or update is truncated.</p>
<p>In addition to the 4000-byte limit for column <code>VALUE</code>, there is a limit on the size of a key for the secondary index created on this column. This is the case for B-tree and function-based indexes as well; it is not an <code>XMLIndex</code> limitation. The index-key size limit is a function of the block size for your database. It is this limit that determines how much of <code>VALUE</code> is indexed.</p>
<p>Thus, only the first 4000 bytes of the effective text value are stored in column <code>VALUE</code>, and only the first <span class="italic">N</span> bytes of column <code>VALUE</code> are indexed, where <span class="italic">N</span> is the index-key size limit (<span class="italic">N</span> &lt; 4000). Because of the index-key size limit, the index on column <code>VALUE</code> acts only as a <span class="italic">preliminary filter</span> for the effective text value.</p>
<p>For example, suppose that your database block size requires that the <code>VALUE</code> index be no larger than 800 bytes, so that only the first 800 bytes of the effective text value is indexed. The first 800 bytes of the effective text value is first tested, using <code>XMLIndex</code>, and only if that text prefix matches the query value is the rest of the effective text value tested.</p>
<p>The secondary index on column <code>VALUE</code> is an index on SQL function <code>substr</code> (substring equality), because that function is used to test the text prefix. This function-based index is created automatically as part of the implementation of <code>XMLIndex</code> for column <code>VALUE</code>.</p>
<p>For example, the XPath expression <code>/PurchaseOrder[Reference/text() = :1]</code> in a query <code>WHERE</code> clause might, in effect, be rewritten to a test something like this:</p>
<pre dir="ltr">substr(VALUE, 1 800) = substr(:1, 1, 800) AND VALUE = :1;
</pre>
<p>This conjunction contains two parts, which are processed from left to right. The first test uses the index on function <code>substr</code> as a preliminary filter, to eliminate text whose first 800 bytes do not match the first 800 bytes of the value of bind variable <code>:1</code>.</p>
<p>Only the first test uses an index&thinsp;&mdash;&thinsp;the full value of column <code>VALUE</code> is not indexed. After preliminary filtering by the first test, the second test checks the entire effective text value&thinsp;&mdash;&thinsp;that is, the full value of column <code>VALUE</code>&thinsp;&mdash;&thinsp;for full equality with the value of <code>:1</code>. This check does not use an index.</p>
<p>Even if only the first 800 bytes of text is indexed, it is important for query performance that up to 4000 bytes be stored in column <code>VALUE</code>, because that provides quick, direct access to the data, instead of requiring, for example, extracting it from deep within a <code>CLOB</code>-instance XML document. If the effective text value is greater than 4000 bytes, then the second test in the <code>WHERE</code>-clause conjunction requires accessing the base-table data.</p>
<p>Note that neither the <code>VALUE</code> column 4000-byte limit nor the index-key size affect query results in any way; they can affect only performance.</p>
<div class="infobox-note" id="GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4__GUID-B1D3EA19-0D86-46FF-B95E-DB315B75CBE8">
<p class="notep1">Note:</p>
<p>Because of the possibility of the <code>VALUE</code> column being truncated, an Oracle Text <code>CONTEXT</code> index created on the <code>VALUE</code> column might return incorrect results.</p>
</div>
<p>As mentioned, <code>XMLIndex</code> can be used with XML schema-based data. If an XML schema specifies a <code>defaultValue</code> value for a given element or attribute, and a particular document does not specify a value for that element or attribute, then the <code>defaultValue</code> value is used for the <code>VALUE</code> column.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4350"></a>
<div class="props_rev_3"><a id="GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149"></a>
<h4 id="ADXDB-GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149" class="sect4"><span class="enumeration_section">6.3.4.3</span> Secondary Indexes on Column VALUE</h4>
<div>
<p>Even if you do not specify a secondary index for column <code>VALUE</code> when you create an <code>XMLIndex</code> index, a default secondary index is created on column <code>VALUE</code>. This default index has the default properties&thinsp;&mdash;&thinsp;in particular, it is an index for <span class="italic">text</span> (string-valued) data only.</p>
<p>You can, however, create a <code>VALUE</code> index of a different type. For example, you can create a number-valued index if that is appropriate for many of your queries. You can create multiple secondary indexes on the <code>VALUE</code> column. An index of a particular type is used only when it is appropriate. For example, a number-valued index is used only when the <code>VALUE</code> column is a number; it is ignored for other values. Secondary indexes on path-table columns are treated like any other secondary indexes&thinsp;&mdash;&thinsp;you can alter them, drop them, mark them unusable, and so on.</p>
<div class="infoboxnotealso" id="GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149__GUID-B5CDB255-2C86-4F10-827E-460131E2E2A5">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" title="You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.">Using XMLIndex with an Unstructured Component</a>&#34;</span> for examples of creating secondary indexes on column <code>VALUE</code></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a>&#34;</span> for the syntax of the <code>PARAMETERS</code> clause</p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB4351"></a>
<div class="props_rev_3"><a id="GUID-5E7E3440-154B-49F1-B87F-DA877015FC48"></a>
<h4 id="ADXDB-GUID-5E7E3440-154B-49F1-B87F-DA877015FC48" class="sect4"><span class="enumeration_section">6.3.4.4</span> XPath Expressions that Are Not Indexed by an XMLIndex Unstructured Component</h4>
<div>
<p>A few types of XPath expressions are <span class="italic">not</span> indexed by <code>XMLIndex</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p>Applications of XPath functions, <span class="italic">except</span> <code>ora:contains</code>. In particular, user-defined XPath functions are <span class="italic">not</span> indexed.</p>
</li>
<li>
<p>Axes other than <code>child</code>, <code>descendant</code>, and <code>attribute</code>, that is, axes <code>parent</code>, <code>ancestor</code>, <code>following-sibling</code>, <code>preceding-sibling</code>, <code>following</code>, <code>preceding</code>, and <code>ancestor-or-self</code>.</p>
</li>
<li>
<p>Expressions using the union operator, <span class="bold"><code>|</code></span> (vertical bar).</p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDB4353"></a><a id="ADXDB4356"></a><a id="ADXDB4357"></a><a id="ADXDB4352"></a>
<div class="props_rev_3"><a id="GUID-AE06E648-B947-4171-929B-68A1DBD93992"></a>
<h3 id="ADXDB-GUID-AE06E648-B947-4171-929B-68A1DBD93992" class="sect3"><span class="enumeration_section">6.3.5</span> Creating, Dropping, Altering, and Examining an XMLIndex Index</h3>
<div>
<p>Basic operations on an <code>XMLIndex</code> index include creating it, dropping it, altering it, and examining it. Examples are presented.</p>
<div class="section">
<p>You create an <code>XMLIndex</code> index by declaring the index type to be <code>XDB.XMLIndex</code>, as illustrated in <a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-5</a>.</p>
<p>This creates an <code>XMLIndex</code> index named <code>po_xmlindex_ix</code> on <code>XMLType</code> table <code>po_binxml</code>. The index has only an unstructured component, no structured component.</p>
<p>You specify inclusion of a <span class="italic">structured</span> component in an <code>XMLIndex</code> index by including a <span class="italic"><code>structured_clause</code></span> in the <code>PARAMETERS</code> clause. You specify inclusion of an <span class="italic">unstructured</span> component by including a <span class="italic"><code>path_table_clause</code></span> in the <code>PARAMETERS</code> clause.</p>
<p>You can do this when you create the <code>XMLIndex</code> index or when you modify it. If, as in <a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-5</a>, you specify neither a <span class="italic"><code>structured_clause</code></span> nor a <span class="italic"><code>path_table_clause</code></span>, then <span class="italic">only</span> an unstructured component is included.</p>
<p>If an <code>XMLIndex</code> index has both an unstructured and a structured component, then you can drop either of these components using <code>ALTER INDEX</code>.</p>
<div class="infoboxnotealso" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__GUID-0FE22123-D012-4C96-8863-0C24357F7A5E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">structured_clause ::=</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAGCI">path_table_clause ::=</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGGGBCB">drop_path_table_clause ::=</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAAGH">alter_index_group_clause ::=</a>&#34;</span></p>
</li>
</ul>
</div>
<p>You can obtain the name of an <code>XMLIndex</code> index on a particular <code>XMLType</code> table (or column), as shown in <a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDDGHDF">Example 6-6</a>. You can also select <code>INDEX_NAME</code> from <code>DBA_INDEXES</code> or <code>ALL_INDEXES</code>, as appropriate.</p>
<p>You rename or drop an <code>XMLIndex</code> index just as you would any other index, as illustrated in <a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDFIGIB">Example 6-7</a>. This renaming changes the name of the <code>XMLIndex</code> index only. It does not change the name of the path table&thinsp;&mdash;&thinsp;you can rename the path table separately.</p>
<p>Similarly, you can change other index properties using other <code>ALTER INDEX</code> options, such as <code>REBUILD</code>. <code>XMLIndex</code> is no different from other index types in this respect.</p>
<p>The <code>RENAME</code> clause of an <code>ALTER INDEX</code> statement for <code>XMLIndex</code> applies only to the <code>XMLIndex</code> index itself. To rename the path table and secondary indexes, you must determine the names of these objects and use appropriate <code>ALTER TABLE</code> or <code>ALTER INDEX</code> statements on them directly. Similarly, to retrieve the physical properties of the secondary indexes or alter them in any other way, you must obtain their names, as in <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">Example 6-12</a>.</p>
<div class="infoboxnotealso" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__GUID-2F8E1EFD-A511-4381-8943-309B65B86735">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a>&#34;</span> for the syntax of the <code>PARAMETERS</code> clause</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">
<p class="titleinexample">Example 6-5 Creating an XMLIndex Index</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS <span class="bold">XDB.XMLIndex</span>;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDDGHDF">
<p class="titleinexample">Example 6-6 Obtaining the Name of an XMLIndex Index on a Particular Table</p>
<pre dir="ltr">SELECT INDEX_NAME FROM <span class="bold">USER_INDEXES</span>
  WHERE TABLE_NAME = &#39;PO_BINXML&#39; AND <span class="bold">ITYP_NAME = &#39;XMLINDEX&#39;</span>;

INDEX_NAME
---------------
PO_XMLINDEX_IX
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDFIGIB">
<p class="titleinexample">Example 6-7 Renaming and Dropping an XMLIndex Index</p>
<pre dir="ltr">ALTER INDEX po_xmlindex_ix <span class="bold">RENAME TO new_name_ix</span>;

DROP INDEX new_name_ix;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4358"></a><a id="ADXDB4359"></a><a id="ADXDB4360"></a><a id="ADXDB5827"></a><a id="ADXDB4361"></a><a id="ADXDB4362"></a>
<div class="props_rev_3"><a id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246"></a>
<h3 id="ADXDB-GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" class="sect3"><span class="enumeration_section">6.3.6</span> Using XMLIndex with an Unstructured Component</h3>
<div>
<p>You can perform various operations on an <code>XMLIndex</code> index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.</p>
<div class="section">
<p>To include an unstructured component in an <code>XMLIndex</code> index, you can use a <span class="italic"><code>path_table_clause</code></span> in the <code>PARAMETERS</code> clause when you create or modify the <code>XMLIndex</code> index&thinsp;&mdash;&thinsp;see <span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAGCI">path_table_clause ::=</a>&#34;</span>.</p>
<p>If you do not specify a <span class="italic">structured</span> component, then the index will have an unstructured component, even if you do not specify the path table. It is however generally a good idea to specify the path table, so that it has a recognizable, user-oriented name that you can refer to in other <code>XMLIndex</code> operations.</p>
<p><a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-8</a> shows how to name the path table (&#34;my_path_table&#34;) when creating an <code>XMLIndex</code> index with an unstructured component.</p>
<p>If you do not name the path table then its name is generated by the system, using the index name you provide to <code>CREATE INDEX</code> as a base. <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">Example 6-9</a> shows this for the <code>XMLIndex</code> index created in <a href="xdb_indexing.htm#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-5</a>.</p>
<p>By default, the storage options of a path table and its secondary indexes are derived from the storage properties of the base table on which the <code>XMLIndex</code> index is created. You can specify different storage options by using a <code>PARAMETERS</code> clause when you create the index, as shown in <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-10</a>. The <code>PARAMETERS</code> clause of <code>CREATE INDEX</code> (and <code>ALTER INDEX</code>) must be between single quotation marks (<span class="bold"><code>&#39;</code></span>).</p>
<div class="infoboxnotealso" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__GUID-A0CC4AC4-1B2C-4F4C-8AFC-294083E9D10A">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a>&#34;</span> for the syntax of the <code>PARAMETERS</code> clause</p>
</div>
<p>Because <code>XMLIndex</code> is a logical <span class="italic">domain</span> index, not a physical index, all physical attributes are either zero (<code>0</code>) or <code>NULL</code>.</p>
<p>If an <code>XMLIndex</code> index has both an unstructured and a structured component, then you can use <code>ALTER INDEX</code> to drop the unstructured component. To do this, you drop the path table. <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__BCGHIIFB">Example 6-11</a> illustrates this. (This assumes that you also have a structured component&thinsp;&mdash;&thinsp;<a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a> results in an index with both structured and unstructured components.)</p>
<p>Note that, in addition to specifying storage options for the path table, <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-10</a> names the secondary indexes on the path table.</p>
<p>Like the name of the path table, the names of the secondary indexes on the path-table columns are generated automatically using the index name as a base, unless you specify them in the <code>PARAMETERS</code> clause. <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">Example 6-12</a> illustrates this, and shows how you can determine these names using public view <code>USER_IND_COLUMNS</code>. It also shows that the pikey index uses three columns.</p>
<div class="infoboxnotealso" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__GUID-DE57EC3B-B5A9-4C0C-BA0B-12F4BC9984E6">
<p class="notep1">See Also:</p>
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-18</a> for a similar, but more complex example</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">
<p class="titleinexample">Example 6-8 Naming the Path Table of an XMLIndex Index</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  <span class="bold">PARAMETERS (&#39;PATH TABLE my_path_table&#39;)</span>;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">
<p class="titleinexample">Example 6-9 Determining the System-Generated Name of an XMLIndex Path Table</p>
<pre dir="ltr">SELECT <span class="bold">PATH_TABLE_NAME</span> FROM <span class="bold">USER_XML_INDEXES</span>
  WHERE TABLE_NAME = &#39;PO_BINXML&#39; AND INDEX_NAME = &#39;PO_XMLINDEX_IX&#39;;
 
PATH_TABLE_NAME
------------------------------
<span class="bold">SYS67567</span>_PO_XMLINDE_<span class="bold">PATH_TABLE</span>
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">
<p class="titleinexample">Example 6-10 Specifying Storage Options When Creating an XMLIndex Index</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS
    (&#39;PATH TABLE po_path_table
      (PCTFREE 5 PCTUSED 90 INITRANS 5
       <span class="bold">STORAGE</span> (INITIAL 1k NEXT 2k MINEXTENTS 3 BUFFER_POOL KEEP)
       NOLOGGING ENABLE ROW MOVEMENT PARALLEL 3)
      <span class="bold">PIKEY INDEX</span> po_pikey_ix (LOGGING PCTFREE 1 INITRANS 3)
      <span class="bold">VALUE INDEX</span> po_value_ix (LOGGING PCTFREE 1 INITRANS 3)&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__BCGHIIFB">
<p class="titleinexample">Example 6-11 Dropping an XMLIndex Unstructured Component</p>
<pre dir="ltr">ALTER INDEX po_xmlindex_ix PARAMETERS(&#39;DROP PATH TABLE&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">
<p class="titleinexample">Example 6-12 Determining the Names of the Secondary Indexes of an XMLIndex Index</p>
<pre dir="ltr">SELECT INDEX_NAME, COLUMN_NAME, COLUMN_POSITION FROM USER_IND_COLUMNS
  WHERE TABLE_NAME IN (SELECT PATH_TABLE_NAME FROM USER_XML_INDEXES
                         WHERE INDEX_NAME = &#39;PO_XMLINDEX_IX&#39;)
  ORDER BY INDEX_NAME, COLUMN_NAME;
 
INDEX_NAME                     COLUMN_NAME  COLUMN_POSITION
------------------------------ ------------ ---------------
SYS67563_PO_XMLINDE_PIKEY_IX   ORDER_KEY                  3
SYS67563_PO_XMLINDE_PIKEY_IX   PATHID                     2
SYS67563_PO_XMLINDE_PIKEY_IX   RID                        1
SYS67563_PO_XMLINDE_VALUE_IX   SYS_NC00006$               1
 
4 rows selected.
</pre></div>
<!-- class="example" --></div>
<a id="ADXDB4363"></a><a id="ADXDB4364"></a><a id="ADXDB4365"></a><a id="ADXDB4366"></a><a id="ADXDB4367"></a><a id="ADXDB4368"></a><a id="ADXDB5828"></a>
<div class="props_rev_3"><a id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24"></a>
<h4 id="ADXDB-GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24" class="sect4"><span class="enumeration_section">6.3.6.1</span> Creating Additional Secondary Indexes on an XMLIndex Path Table</h4>
<div>
<p>You can add extra secondary indexes to an <code>XMLIndex</code> unstructured component.</p>
<div class="section">
<p>Examples <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-13</a>, <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">Example 6-15</a>, <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">Example 6-16</a>, and <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">Example 6-17</a> add extra secondary indexes to the <code>XMLIndex</code> index created in <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-10</a>.</p>
<p>You can create any number of additional secondary indexes on the <code>VALUE</code> column of the path table of an <code>XMLIndex</code> index. These can be of different types, including function-based indexes and Oracle Text indexes.</p>
<p>Whether or not a given index is used for a given element occurrence when processing a query is determined by whether it is of the appropriate type for that value and whether it is cost-effective to use it.</p>
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-13</a> creates a function-based index on column <code>VALUE</code> of the path table using SQL function <code>substr</code>. This might be useful if your queries often use <code>substr</code> applied to the text nodes of XML elements.</p>
<p>If you have many elements whose text nodes represent numeric values, then it can make sense to create a numeric index on the column <code>VALUE</code>. However, doing so directly, in a manner analogous to <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-13</a>, raises an ORA-01722 error (invalid number) if some of the element values are <span class="italic">not</span> numbers. This is illustrated in <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJBCDD">Example 6-14</a>.</p>
<p>What is needed is an index that is used for numeric-valued elements but is ignored for element occurrences that do not have numeric values. Procedure <code>createNumberIndex</code> of package <code>DBMS_XMLINDEX</code> exists specifically for this purpose. You pass it the names of the database schema, the <code>XMLIndex</code> index, and the numeric index to be created. Creation of a numeric index is illustrated in <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">Example 6-15</a>.</p>
<p>Note that because such an index is specifically designed to ignore elements that do not have numeric values, its use does not detect their presence. If there are non-numeric elements and, for whatever reason, the <code>XMLIndex</code> index is not used in some query, then an <code>ORA-01722</code> error is raised. However, if the index is used, no such error is raised, because the index ignores non-numeric data. As always, the use of an index never changes the result set&thinsp;&mdash;&thinsp;it never gives you different results, but use of an index can prevent you from detecting erroneous data.</p>
<p>Creating a date-valued index is similar to creating a numeric index; you use procedure <code>DBMS_XMLINDEX.createDateIndex</code>. <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">Example 6-16</a> shows this.</p>
<p><a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">Example 6-17</a> creates an Oracle Text <code>CONTEXT</code> index on column <code>VALUE</code>. This is useful for full-text queries on text values of XML elements. XPath predicates that use XPath function <code>ora:contains</code> are rewritten to applications of Oracle SQL function <code>contains</code> on column <code>VALUE</code>. If a <code>CONTEXT</code> index is defined on column <code>VALUE</code>, then it is used during predicate evaluation. An Oracle Text index is independent of all other <code>VALUE</code>-column indexes.</p>
<div class="infoboxnotealso" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__GUID-92D20DAB-9879-4411-842A-2C91A76BDF82">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4" title="A secondary index on column VALUE is used with XPath expressions in a WHERE clause that have predicates involving string matches. For example:">Column VALUE of an XMLIndex Path Table</a>&#34;</span> for information about the possibility of an Oracle Text <code>CONTEXT</code> index created on the <code>VALUE</code> column returning incorrect results</p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="app_depr_otext.htm#GUID-845429DB-A464-4649-9FE3-A87E1E30A356" title="Although Oracle XQuery function ora:contains does not rely on a supporting index, when XPath rewrite occurs ora:contains can often make use of an existing CONTEXT index for better performance.">XPath Rewrite and CONTEXT Indexes</a>&#34;</span> for information about parameter <code>TRANSACTIONAL</code></p>
</li>
</ul>
</div>
<p>The query in <a href="xdb_indexing.htm#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-18</a> shows all of the secondary indexes created on the path table of an <code>XMLIndex</code> index. The indexes created explicitly are in bold. Note in particular that some indexes, such as the function-based index created on column <code>VALUE</code>, do not appear as such; the column name listed for such an index is a system-generated name such as <code>SYS_NC00007$</code>. You <span class="italic">cannot</span> see these columns by executing a query with <code>COLUMN_NAME = &#39;VALUE&#39;</code> in the <code>WHERE</code> clause.</p>
<div class="infoboxnotealso" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__GUID-008D1A13-38D6-4ED9-A227-C4D6A81AB467">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ARPLS212" target="_blank" href="../ARPLS/d_xmlindex.htm#ARPLS212"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information on PL/SQL procedures <code>createNumberIndex</code> and <code>createDateIndex</code> in package <code>DBMS_XMLINDEX</code></p>
</li>
<li>
<p><a href="app_depr_otext.htm#GUID-1B838D2B-DD94-480A-8D3D-53E0204A2282" title="Oracle-specific full-text search over XML data is described, including how to use Oracle SQL function contains and Oracle XPath function ora:contains.">Full-Text Search over XML Data Without XQuery</a> for information on using Oracle Text indexes</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">
<p class="titleinexample">Example 6-13 Creating a Function-Based Index on Path-Table Column VALUE</p>
<pre dir="ltr">CREATE INDEX fn_based_ix ON <span class="bold">po_path_table</span> (<span class="bold">substr</span>(<span class="bold">VALUE</span>, 1, 100));
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJBCDD">
<p class="titleinexample">Example 6-14 Trying to Create a Numeric Index on Path-Table Column VALUE Directly</p>
<pre dir="ltr">CREATE INDEX direct_num_ix ON po_path_table (to_binary_double(VALUE));
CREATE INDEX direct_num_ix ON po_path_table (to_binary_double(VALUE))
                                             <span class="bold">*</span>
ERROR at line 1:
ORA-01722: <span class="bold">invalid number</span>
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">
<p class="titleinexample">Example 6-15 Creating a Numeric Index on Column VALUE with Procedure createNumberIndex</p>
<pre dir="ltr">CALL DBMS_XMLINDEX.<span class="bold">createNumberIndex</span>(&#39;OE&#39;, &#39;PO_XMLINDEX_IX&#39;, &#39;API_NUM_IX&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">
<p class="titleinexample">Example 6-16 Creating a Date Index on Column VALUE with Procedure createDateIndex</p>
<pre dir="ltr">CALL DBMS_XMLINDEX.<span class="bold">createDateIndex</span>(&#39;OE&#39;, &#39;PO_XMLINDEX_IX&#39;, &#39;API_DATE_IX&#39;, 
                                   &#39;dateTime&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">
<p class="titleinexample">Example 6-17 Creating an Oracle Text CONTEXT Index on Path-Table Column VALUE</p>
<pre dir="ltr">CREATE INDEX po_otext_ix ON po_path_table (VALUE)
  INDEXTYPE IS <span class="bold">CTXSYS.CONTEXT</span> PARAMETERS(&#39;TRANSACTIONAL&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">
<p class="titleinexample">Example 6-18 Showing All Secondary Indexes on an XMLIndex Path Table</p>
<pre dir="ltr">SELECT c.INDEX_NAME, c.COLUMN_NAME, c.COLUMN_POSITION, e.COLUMN_EXPRESSION
  FROM <span class="bold">USER_IND_COLUMNS</span> c LEFT OUTER JOIN <span class="bold">USER_IND_EXPRESSIONS</span> e
    ON (c.INDEX_NAME = e.INDEX_NAME)
  WHERE c.TABLE_NAME IN (SELECT PATH_TABLE_NAME FROM USER_XML_INDEXES
                           WHERE INDEX_NAME = &#39;PO_XMLINDEX_IX&#39;)
  ORDER BY c.INDEX_NAME, c.COLUMN_NAME;
 
INDEX_NAME           COLUMN_NAME  COLUMN_POSITION COLUMN_EXPRESSION
-------------------- ------------ --------------- ----------------------
<span class="bold">API_DATE_IX</span>          <span class="bold">SYS_NC00009$</span>               1 SYS_EXTRACT_UTC(SYS_XMLCONV(&#34;V
                                                  ALUE&#34;,3,8,0,0,181))
<span class="bold">API_NUM_IX</span>           <span class="bold">SYS_NC00008$</span>               1 TO_BINARY_DOUBLE(&#34;VALUE&#34;)
<span class="bold">FN_BASED_IX</span>          <span class="bold">SYS_NC00007$</span>               1 SUBSTR(&#34;VALUE&#34;,1,100)
<span class="bold">PO_OTEXT_IX</span>          VALUE                      1
PO_PIKEY_IX          ORDER_KEY                  3
PO_PIKEY_IX          PATHID                     2
PO_PIKEY_IX          RID                        1
PO_VALUE_IX          SYS_NC00006$               1 SUBSTRB(&#34;VALUE&#34;,1,1599)
 
8 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB4369"></a>
<div class="props_rev_3"><a id="GUID-476331FD-F58B-4980-BECD-015F0A794AC9"></a>
<h3 id="ADXDB-GUID-476331FD-F58B-4980-BECD-015F0A794AC9" class="sect3"><span class="enumeration_section">6.3.7</span> Use of XMLIndex with a Structured Component</h3>
<div>
<p>An <code>XMLIndex</code> structured component indexes specific islands of structure in your XML data.</p>
<p>To include a structured component in an <code>XMLIndex</code> index, you use a <span class="italic"><code>structured_clause</code></span> in the <code>PARAMETERS</code> clause when you create or modify the <code>XMLIndex</code> index&thinsp;&mdash;&thinsp;see <span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">structured_clause ::=</a>&#34;</span>.</p>
<p>A <span class="italic"><code>structured_clause</code></span> specifies the structured islands that you want to index. You use the keyword <code>GROUP</code> to specify each structured island: an island thus corresponds syntactically to a structure <strong class="term">group</strong>. If you specify no group explicitly, then the predefined group <code>DEFAULT_GROUP</code> is used. For <code>ALTER INDEX</code>, you precede the <code>GROUP</code> keyword with the modification operation keyword: <code>ADD_GROUP</code> specifies a new group (island); <code>DROP_GROUP</code> deletes a group.</p>
<p>Why have multiple groups within a single index, instead of simply using multiple <code>XMLIndex</code> indexes? The reason is that <code>XMLIndex</code> is a domain index, and you can create only one domain index of a given type on a given database column.</p>
<p>The syntax for defining a structure group, that is, indexing a structured island, is similar to the syntax for invoking SQL/XML <span class="italic">function</span> <code>XMLTable</code>: you use keywords <code>XMLTable</code> and <code>COLUMNS</code> to define relational columns, and you use multilevel chaining of <code>XMLTable</code> to handle collections. To simplify the creation of such an index, you can use PL/SQL function <code>DBMS_XMLSTORAGE_MANAGE.getSIDXDefFromView</code> to provide exactly the <code>XMLTable</code> expression needed for creating the index.</p>
<div class="infoboxnotealso" id="GUID-476331FD-F58B-4980-BECD-015F0A794AC9__GUID-9B8DB6E1-63C4-4EE7-973A-BC6B33A92472">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_rel_views.htm#GUID-DFEC1462-BAD9-44CA-A9C4-88C27A0CD46C" title="If the relational columns of the structured component of an XMLIndex index over binary XML data match the columns of a relational view over that data, then the view too is effectively indexed.">Indexing Binary XML Data Exposed Using a Relational View</a>&#34;</span> for information about using <code>DBMS_XMLSTORAGE_MANAGE.getSIDXDefFromView</code></p>
</li>
<li>
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-27</a></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-C04D8939-4A3C-4C54-8399-109AC4914D03" title="The string value used for the PARAMETERS clause of a CREATE INDEX or ALTER INDEX statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures registerParameter and modifyParameter in package DBMS_XMLINDEX.">Using a Registered PARAMETERS Clause for XMLIndex</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">structured_clause ::=</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42" title="Certain considerations apply to using XMLIndex_xmltable_clause.">Usage of XMLIndex_xmltable_clause</a>&#34;</span> for information about an <code>XMLType</code> column in an <code>XMLTable</code> clause</p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-D4474161-F125-4703-98D2-7C609F8806E7" title="Certain considerations apply to using column_clause.">Usage of column_clause</a>&#34;</span> for information about keywords <code>COLUMNS</code> and <code>VIRTUAL</code></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" title="The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).">Data Type Considerations for XMLIndex Structured Component</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<a id="ADXDB5831"></a><a id="ADXDB6087"></a>
<div class="props_rev_3"><a id="GUID-6C638C44-A5E6-476F-95A0-151150EEF16B"></a>
<h4 id="ADXDB-GUID-6C638C44-A5E6-476F-95A0-151150EEF16B" class="sect4"><span class="enumeration_section">6.3.7.1</span> Using Namespaces and Storage Clauses with an XMLIndex Structured Component</h4>
<div>
<p>When you create an <code>XMLIndex</code> index that has a structured component you can specify XML namespaces and storage options to use.</p>
<div class="section">
<p><a href="xdb_indexing.htm#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">Example 6-19</a> shows the creation of an <code>XMLIndex</code> index that has only a structured component (no path table clause) and that uses the <code>XMLNAMESPACES</code> clause to specify namespaces. It specifies that the index data be compressed and use tablespace <code>SYSAUX</code>. The example assumes a binary XML table <code>po_binxml</code> with non XML schema-based data.</p>
<p>Each of the <code>TABLESPACE</code> clauses in <a href="xdb_indexing.htm#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">Example 6-19</a> applies at the table level (tables <code>po_ptab</code> and <code>li_tab</code>). You can also specify <code>TABLESPACE</code> clauses for a given <code>XMLIndex</code> index or a given partition.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">
<p class="titleinexample">Example 6-19 XMLIndex with Only a Structured Component and Using Namespaces</p>
<pre dir="ltr">CREATE INDEX po_struct ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS (&#39;XMLTable po_ptab
                 (TABLESPACE &#34;SYSAUX&#34; COMPRESS FOR OLTP)
                 XMLNAMESPACES (DEFAULT &#39;&#39;http://www.example.com/po&#39;&#39;),
                 &#39;&#39;/purchaseOrder&#39;&#39;
                 COLUMNS orderdate   DATE          PATH &#39;&#39;@orderDate&#39;&#39;,
                         id          BINARY_DOUBLE PATH &#39;&#39;@id&#39;&#39;,
                         items       XMLType       PATH &#39;&#39;items/item&#39;&#39; VIRTUAL
               XMLTable li_tab
                 (TABLESPACE &#34;SYSAUX&#34; COMPRESS FOR OLTP)
                 XMLNAMESPACES (DEFAULT &#39;&#39;http://www.example.com/po&#39;&#39;),
                 &#39;&#39;/item&#39;&#39; PASSING items
                 COLUMNS partnum     VARCHAR2(15)  PATH &#39;&#39;@partNum&#39;&#39;,
                         description CLOB          PATH &#39;&#39;productName&#39;&#39;,
                         usprice     BINARY_DOUBLE PATH &#39;&#39;USPrice&#39;&#39;,
                         shipdat     DATE          PATH &#39;&#39;shipDate&#39;&#39;&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4370"></a><a id="ADXDB6088"></a>
<div class="props_rev_3"><a id="GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0"></a>
<h4 id="ADXDB-GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0" class="sect4"><span class="enumeration_section">6.3.7.2</span> Adding a Structured Component to an XMLIndex Index</h4>
<div>
<p>You can use <code>ALTER INDEX</code> to add a structured component to an existing <code>XMLIndex</code> index.</p>
<div class="section">
<p><a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a> shows the creation of an <code>XMLIndex</code> index with only an unstructured component. An unstructured component is created because the <code>PARAMETERS</code> clause explicitly names the path table.</p>
<p><a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a> then uses <code>ALTER INDEX</code> to add a structured component (group) named <code>po_item</code>. This structure group includes two relational tables, each specified with keyword <code>XMLTable</code>.</p>
<p>The top-level table, <code>po_idx_tab</code>, has columns <code>reference</code>, <code>requestor</code>, <code>username</code>, and <code>lineitem</code>. Column <code>lineitem</code> is of type <code>XMLType</code>. It represents a collection, so it is passed to the second <code>XMLTable</code> construct to form the second-level relational table, <code>po_index_lineitem</code>, which has columns <code>itemno</code>, <code>description</code>, <code>partno</code>, <code>quantity</code>, and <code>unitprice</code>.</p>
<p>The keyword <code>VIRTUAL</code> is <span class="italic">required</span> for an <code>XMLType</code> column. It specifies that the <code>XMLType</code> column itself is not materialized: its data is stored in the <code>XMLIndex</code> index only in the form of the relational columns specified by its corresponding <code>XMLTable</code> table.</p>
<p>You cannot create more than one <code>XMLType</code> column in a given <code>XMLTable</code> clause. To achieve that effect, you must instead define an additional group.</p>
<p><a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a> also illustrates the use of a registered parameter string in the <code>PARAMETERS</code> clause. It uses PL/SQL procedure <code>DBMS_XMLINDEX.registerParameter</code> to register the parameters string named <code>myparam</code>. Then it uses <code>ALTER INDEX</code> to update the index parameters to include those in the string <code>myparam</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">
<p class="titleinexample">Example 6-20 XMLIndex Index: Adding a Structured Component</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE)
  INDEXTYPE IS XDB.XMLIndex PARAMETERS (&#39;PATH TABLE path_tab&#39;);

BEGIN
  DBMS_XMLINDEX.<span class="bold">registerParameter</span>(
    &#39;myparam&#39;,
    &#39;<span class="bold">ADD_GROUP GROUP</span> po_item
       <span class="bold">XMLTable</span> po_idx_tab &#39;&#39;/PurchaseOrder&#39;&#39;
         COLUMNS reference   VARCHAR2(30)  PATH &#39;&#39;Reference&#39;&#39;,
                 requestor   VARCHAR2(30)  PATH &#39;&#39;Requestor&#39;&#39;,
                 username    VARCHAR2(30)  PATH &#39;&#39;User&#39;&#39;,
                 lineitem    XMLType       PATH &#39;&#39;LineItems/LineItem&#39;&#39; <span class="bold">VIRTUAL</span>
       <span class="bold">XMLTable</span> po_index_lineitem &#39;&#39;/LineItem&#39;&#39; PASSING lineitem
         COLUMNS itemno      BINARY_DOUBLE PATH &#39;&#39;@ItemNumber&#39;&#39;,
                 description VARCHAR2(256) PATH &#39;&#39;Description&#39;&#39;,
                 partno      VARCHAR2(14)  PATH &#39;&#39;Part/@Id&#39;&#39;,
                 quantity    BINARY_DOUBLE PATH &#39;&#39;Part/@Quantity&#39;&#39;,
                 unitprice   BINARY_DOUBLE PATH &#39;&#39;Part/@UnitPrice&#39;&#39;&#39;);
END;
/

ALTER INDEX po_xmlindex_ix PARAMETERS(&#39;<span class="bold">PARAM</span> myparam&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6090"></a><a id="ADXDB6089"></a>
<div class="props_rev_3"><a id="GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C"></a>
<h4 id="ADXDB-GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C" class="sect4"><span class="enumeration_section">6.3.7.3</span> Using Non-Blocking ALTER INDEX with an XMLIndex Structured Component</h4>
<div>
<p>You can prevent <code>ALTER INDEX</code> from blocking when you add a group or column for the structured component of an <code>XMLIndex</code> index, so that queries that use the index do not need to wait.</p>
<div class="section">
<p>When you use <code>ALTER INDEX</code> to add a group or a column for the structured component of an <code>XMLIndex</code> index, this index-maintenance operation obtains an exclusive DDL lock on the base table and the index.</p>
<p>The base table is locked to DML operations, and the index cannot be used for queries until the <code>ALTER INDEX</code> operation is finished. This means that during this index maintenance the index cannot be used by other sessions that query or perform DML operations on the base table. The duration of the <code>ALTER INDEX</code> operation and the attendant locking depends on the volume of data in the base <code>XMLType</code> column.</p>
<p>You can avoid or work around this problem as follows:</p>
<ol>
<li>
<p>Use keyword <span class="bold"><code>NONBLOCKING</code></span> before <code>ADD_GROUP</code> or <code>ADD_COLUMN</code> in the <code>PARAMETERS</code> clause of the <code>ALTER INDEX</code> statement that creates the structured-component group or column.</p>
<p>This updates the index as needed, but it does not index any base-table data. Because it does not depend on the base-table data it is quick regardless of the base-table size.</p>
</li>
<li>
<p>Invoke PL/SQL procedure <code>DBMS_XMLINDEX.</code><span class="bold"><code>process_pending</code></span>.</p>
<p>This procedure indexes rows of the base table and populates tables of the index, just as if keyword <code>NONBLOCKING</code> were absent. However, in this case only a few rows are locked at a time while they are processed and the changes committed. Rows that have already been locked for some other purpose are skipped. This can significantly reduce lock contention and allow indexing of some rows to proceed at the same time as querying or DML on other rows.</p>
<p>When procedure <code>process_pending</code> finishes it returns, as <code>OUT</code> parameters:</p>
<ul style="list-style-type: disc;">
<li>
<p>The number of rows that it could not index. This is either because they were <span class="italic">locked</span> for another purpose or because an error was raised (this number includes the number returned as the other <code>OUT</code> parameter).</p>
<p>After you think those locks have been removed, invoke procedure <code>process_pending</code> again to try to process those pending rows.</p>
</li>
<li>
<p>The number of rows that it could not index because an <span class="italic">error</span> was raised. (This should be rare.)</p>
<p>Check table <code>SYS_AIXSXI_</code><span class="italic"><code>index_number</code></span><code>_ERRORTAB</code> for information about those errors, then take action to fix the underlying problems. <span class="italic"><code>index_number</code></span> is the object number of the index.</p>
</li>
</ul>
</li>
<li>
<p>Repeat step 2 as many times as necessary until procedure <code>process_pending</code> indicates that all rows have been successfully indexed or you encounter an insurmountable problem and decide to cancel the indexing operation altogether.</p>
<p>You can cancel the indexing at any time (before step 2) by using keywords <span class="bold"><code>NONBLOCKING ABORT</code></span> in the <code>PARAMETERS</code> clause of a separate <code>ALTER INDEX</code> statement for the same <code>XMLIndex</code> index.</p>
</li>
<li>
<p>If all rows have been successfully indexed then use keywords <span class="bold"><code>NONBLOCKING COMPLETE</code></span> in the <code>PARAMETERS</code> clause of a separate <code>ALTER INDEX</code> statement for the same <code>XMLIndex</code> index.</p>
</li>
</ol>
<p><a href="xdb_indexing.htm#GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C__CEGBBCDG">Example 6-21</a> illustrates this.</p>
<p>Just as table <code>SYS_AIXSXI_</code><span class="italic"><code>index_number</code></span><code>_</code><span class="bold"><code>ERRORTAB</code></span> reports errors, so table <code>SYS_AIXSXI_</code><span class="italic"><code>index_number</code></span><code>_</code><span class="bold"><code>PENDINGTAB</code></span> records the current status of each base-table row: whether or not it has been indexed. A row might not yet be indexed because it is locked by for some other purpose or because trying to index it raised an error. In the latter case, consult <code>SYS_AIXSXI_</code><span class="italic"><code>index_number</code></span><code>_ERRORTAB</code> for specific information about the error.</p>
<div class="infoboxnotealso" id="GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C__GUID-198206E5-C3F2-401E-B227-1EDB6B7B002B">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAAGH">alter_index_group_clause ::=</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C__CEGBBCDG">
<p class="titleinexample">Example 6-21 Using DBMS_XMLINDEX.PROCESS_PENDING To Index XML Data</p>
<pre dir="ltr">CREATE INDEX po_struct ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS (&#39;XMLTable po_idx_tab
                 &#39;&#39;/PurchaseOrder&#39;&#39;
                 COLUMNS reference   VARCHAR2(30)  PATH &#39;&#39;Reference&#39;&#39;,
                         requestor   VARCHAR2(30)  PATH &#39;&#39;Requestor&#39;&#39;,
                         username    VARCHAR2(30)  PATH &#39;&#39;User&#39;&#39;,
                         lineitem    XMLType       PATH &#39;&#39;LineItems/LineItem&#39;&#39; VIRTUAL
               XMLTable po_index_lineitem
                 &#39;&#39;/LineItem&#39;&#39; PASSING lineitem
                 COLUMNS itemno      BINARY_DOUBLE PATH &#39;&#39;@ItemNumber&#39;&#39;,
                         description VARCHAR2(256) PATH &#39;&#39;Description&#39;&#39;,
                         partno      VARCHAR2(14)  PATH &#39;&#39;Part/@Id&#39;&#39;,
                         quantity    BINARY_DOUBLE PATH &#39;&#39;Part/@Quantity&#39;&#39;,
                         unitprice   BINARY_DOUBLE PATH &#39;&#39;Part/@UnitPrice&#39;&#39;&#39;);
 
ALTER INDEX po_struct
  PARAMETERS(&#39;<span class="bold">NONBLOCKING</span> ADD_GROUP GROUP po_action_group 
              XMLTABLE po_idx_tab
                &#39;&#39;/PurchaseOrder&#39;&#39;
                COLUMNS actions       XMLType       PATH  &#39;&#39;Actions/Action&#39;&#39; VIRTUAL
              XMLTABLE po_idx_action
                &#39;&#39;/Action&#39;&#39; PASSING actions
                COLUMNS actioned_by   VARCHAR2(10)  PATH  &#39;&#39;User&#39;&#39;,
                        date_actioned TIMESTAMP     PATH  &#39;&#39;Date&#39;&#39;&#39;);

DECLARE
  num_pending NUMBER := 0;
  num_errored NUMBER := 0;
BEGIN
 DBMS_XMLINDEX.<span class="bold">process_pending</span>(&#39;oe&#39;, &#39;po_struct&#39;, num_pending, num_errored);
 DBMS_OUTPUT.put_line(&#39;Number of rows still pending = &#39; || num_pending);
 DBMS_OUTPUT.put_line(&#39;Number of rows with errors   = &#39; || num_errored);
END;
/
Number of rows still pending = <span class="bold">0</span>
Number of rows with errors   = <span class="bold">0</span>
 
PL/SQL procedure successfully completed.

ALTER INDEX po_struct PARAMETERS(&#39;<span class="bold">NONBLOCKING COMPLETE</span>&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6091"></a>
<div class="props_rev_3"><a id="GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE"></a>
<h4 id="ADXDB-GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE" class="sect4"><span class="enumeration_section">6.3.7.4</span> Modifying the Data Type of a Structured XMLIndex Component</h4>
<div>
<p>If an error is raised because some of your data does not match the data type used for the corresponding column of the structured <code>XMLIndex</code> component, you can in some cases simply modify the index by passing keyword <code>MODIFY_COLUMN_TYPE</code> to <code>ALTER INDEX</code>.</p>
<div class="section">
<p>You can, for example, expand a <code>VARCHAR2(30)</code> column to, say, <code>VARCHAR2(40)</code> if it needs to accommodate data that is up to 40 characters. This is simpler and more efficient than dropping the column and then adding a new column. The new data type must be compatible with the old one: the same restrictions apply as apply for <code>ALTER TABLE MODIFY COLUMN</code>.</p>
<div class="infoboxnotealso" id="GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE__GUID-0C615772-8565-4D18-863B-5B122B496919">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF01001" target="_blank" href="../SQLRF/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>ALTER TABLE MODIFY COLUMN</code></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__CEGEABGE">modify_column_type_clause :==</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5829"></a><a id="ADXDB6092"></a>
<div class="props_rev_3"><a id="GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8"></a>
<h4 id="ADXDB-GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8" class="sect4"><span class="enumeration_section">6.3.7.5</span> Dropping an XMLIndex Structured Component</h4>
<div>
<p>If an <code>XMLIndex</code> index has both an unstructured and a structured component, then you can use <code>ALTER INDEX</code> to drop the structured component. You do this by dropping <span class="italic">all</span> of the structure groups that compose the structured component.</p>
<div class="section">
<p><a href="xdb_indexing.htm#GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8__BCGJGJAD">Example 6-22</a> shows how to drop the structured component that was added in <a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a>, by dropping its only structure group, <code>po_item</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8__BCGJGJAD">
<p class="titleinexample">Example 6-22 Dropping an XMLIndex Structured Component</p>
<pre dir="ltr">ALTER INDEX po_xmlindex_ix PARAMETERS(&#39;DROP_GROUP GROUP po_item&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4371"></a><a id="ADXDB6093"></a>
<div class="props_rev_3"><a id="GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9"></a>
<h4 id="ADXDB-GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9" class="sect4"><span class="enumeration_section">6.3.7.6</span> Indexing the Relational Tables of a Structured XMLIndex Component</h4>
<div>
<p>Because the tables used for the structured component of an <code>XMLIndex</code> index are normal relational tables, you can index them using any standard relational indexes.</p>
<div class="section">
<p>This is explained in section <span class="q">&#34;<a href="xdb_indexing.htm#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>&#34;</span>. It is illustrated by <a href="xdb_indexing.htm#GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9__BCGEGABJ">Example 6-23</a>, which creates a B-tree index on the <code>reference</code> column of the index content table (structured fragment) for the <code>XMLIndex</code> index of <a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9__BCGEGABJ">
<p class="titleinexample">Example 6-23 Creating a B-tree Index on an XMLIndex Index Content Table</p>
<pre dir="ltr">CREATE INDEX idx_tab_ref_ix ON po_idx_tab (reference);
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDB4373"></a><a id="ADXDB4374"></a><a id="ADXDB4375"></a><a id="ADXDB4376"></a><a id="ADXDB4377"></a><a id="ADXDB4372"></a>
<div class="props_rev_3"><a id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52"></a>
<h3 id="ADXDB-GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52" class="sect3"><span class="enumeration_section">6.3.8</span> How to Tell Whether XMLIndex is Used</h3>
<div>
<p>To know whether a particular <code>XMLIndex</code> index has been used in resolving a query, you can examine an execution plan for the query.</p>
<p>It is at query compile time that Oracle Database determines whether or not a given <code>XMLIndex</code> index can be used, that is, whether the query can be rewritten into a query against the index.</p>
<p>For an unstructured <code>XMLIndex</code> component, if it cannot be determined at compile time that an XPath expression in the query is a subset of the paths you specified to be used for <code>XMLIndex</code> indexing, then the unstructured component of the&thinsp; index &thinsp;is not used.</p>
<p>For example, if the path <code>/PurchaseOrder/LineItems//*</code> is included for indexing, then a query with <code>/PurchaseOrder/LineItems/LineItem/Description</code> can use the index, but a query with <code>//Description</code> cannot. The latter also matches potential <code>Description</code> elements that are not children of <code>/PurchaseOrder/LineItems</code>, and it is not possible at compile time to know if such additional <code>Description</code> elements are present in the data.</p>
<p>You can examine the execution plan for a query see whether a particular <code>XMLIndex</code> index has been used in resolving the query.</p>
<ul style="list-style-type: disc;">
<li>
<p>If the <span class="italic">unstructured</span> component of the index is used, then its path table, order key, or path id is referenced in the execution plan. The execution plan does <span class="italic">not</span> directly indicate that a domain index was used; it does <span class="italic">not</span> refer to the <code>XMLIndex</code> index by name. See <a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDDJDGI">Example 6-24</a> and <a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-26</a>.</p>
</li>
<li>
<p>If the <span class="italic">structured</span> component of the index is used, then one or more of its index content tables is called out in the execution plan. See <a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-27</a> and <a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGJEDEA">Example 6-28</a>.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__GUID-BA086F5D-40BD-4DC7-BAC8-3B3D238BCFE6">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF" target="_blank" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink TGSQL" target="_blank" href="../TGSQL/toc.htm"><span class="italic">Oracle Database SQL Tuning Guide</span></a></p>
</li>
</ul>
</div>
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDDJDGI">Example 6-24</a> shows that the <code>XMLIndex</code> index created in <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-8</a> is used in a particular query. The reference to <code>MY_PATH_TABLE</code> in the execution plan here indicates that the <code>XMLIndex</code> index (created in <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-8</a>) is used in this query. Similarly, reference to columns <code>LOCATOR</code>, <code>ORDER_KEY</code>, and <code>PATHID</code> indicates the same thing.</p>
<p>Given the name of a path table from an execution plan such as this, you can obtain the name of its <code>XMLIndex</code> index as shown in <a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDBCJIG">Example 6-25</a>. (This is more or less opposite to the query in <a href="xdb_indexing.htm#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">Example 6-9</a>.)</p>
<p><code>XMLIndex</code> can be used for XPath expressions in the <code>SELECT</code> list, the <code>FROM</code> list, and the <code>WHERE</code> clause of a query, and it is useful for SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>. Unlike function-based indexes, which are deprecated for <code>XMLType</code>, <code>XMLIndex</code> indexes can be used when you extract data from an XML fragment in a document.</p>
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-26</a> illustrates this.</p>
<p>The execution plan for the query in <a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-26</a> shows, by referring to the path table, that <code>XMLIndex</code> is used. It also shows the use of Oracle internal SQL function <code>sys_orderkey_depth</code>&thinsp;&mdash;&thinsp;see <span class="q">&#34;<a href="xdb_indexing.htm#GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF" title="There are several guidelines that can help you use XMLIndex with an unstructured component.">Guidelines for Using XMLIndex with an Unstructured Component</a>&#34;</span>.</p>
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-27</a> shows an execution plan that indicates that the <code>XMLIndex</code> index created in <a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a> is picked up for a query that uses two <code>WHERE</code> clause predicates. It is the same query as in <a href="xdb_indexing.htm#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-43</a>, and the same XML search index is in effect, as is also shown in the execution plan.</p>
<p>With only the unstructured <code>XMLIndex</code> component, the query would have involved a join of the path table to itself, because of the two different paths in the <code>WHERE</code> clause.</p>
<p>The presence in <a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-27</a> of the path table name, <code>path_tab</code>, indicates that the unstructured component of the index is used. The presence of the index content table <code>po_idx_tab</code> indicates that the structured index component is used. The presence of the XML search index, <code>po_ctx_idx</code>, indicates that it too is used.</p>
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGJEDEA">Example 6-28</a> shows an execution plan that indicates that the same <code>XMLIndex</code> index is also picked up for a query that uses multilevel <code>XMLTable</code> chaining. With only the unstructured <code>XMLIndex</code> component, this query too would involve a join of the path table to itself, because of the different paths in the two <code>XMLTable</code> function calls.</p>
<p>The execution plan shows direct access to the relational index content tables, <code>po_idx_tab</code> and <code>po_index_lineitem</code>. There is <span class="italic">no</span> access at all to the path table, <code>path_tab</code>.</p>
<div class="infoboxnotealso" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__GUID-E1B04AF2-C5A0-43D3-9168-7D45819A27BC">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" title="The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a>&#34;</span></p>
</div>
<div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDDJDGI">
<p class="titleinexample">Example 6-24 Checking Whether an XMLIndex Unstructured Component Is Used</p>
<pre dir="ltr">SET AUTOTRACE ON EXPLAIN

SELECT XMLQuery(&#39;/PurchaseOrder/Requestor&#39; PASSING OBJECT_VALUE RETURNING CONTENT) FROM po_binxml
  WHERE XMLExists(&#39;/PurchaseOrder[Reference=&#34;SBELL-2002100912333601PDT&#34;]&#39; PASSING OBJECT_VALUE);
 
XMLQUERY(&#39;/PURCHASEORDER/REQUESTOR&#39;PASSINGOBJECT_VALUERETURNINGCONTENT)
-----------------------------------------------------------------------
&lt;Requestor&gt;Sarah J. Bell&lt;/Requestor&gt;
 
1 row selected.
 
 
Execution Plan
<span class="bold">. . .</span>
----------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name                         | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                              |     1 |    24 |    28   (4)| 00:00:01 |
|   1 |  SORT GROUP BY                  |                              |     1 |  3524 |            |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID   | MY_PATH_TABLE                |     2 |  7048 |     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN             | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |     2   (0)| 00:00:01 |
|   4 |  NESTED LOOPS                   |                              |     1 |    24 |    28   (4)| 00:00:01 |
|   5 |   VIEW                          | VW_SQ_1                      |     1 |    12 |    26   (0)| 00:00:01 |
|   6 |    HASH UNIQUE                  |                              |     1 |  5046 |            |          |
|   7 |     NESTED LOOPS                |                              |     1 |  5046 |    26   (0)| 00:00:01 |
|*  8 |      TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    24   (0)| 00:00:01 |
|*  9 |       INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">VALUE_IX</span> |    73 |       |     1   (0)| 00:00:01 |
|* 10 |      TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |     2   (0)| 00:00:01 |
|* 11 |       INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |     1   (0)| 00:00:01 |
|  12 |   TABLE ACCESS BY USER ROWID    | PO_BINXML                    |     1 |    12 |     1   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(SYS_XMLI_LOC_ISNODE(&#34;SYS_P0&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
   3 - access(&#34;SYS_P0&#34;.&#34;RID&#34;=:B1 AND &#34;SYS_P0&#34;.&#34;<span class="bold">PATHID</span>&#34;=HEXTORAW(&#39;76E2&#39;) )
   8 - filter(&#34;SYS_P4&#34;.&#34;VALUE&#34;=&#39;SBELL-2002100912333601PDT&#39; AND &#34;SYS_P4&#34;.&#34;<span class="bold">PATHID</span>&#34;=HEXTORAW(&#39;4F8C&#39;)  AND
              SYS_XMLI_LOC_ISNODE(&#34;SYS_P4&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
   9 - access(SUBSTRB(&#34;VALUE&#34;,1,1599)=&#39;SBELL-2002100912333601PDT&#39;)
  10 - filter(SYS_XMLI_LOC_ISNODE(&#34;SYS_P2&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
  11 - access(&#34;SYS_P4&#34;.&#34;RID&#34;=&#34;SYS_P2&#34;.&#34;RID&#34; AND &#34;SYS_P2&#34;.&#34;PATHID&#34;=HEXTORAW(&#39;4E36&#39;)  AND
              &#34;SYS_P2&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;&lt;&#34;SYS_P4&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;)
       filter(&#34;SYS_P4&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(&#34;SYS_P2&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;) AND
              <span class="bold">SYS_ORDERKEY_DEPTH</span>(&#34;SYS_P2&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;)+1=<span class="bold">SYS_ORDERKEY_DEPTH</span>(&#34;SYS_P4&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;))
<span class="bold">. . .</span>
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDBCJIG">
<p class="titleinexample">Example 6-25 Obtaining the Name of an XMLIndex Index from Its Path-Table Name</p>
<pre dir="ltr">SELECT INDEX_NAME FROM USER_XML_INDEXES WHERE PATH_TABLE_NAME = &#39;MY_PATH_TABLE&#39;;
 
INDEX_NAME
------------------------------
PO_XMLINDEX_IX
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">
<p class="titleinexample">Example 6-26 Extracting Data from an XML Fragment Using XMLIndex</p>
<pre dir="ltr">SET AUTOTRACE ON EXPLAIN
</pre>
<pre dir="ltr"> 
SELECT li.description, li.itemno
  FROM po_binxml, XMLTable(&#39;/PurchaseOrder/LineItems/LineItem&#39;
                           PASSING OBJECT_VALUE
                           COLUMNS &#34;DESCRIPTION&#34; VARCHAR(40) PATH &#39;Description&#39;,
                                   &#34;ITEMNO&#34;      INTEGER     PATH &#39;@ItemNumber&#39;) li
  WHERE XMLExists(&#39;/PurchaseOrder[Reference=&#34;SBELL-2002100912333601PDT&#34;]&#39;
                  PASSING OBJECT_VALUE);
 
DESCRIPTION                                  ITEMNO
---------------------------------------- ----------
A Night to Remember                               1
The Unbearable Lightness Of Being                 2
Sisters                                           3
 
3 rows selected.
</pre>
<pre dir="ltr">Execution Plan

----------------------------------------------------------------------------------------------------------------
| Id  | Operation                         | Name                         | Rows  | Bytes |Cost (%CPU)| Time    |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |                              |     1 |  1546 |   30   (4)|00:00:01 |
|*  1 |  FILTER                           |                              |       |       |           |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    3   (0)|00:00:01 |
|*  3 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    2   (0)|00:00:01 |
|*  4 |  FILTER                           |                              |       |       |           |         |
|*  5 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    3   (0)|00:00:01 |
|*  6 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    2   (0)|00:00:01 |
|   7 |  NESTED LOOPS                     |                              |       |       |           |         |
|   8 |   NESTED LOOPS                    |                              |     1 |  1546 |   30   (4)|00:00:01 |
|   9 |    NESTED LOOPS                   |                              |     1 |    24 |   28   (4)|00:00:01 |
|  10 |     VIEW                          | VW_SQ_1                      |     1 |    12 |   26   (0)|00:00:01 |
|  11 |      HASH UNIQUE                  |                              |     1 |  5046 |           |         |
|  12 |       NESTED LOOPS                |                              |     1 |  5046 |   26   (0)|00:00:01 |
|* 13 |        TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |   24   (0)|00:00:01 |
|* 14 |         INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">VALUE_IX</span> |    73 |       |    1   (0)|00:00:01 |
|* 15 |        TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |    2   (0)|00:00:01 |
|* 16 |         INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    1   (0)|00:00:01 |
|  17 |     TABLE ACCESS BY USER ROWID    | PO_BINXML                    |     1 |    12 |    1   (0)|00:00:01 |
|* 18 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    1   (0)|00:00:01 |
|* 19 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |    2   (0)|00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter(:B1&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B2))
   2 - filter(SYS_XMLI_LOC_ISNODE(&#34;SYS_P2&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
   3 - access(&#34;SYS_P2&#34;.&#34;RID&#34;=:B1 AND &#34;SYS_P2&#34;.&#34;<span class="bold">PATHID</span>&#34;=HEXTORAW(&#39;28EC&#39;)  AND &#34;SYS_P2&#34;.&#34;ORDER_KEY&#34;&gt;:B2 AND
              &#34;SYS_P2&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B3))
       filter(<span class="bold">SYS_ORDERKEY_DEPTH</span>(&#34;SYS_P2&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;)=<span class="bold">SYS_ORDERKEY_DEPTH</span>(:B1)+1)
   4 - filter(:B1&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B2))
   5 - filter(SYS_XMLI_LOC_ISNODE(&#34;SYS_P5&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
   6 - access(&#34;SYS_P5&#34;.&#34;RID&#34;=:B1 AND &#34;SYS_P5&#34;.&#34;<span class="bold">PATHID</span>&#34;=HEXTORAW(&#39;60E0&#39;)  AND &#34;SYS_P5&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;&gt;:B2 AND
              &#34;SYS_P5&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B3))
       filter(<span class="bold">SYS_ORDERKEY_DEPTH</span>(&#34;SYS_P5&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;)=<span class="bold">SYS_ORDERKEY_DEPTH</span>(:B1)+1)
  13 - filter(&#34;SYS_P10&#34;.&#34;VALUE&#34;=&#39;SBELL-2002100912333601PDT&#39; AND &#34;SYS_P10&#34;.&#34;<span class="bold">PATHID</span>&#34;=HEXTORAW(&#39;4F8C&#39;)  AND
              SYS_XMLI_LOC_ISNODE(&#34;SYS_P10&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
  14 - access(SUBSTRB(&#34;VALUE&#34;,1,1599)=&#39;SBELL-2002100912333601PDT&#39;)
  15 - filter(SYS_XMLI_LOC_ISNODE(&#34;SYS_P8&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
  16 - access(&#34;SYS_P10&#34;.&#34;RID&#34;=&#34;SYS_P8&#34;.&#34;RID&#34; AND &#34;SYS_P8&#34;.&#34;<span class="bold">PATHID</span>&#34;=HEXTORAW(&#39;4E36&#39;)  AND
              &#34;SYS_P8&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;&lt;&#34;SYS_P10&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;)
       filter(&#34;SYS_P10&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(&#34;SYS_P8&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;) AND
              <span class="bold">SYS_ORDERKEY_DEPTH</span>(&#34;SYS_P8&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;)+1=<span class="bold">SYS_ORDERKEY_DEPTH</span>(&#34;SYS_P10&#34;.&#34;<span class="bold">ORDER_KEY</span>&#34;))
  18 - access(&#34;PO_BINXML&#34;.ROWID=&#34;SYS_ALIAS_4&#34;.&#34;RID&#34; AND &#34;SYS_ALIAS_4&#34;.&#34;<span class="bold">PATHID</span>&#34;=HEXTORAW(&#39;3748&#39;) )
  19 - filter(SYS_XMLI_LOC_ISNODE(&#34;SYS_ALIAS_4&#34;.&#34;<span class="bold">LOCATOR</span>&#34;)=1)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">
<p class="titleinexample">Example 6-27 Using a Structured XMLIndex Component for a Query with Two Predicates</p>
<pre dir="ltr">EXPLAIN PLAN FOR
  SELECT XMLQuery(&#39;/PurchaseOrder/LineItems/LineItem&#39;
                  PASSING OBJECT_VALUE RETURNING CONTENT)
    FROM po_binxml
    WHERE XMLExists(&#39;/PurchaseOrder/LineItems/LineItem
                     [Description contains text &#34;Picnic&#34;]&#39;
                    PASSING OBJECT_VALUE)
      AND XMLExists(&#39;/PurchaseOrder[User=&#34;SBELL&#34;]&#39; PASSING OBJECT_VALUE);
 
Explained.
 
</pre>
<pre dir="ltr">----------------------------------------------------------------------------------------------------------------
| Id  | Operation                            | Name                         |Rows|Bytes| Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |                              |   1| 2051|     9   (0)| 00:00:01 |
|   1 |  SORT GROUP BY                       |                              |   1| 3524|            |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID BATCHED| <span class="bold">PATH_TAB</span>                     |   2| 7048|     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN                  | SYS86751_PO_XMLINDE_PIKEY_IX |   1|     |     2   (0)| 00:00:01 |
|   4 |  NESTED LOOPS SEMI                   |                              |   1| 2051|     6   (0)| 00:00:01 |
|   5 |   TABLE ACCESS BY INDEX ROWID        | PO_BINXML                    |   1| 2024|     4   (0)| 00:00:01 |
|*  6 |    DOMAIN INDEX                      | <span class="bold">PO_CTX_IDX</span>                   |    |     |     4   (0)| 00:00:01 |
|*  7 |   TABLE ACCESS BY INDEX ROWID BATCHED| <span class="bold">PO_IDX_TAB</span>                   |  13|  351|     2   (0)| 00:00:01 |
|*  8 |    INDEX RANGE SCAN                  | SYS86751_86755_OID_IDX       |   1|     |     1   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(SYS_XMLI_LOC_ISNODE(&#34;SYS_P1&#34;.&#34;LOCATOR&#34;)=1)
   3 - access(&#34;SYS_P1&#34;.&#34;RID&#34;=:B1 AND &#34;SYS_P1&#34;.&#34;PATHID&#34;=HEXTORAW(&#39;3748&#39;) )
   6 - access(&#34;CTXSYS&#34;.&#34;CONTAINS&#34;(SYS_MAKEXML(0,&#34;XMLDATA&#34;),&#39;&lt;query&gt;&lt;textquery grammar=&#34;CONTEXT&#34;
              lang=&#34;english&#34;&gt;{Picnic} INPATH
              (/PurchaseOrder/LineItems/LineItem/Description)&lt;/textquery&gt;&lt;xquery&gt;&lt;offset&gt;0&lt;/
              offset&gt;&lt;/xquery&gt;&lt;/query&gt;&#39;)&gt;0)
   7 - filter(&#34;SYS_SXI_0&#34;.&#34;USERNAME&#34;=&#39;SBELL&#39;)
   8 - access(&#34;PO_BINXML&#34;.&#34;SYS_NC_OID$&#34;=&#34;SYS_SXI_0&#34;.&#34;OID&#34;)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
 
30 rows selected.
</pre>
<pre dir="ltr"></pre>
<pre dir="ltr"> 
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGJEDEA">
<p class="titleinexample">Example 6-28 Using a Structured XMLIndex Component for a Query with Multilevel Chaining</p>
<pre dir="ltr">EXPLAIN PLAN FOR
  SELECT po.reference, li.*
    FROM po_binxml p,
         XMLTable(&#39;/PurchaseOrder&#39; PASSING p.OBJECT_VALUE
                  COLUMNS reference   VARCHAR2(30)  PATH &#39;Reference&#39;,
                          lineitem    XMLType       PATH &#39;LineItems/LineItem&#39;) po,
         XMLTable(&#39;/LineItem&#39; PASSING po.lineitem
                  COLUMNS itemno      BINARY_DOUBLE PATH &#39;@ItemNumber&#39;,
                          description VARCHAR2(256) PATH &#39;Description&#39;,
                          partno      VARCHAR2(14)  PATH &#39;Part/@Id&#39;,
                          quantity    BINARY_DOUBLE PATH &#39;Part/@Quantity&#39;,
                          unitprice   BINARY_DOUBLE PATH &#39;Part/@UnitPrice&#39;) li
    WHERE po.reference = &#39;SBELL-20021009123335280PDT&#39;;
 
</pre>
<pre dir="ltr">-------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name                   | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                        |    17 | 20366 |     8   (0)| 00:00:01 |
|   1 |  NESTED LOOPS                |                        |       |       |            |          |
|   2 |   NESTED LOOPS               |                        |    17 | 20366 |     8   (0)| 00:00:01 |
|   3 |    NESTED LOOPS              |                        |     1 |   539 |     3   (0)| 00:00:01 |
|*  4 |     TABLE ACCESS FULL        | <span class="bold">PO_IDX_TAB</span>             |     1 |   529 |     3   (0)| 00:00:01 |
|*  5 |     INDEX UNIQUE SCAN        | SYS_C007442            |     1 |    10 |     0   (0)| 00:00:01 |
|*  6 |    INDEX RANGE SCAN          | SYS86751_86759_PKY_IDX |    17 |       |     1   (0)| 00:00:01 |
|   7 |   TABLE ACCESS BY INDEX ROWID| <span class="bold">PO_INDEX_LINEITEM</span>      |    17 | 11203 |     5   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - filter(&#34;SYS_SXI_2&#34;.&#34;REFERENCE&#34;=&#39;SBELL-20021009123335280PDT&#39;)
   5 - access(&#34;P&#34;.&#34;SYS_NC_OID$&#34;=&#34;SYS_SXI_2&#34;.&#34;OID&#34;)
   6 - access(&#34;SYS_SXI_2&#34;.&#34;KEY&#34;=&#34;SYS_SXI_3&#34;.&#34;PKEY&#34;)
 
Note
-----
   - dynamic sampling used for this statement
 
25 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4379"></a><a id="ADXDB4378"></a>
<div class="props_rev_3"><a id="GUID-572DB598-0A31-4143-889B-98D883211FC6"></a>
<h3 id="ADXDB-GUID-572DB598-0A31-4143-889B-98D883211FC6" class="sect3"><span class="enumeration_section">6.3.9</span> Turning Off Use of XMLIndex</h3>
<div>
<p>You can turn off the use of <code>XMLIndex</code> by using optimizer hint: <code>/*+ NO_XML_QUERY_REWRITE */</code> or optimizer hint <code>/*+ NO_XMLINDEX_REWRITE */</code>.</p>
<div class="section">
<p>Each of these hints turns off the use of <span class="italic">all</span> <code>XMLIndex</code> indexes. In addition to turning off the use of <code>XMLIndex</code>, <code>NO_XML_QUERY_REWRITE</code> turns off all XQuery optimization (<code>XMLIndex</code> is part of XPath rewrite).</p>
<p><a href="xdb_indexing.htm#GUID-572DB598-0A31-4143-889B-98D883211FC6__CHDBJFGE">Example 6-29</a> shows the use of these optimizer hints.</p>
<div class="infobox-note" id="GUID-572DB598-0A31-4143-889B-98D883211FC6__GUID-2D3954A8-2FC9-476C-B405-525E36C71E8A">
<p class="notep1">Note:</p>
<p>The <code>NO_INDEX</code> optimizer hint does not apply to <code>XMLIndex</code>.</p>
</div>
<div class="infoboxnotealso" id="GUID-572DB598-0A31-4143-889B-98D883211FC6__GUID-E5938908-5F06-474D-BC76-9F29CF512045">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E" title="The optional XQuery features that are not supported by Oracle XML&nbsp;DB are specified.">XQuery Optional Features</a>&#34;</span> for information about XQuery pragmas <a id="d38232e6428" class="indexterm-anchor"></a><a id="d38232e6430" class="indexterm-anchor"></a><code>ora:no_xmlquery_rewrite</code> and <code>ora:xmlquery_rewrite</code>, which you can use for fine-grained control of XQuery optimization</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-572DB598-0A31-4143-889B-98D883211FC6__CHDBJFGE">
<p class="titleinexample">Example 6-29 Turning Off XMLIndex Using Optimizer Hints</p>
<pre dir="ltr">SELECT <span class="bold">/*+ NO_XMLINDEX_REWRITE */</span> 
  count(*) FROM po_binxml WHERE XMLExists(&#39;$p/*&#39; PASSING OBJECT_VALUE AS &#34;p&#34;);

SELECT <span class="bold">/*+ NO_XML_QUERY_REWRITE */</span>
  count(*) FROM po_binxml WHERE XMLExists(&#39;$p/*&#39; PASSING OBJECT_VALUE AS &#34;p&#34;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4380"></a>
<div class="props_rev_3"><a id="GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8"></a>
<h3 id="ADXDB-GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" class="sect3"><span class="enumeration_section">6.3.10</span> XMLIndex Path Subsetting: Specifying the Paths You Want to Index</h3>
<div>
<p>If you know which XPath expressions you are most likely to query then you can narrow the focus of <code>XMLIndex</code> indexing and thus improve performance.</p>
<div class="section">
<p>One of the advantages of an <code>XMLIndex</code> index with an unstructured component is that it is very general: you need not specify which XPath locations to index; you need no prior knowledge of the XPath expressions that will be queried. By default, an unstructured <code>XMLIndex</code> component indexes all possible XPath locations in your XML data.</p>
<p>However, if you are aware of the XPath expressions that you are most likely to query, then you can narrow the focus of <code>XMLIndex</code> indexing and thus improve performance. Having fewer indexed nodes means less space is required for indexing, which improves index maintenance during DML operations. Having fewer indexed nodes improves DDL performance, and having a smaller path table improves query performance.</p>
<p>You narrow the focus of indexing by pruning the set of XPath expressions (paths) corresponding to XML fragments to be indexed, specifying a subset of all possible paths. You can do this in two alternative ways:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Exclusion &ndash; Start with the default behavior of including all possible XPath expressions, and exclude some of them from indexing.</p>
</li>
<li>
<p>Inclusion &ndash; Start with an empty set of XPath expressions to be used in indexing, and add paths to this inclusion set.</p>
</li>
</ul>
<p>You can specify path subsetting either when you create an <code>XMLIndex</code> index using <code>CREATE INDEX</code> or when you modify it using <code>ALTER INDEX</code>. In both cases, you provide the subsetting information in the <code>PATHS</code> parameter of the statement&#39;s <code>PARAMETERS</code> clause. For exclusion, you use keyword <code>EXCLUDE</code>. For inclusion, you use keyword <code>INCLUDE</code> for <code>ALTER INDEX</code> and no keyword for <code>CREATE INDEX</code> (list the paths to include). You can also specify namespace mappings for the nodes targeted by the <code>PATHS</code> parameter.</p>
<p>For <code>ALTER INDEX</code>, keyword <code>INCLUDE</code> or <code>EXCLUDE</code> is followed by keyword <code>ADD</code> or <code>REMOVE</code>, to indicate whether the list of paths that follows the keyword is to be added or removed from the inclusion or exclusion list. For example, this statement adds path <code>/PurchaseOrder/Reference</code> to the list of paths to be excluded from indexing:</p>
<pre dir="ltr">ALTER INDEX po_xmlindex_ix REBUILD
  PARAMETERS (&#39;PATHS (<span class="bold">EXCLUDE ADD</span> (/PurchaseOrder/Reference))&#39;);
</pre>
<p>To alter an <code>XMLIndex</code> index so that it <span class="italic">includes all</span> possible paths, use keyword <code>INDEX_ALL_PATHS</code>. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFAECD">alter_index_paths_clause ::=</a>&#34;</span>.</p>
<div class="infobox-note" id="GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8__GUID-935A6ECE-04FD-4C8F-B3D1-BAF2C47FE4C4">
<p class="notep1">Note:</p>
<p>If you create an <code>XMLIndex</code> index that has both structured and unstructured components, then, by default, any nodes indexed in the structured component are also indexed in the unstructured component; that is, they are <span class="italic">not</span> automatically <span class="italic">excluded</span> from the unstructured component. If you do not want unstructured <code>XMLIndex</code> indexing to apply to them, then you must explicitly use path subsetting to exclude them.</p>
</div>
<div class="infoboxnotealso" id="GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8__GUID-5CD25483-ECE8-41AE-8D45-379BB4B19EC9">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a>&#34;</span> for the syntax of the <code>PARAMETERS</code> clause</p>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDB4382"></a><a id="ADXDB4383"></a><a id="ADXDB4384"></a><a id="ADXDB4381"></a>
<div class="props_rev_3"><a id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC"></a>
<h4 id="ADXDB-GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC" class="sect4"><span class="enumeration_section">6.3.10.1</span> Examples of XMLIndex Path Subsetting</h4>
<div>
<p>Some examples are presented of defining <code>XMLIndex</code> indexes on subsets of XPath expressions.</p>
<div class="section"></div>
<!-- class="section" -->
<div class="example" id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDIHICC">
<p class="titleinexample">Example 6-30 XMLIndex Path Subsetting with CREATE INDEX</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS (&#39;PATHS (INCLUDE (/PurchaseOrder/LineItems//* 
                               /PurchaseOrder/Reference))&#39;);
</pre>
<p>This statement creates an index that indexes only top-level element <code>PurchaseOrder</code> and some of its children, as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>All <code>LineItems</code> elements and their descendants</p>
</li>
<li>
<p>All <code>Reference</code> elements</p>
</li>
</ul>
<p>It does that by including the specified paths, starting with an empty set of paths to be used for the index.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__GUID-E04EB35A-D17B-498B-8017-D15482134C69">
<p class="titleinexample">Example 6-31 XMLIndex Path Subsetting with ALTER INDEX</p>
<pre dir="ltr">ALTER INDEX po_xmlindex_ix REBUILD
  PARAMETERS (&#39;PATHS (INCLUDE ADD (/PurchaseOrder/Requestor 
                                   /PurchaseOrder/Actions/Action//*))&#39;);
</pre>
<p>This statement adds two more paths to those used for indexing. These paths index element <code>Requestor</code> and descendants of element <code>Action</code> (and their ancestors).</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDJEICC">
<p class="titleinexample">Example 6-32 XMLIndex Path Subsetting Using a Namespace Prefix</p>
<p>If an XPath expression to be used for <code>XMLIndex</code> indexing uses namespace prefixes, you can use a <code>NAMESPACE MAPPING</code> clause to the <code>PATHS</code> list, to specify those prefixes. Here is an example:</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS (&#39;PATHS (INCLUDE (/PurchaseOrder/LineItems//*   /PurchaseOrder/<span class="bold">ipo:</span>Reference)
                     NAMESPACE MAPPING (xmlns=&#34;http://xmlns.oracle.com&#34;
                                        xmlns:<span class="bold">ipo</span>=&#34;http://xmlns.oracle.com/ipo&#34;))&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4385"></a>
<div class="props_rev_3"><a id="GUID-24CE95A6-9C40-4DC0-BE58-E2B33C996BC6"></a>
<h4 id="ADXDB-GUID-24CE95A6-9C40-4DC0-BE58-E2B33C996BC6" class="sect4"><span class="enumeration_section">6.3.10.2</span> XMLIndex Path-Subsetting Rules</h4>
<div>
<p>Rules that apply to <code>XMLIndex</code> path subsetting are described.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The paths must reference only child and descendant axes, and they must test only element and attribute nodes or their names (possibly using wildcards). In particular, the paths must not involve predicates.</p>
</li>
<li>
<p>You cannot specify both path exclusion and path inclusion; choose one or the other.</p>
</li>
<li>
<p>If an index was created using path exclusion (inclusion), then you can modify it using only path exclusion (inclusion)&thinsp;&mdash;&thinsp;index modification must either further restrict or further extend the path subset. For example, you cannot create an index that includes certain paths and subsequently modify it to exclude certain paths.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB4386"></a>
<div class="props_rev_3"><a id="GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF"></a>
<h3 id="ADXDB-GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF" class="sect3"><span class="enumeration_section">6.3.11</span> Guidelines for Using XMLIndex with an Unstructured Component</h3>
<div>
<p>There are several guidelines that can help you use <code>XMLIndex</code> with an unstructured component.</p>
<p>These guidelines are applicable only when the two alternatives discussed return the same result set.</p>
<ul style="list-style-type: disc;">
<li>
<p>Avoid prefixing <code>//</code> with ancestor elements. For example, use <code>//c</code>, <span class="italic">not</span> <span class="bold"><code>/a/b</code></span><code>//c</code>, provided these return the same result set.</p>
</li>
<li>
<p>Avoid prefixing <code>/*</code> with ancestor elements. For example, use <code>/*/*/*</code>, <span class="italic">not</span> <span class="bold"><code>/a</code></span><code>/*/*</code>, provided these return the same result set.</p>
</li>
<li>
<p>In a <code>WHERE</code> clause, use <code>XMLExists</code> rather than <code>XMLCast</code> of <code>XMLQuery</code>. This can allow optimization that, in effect, invokes a subquery against the path-table <code>VALUE</code> column. For example, use this:</p>
<pre dir="ltr">SELECT count(*) FROM purchaseorder p 
  WHERE 
    XMLExists(&#39;$p/PurchaseOrder/LineItems/LineItem/Part[@Id=&#34;715515011020&#34;]&#39;
                  PASSING OBJECT_VALUE AS &#34;p&#34;);
</pre>
<p>Do not use this:</p>
<pre dir="ltr">SELECT count(*) FROM purchaseorder p
  WHERE XMLCast(XMLQuery(&#39;$p/PurchaseOrder/LineItems/LineItem/Part/@Id&#39;
                         PASSING OBJECT_VALUE AS &#34;p&#34; RETURNING CONTENT)
                AS VARCHAR2(14))
        = &#34;715515011020&#34;;
</pre></li>
<li>
<p>When possible, use <code>count(*)</code>, <span class="italic">not</span> <code>count(XMLCast(XMLQuery(...))</code>, in a <code>SELECT</code> clause. For example, if you know that a <code>LineItem</code> element in a purchase-order document has only one <code>Description</code> child, use this:</p>
<pre dir="ltr">SELECT count(*) FROM po_binxml, XMLTable(&#39;//LineItem&#39; PASSING OBJECT_VALUE);
</pre>
<p>Do not use this:</p>
<pre dir="ltr">SELECT count(li.value)
 FROM po_binxml p, XMLTable(&#39;//LineItem&#39; PASSING p.OBJECT_VALUE
                            COLUMNS value VARCHAR2(30) PATH &#39;Description&#39;) li;
</pre></li>
<li>
<p>Reduce the number of XPath expressions used in a query <code>FROM</code> list as much as possible. For example, use this:</p>
<pre dir="ltr">SELECT li.description
  FROM po_binxml p,
       XMLTable(&#39;PurchaseOrder/LineItems/LineItem&#39; PASSING p.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH &#39;Description&#39;) li;
</pre>
<p>Do not use this:</p>
<pre dir="ltr">SELECT li.description
  FROM po_binxml p,
       XMLTable(&#39;PurchaseOrder/LineItems&#39; PASSING p.OBJECT_VALUE) ls,
       XMLTable(&#39;LineItems/LineItem&#39;      PASSING ls.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH &#39;Description&#39;) li;
</pre></li>
<li>
<p>If you use an XPath expression in a query to drill down inside a virtual table (created, for example, using SQL/XML function <code>XMLTable</code>), then create a secondary index on the order key of the path table using Oracle SQL function <code>sys_orderkey_depth</code>. Here is an example of such a query; the selection navigates to element <code>Description</code> inside virtual line-item table <code>li</code>.</p>
<pre dir="ltr">SELECT li.description
  FROM po_binxml p,
       XMLTable(&#39;PurchaseOrder/LineItems/LineItem&#39; PASSING p.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH &#39;Description&#39;) li;
</pre>
<p>Such queries are evaluated using function <code>sys_orderkey_depth</code>, which returns the depth of the order-key value. Because the order index uses two columns, the index needed is a <span class="italic">composite</span> index over columns <code>ORDER_KEY</code> and <code>RID</code>, as well as over function <code>sys_orderkey_depth</code> applied to the <code>ORDER_KEY</code> value. For example:</p>
<pre dir="ltr">CREATE INDEX depth_ix ON my_path_table
  (RID, sys_orderkey_depth(ORDER_KEY), ORDER_KEY);
</pre>
<div class="infoboxnotealso" id="GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF__GUID-66114AB1-EC95-4DAF-89AF-B96B17694886">
<p class="notep1">See Also:</p>
<p><a href="xdb_indexing.htm#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-26</a> for an example that shows the use of <code>sys_orderkey_depth</code></p>
</div>
</li>
</ul>
</div>
</div>
<a id="ADXDB6001"></a>
<div class="props_rev_3"><a id="GUID-B8FCC742-EE57-4B86-8B61-17CC780A5821"></a>
<h3 id="ADXDB-GUID-B8FCC742-EE57-4B86-8B61-17CC780A5821" class="sect3"><span class="enumeration_section">6.3.12</span> Guidelines for Using XMLIndex with a Structured Component</h3>
<div>
<p>There are several guidelines that can help you use <code>XMLIndex</code> with a structured component.</p>
<ul style="list-style-type: disc;">
<li>
<p>Use <code>XMLIndex</code> with a structured component to project and index XML data as relational columns. Do not use function-based indexes; they are deprecated for use with XML. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" title="In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with XMLType data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of XMLIndex instead.">Function-Based Indexes Are Deprecated for XMLType</a>&#34;</span>.</p>
</li>
<li>
<p>Ensure data type correspondence between a query and an <code>XMLIndex</code> index that has a structured component. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" title="The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).">Data Type Considerations for XMLIndex Structured Component</a>&#34;</span>.</p>
</li>
<li>
<p>If you create a relational view over <code>XMLType</code> data (for example, using SQL function <code>XMLTable</code>), then consider also creating an <code>XMLIndex</code> index with a structured component that targets the same relational columns. See <a href="xdb_rel_views.htm#GUID-420496CE-D62F-4EBE-A76E-861B932AE1E6" title="Relational database views over XML data provide conventional, relational access to XML content.">Relational Views over XML Data</a>.</p>
</li>
<li>
<p>Instead of using a single XQuery expression for both fragment extraction and value filtering (search), use SQL/XML function <code>XMLQuery</code> in the <code>SELECT</code> clause to extract fragments and <code>XMLExists</code> in the <code>WHERE</code> clause to filter values.</p>
<p>This lets Oracle XML DB evaluate fragment extraction functionally or by using streaming evaluation. For value filtering, this lets Oracle XML&nbsp;DB pick up an <code>XMLIndex</code> index that has a relevant structured component.</p>
</li>
<li>
<p>To order query results, use a SQL <code>ORDER BY</code> clause, together with SQL/XML function <code>XMLTable</code>. Avoid using the XQuery <code>order by</code> clause. This is particularly pertinent if you use an <code>XMLIndex</code> index with a structured component.</p>
</li>
</ul>
</div>
</div>
<a id="ADXDB4398"></a><a id="ADXDB4399"></a><a id="ADXDB4397"></a>
<div class="props_rev_3"><a id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652"></a>
<h3 id="ADXDB-GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" class="sect3"><span class="enumeration_section">6.3.13</span> XMLIndex Partitioning and Parallelism</h3>
<div>
<p>If you partition an <code>XMLType</code> table, or a table with an <code>XMLType</code> column, using range, list, or hash partitioning, you can also create an <code>XMLIndex</code> index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.</p>
<div class="section">
<p>To ensure parallel index creation and maintenance, you use a <code>PARALLEL</code> clause (with optional degree) when creating or altering an <code>XMLIndex</code> index.</p>
<p>If you use the keyword <code>LOCAL</code> when you create the <code>XMLIndex</code> index, then the index and all of its storage tables are locally equipartitioned with respect to the base table.</p>
<p>If you do not use the keyword <code>LOCAL</code> then you cannot create an <code>XMLIndex</code> index on a partitioned table. Also, if you composite-partition a table, then you cannot create an <code>XMLIndex</code> index on it.</p>
<p>If you use a <code>PARALLEL</code> clause and the base table is partitioned or enabled for parallelism, then this can improve the performance for both DML operations (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) and index DDL operations (<code>CREATE</code>, <code>ALTER</code>, <code>REBUILD</code>).</p>
<p>Specifying parallelism for an index can also consume more storage, because storage parameters apply separately to each query server process. For example, an index created with an <code>INITIAL</code> value of 5M and a parallelism degree of 12 consumes at least 60M of storage during index creation.</p>
<p>The syntax for the parallelism clause for <code>CREATE INDEX</code> and <code>ALTER INDEX</code> is the same as for other domain indexes:</p>
<pre dir="ltr">{ NOPARALLEL | PARALLEL [ integer ] }
</pre>
<p><a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">Example 6-33</a> creates an <code>XMLIndex</code> index with a parallelism degree of 10. If the base table is partitioned, then this index is equipartitioned.</p>
<p>In <a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">Example 6-33</a>, the path table and the secondary indexes are created with the same parallelism degree as the <code>XMLIndex</code> index itself, 10, by inheritance. You can specify different parallelism degrees for these by using separate <code>PARALLEL</code> clauses. <a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">Example 6-34</a> demonstrates this. Again, because of keyword <code>LOCAL</code>, if the base table is partitioned, then this index is equipartitioned.</p>
<p>In <a href="xdb_indexing.htm#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">Example 6-34</a>, the <code>XMLIndex</code> index itself is created serially, because of <code>NOPARALLEL</code>. The secondary index <code>po_pikey_ix</code> is also populated serially, because no parallelism is specified explicitly for it; it inherits the parallelism of the <code>XMLIndex</code> index. The path table itself is created with a parallelism degree of 10, and the secondary index value column, <code>po_value_ix</code>, is populated with a degree of 5, due to their explicit parallelism specifications.</p>
<p>Any parallelism you specify for an <code>XMLIndex</code> index, its path table, or its secondary indexes is exploited during subsequent DML operations and queries.</p>
<p>Note that there are two places where you can specify parallelism for <code>XMLIndex</code>: within the <code>PARAMETERS</code> clause parenthetical expression and after it.</p>
<div class="infoboxnotealso" id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__GUID-434DFE6A-FEF3-4AFA-A30F-A53567954909">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF01209" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF01209"><span class="italic">Oracle Database SQL Language Reference</span></a> for information on the <code>CREATE INDEX</code> parallel clause</p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a>&#34;</span> for the syntax of the <code>PARAMETERS</code> clause</p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9" title="XMLIndex is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to XMLType data that is stored as binary XML.">Structured and Unstructured XMLIndex Components</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">
<p class="titleinexample">Example 6-33 Creating an XMLIndex Index in Parallel</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON sale_info (sale_po_clob) INDEXTYPE IS XDB.XMLIndex 
 <span class="bold"> LOCAL PARALLEL 10</span>;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">
<p class="titleinexample">Example 6-34 Using Different PARALLEL Degrees for XMLIndex Internal Objects</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON sale_info (sale_po_clob) INDEXTYPE IS XDB.XMLIndex 
  LOCAL <span class="bold">NOPARALLEL</span> PARAMETERS (&#39;PATH TABLE po_path_table <span class="bold">(PARALLEL 10)</span>
                                PIKEY INDEX po_pikey_ix
                                VALUE INDEX po_value_ix <span class="bold">(PARALLEL 5)</span>&#39;);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4401"></a><a id="ADXDB4402"></a><a id="ADXDB4403"></a><a id="ADXDB4400"></a>
<div class="props_rev_3"><a id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940"></a>
<h3 id="ADXDB-GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" class="sect3"><span class="enumeration_section">6.3.14</span> Asynchronous (Deferred) Maintenance of XMLIndex Indexes</h3>
<div>
<p>You can defer the cost of maintaining an <code>XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.</p>
<p>This feature applies to an <code>XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component. If you specify asynchronous maintenance for an <code>XMLIndex</code> index that has a <span class="italic">structured</span> component (even if it also has an unstructured component), then an error is raised.</p>
<p>By default, <code>XMLIndex</code> indexing is updated (maintained) at each DML operation, so that it remains in sync with the base table. In some situations, you might not require this, and using possibly stale indexes might be acceptable. In that use case, you can decide to defer the cost of index maintenance, performing at commit time only or at some time when database load is reduced. This can improve DML performance. It can also improve index maintenance performance by enabling bulk loading of unsynchronized index rows when an index is synchronized.</p>
<p>Using a stale index has no effect, other than performance, on DML operations. It can have an effect on query results, however: If the index is not up-to-date at query time, then the query results might not be up-to-date either. Even if only one column of a base table is of data type <code>XMLType</code>, all queries on that table reflect the database data as of the last synchronization of the <code>XMLIndex</code> index on the <code>XMLType</code> column.</p>
<p>You can specify index maintenance deferment using the parameters clause of a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement.</p>
<p>Be aware that even if you defer synchronization for an <code>XMLIndex</code> index, the following database operations automatically synchronize the index:</p>
<ul style="list-style-type: disc;">
<li>
<p>Any DDL operation on the index &ndash; <code>ALTER INDEX</code> or creation of secondary indexes</p>
</li>
<li>
<p>Any DDL operation on the base table &ndash; <code>ALTER TABLE</code> or creation of another index</p>
</li>
</ul>
<p><a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBEJGA" title="Index Synchronization">Table 6-7</a> lists the synchronization options and the <code>ASYNC</code> clause syntax you use to specify them. The <code>ASYNC</code> clause is used in the <code>PARAMETERS</code> clause of a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement for <code>XMLIndex</code>.</p>
<div class="tblformal" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBEJGA">
<p class="titleintable">Table 6-7 Index Synchronization</p>
<table class="cellalignment3420" title="Index Synchronization" summary="Index Synchronization">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3510" id="d38232e7407">When to Synchronize</th>
<th class="cellalignment3511" id="d38232e7410">ASYNC Clause Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3512" id="d38232e7415" headers="d38232e7407">
<p>Always</p>
</td>
<td class="cellalignment3513" headers="d38232e7415 d38232e7410">
<p><code>ASYNC (SYNC ALWAYS)</code></p>
<p>This is the default behavior. You can specify it explicitly, to cancel a previous <code>ASYNC</code> specification.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3512" id="d38232e7428" headers="d38232e7407">
<p>Upon commit</p>
</td>
<td class="cellalignment3513" headers="d38232e7428 d38232e7410">
<p><code>ASYNC (SYNC ON COMMIT)</code></p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3512" id="d38232e7436" headers="d38232e7407">
<p>Periodically</p>
</td>
<td class="cellalignment3513" headers="d38232e7436 d38232e7410">
<p><code>ASYNC (SYNC EVERY &#34;</code><span class="italic"><code>repeat_interval</code></span><code>&#34;)</code></p>
<p><span class="italic"><code>repeat_interval</code></span> is the same as for the calendaring syntax of <code>DBMS_SCHEDULER</code></p>
<p>To use <code>EVERY</code>, you must have the <code>CREATE JOB</code> privilege.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3512" id="d38232e7464" headers="d38232e7407">
<p>Manually, on demand</p>
</td>
<td class="cellalignment3513" headers="d38232e7464 d38232e7410">
<p><code>ASYNC (SYNC MANUAL)</code></p>
<p>You can manually synchronize the index using PL/SQL procedure <code>DBMS_XMLINDEX.syncIndex</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Optional <code>ASYNC</code> syntax parameter <code>STALE</code> is intended for possible future use; you need never specify it explicitly. It has value <code>FALSE</code> whenever <code>ALWAYS</code> is used; otherwise it has value <code>TRUE</code>. Specifying an explicit <code>STALE</code> value that contradicts this rule raises an error.</p>
<p><a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">Example 6-35</a> creates an XMLIndex index that is synchronized every Monday at 3:00 pm, starting tomorrow.</p>
<p><a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDHIGIA">Example 6-36</a> manually synchronizes the index created in <a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">Example 6-35</a>.</p>
<p>When <code>XMLIndex</code> index synchronization is deferred, all DML changes (inserts, updates, and deletions) made to the base table since the last index synchronization are recorded in a pending table, one row per DML operation. The name of this table is the value of column <code>PEND_TABLE_NAME</code> of static public views <code>USER_XML_INDEXES</code>, <code>ALL_XML_INDEXES</code>, and <code>DBA_XML_INDEXES</code>.</p>
<p>You can examine this table to determine when synchronization might be appropriate for a given <code>XMLIndex</code> index. The more rows there are in the pending table, the more the index is likely to be in need of synchronization.</p>
<p>If the pending table is large, then setting parameter <code>REINDEX</code> to <code>TRUE</code> when calling <code>syncIndex</code>, as in <a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDHIGIA">Example 6-36</a>, can improve performance. When <code>REINDEX</code> is <code>TRUE</code>, all of the secondary indexes are dropped and then re-created after the pending table data is bulk-loaded.</p>
<div class="infoboxnotealso" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__GUID-7C45F753-2BB1-4B19-9213-0ED93CA2A212">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ARPLS72263" target="_blank" href="../ARPLS/d_sched.htm#ARPLS72263"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>, section &#34;Calendaring Syntax&#34;, for the syntax of <span class="italic"><code>repeat_interval</code></span></p>
</li>
<li>
<p><a class="olink ARPLS212" target="_blank" href="../ARPLS/d_xmlindex.htm#ARPLS212"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information on PL/SQL procedure <code>DBMS_XMLINDEX.syncIndex</code></p>
</li>
</ul>
</div>
<div class="example" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">
<p class="titleinexample">Example 6-35 Specifying Deferred Synchronization for XMLIndex</p>
<pre dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS (&#39;<span class="bold">ASYNC (SYNC EVERY &#34;FREQ=HOURLY; INTERVAL = 1&#34;)</span>&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDHIGIA">
<p class="titleinexample">Example 6-36 Manually Synchronizing an XMLIndex Index Using SYNCINDEX</p>
<pre dir="ltr">EXEC DBMS_XMLINDEX.syncIndex(&#39;OE&#39;, &#39;PO_XMLINDEX_IX&#39;, REINDEX =&gt; TRUE);
</pre></div>
<!-- class="example" --></div>
<a id="ADXDB6145"></a>
<div class="props_rev_3"><a id="GUID-1D3627B8-0738-450D-8C6A-BB64F4207A36"></a>
<h4 id="ADXDB-GUID-1D3627B8-0738-450D-8C6A-BB64F4207A36" class="sect4"><span class="enumeration_section">6.3.14.1</span> Syncing an XMLIndex Index in Case of Error ORA-08181</h4>
<div>
<p>If a query raises error ORA-08181, check whether the base <code>XMLType</code> table of the query has an <code>XMLIndex</code> index with an unstructured component. If so, then manually synchronize the <code>XMLIndex</code> index using <code>DBMS_XMLINDEX.syncIndex</code>.</p>
<div class="section">
<p>This applies only if error ORA-08181 is raised in the following situation:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>In a pluggable database, <span class="italic"><code>PDB1</code></span>, you created an <code>XMLType</code> table or column <span class="italic"><code>XTABCOL</code></span>, which you indexed using an <code>XMLIndex</code> index that has an unstructured component.</span></li>
<li><span>You plugged <span class="italic"><code>PDB1</code></span> into a container database.</span></li>
<li><span>You cloned <span class="italic"><code>PDB1</code></span> to a new pluggable database, <span class="italic"><code>PDB2</code></span>.</span></li>
<li><span>Error ORA-08181 is raised when you query <span class="italic"><code>XTABCOL</code></span> in <span class="italic"><code>PDB2</code></span>.</span></li>
</ol>
<div class="section">
<p>If the error is raised even after synchronizing then seek another cause. Error ORA-08181 is a general error that can be raised in various situations, of which this is only one.</p>
<div class="infoboxnotealso" id="GUID-1D3627B8-0738-450D-8C6A-BB64F4207A36__GUID-3E4655FD-4C3D-484C-988C-507054B26C34">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="appaman.htm#GUID-C6C0EC34-29F6-47F5-B7A7-88F315403DC9" title="Each pluggable database has its own Oracle XML&nbsp;DB Repository, and its own Oracle XML&nbsp;DB configuration file, xdbconfig.xml.">Oracle XML&nbsp;DB and Database Consolidation</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB4405"></a><a id="ADXDB4404"></a>
<div class="props_rev_3"><a id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC"></a>
<h3 id="ADXDB-GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" class="sect3"><span class="enumeration_section">6.3.15</span> Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</h3>
<div>
<p>The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.</p>
<div class="section">
<div class="infobox-note" id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__GUID-94855574-E935-4AB8-86C9-2404F19971CA">
<p class="notep1">Note:</p>
<p>The following applies only to procedures in package <code>DBMS_STATS</code>; it does not apply to <code>ANALYZE INDEX</code>.</p>
</div>
<p>For <code>XMLIndex</code>, you normally need to collect statistics on only the base table on which the <code>XMLIndex</code> index is defined (using, for example, procedure <code>DBMS_STATS.gather_table_stats</code>). This automatically collects statistics for the <code>XMLIndex</code> index itself, as well as the path table, its secondary indexes, and any structured component content tables and their secondary indexes.</p>
<p>If you delete statistics on the base table (using procedure <code>DBMS_STATS.delete_table_stats</code>), then statistics on the other objects are also deleted. Similarly, if you collect statistics on the <code>XMLIndex</code> index (using procedure <code>DBMS_STATS.gather_index_stats</code>), then statistics are also collected on the path table, its secondary indexes, and any structured component content tables and their secondary indexes.</p>
<p><a href="xdb_indexing.htm#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__CHDEHFDF">Example 6-37</a> collects statistics on the base table <code>po_binxml</code>. Statistics are automatically collected on the <code>XMLIndex</code> index, its path table, and the secondary path-table indexes.</p>
<div class="infoboxnotealso" id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__GUID-1CD47A36-B877-42DF-A8CA-3A96DE8B0D67">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-486E91AE-9FE0-489A-A035-AF320D04350B" title="Information about the standard database indexes is available in static public views USER_INDEXES, ALL_INDEXES, and DBA_INDEXES. Similar information about XMLIndex indexes is available in static public views USER_XML_INDEXES, ALL_XML_INDEXES, and DBA_XML_INDEXES.">Data Dictionary Static Public Views Related to XMLIndex</a>&#34;</span> for information about database views that record statistics information for an <code>XMLIndex</code> index</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__CHDEHFDF">
<p class="titleinexample">Example 6-37 Automatic Collection of Statistics on XMLIndex Objects</p>
<pre dir="ltr">CALL DBMS_STATS.gather_table_stats(USER, &#39;PO_BINXML&#39;, ESTIMATE_PERCENT =&gt; NULL);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4335"></a><a id="ADXDB4334"></a>
<div class="props_rev_3"><a id="GUID-486E91AE-9FE0-489A-A035-AF320D04350B"></a>
<h3 id="ADXDB-GUID-486E91AE-9FE0-489A-A035-AF320D04350B" class="sect3"><span class="enumeration_section">6.3.16</span> Data Dictionary Static Public Views Related to XMLIndex</h3>
<div>
<p>Information about the standard database indexes is available in static public views <code>USER_INDEXES</code>, <code>ALL_INDEXES</code>, and <code>DBA_INDEXES</code>. Similar information about <code>XMLIndex</code> indexes is available in static public views <code>USER_XML_INDEXES</code>, <code>ALL_XML_INDEXES</code>, and <code>DBA_XML_INDEXES</code>.</p>
<div class="section">
<p><a href="xdb_indexing.htm#GUID-486E91AE-9FE0-489A-A035-AF320D04350B__CHDGHHAB" title="XMLIndex Public Views">Table 6-8</a> describes the columns in each of these views.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-486E91AE-9FE0-489A-A035-AF320D04350B__CHDGHHAB">
<p class="titleintable">Table 6-8 XMLIndex Static Public Views</p>
<table class="cellalignment3420" title="XMLIndex Static Public Views" summary="XMLIndex Public Views">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3474" id="d38232e7864">Column Name</th>
<th class="cellalignment3454" id="d38232e7867">Type</th>
<th class="cellalignment3552" id="d38232e7870">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e7875" headers="d38232e7864">
<p><code>ASYNC</code></p>
</td>
<td class="cellalignment3458" headers="d38232e7875 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e7875 d38232e7870">
<p>Asynchronous index updating specification. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a>&#34;</span>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e7904" headers="d38232e7864">
<p><code>EX_OR_INCLUDE</code></p>
</td>
<td class="cellalignment3458" headers="d38232e7904 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e7904 d38232e7870">
<p>Path subsetting:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>FULLY_IX</code> &ndash; The index uses no path subsetting.</p>
</li>
<li>
<p><code>EXCLUDE</code> &ndash; The index uses only exclusion subsetting.</p>
</li>
<li>
<p><code>INCLUDE</code> &ndash; The index uses only inclusion subsetting.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e7933" headers="d38232e7864">
<p><code>INDEX_NAME</code></p>
</td>
<td class="cellalignment3458" headers="d38232e7933 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e7933 d38232e7870">
<p>Name of the <code>XMLIndex</code> index.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e7948" headers="d38232e7864">
<p><code>INDEX_OWNER</code></p>
</td>
<td class="cellalignment3458" headers="d38232e7948 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e7948 d38232e7870">
<p>Owner of the index. Not available for <code>USER_XML_INDEXES</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e7963" headers="d38232e7864">
<p><code>INDEX_TYPE</code></p>
</td>
<td class="cellalignment3458" headers="d38232e7963 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e7963 d38232e7870">
<p>The types of components the index is composed of: <code>STRUCTURED</code>, <code>UNSTRUCTURED</code>, or <code>STRUCTURED AND UNSTRUCTURED</code>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e7984" headers="d38232e7864">
<p><code>PARAMETERS</code></p>
</td>
<td class="cellalignment3458" headers="d38232e7984 d38232e7867">
<p><code>XMLType</code></p>
</td>
<td class="cellalignment3553" headers="d38232e7984 d38232e7870">
<p>Information from the <code>PARAMETERS</code> clause that was used to create the index.</p>
<p>If an unstructured <code>XMLIndex</code> component is present, the <code>PARAMETERS</code> clause can include the set of XPath paths defining path-subsetting and the name of a scheduler job for synchronization.</p>
<p>If a structured component is present, the <code>PARAMETERS</code> clause includes the name of the structure group and the table definitions provided by <code>XMLTable</code>, including the XQuery expressions that define the columns.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e8015" headers="d38232e7864">
<p><code>PATH_TABLE_NAME</code></p>
</td>
<td class="cellalignment3458" headers="d38232e8015 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e8015 d38232e7870">
<p>Name of the <code>XMLIndex</code> path table.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e8030" headers="d38232e7864">
<p><code>PEND_TABLE_NAME</code></p>
</td>
<td class="cellalignment3458" headers="d38232e8030 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e8030 d38232e7870">
<p>Name of the table that records base-table DML operations since the last index synchronization. See <span class="q">&#34;<a href="xdb_indexing.htm#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a>&#34;</span>.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e8059" headers="d38232e7864">
<p><code>TABLE_NAME</code></p>
</td>
<td class="cellalignment3458" headers="d38232e8059 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e8059 d38232e7870">
<p>Name of the base table on which the index is defined.</p>
</td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3477" id="d38232e8071" headers="d38232e7864">
<p><code>TABLE_OWNER</code></p>
</td>
<td class="cellalignment3458" headers="d38232e8071 d38232e7867">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment3553" headers="d38232e8071 d38232e7870">
<p>Owner of the base table on which the index is defined.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p>These views provide information about an <code>XMLIndex</code> index, but there is no single static data dictionary view that provides information about the statistics gathered for an <code>XMLIndex</code> index. This statistics information is distributed among the following views:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>USER_INDEXES</code>, <code>ALL_INDEXES</code>, <code>DBA_INDEXES</code> &ndash; Column <code>LAST_ANALYZED</code> provides the date when the <code>XMLIndex</code> index was last analyzed.</p>
</li>
<li>
<p><code>USER_TAB_STATISTICS</code>, <code>ALL_TAB_STATISTICS</code>, <code>DBA_TAB_STATISTICS</code> &ndash; Column <code>TABLE_NAME</code> provides information about the structured and unstructured components of an <code>XMLIndex</code> index. For information about the structured or unstructured component, query using the name of the path table or the <code>XMLTable</code> table as <code>TABLE_NAME</code>, respectively.</p>
</li>
<li>
<p><code>USER_IND_STATISTICS</code>, <code>ALL_IND_STATISTICS</code>, <code>DBA_IND_STATISTICS</code> &ndash; Column <code>INDEX_NAME</code> provides information about each of the secondary indexes for an <code>XMLIndex</code> index. for information about a given secondary index, query using the name of that secondary index as <code>INDEX_NAME</code>.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4406"></a>
<div class="props_rev_3"><a id="GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC"></a>
<h3 id="ADXDB-GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" class="sect3"><span class="enumeration_section">6.3.17</span> PARAMETERS Clause for CREATE INDEX and ALTER INDEX</h3>
<div>
<p>Creation or modification of an <code>XMLIndex</code> index often involves the use of a <code>PARAMETERS</code> clause with SQL statement <code>CREATE INDEX</code> or <code>ALTER INDEX</code>. You can use it to specify index characteristics in detail.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>See <a href="xdb_indexing.htm#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" title="The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.">PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</a> for the syntax of the <code>PARAMETERS</code> clause for use with <code>XMLIndex</code>.</p>
</li>
<li>
<p>You can use PL/SQL procedures <code>registerParameter</code> and <code>modifyParameter</code> in package <code>DBMS_XMLINDEX</code> to get around the 1000&ndash;character <code>PARAMETERS</code> clause limit. See <a href="xdb_indexing.htm#GUID-C04D8939-4A3C-4C54-8399-109AC4914D03" title="The string value used for the PARAMETERS clause of a CREATE INDEX or ALTER INDEX statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures registerParameter and modifyParameter in package DBMS_XMLINDEX.">Using a Registered PARAMETERS Clause for XMLIndex</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC__GUID-6298526F-A48D-4A8A-B298-9C82DB28E283">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF20021" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF20021"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <span class="italic"><code>index_attributes</code></span></p>
</li>
<li>
<p><a class="olink SQLRF20022" target="_blank" href="../SQLRF/statements_7002.htm#SQLRF20022"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <span class="italic"><code>segment_attributes_clause</code></span></p>
</li>
<li>
<p><a class="olink SQLRF20023" target="_blank" href="../SQLRF/statements_7002.htm#SQLRF20023"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <span class="italic"><code>table_properties</code></span></p>
</li>
<li>
<p><a class="olink SQLRF20024" target="_blank" href="../SQLRF/clauses006.htm#SQLRF20024"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <span class="italic"><code>parallel_clause</code></span></p>
</li>
<li>
<p><a class="olink SQLRF01209" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF01209"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional information about the syntax and semantics of <code>CREATE INDEX</code></p>
</li>
<li>
<p><a class="olink SQLRF00805" target="_blank" href="../SQLRF/statements_1012.htm#SQLRF00805"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional information about the syntax and semantics of <code>ALTER INDEX</code></p>
</li>
<li>
<p><a class="olink ARPLS72263" target="_blank" href="../ARPLS/d_sched.htm#ARPLS72263"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>, section &#34;Calendaring Syntax&#34;, for the syntax of <span class="italic"><code>repeat_interval</code></span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDB4407"></a>
<div class="props_rev_3"><a id="GUID-C04D8939-4A3C-4C54-8399-109AC4914D03"></a>
<h4 id="ADXDB-GUID-C04D8939-4A3C-4C54-8399-109AC4914D03" class="sect4"><span class="enumeration_section">6.3.17.1</span> Using a Registered PARAMETERS Clause for XMLIndex</h4>
<div>
<p>The string value used for the <code>PARAMETERS</code> clause of a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures <code>registerParameter</code> and <code>modifyParameter</code> in package <code>DBMS_XMLINDEX</code>.</p>
<div class="section">
<p>For each of these procedures, you provide a string of parameters (unlimited in length) and an identifier under which the string is registered. Then, in the index <code>PARAMETERS</code> clause, you provide the identifier preceded by the keyword <code>PARAM</code>, instead of a literal string.</p>
<p>The identifier must already have been registered before you can use it in a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement.</p>
<div class="infoboxnotealso" id="GUID-C04D8939-4A3C-4C54-8399-109AC4914D03__GUID-6CB729AD-0B47-4BD2-9036-C402C71194B6">
<p class="notep1">See Also:</p>
<p><a href="xdb_indexing.htm#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-20</a></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4409"></a><a id="ADXDB4410"></a><a id="ADXDB4411"></a><a id="ADXDB5832"></a><a id="ADXDB4412"></a><a id="ADXDB4413"></a><a id="ADXDB4414"></a><a id="ADXDB4415"></a><a id="ADXDB5833"></a><a id="ADXDB4416"></a><a id="ADXDB4417"></a><a id="ADXDB4418"></a><a id="ADXDB5834"></a><a id="ADXDB4419"></a><a id="ADXDB4420"></a><a id="ADXDB5835"></a><a id="ADXDB4421"></a><a id="ADXDB4422"></a><a id="ADXDB4423"></a><a id="ADXDB4424"></a><a id="ADXDB4425"></a><a id="ADXDB4426"></a><a id="ADXDB4427"></a><a id="ADXDB4428"></a><a id="ADXDB4429"></a><a id="ADXDB6106"></a><a id="ADXDB6107"></a><a id="ADXDB4408"></a>
<div class="props_rev_3"><a id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393"></a>
<h4 id="ADXDB-GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" class="sect4"><span class="enumeration_section">6.3.17.2</span> PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</h4>
<div>
<p>The syntax for the <code>PARAMETERS</code> clause for <code>CREATE INDEX</code> and <code>ALTER INDEX</code> is defined.</p>
<div class="section"></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XMLIndex_parameters_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-22945D8D-CE93-4FED-A2B9-79DFD2D6230C"><img width="412" height="58" src="img/GUID-6F441484-F74E-4453-8AA3-B31E5923DBF7-default.gif" alt="Description of GUID-6F441484-F74E-4453-8AA3-B31E5923DBF7-print.eps follows" title="Description of GUID-6F441484-F74E-4453-8AA3-B31E5923DBF7-print.eps follows"/><br/>
<a href="img_text/GUID-6F441484-F74E-4453-8AA3-B31E5923DBF7-print.htm">Description of the illustration GUID-6F441484-F74E-4453-8AA3-B31E5923DBF7-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C98E9FB9-BC89-4BDD-AC08-8FA6A168457C">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C" title="When you create an XMLIndex index, if there is no XMLIndex_parameters_clause, then the new index has only an unstructured component. If there is an XMLIndex_parameters_clause, but the PARAMETERS argument is empty (&#39;&#39;), then the result is the same: an index with only an unstructured component.">Usage of XMLIndex_parameters_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XMLIndex_parameters ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-46FCC879-D90B-4132-9DFE-982F5387C8BE"><img width="487" height="50" src="img/GUID-74E87114-FD23-46DC-A0ED-03C7C63431EB-default.gif" alt="Description of GUID-74E87114-FD23-46DC-A0ED-03C7C63431EB-print.eps follows" title="Description of GUID-74E87114-FD23-46DC-A0ED-03C7C63431EB-print.eps follows"/><br/>
<a href="img_text/GUID-74E87114-FD23-46DC-A0ED-03C7C63431EB-print.htm">Description of the illustration GUID-74E87114-FD23-46DC-A0ED-03C7C63431EB-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-BB050FB2-8EDE-4DDD-8112-3669936667F6">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-0563D8B4-9C46-4620-B814-0D608B57F84C" title="Certain considerations apply to using XMLIndex_parameters.">Usage of XMLIndex_parameters</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XMLIndex_parameter_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-752DCF5B-17A6-44B0-8885-322075A7ACCE"><img width="178" height="91" src="img/GUID-E332B16C-887F-4F76-BE56-4B71CDB59061-default.gif" alt="Description of GUID-E332B16C-887F-4F76-BE56-4B71CDB59061-print.eps follows" title="Description of GUID-E332B16C-887F-4F76-BE56-4B71CDB59061-print.eps follows"/><br/>
<a href="img_text/GUID-E332B16C-887F-4F76-BE56-4B71CDB59061-print.htm">Description of the illustration GUID-E332B16C-887F-4F76-BE56-4B71CDB59061-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">unstructured_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-9BACE068-2AB2-44A0-A5E3-CB6B6740F318"><img width="378" height="251" src="img/GUID-B7708192-058C-43E7-84D8-9007268C00BC-default.gif" alt="Description of GUID-B7708192-058C-43E7-84D8-9007268C00BC-print.eps follows" title="Description of GUID-B7708192-058C-43E7-84D8-9007268C00BC-print.eps follows"/><br/>
<a href="img_text/GUID-B7708192-058C-43E7-84D8-9007268C00BC-print.htm">Description of the illustration GUID-B7708192-058C-43E7-84D8-9007268C00BC-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">create_index_paths_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-B52C3262-79E0-431F-936F-97FA7A79F32F"><img width="553" height="64" src="img/GUID-7BD941C0-0407-473D-9F4F-DE71FD492E63-default.gif" alt="Description of GUID-7BD941C0-0407-473D-9F4F-DE71FD492E63-print.eps follows" title="Description of GUID-7BD941C0-0407-473D-9F4F-DE71FD492E63-print.eps follows"/><br/>
<a href="img_text/GUID-7BD941C0-0407-473D-9F4F-DE71FD492E63-print.htm">Description of the illustration GUID-7BD941C0-0407-473D-9F4F-DE71FD492E63-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-13860D3C-FD4D-41F2-9A98-9E2F8B083DE4">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7" title="Certain considerations apply to using the PATHS clause.">Usage of PATHS Clause</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D" title="Certain considerations apply to using create_index_paths_clause and alter_index_paths_clause.">Usage of create_index_paths_clause and alter_index_paths_clause</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFAECD">
<p class="subhead3"><span class="italic">alter_index_paths_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-837A5031-6A94-4CB2-B88A-E51B066B6F7C"><img width="690" height="95" src="img/GUID-BC167579-44D2-43C2-85AE-CA998BAF353C-default.gif" alt="Description of GUID-BC167579-44D2-43C2-85AE-CA998BAF353C-print.eps follows" title="Description of GUID-BC167579-44D2-43C2-85AE-CA998BAF353C-print.eps follows"/><br/>
<a href="img_text/GUID-BC167579-44D2-43C2-85AE-CA998BAF353C-print.htm">Description of the illustration GUID-BC167579-44D2-43C2-85AE-CA998BAF353C-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-36FC14F5-F78F-49FA-B4A6-86B6534A81BA">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7" title="Certain considerations apply to using the PATHS clause.">Usage of PATHS Clause</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D" title="Certain considerations apply to using create_index_paths_clause and alter_index_paths_clause.">Usage of create_index_paths_clause and alter_index_paths_clause</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">namespace_mapping_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-756E1FE2-AD89-41D7-A809-3394D9DAB955"><img width="371" height="39" src="img/GUID-B23678E1-3EF3-423B-8408-BBA667A7CDB4-default.gif" alt="Description of GUID-B23678E1-3EF3-423B-8408-BBA667A7CDB4-print.eps follows" title="Description of GUID-B23678E1-3EF3-423B-8408-BBA667A7CDB4-print.eps follows"/><br/>
<a href="img_text/GUID-B23678E1-3EF3-423B-8408-BBA667A7CDB4-print.htm">Description of the illustration GUID-B23678E1-3EF3-423B-8408-BBA667A7CDB4-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAGCI">
<p class="subhead3"><span class="italic">path_table_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-A2B60DE1-4E71-4CB6-A765-D1C590484CD5"><img width="629" height="48" src="img/GUID-E52AF899-D63C-44E7-A03F-D76BBFB63D02-default.gif" alt="Description of GUID-E52AF899-D63C-44E7-A03F-D76BBFB63D02-print.eps follows" title="Description of GUID-E52AF899-D63C-44E7-A03F-D76BBFB63D02-print.eps follows"/><br/>
<a href="img_text/GUID-E52AF899-D63C-44E7-A03F-D76BBFB63D02-print.htm">Description of the illustration GUID-E52AF899-D63C-44E7-A03F-D76BBFB63D02-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">pikey_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5B98FFF2-2F94-4AF2-A00D-65A91F83F6C9"><img width="515" height="67" src="img/GUID-E671895E-1095-4A20-AFDE-64FC620710BF-default.gif" alt="Description of GUID-E671895E-1095-4A20-AFDE-64FC620710BF-print.eps follows" title="Description of GUID-E671895E-1095-4A20-AFDE-64FC620710BF-print.eps follows"/><br/>
<a href="img_text/GUID-E671895E-1095-4A20-AFDE-64FC620710BF-print.htm">Description of the illustration GUID-E671895E-1095-4A20-AFDE-64FC620710BF-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-32EA0C93-902C-4EBE-807C-67E3D7654855">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-7B126CF1-5397-455C-B01D-696CF64B2001" title="Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.">Usage of pikey_clause_ path_id_clause_ and order_key_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">path_id_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-35BEC568-0DDA-4075-8EA1-4AD94B0150EB"><img width="548" height="67" src="img/GUID-D69AEE16-920E-4905-8CE9-79F9BB74E5B1-default.gif" alt="Description of GUID-D69AEE16-920E-4905-8CE9-79F9BB74E5B1-print.eps follows" title="Description of GUID-D69AEE16-920E-4905-8CE9-79F9BB74E5B1-print.eps follows"/><br/>
<a href="img_text/GUID-D69AEE16-920E-4905-8CE9-79F9BB74E5B1-print.htm">Description of the illustration GUID-D69AEE16-920E-4905-8CE9-79F9BB74E5B1-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-FD260B24-0AC2-4313-AB34-BE5ED10D33F8">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-7B126CF1-5397-455C-B01D-696CF64B2001" title="Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.">Usage of pikey_clause_ path_id_clause_ and order_key_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">order_key_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-692BD0F4-CE28-4763-BDEC-B8A8ED83F52E"><img width="570" height="67" src="img/GUID-88AEF888-7D90-468B-9678-1C01B483CE02-default.gif" alt="Description of GUID-88AEF888-7D90-468B-9678-1C01B483CE02-print.eps follows" title="Description of GUID-88AEF888-7D90-468B-9678-1C01B483CE02-print.eps follows"/><br/>
<a href="img_text/GUID-88AEF888-7D90-468B-9678-1C01B483CE02-print.htm">Description of the illustration GUID-88AEF888-7D90-468B-9678-1C01B483CE02-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C0017A22-39D4-4D44-8329-5CCD7D9902FB">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-7B126CF1-5397-455C-B01D-696CF64B2001" title="Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.">Usage of pikey_clause_ path_id_clause_ and order_key_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">value_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-303056F8-EFBF-465C-A46C-7F646276D8F9"><img width="518" height="67" src="img/GUID-803F9C14-BDDA-40C6-BB81-AFD8638CE5D9-default.gif" alt="Description of GUID-803F9C14-BDDA-40C6-BB81-AFD8638CE5D9-print.eps follows" title="Description of GUID-803F9C14-BDDA-40C6-BB81-AFD8638CE5D9-print.eps follows"/><br/>
<a href="img_text/GUID-803F9C14-BDDA-40C6-BB81-AFD8638CE5D9-print.htm">Description of the illustration GUID-803F9C14-BDDA-40C6-BB81-AFD8638CE5D9-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-63D45313-916C-422B-80A0-2BF695779730">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-3D908187-37BE-48DB-88A3-285442FB3DE1" title="Certain considerations apply to using value_clause.">Usage of value_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGGGBCB">
<p class="subhead3"><span class="italic">drop_path_table_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-BE350CDB-9167-47CF-8D9E-FF1733D810A9"><img width="195" height="27" src="img/GUID-05C3B172-297B-4C91-AA90-CF89B5AE5DDA-default.gif" alt="Description of GUID-05C3B172-297B-4C91-AA90-CF89B5AE5DDA-print.eps follows" title="Description of GUID-05C3B172-297B-4C91-AA90-CF89B5AE5DDA-print.eps follows"/><br/>
<a href="img_text/GUID-05C3B172-297B-4C91-AA90-CF89B5AE5DDA-print.htm">Description of the illustration GUID-05C3B172-297B-4C91-AA90-CF89B5AE5DDA-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">parallel_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-0F378CCC-7B45-4DA9-852D-6B36658731A9"><img width="241" height="79" src="img/GUID-E9D45EE7-89C0-42CD-92D2-8D2DCF95D6A5-default.gif" alt="Description of GUID-E9D45EE7-89C0-42CD-92D2-8D2DCF95D6A5-print.eps follows" title="Description of GUID-E9D45EE7-89C0-42CD-92D2-8D2DCF95D6A5-print.eps follows"/><br/>
<a href="img_text/GUID-E9D45EE7-89C0-42CD-92D2-8D2DCF95D6A5-print.htm">Description of the illustration GUID-E9D45EE7-89C0-42CD-92D2-8D2DCF95D6A5-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">
<p class="subhead3"><span class="italic">structured_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C3D9026F-D932-48D1-A249-B9E0E91EF357"><img width="206" height="58" src="img/GUID-1659AF71-0742-481B-B76B-C421D6438870-default.gif" alt="Description of GUID-1659AF71-0742-481B-B76B-C421D6438870-print.eps follows" title="Description of GUID-1659AF71-0742-481B-B76B-C421D6438870-print.eps follows"/><br/>
<a href="img_text/GUID-1659AF71-0742-481B-B76B-C421D6438870-print.htm">Description of the illustration GUID-1659AF71-0742-481B-B76B-C421D6438870-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5093170E-E559-4919-A53B-16225E7BD5A0">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">async_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-BE6C1E4E-6CC6-4064-A9FB-3F3FB31C3AA7"><img width="661" height="128" src="img/GUID-C8AEF3CB-D8AC-4EA6-BC32-8EC4FE330346-default.gif" alt="Description of GUID-C8AEF3CB-D8AC-4EA6-BC32-8EC4FE330346-print.eps follows" title="Description of GUID-C8AEF3CB-D8AC-4EA6-BC32-8EC4FE330346-print.eps follows"/><br/>
<a href="img_text/GUID-C8AEF3CB-D8AC-4EA6-BC32-8EC4FE330346-print.htm">Description of the illustration GUID-C8AEF3CB-D8AC-4EA6-BC32-8EC4FE330346-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-558C4F03-A725-4A11-8744-0FF8DCAA0389">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1" title="Certain considerations apply to using the ASYNC clause.">Usage of async_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">groups_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-77B8AFED-CF5F-4351-B1A0-78C986DD12D1"><img width="143" height="39" src="img/GUID-2CD35997-CF2A-4A10-A8EA-A82A914755A1-default.gif" alt="Description of GUID-2CD35997-CF2A-4A10-A8EA-A82A914755A1-print.eps follows" title="Description of GUID-2CD35997-CF2A-4A10-A8EA-A82A914755A1-print.eps follows"/><br/>
<a href="img_text/GUID-2CD35997-CF2A-4A10-A8EA-A82A914755A1-print.htm">Description of the illustration GUID-2CD35997-CF2A-4A10-A8EA-A82A914755A1-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-2E78604E-3FF6-4347-A5B4-DB7E543C5A42">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">group_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-2808C9B7-D93C-4D3F-9BD9-B7AEBAE67970"><img width="367" height="46" src="img/GUID-58688C2F-C2E0-4AF7-A791-32660D5AEFAD-default.gif" alt="Description of GUID-58688C2F-C2E0-4AF7-A791-32660D5AEFAD-print.eps follows" title="Description of GUID-58688C2F-C2E0-4AF7-A791-32660D5AEFAD-print.eps follows"/><br/>
<a href="img_text/GUID-58688C2F-C2E0-4AF7-A791-32660D5AEFAD-print.htm">Description of the illustration GUID-58688C2F-C2E0-4AF7-A791-32660D5AEFAD-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-F1D62A14-E1C7-48C3-9559-B17D7AF0849E">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">XMLIndex_xmltable_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C1E9E927-A73C-4E2A-92B9-31FBD1EBFCFB"><img width="550" height="211" src="img/GUID-69202FA0-332E-43E2-AF6C-0BF894CB2521-default.gif" alt="Description of GUID-69202FA0-332E-43E2-AF6C-0BF894CB2521-print.eps follows" title="Description of GUID-69202FA0-332E-43E2-AF6C-0BF894CB2521-print.eps follows"/><br/>
<a href="img_text/GUID-69202FA0-332E-43E2-AF6C-0BF894CB2521-print.htm">Description of the illustration GUID-69202FA0-332E-43E2-AF6C-0BF894CB2521-print.eps</a></div>
<!-- class="figure" -->
<p>Syntax elements <tt>XML_namespaces_clause</tt> and <tt>XQuery_string</tt> are the same as for SQL/XML function <code>XMLTable</code>.</p>
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-51982120-529B-4D7F-A337-1C31C3C44219">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42" title="Certain considerations apply to using XMLIndex_xmltable_clause.">Usage of XMLIndex_xmltable_clause</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="You use SQL/XML function XMLTable to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL &mdash; in a join expression, for example.">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">column_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-D5D4C8BB-669E-4DF1-B77D-85669BC13CAC"><img width="412" height="79" src="img/GUID-417096E7-8C02-4D8D-B983-883040CC21BA-default.gif" alt="Description of GUID-417096E7-8C02-4D8D-B983-883040CC21BA-print.eps follows" title="Description of GUID-417096E7-8C02-4D8D-B983-883040CC21BA-print.eps follows"/><br/>
<a href="img_text/GUID-417096E7-8C02-4D8D-B983-883040CC21BA-print.htm">Description of the illustration GUID-417096E7-8C02-4D8D-B983-883040CC21BA-print.eps</a></div>
<!-- class="figure" -->
<p>Syntax element <tt>column_clause</tt> is similar, but not identical, to <tt>XML_table_column</tt> in SQL/XML function <code>XMLTable</code>.</p>
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-B6BCE32F-DAA8-4D15-A626-DCA778AE095E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-D4474161-F125-4703-98D2-7C609F8806E7" title="Certain considerations apply to using column_clause.">Usage of column_clause</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="You use SQL/XML function XMLTable to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL &mdash; in a join expression, for example.">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAAGH">
<p class="subhead3"><span class="italic">alter_index_group_clause ::=</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5155A7FD-7F88-44A2-BD04-3C0B76C845F1"><img width="406" height="312" src="img/GUID-1C0A0262-6A96-4052-B31F-8F20EF07100C-default.gif" alt="Description of GUID-1C0A0262-6A96-4052-B31F-8F20EF07100C-print.eps follows" title="Description of GUID-1C0A0262-6A96-4052-B31F-8F20EF07100C-print.eps follows"/><br/>
<a href="img_text/GUID-1C0A0262-6A96-4052-B31F-8F20EF07100C-print.htm">Description of the illustration GUID-1C0A0262-6A96-4052-B31F-8F20EF07100C-print.eps</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-AD9466C7-72BE-440C-B2BA-0839E6B9A542">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">add_column_clause :==</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-E7E8C533-E0A1-444B-BC9F-B578554B55D1"><img width="254" height="27" src="img/GUID-292A7E95-FE0E-4624-9AF1-6D531EDB9842-default.gif" alt="Description of GUID-292A7E95-FE0E-4624-9AF1-6D531EDB9842-print.eps follows" title="Description of GUID-292A7E95-FE0E-4624-9AF1-6D531EDB9842-print.eps follows"/><br/>
<a href="img_text/GUID-292A7E95-FE0E-4624-9AF1-6D531EDB9842-print.htm">Description of the illustration GUID-292A7E95-FE0E-4624-9AF1-6D531EDB9842-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">add_column_options :==</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-4B191901-116A-4AE8-92F6-537A0875E7A0"><img width="803" height="58" src="img/GUID-BB1AD8E5-FCDA-4ABB-A0A8-885B29681AF2-default.gif" alt="Description of GUID-BB1AD8E5-FCDA-4ABB-A0A8-885B29681AF2-print.eps follows" title="Description of GUID-BB1AD8E5-FCDA-4ABB-A0A8-885B29681AF2-print.eps follows"/><br/>
<a href="img_text/GUID-BB1AD8E5-FCDA-4ABB-A0A8-885B29681AF2-print.htm">Description of the illustration GUID-BB1AD8E5-FCDA-4ABB-A0A8-885B29681AF2-print.eps</a></div>
<!-- class="figure" -->
<p>Syntax element <tt>XML_namespaces_clause</tt> is the same as for SQL/XML function <code>XMLTable</code>. See <span class="q">&#34;<a href="xdb_xquery.htm#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="You use SQL/XML function XMLTable to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL &mdash; in a join expression, for example.">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">drop_column_clause :==</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-2A4C62C6-0E3C-47E6-AAC3-C29EE8E559C7"><img width="268" height="27" src="img/GUID-4A526AD8-E049-4157-B2A6-EEF588309717-default.gif" alt="Description of GUID-4A526AD8-E049-4157-B2A6-EEF588309717-print.eps follows" title="Description of GUID-4A526AD8-E049-4157-B2A6-EEF588309717-print.eps follows"/><br/>
<a href="img_text/GUID-4A526AD8-E049-4157-B2A6-EEF588309717-print.htm">Description of the illustration GUID-4A526AD8-E049-4157-B2A6-EEF588309717-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">drop_column_options :==</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-05DA1B85-9822-422B-A78C-AA294CEC46DC"><img width="539" height="58" src="img/GUID-8A52C03F-E878-49CD-BA30-70586DBD7AC6-default.gif" alt="Description of GUID-8A52C03F-E878-49CD-BA30-70586DBD7AC6-print.eps follows" title="Description of GUID-8A52C03F-E878-49CD-BA30-70586DBD7AC6-print.eps follows"/><br/>
<a href="img_text/GUID-8A52C03F-E878-49CD-BA30-70586DBD7AC6-print.htm">Description of the illustration GUID-8A52C03F-E878-49CD-BA30-70586DBD7AC6-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__CEGEABGE">
<p class="subhead3"><span class="italic">modify_column_type_clause :==</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-D6F2F095-EBB0-46F8-B064-C37E35F90C23"><img width="353" height="27" src="img/GUID-25689360-960A-47A0-8FDD-84F4FD5B6515-default.gif" alt="Description of GUID-25689360-960A-47A0-8FDD-84F4FD5B6515-print.eps follows" title="Description of GUID-25689360-960A-47A0-8FDD-84F4FD5B6515-print.eps follows"/><br/>
<a href="img_text/GUID-25689360-960A-47A0-8FDD-84F4FD5B6515-print.htm">Description of the illustration GUID-25689360-960A-47A0-8FDD-84F4FD5B6515-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="italic">modify_column_type_options :==</span></p>
</div>
<!-- class="section" -->
<div class="section">
<div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-08F4FF1D-308D-4B5B-851D-85307945AE0C"><img width="609" height="58" src="img/GUID-6D41F592-AA26-49CD-9234-CC64568E3831-default.gif" alt="Description of GUID-6D41F592-AA26-49CD-9234-CC64568E3831-print.eps follows" title="Description of GUID-6D41F592-AA26-49CD-9234-CC64568E3831-print.eps follows"/><br/>
<a href="img_text/GUID-6D41F592-AA26-49CD-9234-CC64568E3831-print.htm">Description of the illustration GUID-6D41F592-AA26-49CD-9234-CC64568E3831-print.eps</a></div>
<!-- class="figure" --></div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4430"></a>
<div class="props_rev_3"><a id="GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C"></a>
<h4 id="ADXDB-GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C" class="sect4"><span class="enumeration_section">6.3.17.3</span> Usage of XMLIndex_parameters_clause</h4>
<div>
<p>When you create an <code>XMLIndex</code> index, if there is no <span class="italic"><code>XMLIndex_parameters_clause</code></span>, then the new index has only an unstructured component. If there is an <span class="italic"><code>XMLIndex_parameters_clause</code></span>, but the <code>PARAMETERS</code> argument is empty (<code>&#39;&#39;</code>), then the result is the same: an index with only an unstructured component.</p>
<div class="section">
<div class="infoboxnotealso" id="GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C__GUID-A4B03CC0-4E7E-4488-B0C5-D05D98817C40">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF54032" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF54032"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the use context for <span class="italic"><code>XMLIndex_parameters_clause</code></span> in <code>CREATE INDEX</code></p>
</li>
<li>
<p><a class="olink SQLRF52771" target="_blank" href="../SQLRF/statements_1012.htm#SQLRF52771"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the use context for <span class="italic"><code>XMLIndex_parameters_clause</code></span> in <code>ALTER INDEX</code></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4431"></a>
<div class="props_rev_3"><a id="GUID-0563D8B4-9C46-4620-B814-0D608B57F84C"></a>
<h4 id="ADXDB-GUID-0563D8B4-9C46-4620-B814-0D608B57F84C" class="sect4"><span class="enumeration_section">6.3.17.4</span> Usage of XMLIndex_parameters</h4>
<div>
<p>Certain considerations apply to using <span class="italic"><code>XMLIndex_parameters</code></span>.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>There can be at most one <span class="italic"><code>XMLIndex_parameter_clause</code></span> of each type in <span class="italic"><code>XMLIndex_parameters</code></span>. For example, there can be at most one <code>PATHS</code> clause, at most one <span class="italic"><code>path_table_clause</code></span>, and so on.</p>
</li>
<li>
<p>If there is no <span class="italic"><code>structured_clause</code></span> when you create an <code>XMLIndex</code> index, then the new index has only an unstructured component. If there is only a <span class="italic"><code>structured_clause</code></span>, then the new index has only a structured component.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4433"></a>
<div class="props_rev_3"><a id="GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7"></a>
<h4 id="ADXDB-GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7" class="sect4"><span class="enumeration_section">6.3.17.5</span> Usage of PATHS Clause</h4>
<div>
<p>Certain considerations apply to using the <code>PATHS</code> clause.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>There can be at most one <code>PATHS</code> clause in a <code>CREATE INDEX</code> statement. That is, there can be at most one occurrence of <code>PATHS</code> followed by <span class="italic"><code>create_index_paths_clause</code></span>.</p>
</li>
<li>
<p>Clause <span class="italic"><code>create_index_paths_clause</code></span> is used only with <code>CREATE INDEX</code>; <span class="italic"><code>alter_index_paths_clause</code></span> is used only with <code>ALTER INDEX</code>.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4434"></a>
<div class="props_rev_3"><a id="GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D"></a>
<h4 id="ADXDB-GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D" class="sect4"><span class="enumeration_section">6.3.17.6</span> Usage of create_index_paths_clause and alter_index_paths_clause</h4>
<div>
<p>Certain considerations apply to using <span class="italic"><code>create_index_paths_clause</code></span> and <span class="italic"><code>alter_index_paths_clause</code></span>.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The <code>INDEX_ALL_PATHS</code> keyword rebuilds the index to include all paths. This keyword is available only for <span class="italic"><code>alter_index_paths_clause</code></span>, not <span class="italic"><code>create_index_paths_clause</code></span>.</p>
</li>
<li>
<p>An explicit list of paths to index can include wildcards and <code>//</code>.</p>
</li>
<li>
<p><span class="italic"><code>XPaths_list</code></span> is a list of one or more XPath expressions, each of which includes only child axis, descendant axis, name test, and wildcard (<code>*</code>) constructs.</p>
</li>
<li>
<p>If <span class="italic"><code>XPaths_list</code></span> is omitted from <span class="italic"><code>create_index_paths_clause</code></span>, all paths are indexed.</p>
</li>
<li>
<p>For each unique namespace prefix that is used in an XPath expression in <span class="italic"><code>XPaths_list</code></span>, a standard XML <span class="italic"><code>namespace</code></span> declaration is needed, to provide the corresponding namespace information.</p>
</li>
<li>
<p>You can change an index in ways that are not reflected directly in the syntax by dropping it and then creating it again as needed. For example, to change an index that was defined by including paths to one that is defined by excluding paths, drop it and then create it using <code>EXCLUDE</code>.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB5939"></a>
<div class="props_rev_3"><a id="GUID-7B126CF1-5397-455C-B01D-696CF64B2001"></a>
<h4 id="ADXDB-GUID-7B126CF1-5397-455C-B01D-696CF64B2001" class="sect4"><span class="enumeration_section">6.3.17.7</span> Usage of pikey_clause, path_id_clause, and order_key_clause</h4>
<div>
<p>Syntactically, each of the clauses <code>pikey_clause</code>, <code>path_id_clause</code>, and <code>order_key_clause</code> is optional. A pikey index is created even if you do not specify a <code>pikey_clause</code>. To create a path id index or an order-key index, you must specify a <code>path_id_clause</code> or an <code>order_key_clause</code>, respectively.</p>
<div class="section"></div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4435"></a>
<div class="props_rev_3"><a id="GUID-3D908187-37BE-48DB-88A3-285442FB3DE1"></a>
<h4 id="ADXDB-GUID-3D908187-37BE-48DB-88A3-285442FB3DE1" class="sect4"><span class="enumeration_section">6.3.17.8</span> Usage of value_clause</h4>
<div>
<p>Certain considerations apply to using <span class="italic"><code>value_clause</code></span>.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Column <code>VALUE</code> is created as <code>VARCHAR2(4000)</code>.</p>
</li>
<li>
<p>If clause <span class="italic"><code>value_clause</code></span> consists only of the keyword <code>VALUE</code>, then the value index is created with the usual default attributes.</p>
</li>
<li>
<p>If clause <span class="italic"><code>path_id_clause</code></span> consists only of the keywords <code>PATH ID</code>, then the path-id index is created with the usual default attributes.</p>
</li>
<li>
<p>If clause <span class="italic"><code>order_key_clause</code></span> consists only of the keywords <code>ORDER KEY</code>, then the order-key index is created with the usual default attributes.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4436"></a>
<div class="props_rev_3"><a id="GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1"></a>
<h4 id="ADXDB-GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1" class="sect4"><span class="enumeration_section">6.3.17.9</span> Usage of async_clause</h4>
<div>
<p>Certain considerations apply to using the <code>ASYNC</code> clause.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Use this feature only with an <code>XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component. If you specify an <code>ASYNC</code> clause for an <code>XMLIndex</code> index that has a <span class="italic">structured</span> component, then an error is raised.</p>
</li>
<li>
<p><code>ALWAYS</code> means automatic synchronization occurs for each DML statement.</p>
</li>
<li>
<p><code>MANUAL</code> means no automatic synchronization occurs. You must manually synchronize the index using <code>DBMS_XMLINDEX.syncIndex</code>.</p>
</li>
<li>
<p><code>EVERY</code> <span class="italic"><code>repeat_interval</code></span> means automatically synchronize the index at interval <span class="italic"><code>repeat_interval</code></span>. The syntax of <span class="italic"><code>repeat_interval</code></span> is the same as that for PL/SQL package <code>DBMS_SCHEDULER</code>, and it must be enclosed in double quotation marks (<span class="bold"><code>&#34;</code></span>). To use <code>EVERY</code> you must have the <code>CREATE JOB</code> privilege.</p>
</li>
<li>
<p><code>ON COMMIT</code> means synchronize the index immediately after a commit operation. The commit does not return until the synchronization is complete. Since the synchronization is performed as a separate transaction, there can be a short period when the data is committed but index changes are not yet committed.</p>
</li>
<li>
<p><code>STALE</code> is optional. A value of <code>TRUE</code> means that query results might be stale; a value of <code>FALSE</code> means that query results are always up-to-date. The default value, and the only permitted explicitly specified value, is as follows.</p>
<ul style="list-style-type: disc;">
<li>
<p>For <code>ALWAYS</code>, <code>STALE</code> is <code>FALSE</code>.</p>
</li>
<li>
<p>For any other <code>ASYNC</code> option besides <code>ALWAYS</code>, <code>STALE</code> is <code>TRUE</code>.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4437"></a>
<div class="props_rev_3"><a id="GUID-35B0101C-DB6B-460B-9587-D7254DD1079D"></a>
<h4 id="ADXDB-GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" class="sect4"><span class="enumeration_section">6.3.17.10</span> Usage of groups_clause and alter_index_group_clause</h4>
<div>
<p>Clause <span class="italic"><code>groups_clause</code></span> is used only with <code>CREATE INDEX</code> (or following <code>ADD GROUP</code> in clause <span class="italic"><code>alter_index_group_clause</code></span>). Clause <span class="italic"><code>alter_index_group_clause</code></span> is used only with <code>ALTER INDEX</code>.</p>
<div class="section"></div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4438"></a>
<div class="props_rev_3"><a id="GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42"></a>
<h4 id="ADXDB-GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42" class="sect4"><span class="enumeration_section">6.3.17.11</span> Usage of XMLIndex_xmltable_clause</h4>
<div>
<p>Certain considerations apply to using <span class="italic"><code>XMLIndex_xmltable_clause</code></span>.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The <span class="italic"><code>XQuery_string</code></span> expression in <span class="italic"><code>XMLIndex_xmltable_clause</code></span> must not use the XQuery functions <code>ora:view</code> (deprecated), <code>fn:doc</code>, or <code>fn:collection</code>.</p>
</li>
<li>
<p>Oracle XML&nbsp;DB raises an error if a given <span class="italic"><code>XMLIndex_xmltable_clause</code></span> contains more than one <span class="italic"><code>column_clause</code></span> of data type <code>XMLType</code>. To achieve the effect of defining two such virtual columns, you must instead add a separate <span class="italic"><code>group_clause</code></span>.</p>
</li>
<li>
<p>The <code>PASSING</code> clause in <span class="italic"><code>XMLIndex_xmltable_clause</code></span> is optional. If not present, then an <code>XMLType</code> column is passed implicitly, as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>For the first <span class="italic"><code>XMLIndex_xmltable_clause</code></span> in a parameters clause, the <code>XMLType</code> column being indexed is passed implicitly. (When indexing an <code>XMLType</code> table, pseudocolumn <code>OBJECT_VALUE</code> is passed.)</p>
</li>
<li>
<p>For each subsequent <span class="italic"><code>XMLIndex_xmltable_clause</code></span>, the <code>VIRTUAL</code> <code>XMLType</code> column of the preceding <span class="italic"><code>XMLIndex_xmltable_clause</code></span> is passed implicitly.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB4439"></a>
<div class="props_rev_3"><a id="GUID-D4474161-F125-4703-98D2-7C609F8806E7"></a>
<h4 id="ADXDB-GUID-D4474161-F125-4703-98D2-7C609F8806E7" class="sect4"><span class="enumeration_section">6.3.17.12</span> Usage of column_clause</h4>
<div>
<p>Certain considerations apply to using <span class="italic"><code>column_clause</code></span>.</p>
<div class="section">
<p>When you use multilevel chaining of <code>XMLTable</code> in an <code>XMLIndex</code> index, the <code>XMLTable</code> table at one level corresponds to an <code>XMLType</code> column at the previous level. The syntax description shows keyword <code>VIRTUAL</code> as optional. In fact, it is used only for such an <code>XMLType</code> column, in which case it is <span class="italic">required</span>. It is an error to use it for a non-<code>XMLType</code> column. <code>VIRTUAL</code> specifies that the <code>XMLType</code> column itself is not materialized, meaning that its data is stored in the index only in the form of the relational columns specified by its corresponding <code>XMLTable</code> table.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<a id="ADXDB4442"></a>
<div class="props_rev_3"><a id="GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C"></a>
<h2 id="ADXDB-GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" class="sect2"><span class="enumeration_section">6.4</span> Indexing XML Data for Full-Text Queries</h2>
<div>
<p>When you need full-text search over XML data, Oracle recommends that you store your <code>XMLType</code> data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.</p>
<p>If portability and standardized code is not a concern, or if your <code>XMLType</code> data is stored object-relationally, then you can alternatively use the Oracle-specific full-text constructs and syntax provided by Oracle Text, specifically Oracle SQL function <code>contains</code> or Oracle XPath function <code>ora:contains</code>. This is covered in <a href="app_depr_otext.htm#GUID-1B838D2B-DD94-480A-8D3D-53E0204A2282" title="Oracle-specific full-text search over XML data is described, including how to use Oracle SQL function contains and Oracle XPath function ora:contains.">Full-Text Search over XML Data Without XQuery</a>.</p>
<div class="infoboxnotealso" id="GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C__GUID-5AC81666-0C6A-4791-A3D3-8F102BF451AB">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xdb_indexing.htm#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-43</a></p>
</li>
<li>
<p><a href="app_depr_otext.htm#GUID-1B838D2B-DD94-480A-8D3D-53E0204A2282" title="Oracle-specific full-text search over XML data is described, including how to use Oracle SQL function contains and Oracle XPath function ora:contains.">Full-Text Search over XML Data Without XQuery</a> for more information about using Oracle Text operations with Oracle XML&nbsp;DB</p>
</li>
</ul>
</div>
<p>You can perform XQuery Full Text (XQFT) queries on <code>XMLType</code> data that is stored as binary XML. If you use an XQFT full-text predicate in an <code>XMLExists</code> expression within a SQL <code>WHERE</code> clause, then you must create an <strong class="term">XML search index</strong>. This section describes the creation and use of such an index.</p>
<div class="infoboxnotealso" id="GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C__GUID-3CBA64CD-769A-4B77-8E13-C01737583C86">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_xquery.htm#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a>&#34;</span></p>
</div>
</div>
<a id="ADXDB6148"></a><a id="ADXDB6149"></a><a id="ADXDB6150"></a><a id="ADXDB6147"></a>
<div class="props_rev_3"><a id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55"></a>
<h3 id="ADXDB-GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55" class="sect3"><span class="enumeration_section">6.4.1</span> Creating and Using an XML Search Index</h3>
<div>
<p>An XQuery Full Text query can use an XML search index to improve performance.</p>
<div class="section">
<p>To create an XML search index you must be granted database role <a id="d38232e10014" class="indexterm-anchor"></a><a id="d38232e10016" class="indexterm-anchor"></a><code>CTXAPP</code>. More generally, this role is needed to create Oracle Text indexes, to set Oracle Text index preferences, or to use Oracle Text PL/SQL packages.</p>
<p>Before creating the index, you must create an Oracle Text path section group and set its <a id="d38232e10025" class="indexterm-anchor"></a><code>XML_ENABLE</code> attribute to <code>t</code>. This makes the path section group XML-aware.</p>
<p>For best performance, create an index preference of type <code>BASIC_STORAGE</code> in the Oracle Text data dictionary, specifying the following attributes:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code>D_TABLE_CLAUSE</code> &ndash; Specify <code>SECUREFILE</code> storage for column <code>DOC</code> of index data table <code>$D</code>, which contains information about the structure of your XML documents. Specify <span class="italic">caching</span> and medium <span class="italic">compression</span>.</p>
</li>
<li>
<p><code>I_TABLE_CLAUSE</code> &ndash; Specify <code>SECUREFILE</code> storage for column <code>TOKEN_INFO</code> of index data table <code>$I</code>, which contains information about full-text tokens and their occurrences in the indexed documents. Specify <span class="italic">caching</span> (but not compression).</p>
</li>
</ul>
<p>This is illustrated in <a href="xdb_indexing.htm#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">Example 6-38</a>, which uses a non XML-schema-based <code>XMLType</code> table, <code>po_binxml</code> (which has the same data as table <code>purchaseorder</code> in standard database schema <code>OE</code>).</p>
<p>Index preference <code>BASIC_STORAGE</code> specifies the tablespace and creation parameters for the database tables and indexes that constitute an Oracle Text index.</p>
<div class="infoboxnotealso" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__GUID-DD6B5E3A-7690-475E-AFEB-72D64801F97A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CCREF0234" target="_blank" href="../CCREF/cdatadic.htm#CCREF0234"><span class="italic">Oracle Text Reference</span></a> for information about section groups</p>
</li>
<li>
<p><a class="olink CCREF24098" target="_blank" href="../CCREF/cddlpkg.htm#CCREF24098"><span class="italic">Oracle Text Reference</span></a> for information about procedure <code>CTX_DDL.set_sec_grp_attr</code></p>
</li>
<li>
<p><a class="olink CCREF0624" target="_blank" href="../CCREF/cddlpkg.htm#CCREF0624"><span class="italic">Oracle Text Reference</span></a> for information about procedure <code>CTX_DDL.create_preference</code></p>
</li>
<li>
<p><a class="olink CCREF0650" target="_blank" href="../CCREF/cddlpkg.htm#CCREF0650"><span class="italic">Oracle Text Reference</span></a> for information about procedure <code>CTX_DDL.set_attribute</code></p>
</li>
<li>
<p><a class="olink CCREF2028" target="_blank" href="../CCREF/cdatadic.htm#CCREF2028"><span class="italic">Oracle Text Reference</span></a> for information about preference <code>BASIC_STORAGE</code>, <code>D_TABLE_CLAUSE</code>, and <code>I_TABLE_CLAUSE</code></p>
</li>
</ul>
</div>
<p><a href="xdb_indexing.htm#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGJABCA">Example 6-39</a> queries the data to retrieve the <code>Description</code> elements whose text contains both <code>Big</code> and <code>Street</code>, in that order.</p>
<p><a href="xdb_indexing.htm#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGCHDFB">Example 6-40</a> shows the execution plan for the query, which indicates that index <code>po_ctx_idx</code> is picked up.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">
<p class="titleinexample">Example 6-38 Creating an XML Search Index</p>
<pre dir="ltr">BEGIN
  CTX_DDL.<span class="bold">create_section_group</span>(&#39;mysecgroup&#39;, &#39;<span class="bold">PATH_SECTION_GROUP</span>&#39;);
  CTX_DDL.<span class="bold">set_sec_grp_attr</span>(&#39;mysecgroup&#39;, &#39;<span class="bold">XML_ENABLE</span>&#39;, &#39;<span class="bold">T</span>&#39;);

  CTX_DDL.<span class="bold">create_preference</span>(&#39;mypref&#39;, &#39;<span class="bold">BASIC_STORAGE</span>&#39;);
  CTX_DDL.<span class="bold">set_attribute</span>(&#39;mypref&#39;,
                        &#39;<span class="bold">D_TABLE_CLAUSE</span>&#39;,
                        &#39;TABLESPACE my_ts
                         <span class="bold">LOB(DOC)</span> <span class="bold">STORE AS SECUREFILE</span> 
                         <span class="bold">(TABLESPACE</span> my_ts <span class="bold">COMPRESS MEDIUM CACHE)</span>&#39;);
  CTX_DDL.<span class="bold">set_attribute</span>(&#39;mypref&#39;,
                        &#39;<span class="bold">I_TABLE_CLAUSE</span>&#39;,
                        &#39;TABLESPACE my_ts
                         <span class="bold">LOB(TOKEN_INFO)</span> <span class="bold">STORE AS SECUREFILE</span>
                         <span class="bold">(TABLESPACE</span> my_ts <span class="bold">NOCOMPRESS CACHE)</span>&#39;);
END;
/

CREATE INDEX po_ctx_idx ON po_binxml(OBJECT_VALUE)
  INDEXTYPE IS <span class="bold">CTXSYS.CONTEXT</span>
  PARAMETERS(&#39;<span class="bold">storage</span> mypref <span class="bold">section group</span> mysecgroup&#39;);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGJABCA">
<p class="titleinexample">Example 6-39 XQuery Full Text Query</p>
<pre dir="ltr">SELECT XMLQuery(&#39;for $i in /PurchaseOrder/LineItems/LineItem/Description
                   where $i[<span class="bold">. contains text &#34;Big&#34; ftand &#34;Street&#34;</span>]
               return &lt;Title&gt;{$i}&lt;/Title&gt;&#39;
               PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM po_binxml
  WHERE XMLExists(&#39;/PurchaseOrder/LineItems/LineItem/Description
                   [<span class="bold">. contains text &#34;Big&#34; ftand &#34;Street&#34;</span>]&#39;
                  PASSING OBJECT_VALUE);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGCHDFB">
<p class="titleinexample">Example 6-40 Execution Plan for XQuery Full Text Query</p>
<pre dir="ltr">------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |     1 |  2014 |     4   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| PO_BINXML  |     1 |  2014 |     4   (0)| 00:00:01 |
|*  2 |   DOMAIN INDEX              | <span class="bold">PO_CTX_IDX</span> |       |       |     4   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access(&#34;CTXSYS&#34;.&#34;CONTAINS&#34;(SYS_MAKEXML(0,&#34;XMLDATA&#34;),&#39;&lt;query&gt;&lt;textquery
              grammar=&#34;CONTEXT&#34; lang=&#34;english&#34;&gt; <span class="bold">( ( {Big} ) and ( {Street} ) )</span>  INPATH
              (/PurchaseOrder/LineItems/LineItem/<span class="bold">Description</span>)&lt;/textquery&gt;&lt;/query&gt;&#39;)&gt;0)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
   - Unoptimized XML construct detected (enable XMLOptimizationCheck for more information)
 
21 rows selected.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6151"></a>
<div class="props_rev_3"><a id="GUID-BB2425FE-DD0F-414B-8166-906C77F824FD"></a>
<h3 id="ADXDB-GUID-BB2425FE-DD0F-414B-8166-906C77F824FD" class="sect3"><span class="enumeration_section">6.4.2</span> What To Do If an XML Search Index Is Not Picked Up</h3>
<div>
<p>You can modify your query to ensure that certain conditions are satisfied, so its evaluation picks up an XML search index.</p>
<div class="section">
<p>If you use an XQuery full-text predicate in an <code>XMLExists</code> expression within a SQL <code>WHERE</code> clause, but you do not create an XML search index or the index cannot be used for some reason, then compile-time error ORA-18177 is raised.</p>
<p>If this error is raised then your execution plan does not indicate that the index is picked up: in the plan you do not see operation <code>DOMAIN INDEX</code> followed by the name of the index.</p>
<p>In that case, try to change your query to enable the index to be used. The following conditions must both apply for the index to be picked up:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The expression that computes the XML nodes for the search context must be an XPath expression whose steps are only along <span class="italic">forward</span> and <span class="italic">descendent axes</span>.</p>
</li>
<li>
<p>You can pass only one <code>XMLType</code> instance as a SQL expression in the <code>PASSING</code> clause of SQL/XML function <code>XMLExists</code>, and each of the other, non-<code>XMLType</code> SQL expressions in that clause must be either a <span class="italic">compile-time constant</span> of a SQL built-in data type or a <span class="italic">bind variable</span> that is bound to an instance of such a data type.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDB6153"></a><a id="ADXDB6154"></a><a id="ADXDB6152"></a>
<div class="props_rev_3"><a id="GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2"></a>
<h3 id="ADXDB-GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2" class="sect3"><span class="enumeration_section">6.4.3</span> Pragma ora:no_schema: Using XML Schema-Based Data with XQuery Full Text</h3>
<div>
<p>Oracle recommends in general that you use <span class="italic">non</span> XML Schema-based <code>XMLType</code> data when you use XQuery Full Text and an XML search index. But you can in some circumstances use XML Schema-based <code>XMLType</code> data that is stored as binary XML. Oracle XQuery pragma <code>ora:no_schema</code> can be useful in this context.</p>
<p>By default, when an XML search index is used to evaluate XML Schema-based data, compile-time error <a id="d38232e10386" class="indexterm-anchor"></a><a id="d38232e10388" class="indexterm-anchor"></a>ORA-18177 is raised. This is because the full-text indexing itself makes no use of the associated XML schema: it is not type-aware. It treats all of the text that it applies to as untyped. This error is raised even if you type-cast data appropriately and thus do not depend on the XML schema to cast types implicitly. <a href="xdb_indexing.htm#GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGIEJJA">Example 6-41</a> illustrates this.</p>
<p>The error raised draws this to your attention, in case you might be expecting a full-text condition in your query to depend on XML Schema types and typed operations.</p>
<p>In order to use a condition that depends on types you must explicitly cast the relevant XQuery expressions to the appropriate types. Do not expect Oracle XML&nbsp;DB to use the XML schema to perform implicit type casting. Failure to type-cast appropriately can lead to results that you might not expect.</p>
<p><a href="xdb_indexing.htm#GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGBHDEE">Example 6-42</a> shows a query of XML Schema-based data that uses explicit type-casting to ensure that the proper condition is evaluated.</p>
<p>However, most uses of XQuery Full Text expressions, even with XML Schema-based data, do not involve data that is typed. Just remember that if you do use a condition that makes use of typed data then you must cast to the proper type.</p>
<p>In sum, if you are sure that your query does not involve typed data, or if you judge that it is all right to treat particular typed data as if it were untyped, or if you explicitly type-cast any data that needs to be typed, then you can use Oracle XQuery pragma <code>ora:no_schema</code> in your query to inhibit raising the error and allow evaluation of the query using an XML search index.</p>
<div class="example" id="GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGIEJJA">
<p class="titleinexample">Example 6-41 XQuery Full Text Query with XML Schema-Based Data: Error ORA-18177</p>
<pre dir="ltr">SELECT XMLQuery(&#39;/PurchaseOrder/LineItems/LineItem&#39;
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM oe.purchaseorder
  WHERE XMLExists(&#39;/PurchaseOrder
                   [LineItems/LineItem/@ItemNumber &gt; xs:integer(&#34;20&#34;)
                    and Actions/Action/User contains text &#34;KPARTNER&#34;]&#39;
                  PASSING OBJECT_VALUE);
  FROM oe.purchaseorder
          *
ERROR at line 3:
<span class="bold">ORA-18177</span>: XQuery full text expression &#39;/PurchaseOrder
[LineItems/LineItem/@ItemNumber &gt; xs:integer(&#34;20&#34;)
and Actions/Action/User contains text &#34;KPARTNER&#34;]&#39;
<span class="bold">cannot be evaluated using XML text index</span>
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGBHDEE">
<p class="titleinexample">Example 6-42 Using XQuery Pragma ora:no_schema with XML Schema-Based Data</p>
<pre dir="ltr">SELECT XMLQuery(&#39;/PurchaseOrder/LineItems/LineItem&#39;
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM oe.purchaseorder
  WHERE XMLExists(&#39;<span class="bold">(# ora:no_schema #)</span>
                   {/PurchaseOrder
                    [LineItems/LineItem/@ItemNumber &gt; <span class="bold">xs:integer</span>(&#34;20&#34;)
                     and Actions/Action/User contains text &#34;KPARTNER&#34;]}&#39;
                  PASSING OBJECT_VALUE);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB5830"></a><a id="ADXDB6155"></a>
<div class="props_rev_3"><a id="GUID-748DD8D4-2311-4D02-B050-A5940204A2A9"></a>
<h3 id="ADXDB-GUID-748DD8D4-2311-4D02-B050-A5940204A2A9" class="sect3"><span class="enumeration_section">6.4.4</span> Pragma ora:use_xmltext_idx: Forcing the Use of an XML Search Index</h3>
<div>
<p>You can use XQuery pragma <code>ora:use_xmltext_idx</code> to force the use of an XML search index.</p>
<p>A given query involving XML data can be evaluated in various ways, depending on the existence of different indexes and other factors. Sometimes the default evaluation method is not the most performant and it would be more efficient to force the use of an existing XML search index. You can use XQuery pragma <code>ora:use_xmltext_idx</code> to do this. (An XML search index applies only to <code>XMLType</code> data stored as binary XML.)</p>
<p>For example, a <code>WHERE</code> clause might include two <code>XMLExists</code> expressions, only one of which involves an XQuery full-text condition, and you might have an <code>XMLIndex</code> index that applies to the <code>XMLExists</code> expression that has no full-text condition. With such a query it is typically more efficient to use an XML search index to evaluate the entire <code>WHERE</code> clause.</p>
<p>Even in some cases where there is no full-text condition in the query, the use of an XML search index can provide the most efficient query evaluation.</p>
<p>The query in <a href="xdb_indexing.htm#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-43</a> illustrates the use of pragma <code>ora:use_xmltext_idx</code>. Only the first of the <code>XMLExists</code> clauses uses a full-text condition. Because of the pragma, the full-text index (<code>po_ctx_idx</code>, created in <a href="xdb_indexing.htm#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">Example 6-38</a>) is used for both <code>XMLExists</code> clauses.</p>
<div class="example" id="GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">
<p class="titleinexample">Example 6-43 Full-Text Query with XQuery Pragma ora:use_xmltext_idx</p>
<pre dir="ltr">SELECT XMLQuery(&#39;/PurchaseOrder/LineItems/LineItem&#39;
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM po_binxml
  WHERE XMLExists(&#39;/PurchaseOrder/LineItems/LineItem
                   [Description contains text &#34;Picnic&#34;]&#39; PASSING OBJECT_VALUE)
    AND XMLExists(&#39;<span class="bold">(# ora:use_xmltext_idx #)</span> {/PurchaseOrder[User=&#34;SBELL&#34;]}&#39;
                  PASSING OBJECT_VALUE);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB6157"></a><a id="ADXDB6156"></a>
<div class="props_rev_3"><a id="GUID-85F61312-2713-416F-B741-85C2E2D4A13E"></a>
<h3 id="ADXDB-GUID-85F61312-2713-416F-B741-85C2E2D4A13E" class="sect3"><span class="enumeration_section">6.4.5</span> Migrating from Using Oracle Text Index to XML Search Index</h3>
<div>
<p>If you have legacy queries for <code>XMLType</code> data stored as binary XML that use SQL function <code>CONTAINS</code> or XPath function <code>ora:contains</code> and an Oracle Text index that is not XML-enabled, then consider using XQuery Full Text constructs instead.</p>
<div class="section">
<p>The XQuery and XPath Full Text (XQFT) standard is supported by Oracle XML&nbsp;DB starting with Oracle Database&nbsp;12c Release 1 (12.1). This support applies only to <code>XMLType</code> data stored as binary XML. Prior to that release, for full-text querying of XML data you could use only an Oracle Text index that was not XML-enabled (not an XML search index), and your full-text queries necessarily used Oracle-specific constructs: SQL function <code>CONTAINS</code> or XPath function <code>ora:contains</code>.</p>
<p>If you have legacy code that does this, Oracle recommends that you migrate that code to use XQFT. This section provides information about which XQFT constructs you can use to replace the use of <code>CONTAINS</code> and <code>ora:contains</code> in queries.</p>
<p>In addition to its use for full-text queries, an Oracle Text index that is not XML-enabled (is not an XML search index) can also be used with the Oracle Text structure operator <code>HASPATH</code>, which tests for the existence of a given document section; that is, it tests whether a given XPath expression has a non-null target.</p>
<p>This use of the index can also be replaced by the use of an XML search index. To replace a query that uses <code>HASPATH</code> by one that uses a simple XQuery expression, you use Oracle XQuery pragma <code>ora:use_xmltext_idx</code> to specify that the XML search index is to be picked up. This section also illustrates this.</p>
<p><a href="xdb_indexing.htm#GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGECFIA" title="Migrating XML Queries with HASPATH to XQuery Full Text">Table 6-9</a> provides a mapping from typical queries that use Oracle-specific constructs to queries that use XQuery Full Text.</p>
<div class="tblformalwide" id="GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGECFIA">
<p class="titleintable">Table 6-9 Migrating Oracle-Specific XML Queries to XQuery Full Text</p>
<table class="cellalignment3431" title="Migrating Oracle-Specific XML Queries to XQuery Full Text" summary="Migrating XML Queries with HASPATH to XQuery Full Text">
<thead>
<tr class="cellalignment3411">
<th class="cellalignment3425" id="d38232e10603">Original Example</th>
<th class="cellalignment3425" id="d38232e10606">Replacement Example</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10611" headers="d38232e10603">
<pre dir="ltr">CONTAINS(t.x, &#39;<span class="bold">HASPATH</span> (/P/LIs/LI/Description<a id="GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGBBCGC" href="#GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGBBCGC" onclick="footdisplay(3,&#34;The path test can contain a predicate expression, which is the same for both the original query (with HASPATH) and its replacement. For example: /PurchaseOrder/LineItems/LineItem/Part[@Id &lt; \&#34;31415927\&#34;]. &#34;)"><sup>Foot 3</sup></a>)&#39;) &gt; 0
</pre></td>
<td class="cellalignment3426" headers="d38232e10611 d38232e10606">
<pre dir="ltr">XMLExists(&#39;<span class="bold">(# ora:use_xmltext_idx #)</span> 
           {$d/P/LIs/LI/Description<a id="fnsrc_d38232e10633" href="#fnsrc_d38232e10633" onclick="footdisplay(3,&#34;The path test can contain a predicate expression, which is the same for both the original query (with HASPATH) and its replacement. For example: /PurchaseOrder/LineItems/LineItem/Part[@Id &lt; \&#34;31415927\&#34;]. &#34;)"><sup>Footref 3</sup></a>}&#39;
          PASSING t.x AS &#34;d&#34;)
</pre>
<p>Or if the data is XML Schema-based:</p>
<pre dir="ltr">XMLExists(&#39;<span class="bold">(# ora:use_xmltext_idx #)</span>
           {<span class="bold">(# ora:no_schema #)</span> 
            {$d/P/LIs/LI/Description<a id="fnsrc_d38232e10646" href="#fnsrc_d38232e10646" onclick="footdisplay(3,&#34;The path test can contain a predicate expression, which is the same for both the original query (with HASPATH) and its replacement. For example: /PurchaseOrder/LineItems/LineItem/Part[@Id &lt; \&#34;31415927\&#34;]. &#34;)"><sup>Footref 3</sup></a>}}&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10650" headers="d38232e10603">
<pre dir="ltr">CONTAINS(t.x, &#39;Big INPATH
               (/P/LIs/LI/Description)&#39;) &gt; 0
</pre></td>
<td class="cellalignment3426" headers="d38232e10650 d38232e10606">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [. contains text &#34;Big&#34;]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre>
<p>Or if the data is XML Schema-based:</p>
<pre dir="ltr">XMLExists(&#39;<span class="bold">(# ora:no_schema #)</span>
           {$d/P/LIs/LI/Description
           [. contains text &#34;Big&#34;]}&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10664" headers="d38232e10603">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [<span class="bold">ora:contains</span>(., &#34;Big <span class="bold">AND</span> Street&#34;) &gt; 0]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
<td class="cellalignment3426" headers="d38232e10664 d38232e10606">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [. contains text &#34;Big&#34; <span class="bold">ftand</span> &#34;Street&#34;]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10680" headers="d38232e10603">
<pre dir="ltr">CONTAINS(t.x, &#39;(Big) <span class="bold">AND</span> (Street) INPATH
               (/P/LIs/LI/Description)&#39;) &gt; 0
</pre></td>
<td class="cellalignment3426" headers="d38232e10680 d38232e10606">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [. contains text &#34;Big&#34; <span class="bold">ftand</span> &#34;Street&#34;]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10693" headers="d38232e10603">
<pre dir="ltr">CONTAINS(t.x, &#39;(Big) <span class="bold">OR</span> (Street) INPATH
               (/P/LIs/LI/Description)&#39;) &gt; 0
</pre></td>
<td class="cellalignment3426" headers="d38232e10693 d38232e10606">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [. contains text &#34;Big&#34; <span class="bold">ftor</span> &#34;Street&#34;]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10706" headers="d38232e10603">
<pre dir="ltr">CONTAINS(t.x, &#39;({Big}) <span class="bold">NOT</span> ({Street}) INPATH
               (/P/LIs/LI/Description)&#39;) &gt; 0
</pre></td>
<td class="cellalignment3426" headers="d38232e10706 d38232e10606">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [. contains text
            &#34;Big&#34; <span class="bold">ftand</span> <span class="bold">ftnot</span> &#34;Street&#34;]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10722" headers="d38232e10603">
<pre dir="ltr">CONTAINS(t.x, &#39;({Street}) <span class="bold">MNOT</span> ({Big Street}) INPATH
               (/P/LIs/LI/Description)&#39;) &gt; 0
</pre></td>
<td class="cellalignment3426" headers="d38232e10722 d38232e10606">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [. contains text
            &#34;Street&#34; <span class="bold">not in</span> &#34;Big Street&#34;]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10735" headers="d38232e10603">
<pre dir="ltr">CONTAINS(t.x, &#39;(<span class="bold">NEAR</span> (({Big}, {Street}), <span class="bold">3</span>) INPATH
               (/P/LIs/LI/Description)&#39;) &gt; 0
</pre></td>
<td class="cellalignment3426" headers="d38232e10735 d38232e10606">
<pre dir="ltr">XMLExists(&#39;$d/P/LIs/LI/Description
           [. contains text
            &#34;Big&#34; <span class="bold">ftand</span> &#34;Street&#34; <span class="bold">window 3 words</span>]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
<tr class="cellalignment3411">
<td class="cellalignment3426" id="d38232e10754" headers="d38232e10603">
<p>(Not applicable &ndash; Oracle Text queries are not XML namespace aware.)</p>
</td>
<td class="cellalignment3426" headers="d38232e10754 d38232e10606">
<pre dir="ltr">XMLExists(&#39;<span class="bold">declare namespace</span>
           <span class="bold">ipo=&#34;http://www.example.com/IPO&#34;;</span>
           /<span class="bold">ipo:</span>P/<span class="bold">ipo:</span>LIs/<span class="bold">ipo:</span>LI/<span class="bold">ipo:</span>Description
           [. contains text &#34;Big&#34;]&#39;
          PASSING t.x AS &#34;d&#34;)
</pre></td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;3</sup></p>
<p>The path test can contain a predicate expression, which is the same for both the original query (with <code>HASPATH</code>) and its replacement. For example: <code>/PurchaseOrder/LineItems/LineItem/Part[@Id &lt; &#34;31415927&#34;]</code>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDB4320"></a>
<div class="props_rev_3"><a id="GUID-BF638421-9D6E-4D72-8371-79D084A04BCA"></a>
<h2 id="ADXDB-GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" class="sect2"><span class="enumeration_section">6.5</span> Indexing XMLType Data Stored Object-Relationally</h2>
<div>
<p>You can effectively index <code>XMLType</code> data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.</p>
<div class="section">
<p>If the data to be indexed is a <span class="italic">singleton</span>, that is, if it can occur only once in any XML instance document, then you can use a <span class="italic">shortcut</span> of ostensibly creating a function-based index, where the expression defining the index is a functional application, with an XPath-expression argument that targets the singleton data. A shortcut is defined for <code>XMLCast</code> applied to <code>XMLQuery</code>, and another shortcut is defined for (deprecated) Oracle SQL function <code>extractValue</code>.</p>
<p>In many cases, Oracle XML&nbsp;DB then automatically creates appropriate indexes on the underlying object-relational tables or columns; it does <span class="italic">not</span> create a function-based index on the targeted <code>XMLType</code> data as the <code>CREATE INDEX</code> statement would suggest.</p>
<p>In the case of the <code>extractValue</code> shortcut, the index created is a B-tree index. In the case of <code>XMLCast</code> applied to <code>XMLQuery</code>, the index created is a function-based index on the scalar value resulting from the functional expression. <span class="q">&#34;<a href="xdb_indexing.htm#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E" title="Table purchaseorder in sample database schema OE is stored object-relationally. Each purchase-order document has a single Reference element; this element is a singleton. You can thus use a shortcut to create an index on the underlying object-relational data.">Indexing Non-Repeating Text Nodes or Attribute Values</a>&#34;</span> describes this.</p>
<p>If the data to be indexed is a <span class="italic">collection</span>, then you cannot use such a shortcut; you must create the B-tree indexes manually. <span class="q">&#34;<a href="xdb_indexing.htm#GUID-8B74D3E8-506C-450E-882A-77F71C051F93" title="In XMLType data stored object-relationally, a collection is stored as an ordered collection table (OCT) of an XMLType instance, which means that you can directly access its members. Because object-relational storage directly reflects the fine-grained structure of the XML data, you can create indexes that target individual collection members.">Indexing Repeating (Collection) Elements</a>&#34;</span> describes this.</p>
<div class="infoboxnotealso" id="GUID-BF638421-9D6E-4D72-8371-79D084A04BCA__GUID-652F054E-603A-4D63-B4C7-E6EAF52C8EA6">
<p class="notep1">See Also:</p>
<p><a href="app_depr_otext.htm#GUID-1B838D2B-DD94-480A-8D3D-53E0204A2282" title="Oracle-specific full-text search over XML data is described, including how to use Oracle SQL function contains and Oracle XPath function ora:contains.">Full-Text Search over XML Data Without XQuery</a> for information about indexing <code>XMLType</code> data stored object-relationally for full-text search</p>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDB4326"></a><a id="ADXDB5818"></a><a id="ADXDB4325"></a>
<div class="props_rev_3"><a id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E"></a>
<h3 id="ADXDB-GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E" class="sect3"><span class="enumeration_section">6.5.1</span> Indexing Non-Repeating Text Nodes or Attribute Values</h3>
<div>
<p>Table <code>purchaseorder</code> in sample database schema <code>OE</code> is stored object-relationally. Each purchase-order document has a single <code>Reference</code> element; this element is a singleton. You can thus use a shortcut to create an index on the underlying object-relational data.</p>
<div class="section">
<p><a href="xdb_indexing.htm#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__CHDBJCCI">Example 6-44</a> shows a <code>CREATE INDEX</code> statement that ostensibly tries to create a function-based index using <code>XMLCast</code> applied to <code>XMLQuery</code>, targeting the text content of element <code>Reference</code>. (The content of this element is only text, so targeting the element is the same as targeting its text node using XPath node test <code>text()</code>.)</p>
<p><a href="xdb_indexing.htm#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__BCGFIDAE">Example 6-45</a> ostensibly tries to create a function-based index using (deprecated) Oracle SQL function <code>extractValue</code>, targeting the same data.</p>
<p>In reality, in both <a href="xdb_indexing.htm#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__CHDBJCCI">Example 6-44</a> and <a href="xdb_indexing.htm#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__BCGFIDAE">Example 6-45</a> no function-based index is created on the targeted <code>XMLType</code> data. Instead, Oracle XML&nbsp;DB rewrites the <code>CREATE INDEX</code> statements to create indexes on the underlying scalar data.</p>
<div class="infoboxnotealso" id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__GUID-51DD6FB9-02E9-44BD-A1E5-714F71CE3BFE">
<p class="notep1">See Also:</p>
<p><a href="xdb_rewrite.htm#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACDBHCJ">Example 19-7</a> and <a href="xdb_rewrite.htm#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCAJDI">Example 19-8</a> for information about XPath rewrite as it applies to such <code>CREATE INDEX</code> statements</p>
</div>
<p>In some cases when you use either of these shortcuts, the <code>CREATE INDEX</code> statement is not able to create an index on the underlying scalar data as described, and it instead actually does create a function-based index on the referenced <code>XMLType</code> data. (This is so, even if the <span class="italic">value</span> of the index might be a scalar.)</p>
<p>If this happens, drop the index, and create instead an <code>XMLIndex</code> index with a structured component that targets the same XPath. As a general rule, Oracle recommends against using a function-based index on <code>XMLType</code> data.</p>
<p>This is an instance of a general rule for <code>XMLType</code> data, regardless of the storage method used: Use an <code>XMLIndex</code> with a structured component instead of a function-based index. This rule applies starting with Oracle Database&nbsp;11<span class="italic">g</span> Release&nbsp;2 (11.2). Respecting this rule obviates the overhead associated with maintenance operations on function-based indexes, and it can increase the number of situations in which the optimizer can correctly select the index.</p>
<div class="infoboxnotealso" id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__GUID-C45A076F-330D-494D-9259-A5FBB18E0753">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="xdb_indexing.htm#GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" title="In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with XMLType data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of XMLIndex instead.">Function-Based Indexes Are Deprecated for XMLType</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__CHDBJCCI">
<p class="titleinexample">Example 6-44 CREATE INDEX Using XMLCAST and XMLQUERY on a Singleton Element</p>
<pre dir="ltr">CREATE INDEX po_reference_ix ON purchaseorder
  (XMLCast(XMLQuery (&#39;$p/PurchaseOrder/Reference&#39; PASSING po.OBJECT_VALUE AS &#34;p&#34;
                                                  RETURNING CONTENT)
              AS VARCHAR2(128)));
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__BCGFIDAE">
<p class="titleinexample">Example 6-45 CREATE INDEX Using EXTRACTVALUE on a Singleton Element</p>
<pre dir="ltr">CREATE INDEX po_reference_ix ON purchaseorder
  (extractValue(OBJECT_VALUE, &#39;/PurchaseOrder/Reference&#39;));
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDB4328"></a>
<div class="props_rev_3"><a id="GUID-8B74D3E8-506C-450E-882A-77F71C051F93"></a>
<h3 id="ADXDB-GUID-8B74D3E8-506C-450E-882A-77F71C051F93" class="sect3"><span class="enumeration_section">6.5.2</span> Indexing Repeating (Collection) Elements</h3>
<div>
<p>In <code>XMLType</code> data stored object-relationally, a collection is stored as an ordered collection table (OCT) of an <code>XMLType</code> instance, which means that you can directly access its members. Because object-relational storage directly reflects the fine-grained structure of the XML data, you can create indexes that target individual collection members.</p>
<div class="section">
<p>You must create such indexes manually. The special feature of automatically creating B-tree indexes when you ostensibly create a function-based index for (deprecated) Oracle SQL function <code>extractValue</code> does <span class="italic">not</span> apply to collections (the XPath expression passed to <code>extractValue</code> must target a singleton).</p>
<p>To create B-tree indexes for a collection, you must understand the structure of the SQL object that is used to manage the collection. Given this information, you can use conventional object-relational SQL code to created the indexes directly on the appropriate SQL-object attributes. Refer to <span class="q">&#34;<a href="xdb_rewrite.htm#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4" title="If a collection is stored as an ordered collection table (OCT) or as an XMLType instance, then you can directly access members of the collection. Each member becomes a table row, so you can access it directly with SQL. You can often improve performance by indexing such collection members.">Guideline: Create indexes on ordered collection tables</a>&#34;</span> for an example of how to do this.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<hr/>
<br/>
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:
<p>For <code>XMLType</code> data stored object-relationally, see <span class="q">&#34;<a href="xdb_indexing.htm#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>&#34;</span>. If your data is highly structured throughout, or your queries are not known at index creation time, then this approach might be appropriate.</p>
<br/>
Footnote&nbsp;2:
<p>The actual path table implementation may be slightly different.</p>
<br/></div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3410">
<tr>
<td class="cellalignment3417">
<table class="cellalignment3415">
<tr>
<td class="cellalignment3414"><a href="xdb04cre.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3414"><a href="xdb08tra.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3419">
<table class="cellalignment3413">
<tr>
<td class="cellalignment3414"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3414"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3414"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3414"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3414"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3414"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>


</body></html>