<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114663"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/UTL_RAW%20Package"></a><title>UTL_RAW Package</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1090"/>
<meta name="dcterms.created" content="2017-06-09T14:12:29Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Gateway for WebSphere MQ Installation and User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17930-06"/>
<meta name="dcterms.isVersionOf" content="WSMQG"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ap_pgm8.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ap_gip.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17930-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/18</span> <!-- End Header -->
<div id="WSMQG285" class="appendix"><a id="CEGGDECA"></a>
<h1 class="appendix"><span class="secnum">B</span> UTL_RAW Package</h1>
<p><a id="sthref503"></a>Use the Oracle Visual Workbench for developing applications that access WebSphere MQ through the gateway.&nbsp;The Oracle Visual Workbench defines an interface for accessing WebSphere MQ and automatically generates the PL/SQL code (the MIP) for Oracle applications to interface with the gateway.&nbsp;Refer to the <span class="italic">Oracle Procedural Gateway Visual Workbench for WebSphere MQ Installation and User&#39;s Guide for Microsoft Windows (32-Bit)</span> for more information about Oracle Visual Workbench. This appendix includes the following sections:</p>
<ul>
<li>
<p><a href="#i640856">Message Data Types</a></p>
</li>
<li>
<p><a href="#i640864">UTL_RAW Functions</a></p>
</li>
</ul>
<a id="i640856"></a>
<div id="WSMQG286" class="sect1">
<h2 class="sect1">Message Data Types</h2>
<p>Messages sent to a WebSphere MQ queue or retrieved from a WebSphere MQ queue are transferred as untyped data by the MIP procedures.&nbsp;When data profiles are defined in the <a id="sthref504"></a>MIP, the MIP converts message data from Oracle data types to target data types that the receiving application understands. The message data is packed into a buffer of the <code dir="ltr">RAW</code> data type before being sent to the WebSphere MQ queue.&nbsp;The same conversion process applies when receiving a message. The MIP unpacks the message from the buffer and converts it to specified Oracle data types.</p>
<p>The <a id="sthref505"></a>MIP uses the functions of the <code dir="ltr">UTL_RAW</code> package to perform the message data conversions.&nbsp;The <code dir="ltr">UTL_RAW</code> package is a PL/SQL package that contains procedures for converting and packing message data which is sent back and forth through the WebSphere MQ queues using the <code dir="ltr">RAW</code> data type and PL/SQL data types.</p>
<p>When necessary, you can enhance the message data conversions in the generated MIP with the <code dir="ltr">UTL_RAW</code> functions. When no data profiles are defined in the MIP, you can create your own data conversion procedures with <code dir="ltr">UTL_RAW</code> functions, calling these functions before sending a message and immediately after receiving a message.</p>
<p>The <code dir="ltr">UTL_RAW</code> package is not included with the gateway. It is shipped with each Oracle database.&nbsp;Refer to your Oracle DBA for information about installing the <code dir="ltr">UTL_RAW</code> package.</p>
</div>
<!-- class="sect1" -->
<a id="i640864"></a>
<div id="WSMQG287" class="sect1">
<h2 class="sect1">UTL_RAW Functions</h2>
<p><a id="sthref506"></a>The <code dir="ltr">UTL_RAW</code> functions are called with the following syntax:</p>
<pre dir="ltr">UTL_RAW.function(<span class="italic">arg1</span>, <span class="italic">arg2</span>, ...)
</pre>
<p>The function name, arguments, their Oracle data types, and the return value data type are provided with each function description in this appendix. For ease of description, the functions are described with PL/SQL syntax that shows the resulting function value placed in a variable as follows:</p>
<pre dir="ltr">result := UTL_RAW.function(<span class="italic">arg1</span>, <span class="italic">arg2</span>, ...);
</pre>
<p>However, the function can also be used as a component in a PL/SQL expression.&nbsp;<a id="sthref507"></a>For example, the function takes two characters strings, <span class="italic">Hello</span> and <span class="italic">world!</span>, converts them to raw message data with <a id="sthref508"></a><a id="sthref509"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">CAST_TO_RAW</code>, concatenates them with <a id="sthref510"></a><a id="sthref511"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">CONCAT</code>, and uses the gateway to send them to a WebSphere MQ queue. The same message is retrieved from the queue, converted to a character data type with <a id="sthref512"></a><a id="sthref513"></a><code dir="ltr">UTL_RAW.CAST_TO_VARCHAR2</code>, and then printed.</p>
<div id="WSMQG288" class="sect2"><a id="sthref514"></a>
<h3 class="sect2">UTL_RAW.TO_RAW</h3>
<p><code dir="ltr">PGM_UTL.TO_RAW</code> converts values of the <code dir="ltr">PGM.MQOD</code>, <code dir="ltr">PGM.MQMD</code>, <code dir="ltr">PGM.MQPMO</code> and <code dir="ltr">PGM.MQGMO</code> object to into raw values.</p>
<p class="subhead2"><a id="WSMQG359"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := PGM_UTL.TO_RAW(<span class="codeinlineitalic">input</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><span class="italic">result</span> is a variable that holds the output value of the function.&nbsp;It is of the RAW data type.</p>
</li>
<li>
<p><span class="italic">input</span> is the input value of the <code dir="ltr">PGM</code>.<code dir="ltr">MQOD</code>, <code dir="ltr">PGM</code>.<code dir="ltr">MQMD</code>, <code dir="ltr">PGM</code>.<code dir="ltr">MQPMO</code> or <code dir="ltr">PGM</code>.<code dir="ltr">MQGMO</code> data type objects that is converted to raw data.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG289" class="sect2"><a id="sthref515"></a>
<h3 class="sect2">UTL_RAW.BIT_AND</h3>
<p><a id="sthref516"></a><a id="sthref517"></a><code dir="ltr">UTL_RAW.BIT_AND</code> performs a bitwise logical <code dir="ltr">AND</code> operation on two raw values.&nbsp;If the values have different lengths, then the <code dir="ltr">AND</code> operation is terminated after the last byte of the shorter of the two values.&nbsp;The unprocessed portion of the longer value is appended to the partial result to produce the final result. The length of the resulting value equals the longer of the two input values.</p>
<p class="subhead2"><a id="WSMQG360"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.BIT_AND(<span class="italic">input1</span>, <span class="italic">input2</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p>result is the variable that holds the output value of the function.&nbsp;It is data type RAW.&nbsp;The value is null if <code dir="ltr"><span class="codeinlineitalic">input1</span></code> or <code dir="ltr"><span class="codeinlineitalic">input2</span></code> is null.</p>
</li>
<li>
<p>input1 is an input value of data type <code dir="ltr">RAW</code> to <code dir="ltr">BIT_AND</code> with <code dir="ltr"><span class="codeinlineitalic">input2</span></code>.</p>
</li>
<li>
<p>input2 is an input value of data type <code dir="ltr">RAW</code> to <code dir="ltr">BIT_AND</code> with <code dir="ltr"><span class="codeinlineitalic">input1</span></code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG290" class="sect2"><a id="sthref518"></a>
<h3 class="sect2">UTL_RAW.BIT_COMPLEMENT</h3>
<p><a id="sthref519"></a><a id="sthref520"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">BIT_COMPLEMENT</code> performs a bitwise logical <code dir="ltr">COMPLEMENT</code> operation of a raw value.&nbsp;The length of the resulting value equals the length of the input value.</p>
<p class="subhead2"><a id="WSMQG361"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.BIT_COMPLEMENT(<span class="italic">input</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is of <code dir="ltr">RAW</code> data type.&nbsp;The value is null if <code dir="ltr"><span class="codeinlineitalic">input</span></code> is null.</p>
</li>
<li>
<p><code dir="ltr">input</code> is an input value of the <code dir="ltr">RAW</code> data type on which to perform the <code dir="ltr">COMPLEMENT</code> operation.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG291" class="sect2"><a id="sthref521"></a>
<h3 class="sect2">UTL_RAW.BIT_OR</h3>
<p><a id="sthref522"></a><a id="sthref523"></a><code dir="ltr">UTL_RAW.BIT_OR</code> performs a bitwise logical <code dir="ltr">OR</code> operation of two raw values.&nbsp;If the values have different lengths, then the <code dir="ltr">OR</code> operation is terminated after the last byte of the shorter of the two values. The unprocessed portion of the longer value is appended to the partial result to produce the final result.&nbsp;The length of the resulting value equals the length of the longer of the two input values.</p>
<p class="subhead2"><a id="WSMQG362"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.BIT_OR(<span class="italic">input1</span>, <span class="italic">input2</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is of the data type <code dir="ltr">RAW</code>. The value is null if <code dir="ltr"><span class="codeinlineitalic">input1</span></code> or <code dir="ltr"><span class="codeinlineitalic">input2</span></code> is null.</p>
</li>
<li>
<p><code dir="ltr">input1</code> is an input value of the <code dir="ltr">RAW</code> data type to <code dir="ltr">BIT_OR</code> with <code dir="ltr"><span class="codeinlineitalic">input2</span></code>.</p>
</li>
<li>
<p><code dir="ltr">input2</code> is an input value of the <code dir="ltr">RAW</code> data type to <code dir="ltr">BIT_OR</code> with <code dir="ltr"><span class="codeinlineitalic">input1</span></code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG292" class="sect2"><a id="sthref524"></a>
<h3 class="sect2">UTL_RAW.BIT_XOR</h3>
<p><a id="sthref525"></a><a id="sthref526"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">BIT_XOR</code> performs a bitwise logical <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">OR</code> operation of two raw values.&nbsp;If the values have different lengths, then the <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">OR</code> operation is terminated after the last byte of the shorter of the two values. The unprocessed portion of the longer value is appended to the partial result to produce the final result. The length of the resulting value equals the longer of the two input values.</p>
<p class="subhead2"><a id="WSMQG363"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.BIT_XOR(<span class="italic">input1</span>, <span class="italic">input2</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is data type <code dir="ltr">RAW</code>.&nbsp;The value is null if <code dir="ltr"><span class="codeinlineitalic">input1</span></code> or <code dir="ltr"><span class="codeinlineitalic">input2</span></code> is null.</p>
</li>
<li>
<p><code dir="ltr">input1</code> is an input value of the <code dir="ltr">RAW</code> data type to <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">OR</code> with <code dir="ltr"><span class="codeinlineitalic">input2</span></code>.</p>
</li>
<li>
<p><code dir="ltr">input2</code> is an input value of the <code dir="ltr">RAW</code> data type to <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">OR</code> with <code dir="ltr"><span class="codeinlineitalic">input1</span></code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG293" class="sect2"><a id="sthref527"></a>
<h3 class="sect2">UTL_RAW.CAST_TO_RAW</h3>
<p><a id="sthref528"></a><a id="sthref529"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">CAST_TO_RAW</code> converts a value of data type <code dir="ltr">VARCHAR2</code> into a raw value with the same number of bytes.&nbsp;The input value is treated as if it were composed of single 8-bit bytes, not characters.&nbsp;Multibyte character boundaries are ignored. The data is not modified in any way, it is only changed to data type <code dir="ltr">RAW</code>.</p>
<p class="subhead2"><a id="WSMQG364"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.CAST_TO_RAW(<span class="italic">input</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is data type <code dir="ltr">RAW</code>.&nbsp;The value is null if <code dir="ltr"><span class="codeinlineitalic">input</span></code> is null.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of the <code dir="ltr">VARCHAR2</code> data type to convert to raw data.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG294" class="sect2"><a id="sthref530"></a>
<h3 class="sect2">UTL_RAW.CAST_TO_VARCHAR2</h3>
<p><a id="sthref531"></a><a id="sthref532"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">CAST_TO_VARCHAR2</code> converts a raw value into a value of data type <code dir="ltr">VARCHAR2</code> with the same number of data bytes.&nbsp;The result is treated as if it were composed of single 8-bit bytes, not characters. Multibyte character boundaries are ignored. The data is not modified in any way, it is only changed to data type <code dir="ltr">VARCHAR2</code>.</p>
<p class="subhead2"><a id="WSMQG365"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.CAST_TO_VARCHAR2(<span class="italic">input</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is data type <code dir="ltr">VARCHAR2</code>.&nbsp;The value is null if <code dir="ltr"><span class="codeinlineitalic">input</span></code> is null.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of the <code dir="ltr">RAW</code> data type to convert to data type <code dir="ltr">VARCHAR2</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG295" class="sect2"><a id="sthref533"></a>
<h3 class="sect2">UTL_RAW.COMPARE</h3>
<p><a id="sthref534"></a><a id="sthref535"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">COMPARE</code> compares one raw value to another raw value. If they are identical, then <code dir="ltr">UTL_RAW</code>.<code dir="ltr">COMPARE</code> returns 0.&nbsp;If they are not identical, then <code dir="ltr">COMPARE</code> returns the position of the first byte that does not match.&nbsp;If the input values have different lengths, then the shorter input value is padded on the right by a value that you specify.</p>
<p class="subhead2"><a id="WSMQG366"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.COMPARE(<span class="italic">input1</span>, <span class="italic">input2</span>[, <span class="italic">pad</span>]);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is of data type <code dir="ltr">NUMBER</code>. A value of 0 is returned if the values of <code dir="ltr"><span class="codeinlineitalic">input1</span></code> and <code dir="ltr"><span class="codeinlineitalic">input2</span></code> are null or identical or the position, numbered from&nbsp;1, of the first mismatched byte.</p>
</li>
<li>
<p><code dir="ltr">input1</code> is the first input value of the <code dir="ltr">RAW</code> data type to compare.</p>
</li>
<li>
<p><code dir="ltr">input2</code> is the second input value of the <code dir="ltr">RAW</code> data type to compare.</p>
</li>
<li>
<p><code dir="ltr">padis</code> a single byte value used to pad the shorter input value. The default is X&#39;00&#39;.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG296" class="sect2"><a id="sthref536"></a>
<h3 class="sect2">UTL_RAW.CONCAT</h3>
<p><a id="sthref537"></a><a id="sthref538"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">CONCAT</code> concatenates a set of up to 12&nbsp;raw values into a single raw value.&nbsp; The values are appended together, left to right, in the order that they appear in the parameter list.&nbsp;Null input values are skipped, and the concatenation continues with the next non-null value.</p>
<p>If the sum of the lengths of the input values exceeds 32&nbsp;767&nbsp;bytes, then a <code dir="ltr">VALUE_ERROR</code> exception is raised.</p>
<p class="subhead2"><a id="WSMQG367"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.CONCAT(<span class="italic">input1</span>, ...  <span class="italic">input12</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is data type <code dir="ltr">RAW</code>.&nbsp;</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">input1</span></code>&nbsp;<code dir="ltr"><span class="codeinlineitalic">...</span></code><code dir="ltr"><span class="codeinlineitalic">&nbsp; input12</span></code> are the input values of <code dir="ltr">RAW</code> data type to concatenate.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG297" class="sect2"><a id="sthref539"></a>
<h3 class="sect2">UTL_RAW.CONVERT</h3>
<p><a id="sthref540"></a><a id="sthref541"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">CONVERT</code> converts a raw value to a different character set <code dir="ltr">A</code> <code dir="ltr">VALUE_ERROR</code> exception is raised for any of the following conditions:</p>
<ul>
<li>
<p>The input value is null or 0 in length</p>
</li>
<li>
<p>One or both of the specified character sets is missing, null, or 0 in length</p>
</li>
<li>
<p>The character set names are invalid or unsupported by the Oracle database</p>
</li>
</ul>
<p class="subhead2"><a id="WSMQG368"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.CONVERT(<span class="italic">input</span>, <span class="codeinlineitalic">new_charset</span>, <span class="codeinlineitalic">old_charset</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is of the <code dir="ltr">RAW</code> data type.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of the <code dir="ltr">RAW</code> data type to convert.</p>
</li>
<li>
<p><code dir="ltr">new_charset</code> is the Globalization Support character set to convert <code dir="ltr"><span class="codeinlineitalic">input</span></code> to.</p>
</li>
<li>
<p><code dir="ltr">old_charset</code> is the Globalization Support character set that input is currently using.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG298" class="sect2"><a id="sthref542"></a>
<h3 class="sect2">UTL_RAW.COPIES</h3>
<p><a id="sthref543"></a><a id="sthref544"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">COPIES</code> returns one or more copies of a value.&nbsp;The values are concatenated together. <code dir="ltr">A</code> <code dir="ltr">VALUE_ERROR</code> exception is raised for any of the following conditions:</p>
<ul>
<li>
<p>The input value is null or has a length of 0</p>
</li>
<li>
<p>A negative number of copies is specified</p>
</li>
<li>
<p>The length of the result exceeds 32&nbsp;767&nbsp;bytes</p>
</li>
</ul>
<p class="subhead2"><a id="WSMQG369"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.COPIES(<span class="italic">input</span>, <span class="italic">number</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is of the <code dir="ltr">RAW</code> data type.</p>
</li>
<li>
<p><code dir="ltr">input</code> is a value of the <code dir="ltr">RAW</code> data type to copy.</p>
</li>
<li>
<p><code dir="ltr">number</code> is the number of times to copy input.&nbsp;It must be a positive value.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG299" class="sect2"><a id="sthref545"></a>
<h3 class="sect2">UTL_RAW.LENGTH</h3>
<p><a id="sthref546"></a><a id="sthref547"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">LENGTH</code> returns the length, in bytes, of a raw value.</p>
<p class="subhead2"><a id="WSMQG370"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.LENGTH(<span class="italic">input</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the output value of the function.&nbsp;It is of the <code dir="ltr">NUMBER</code> data type.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of the RAW data type to evaluate.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG300" class="sect2"><a id="sthref548"></a>
<h3 class="sect2">UTL_RAW.OVERLAY</h3>
<p><a id="sthref549"></a><a id="sthref550"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">OVERLAY</code> replaces a portion of a raw value with a new string of raw data.&nbsp; If the new data is shorter than the length of the overlay area, then the new data is padded to make it long enough.&nbsp;If the new data is longer than the overlay area, then the extra bytes are ignored.&nbsp;If you specify an overlay area that exceeds the length of the input value, then the input value is extended according to the length specified.&nbsp;If you specify a starting position for the overlay area that exceeds the length of the input value, then the input value is padded to the position specified, and then the input value is further extended with the new data.</p>
<p><code dir="ltr">A</code> <code dir="ltr">VALUE_ERROR</code> exception is raised for any of the following conditions:</p>
<ul>
<li>
<p>The new data used to overlay the input value is null or has a length of 0</p>
</li>
<li>
<p>The portion of the input value to overlay is not defined</p>
</li>
<li>
<p>The length of the portion to overlay exceeds 32&nbsp;767&nbsp;bytes</p>
</li>
<li>
<p>The number of bytes to overlay is defined as less than 0</p>
</li>
<li>
<p>The position within the input value to begin the overlay operation is defined as less than&nbsp;1</p>
</li>
</ul>
<p class="subhead2"><a id="WSMQG371"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.OVERLAY(<span class="codeinlineitalic">new_bytes</span>, <span class="italic">input</span>, <span class="italic">position</span>, <span class="italic">length</span>, <span class="italic">pad</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is of the <code dir="ltr">RAW</code> data type.</p>
</li>
<li>
<p><code dir="ltr">new_bytes</code> is the new value, a byte string of the <code dir="ltr">RAW</code> data type, to overlay input with.&nbsp;Bytes are selected from <code dir="ltr"><span class="codeinlineitalic">new_bytes</span></code> beginning with the leftmost byte.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of data type <code dir="ltr">RAW</code> to overlay.</p>
</li>
<li>
<p><code dir="ltr">position</code> is the position within input, numbered from&nbsp;1, at which to begin overlaying.&nbsp;This value must be greater than 0.&nbsp;The default is&nbsp;1.</p>
</li>
<li>
<p><code dir="ltr">length</code> is the number of bytes to overlay.&nbsp;This must be greater than, or equal to, 0.&nbsp;The default is the length of <code dir="ltr"><span class="codeinlineitalic">new_bytes</span></code>.</p>
</li>
<li>
<p><code dir="ltr">pad</code> is a single byte value used to pad when length exceeds the overlay length or when position exceeds the length of <code dir="ltr"><span class="codeinlineitalic">input</span></code>.&nbsp;The default is X&#39;00&#39;.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG301" class="sect2"><a id="sthref551"></a>
<h3 class="sect2">UTL_RAW.REVERSE</h3>
<p><a id="sthref552"></a><a id="sthref553"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">REVERSE</code> reverses the byte sequence of a raw value from end-to-end.&nbsp;For example, this function reverses X&#39;0102F3&#39; to X&#39;F30201&#39; or xyz to zyx.&nbsp;The length of the resulting value is the same length as the input value.&nbsp;<code dir="ltr">A</code> <code dir="ltr">VALUE_ERROR</code> exception is raised if the input value is null or has a length of 0.</p>
<p class="subhead2"><a id="WSMQG372"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.REVERSE(<span class="italic">input</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the output value of the function.&nbsp;It is of the <code dir="ltr">RAW</code> data type.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of the <code dir="ltr">RAW</code> data type to be reversed.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG302" class="sect2"><a id="sthref554"></a>
<h3 class="sect2">UTL_RAW.SUBSTR</h3>
<p><a id="sthref555"></a><a id="sthref556"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">SUBSTR</code> removes bytes from a raw value.&nbsp;If you specify a positive number as the starting point for the bytes to remove, then <code dir="ltr">SUBSTR</code> counts from the beginning of the input value to find the first byte.&nbsp;If you specify a negative number, then<br/>
<code dir="ltr">UTL_RAW</code>.<code dir="ltr">SUBSTR</code> counts backwards from the end of the input value to find the first byte.</p>
<p><code dir="ltr">A</code> <code dir="ltr">VALUE_ERROR</code> exception is raised for any of the following conditions:</p>
<ul>
<li>
<p>The position to begin the removal is specified as 0</p>
</li>
<li>
<p>The number of bytes to remove is specified as less than 0</p>
</li>
</ul>
<p class="subhead2"><a id="WSMQG373"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.SUBSTR(<span class="italic">input</span>, <span class="italic">position</span>[,<span class="italic">length</span>]);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function. It is of the <code dir="ltr">RAW</code> data type.&nbsp;The value is the specified byte or bytes from <code dir="ltr"><span class="codeinlineitalic">input</span></code>, or the value is a null value if <code dir="ltr"><span class="codeinlineitalic">input</span></code> is null.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of the <code dir="ltr">RAW</code> data type from which to extract a portion of its bytes.</p>
</li>
<li>
<p><code dir="ltr">position</code> is the byte position from which to start extraction.&nbsp;This value cannot be 0.&nbsp;If the value of <code dir="ltr"><span class="codeinlineitalic">position</span></code> is negative, then <code dir="ltr">SUBSTR</code> counts backwards from the end of input.</p>
</li>
<li>
<p><code dir="ltr">length</code> is the number of bytes to extract from <code dir="ltr"><span class="codeinlineitalic">input</span></code> after <code dir="ltr"><span class="codeinlineitalic">position</span></code>.&nbsp;This value must be greater than 0.&nbsp;When not specified, all bytes to the end of input are returned.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG303" class="sect2"><a id="sthref557"></a>
<h3 class="sect2">UTL_RAW.TRANSLATE</h3>
<p><a id="sthref558"></a><a id="sthref559"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">TRANSLATE</code> changes the value of some of the bytes in a raw value according to a scheme that you specify.&nbsp;Bytes in the input value are compared to a matching string, and when found to match, the byte at the same position in the replacement string is copied to the result. It is omitted from the result if the offset exceeds the length of the replacement string.&nbsp;Bytes in the input value that do not appear in the matching string are copied to the resulting value. Only the leftmost occurrence of a byte in the matching string is used, and subsequent duplicate occurrences are ignored.</p>
<p>If the matching string contains more bytes than the replacement string, then the extra bytes at the end of the matching string have no corresponding bytes in the replacement string.&nbsp;Any bytes in the input value that match such bytes are omitted from the resulting value.</p>
<p><code dir="ltr">A</code> <code dir="ltr">VALUE_ERROR</code> exception is raised for any of the following conditions:</p>
<ul>
<li>
<p>The input value is null or has a length of 0</p>
</li>
<li>
<p>The matching string is null or has a length of 0</p>
</li>
<li>
<p>The replacement string is null or has a length of 0</p>
</li>
</ul>
<p class="subhead2"><a id="WSMQG374"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.TRANSLATE(<span class="italic">input</span>, <span class="italic">match</span>, <span class="italic">replace_bytes</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the variable that holds the output value of the function.&nbsp;It is of data type <code dir="ltr">RAW</code>.</p>
</li>
<li>
<p><code dir="ltr">input</code> is the input value of data type <code dir="ltr">RAW</code> to change.</p>
</li>
<li>
<p><code dir="ltr">match</code> specifies the byte 0codes to search for in <code dir="ltr"><span class="codeinlineitalic">input</span></code> and to change to <code dir="ltr"><span class="codeinlineitalic">replace_bytes</span></code>.&nbsp;It is of data type <code dir="ltr">RAW</code>.</p>
</li>
<li>
<p><code dir="ltr">replace_bytes</code> specifies the byte codes that replace the codes specified by match.&nbsp;It is of data type <code dir="ltr">RAW</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG304" class="sect2"><a id="sthref560"></a>
<h3 class="sect2">UTL_RAW.TRANSLITERATE</h3>
<p><a id="sthref561"></a><a id="sthref562"></a><code dir="ltr">UTL_RAW</code>.<code dir="ltr">TRANSLITERATE</code> replaces all occurrences of any bytes in a matching string with the corresponding bytes of a replacement string.&nbsp;Bytes in the input value are compared to the matching string, and if they are not found, then they are copied unaltered to the resulting value. If they are found, then they are replaced in the resulting value by the byte at the same offset in the replacement string, or with the pad byte that you specify when the offset exceeds the length of the replacement string.&nbsp; Only the leftmost occurrence of a byte in the matching string is used.&nbsp;Subsequent duplicate occurrences are ignored.&nbsp;The result value of <code dir="ltr">UTL_RAW</code>.<code dir="ltr">TRANSLITERATE</code> is always the same length as the input value.</p>
<p>If the replacement string is shorter than the matching string, then the pad byte is placed in the resulting value when a selected matching string byte has no corresponding byte in the replacement string. A VALUE_ERROR exception is raised when the input value is null or has a length of 0.</p>
<p><code dir="ltr">UTL_RAW</code>.<code dir="ltr">TRANSLITERATE</code> differs from <code dir="ltr">UTL_RAW</code>.<code dir="ltr">TRANSLATE</code> in the following ways:</p>
<ul>
<li>
<p>Bytes in the input value that are undefined in the replacement string are padded with a value that you specify</p>
</li>
<li>
<p>The resulting value is always the same length as the input value</p>
</li>
</ul>
<p class="subhead2"><a id="WSMQG375"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.TRANSLITERATE (<span class="italic">input</span>, <span class="italic">replace_bytes</span>, <span class="italic">match</span>, <span class="italic">pad</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">Result</code> is the output value of the function.&nbsp;It is data type <code dir="ltr">RAW</code>.</p>
</li>
<li>
<p><code dir="ltr">Input</code> is the input value of data type <code dir="ltr">RAW</code> to change.</p>
</li>
<li>
<p><code dir="ltr">Replace_bytes</code> specifies the byte codes to which corresponding bytes of match are changed.&nbsp;This value can be any length that is valid for the RAW data type.&nbsp;The default is a null value and effectively extends with pad to the length of match as necessary.</p>
</li>
<li>
<p><code dir="ltr">Match</code> specifies the <code dir="ltr">byte</code> codes to match in <code dir="ltr"><span class="codeinlineitalic">input</span></code>.&nbsp;The value can be any length that is valid for the RAW data type.&nbsp;The default is X&#39;00&#39; through X&#39;FF&#39;.</p>
</li>
<li>
<p><code dir="ltr">Pad</code> is a singe byte value that is used to extend the length of <code dir="ltr"><span class="codeinlineitalic">replace_bytes</span></code> when <code dir="ltr"><span class="codeinlineitalic">replace_bytes</span></code> is shorter than match.&nbsp;The default is X&#39;00&#39;.</p>
<p><code dir="ltr">UTL_RAW</code>.<code dir="ltr">TRANSLATE</code> differs from the <code dir="ltr">UTL_RAW</code>.<code dir="ltr">TRANSLITERATE</code> function in the following ways:</p>
<ul>
<li>
<p>The raw values used for the matching and replacement strings have no default values</p>
</li>
<li>
<p>Bytes in the input value that are undefined in the replacement string are omitted in the resulting value</p>
</li>
<li>
<p>The resulting value can be shorter than the input value</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="WSMQG305" class="sect2"><a id="sthref563"></a>
<h3 class="sect2">UTL_RAW.XRANGE</h3>
<p><code dir="ltr">UTL_RAW</code>.<code dir="ltr">XRANGE</code><a id="sthref564"></a><a id="sthref565"></a> returns a raw value containing all valid one-byte codes within a range that you specify.&nbsp;If the starting byte value is greater than the ending byte value, then the succession of resulting bytes begin with the starting byte, wrapping from X&#39;FF&#39; to X&#39;00&#39;, and end at the ending byte.</p>
<p>When specified, the values for the starting and ending bytes must be single-byte raw values.</p>
<p class="subhead2"><a id="WSMQG376"></a>Syntax</p>
<pre dir="ltr"><span class="italic">result</span> := UTL_RAW.XRANGE(<span class="italic">start</span>, <span class="codeinlineitalic">end</span>);
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr">result</code> is the output value of the function.&nbsp;It is of data type RAW.</p>
</li>
<li>
<p><code dir="ltr">start</code> is a single byte code to start with.&nbsp;The default is X&#39;00&#39;.</p>
</li>
<li>
<p><code dir="ltr">end</code> is a single byte code to end with.&nbsp;The default is X&#39;FF&#39;.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="appendix" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4993">
<tr>
<td class="cellalignment5002">
<table class="cellalignment4998">
<tr>
<td class="cellalignment4997"><a href="ap_pgm8.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4997"><a href="ap_gip.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5004">
<table class="cellalignment4996">
<tr>
<td class="cellalignment4997"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4997"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4997"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4997"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4997"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4997"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>